<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Introduction to Generative AI | GopherDing's Blog</title><meta name=keywords content><meta name=description content="关于CS5494——Generative AI的课程描述"><meta name=author content="GopherDing"><link rel=canonical href=https://gopherding.github.io/posts/tech/introduction-to-generative-ai/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://gopherding.github.io/img/GopherSpaceCommunity.png><link rel=icon type=image/png sizes=16x16 href=https://gopherding.github.io/img/GopherSpaceCommunity.png><link rel=icon type=image/png sizes=32x32 href=https://gopherding.github.io/img/GopherSpaceCommunity.png><link rel=apple-touch-icon href=https://gopherding.github.io/img/GopherSpaceCommunity.png><link rel=mask-icon href=https://gopherding.github.io/img/GopherSpaceCommunity.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=google-site-verification content="7XaJy5jt6ZoEXT-jlbI3sDg79M-BnIkGtU7WZLCQkzg"><link rel=alternate hreflang=zh href=https://gopherding.github.io/posts/tech/introduction-to-generative-ai/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=/js/busuanzi.pure.mini.js></script><link rel=stylesheet href=/css/font-awesome.min.css><script src=/js/jquery-3.7.1.min.js></script><meta property="og:title" content="Introduction to Generative AI"><meta property="og:description" content="关于CS5494——Generative AI的课程描述"><meta property="og:type" content="article"><meta property="og:url" content="https://gopherding.github.io/posts/tech/introduction-to-generative-ai/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-15T15:55:23+08:00"><meta property="article:modified_time" content="2025-12-15T15:55:23+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduction to Generative AI"><meta name=twitter:description content="关于CS5494——Generative AI的课程描述"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://gopherding.github.io/posts/"},{"@type":"ListItem","position":2,"name":"技术","item":"https://gopherding.github.io/posts/tech/"},{"@type":"ListItem","position":3,"name":"Introduction to Generative AI","item":"https://gopherding.github.io/posts/tech/introduction-to-generative-ai/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introduction to Generative AI","name":"Introduction to Generative AI","description":"关于CS5494——Generative AI的课程描述","keywords":[""],"articleBody":"CS5494 Week 1: Introduction to Generative AI \u0026 Perception Models 第一周：生成式人工智能与感知模型导论 1. 核心概念：生成模型与判别模型 Core Concept: Generative vs. Discriminative Models 这是本节课最重要的理论基础，理解它们的区别是入门的关键。\n1. 判别模型 (Discriminative Models)\n功能 (Function): 学习如何区分或预测。就像给作业打分的老师，看到一个输入（试卷），给出一个输出（分数）。 Analogy: Like a teacher grading an exam. Given an input (exam paper), it produces an output (score). 数学表达 (Mathematical Form): 建模条件概率 $P(y|x)$。即给定输入 $x$（如一张照片），预测标签 $y$（如“猫”或“狗”）的概率。 Math: Models the conditional probability $P(y|x)$. Given input $x$, predict the probability of label $y$. 局限 (Limitation): 它们无法创造新数据，只能对现有数据进行分类或回归。 2. 生成模型 (Generative Models)\n功能 (Function): 学习数据的底层分布 (Underlying Distribution)，从而能够创造出与训练数据相似但全新的数据。就像一个画家，看过很多猫之后，在一张白纸上画出一只从未存在过的猫。 Analogy: Like an artist who, after seeing many cats, draws a new cat that never existed before on a blank piece of paper. 数学表达 (Mathematical Form): 建模联合概率分布 $P(x,y)$ 或数据本身的分布 $P(x)$。 Math: Models the joint probability distribution $P(x,y)$ or the data distribution $P(x)$ itself. 核心目标 (Core Goal): 能够从学习到的分布中采样 (Sample)，生成逼真的新样本（图像、文本、音频）。 2. 感知模型与表示学习 Perception Models \u0026 Representation Learning 课件中强调，为了做好生成（Generation），首先要解决感知（Perception）的问题。感知模型的核心就是表示学习。\n什么是表示学习？ (What is Representation Learning?)\n定义: 将原始数据（Raw Data）转化为机器更容易理解和处理的形式（Feature/Embedding）。 Definition: Converting raw data into a form (features/embeddings) that is easier for machines to understand and process. 过程: 从原始像素（Pixels）$\\rightarrow$ 抽象特征（Abstraction）$\\rightarrow$ 概念（Concepts）。 Process: From raw pixels $\\rightarrow$ Abstract features $\\rightarrow$ High-level concepts. 重要性: 好的表示（Representation）能让模型“理解”数据的本质，而不仅仅是死记硬背。AlphaGo 的成功就归功于它能比人类更好地表示棋盘局势。 3. 深度神经网络的演进 (Deep Neural Networks Evolution) From LeNet to Transformers 这部分回顾了深度学习过去十年的关键突破，正是这些技术让现在的 GenAI 成为可能。\nA. 卷积神经网络 (CNNs) 的崛起 LeNet (1989/1998): 引入了卷积 (Convolution) 和 池化 (Pooling) 的概念。利用权值共享（Weight Sharing）大大减少了参数量，适合处理图像。 AlexNet (2012): 深度学习的爆发点。引入了 ReLU 激活函数（解决了梯度消失问题）和 Dropout，并使用了 GPU 加速训练。 VGG (2014): 证明了**“越深越好” (Deeper is better)**。它用连续的 3x3 小卷积核代替了大卷积核，加深了网络结构。 B. 突破瓶颈：初始化与归一化 (Initialization \u0026 Normalization) 随着网络变深，训练变得极其困难（梯度爆炸或消失）。\n初始化 (Initialization): Xavier 和 Kaiming Initialization 提供了科学的参数初始值设定方法，让信号能更稳定地在网络中传播。 批归一化 (Batch Normalization, BN): 强制将每一层的输入拉回到标准的分布。这被认为是训练深层网络的“神技”，大大加速了收敛。 C. 残差网络 (ResNet, 2015) 问题: 当网络非常深时（如 100 层），简单堆叠层数反而会导致性能下降（Degradation problem）。 解决方案: 引入 Shortcut Connection (跳跃连接)，让数据可以直接跨层传递。 Mechanism: The network learns the residual (difference) $F(x)$ instead of the original mapping. Mathematically: $y = F(x) + x$. 意义: 使得训练成百上千层的网络成为可能，是现代大模型（包括 GPT 系列）的基石结构。 D. Transformer (2017) \u0026 ViT (2020) Transformer: 抛弃了循环（RNN）和卷积（CNN），完全依赖 Attention Mechanism (注意力机制)。每一个 token 都能看到所有其他 token，拥有全局上下文 (Global Context)。 Vision Transformer (ViT): 将图像切成小块（Patches），像处理文字一样处理图像。这统一了视觉和语言的模型架构。 4. 生成模型的框架 Framework of Generative Models 课件最后总结了构建一个生成模型的五个关键要素：\n形式化 (Formulation): 将问题定义为概率建模问题（如何描述 $P(x)$？）。 表示 (Representation): 使用深度神经网络（如 ResNet, Transformer）来拟合复杂的数据分布。 目标函数 (Objective Function): 定义“生成得好不好”的标准（Loss Function），衡量预测分布与真实分布的差异。 优化 (Optimization): 调整网络参数以最小化目标函数（通常使用反向传播）。 推断 (Inference): 训练好后，如何采样（Sampler）生成新数据？ 5. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 生成模型 Generative Model 学习数据分布 $P(x)$ 以生成新样本的模型。如 GPT, Stable Diffusion。 判别模型 Discriminative Model 学习条件概率 $P(y|x)$ 以分类或预测标签的模型。如垃圾邮件分类器。 表示学习 Representation Learning 自动从原始数据中提取有效特征的过程，将高维数据映射到低维、抽象的特征空间。 卷积神经网络 CNN (Convolutional Neural Network) 专门处理网格数据（如图像）的神经网络，利用卷积层提取局部特征。 残差学习 Residual Learning ResNet 的核心。通过引入“跳跃连接”，让网络学习残差（差异）而不是完整的映射，解决了深层网络的退化问题。 批归一化 Batch Normalization (BN) 在每一层网络的激活前对数据进行归一化处理，防止分布偏移，加速训练。 注意力机制 Attention Mechanism Transformer 的核心。允许模型在处理一个元素时，动态关注序列中的其他相关元素（无论距离多远）。 反向传播 Backpropagation 训练神经网络的核心算法。根据输出误差，反向计算梯度并更新网络参数。 概率分布 Probability Distribution 描述随机变量取值可能性的数学函数。生成模型本质上就是在拟合这个复杂的函数。 推断 Inference 模型训练完成后，利用模型进行预测或生成新数据的过程。 总结 (Summary) 这份课件的核心逻辑是：Generative AI 的本质是概率分布的建模，而为了通过机器学习好这个分布，我们需要强大的 Deep Learning 模型（如 ResNet, Transformer）作为支撑。 所以第一周花了很多时间复习深度学习的基础架构。\nCS5494 Week 2: Basics of Probability Distributions 第二周：概率分布基础 1. 生成模型 vs. 判别模型 (进阶版) Generative vs. Discriminative Models (Revisited) 上周讲了概念，这周从数学角度深入对比。\n判别模型 (Discriminative Models):\n目标 (Goal): 直接区分 $y$（标签）。建立 $x$ 到 $y$ 的映射。 数学 (Math): 建模条件概率 $P(y|x)$。 决策边界 (Decision Boundary): 它只关心怎么把两类数据分开，不关心数据长什么样。 Analogy: Like learning a rule to distinguish cats from dogs without knowing how to draw them. 生成模型 (Generative Models):\n目标 (Goal): 描述数据 $x$ 是如何生成的。 数学 (Math): 建模联合概率 $P(x, y)$ 或边缘概率 $P(x)$。 贝叶斯公式 (Bayes’ Rule): 生成模型可以通过贝叶斯公式转化为判别模型： $$P(y|x) = \\frac{P(x|y)P(y)}{P(x)}$$ 优势 (Advantage): 课件特别提到，生成模型在缺失数据 (Missing Data) 的情况下依然有效。因为它可以对未观察到的变量进行边缘化 (Marginalize)，而判别模型必须依赖完整的 $x$。 2. 核心挑战：维数灾难 The Core Challenge: Curse of Dimensionality 这是本节课提出的最根本问题：为什么生成模型这么难做？\n问题描述 (Problem): 假设我们要为一个简单的 $28 \\times 28$ 黑白像素图像（如 MNIST 数字）建模联合分布。 每个像素有 2 种状态（0 或 1）。 总共有 $784$ 个像素。 那么这幅图可能的状态总数是 $2^{784}$。 Concept: The number of possible configurations grows exponentially with the number of variables (pixels). 结论 (Conclusion): 我们不可能列出一张表来记录每一个可能图像的概率。所需的参数量远远超过了宇宙中原子的数量。 解决方案 (Solution): 我们必须引入假设 (Assumptions) 和 结构 (Structure) 来减少参数量。 3. 结构化模型：贝叶斯网络 Structured Models: Bayesian Networks 为了解决维数灾难，我们引入了“条件独立性”假设。\nA. 链式法则 (The Chain Rule) 任何复杂的联合分布都可以分解为条件概率的乘积： $$P(x_1, x_2, x_3, x_4) = P(x_1) P(x_2|x_1) P(x_3|x_1, x_2) P(x_4|x_1, x_2, x_3)$$\n解释: 就像讲故事，后面的情节取决于前面的铺垫。 问题: 即使分解了，参数量并没有减少。最后几项依然非常复杂。 B. 条件独立性假设 (Conditional Independence Assumption) 这是贝叶斯网络的核心。我们假设：每个变量只依赖于它的少数几个“父节点”，而不是之前的所有变量。\nKey Idea: Variable $x_i$ is independent of its non-descendants given its parents. C. 贝叶斯网络 (Bayesian Networks) 定义: 一个有向无环图 (DAG)，其中节点代表变量，边代表依赖关系。 公式: $P(x_1, …, x_n) = \\prod_{i=1}^{n} P(x_i | \\text{Parents}(x_i))$ 效果: 极大地减少了参数量。 全连接 (Fully Connected): 每个变量都依赖所有前序变量 $\\rightarrow$ 参数爆炸。 稀疏连接 (Sparse): 每个变量只依赖 1-2 个父节点 $\\rightarrow$ 参数可控。 D. 经典案例：朴素贝叶斯 (Naive Bayes) 这是贝叶斯网络的一个极端特例。 假设: 给定类别 $y$ 后，所有的特征 $x_i$ 都是相互独立的。 Assumption: All features are independent given the class label. 局限: 这个假设太强了（现实中像素之间肯定有关联），所以它生成的图片通常全是噪点，效果不好。但它作为分类器效果还不错。 4. 神经模型：引入深度学习 Neural Models: Merging Probability with Deep Learning 传统的图模型（如贝叶斯网络）需要专家手工设计依赖关系图，这很难。现在的趋势是结合神经网络。\n参数化 (Parameterization): 在贝叶斯网络中，我们需要用表格或简单函数来表示 $P(x_i | \\text{Parents}(x_i))$。 在神经模型中，我们用一个神经网络来拟合这个条件概率函数。 Mechanism: Use a neural network to output the probability distribution parameters. 非线性依赖 (Non-linear Dependence): 线性模型（如逻辑回归）假设变量间是线性关系。而神经网络通过激活函数（如 Sigmoid, ReLU）引入了非线性，能够捕捉更复杂的数据关系。 $$y = \\sigma(Wx + b)$$ 从图到网 (From Graphs to Nets): 我们可以重复堆叠神经层，构建深层网络。这实际上是在学习更复杂的、隐含的依赖结构，而不需要人工显式地画出每一条边。 5. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 联合分布 Joint Distribution $P(x, y)$ 或 $P(x_1, …, x_n)$。描述所有变量同时取特定值的概率。这是生成模型的核心。 条件概率 Conditional Probability $P(A|B)$。在事件 B 发生的条件下，事件 A 发生的概率。 边缘化 Marginalization 通过对某些变量求和（或积分），从联合分布中得到子集变量分布的过程。常用于处理缺失数据。 维数灾难 Curse of Dimensionality 随着数据维度（特征数量）增加，数据空间呈指数级爆炸，导致数据变得极其稀疏，难以建模。 链式法则 Chain Rule (Probability) 概率论基本定理，允许将联合概率分解为一系列条件概率的乘积。 贝叶斯网络 Bayesian Network 一种概率图模型，使用有向无环图 (DAG) 来表示变量间的条件依赖关系。 条件独立 Conditional Independence 如果已知变量 Z，变量 X 和 Y 互不影响，则称 X 和 Y 关于 Z 条件独立。这是简化模型的关键。 朴素贝叶斯 Naive Bayes 一种简单的生成模型，假设特征之间相互独立。常作为基准模型 (Baseline)。 有向无环图 DAG (Directed Acyclic Graph) 贝叶斯网络的结构基础，图中的边是有方向的，且不存在闭环。 逻辑函数 Logistic Function (Sigmoid) $\\sigma(z) = \\frac{1}{1+e^{-z}}$。常用于神经网络中将输出压缩到 (0,1) 之间，表示概率。 总结 (Summary) Week 2 告诉你：因为世界太复杂（维数灾难），我们不能蛮力记录所有可能性。 我们必须偷懒——要么假设变量之间没那么多关系（贝叶斯网络），要么用一个强大的黑盒（神经网络）去拟合这些关系。现代 GenAI 正是选择了后者。\nCS5494 Week 3: Autoregressive Models 第三周：自回归模型 1. 核心定义：什么是自回归模型？ Core Definition: What are Autoregressive Models? 自回归模型是生成式 AI 中最主流的一派（GPT 中的 “G” 就是 Generative，实际上是 Autoregressive 的）。\n基本思想 (Basic Idea): 将生成高维数据（如一张图或一段话）的任务，拆解为序列生成 (Sequential Generation) 任务。即：根据前面所有的内容，预测下一个内容。\nConcept: Decompose the task of generating high-dimensional data into a sequential generation task. Predict the next token based on all previous tokens. 数学基础：链式法则 (Mathematical Foundation: Chain Rule) 我们利用概率链式法则，将联合分布分解为条件概率的乘积，不引入任何独立性假设： $$P(x_1, …, x_n) = \\prod_{i=1}^{n} P(x_i | x_1, …, x_{i-1})$$\nExplanation: $x_i$ depends on all previous variables $x_{","wordCount":"19120","inLanguage":"zh","datePublished":"2025-12-15T15:55:23+08:00","dateModified":"2025-12-15T15:55:23+08:00","author":[{"@type":"Person","name":"GopherDing"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://gopherding.github.io/posts/tech/introduction-to-generative-ai/"},"publisher":{"@type":"Organization","name":"GopherDing's Blog","logo":{"@type":"ImageObject","url":"https://gopherding.github.io/img/GopherSpaceCommunity.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gopherding.github.io/ accesskey=h title="GopherDing's Blog (Alt + H)"><img src=https://gopherding.github.io/img/GopherSpaceCommunity.png alt=logo aria-label=logo height=50>GopherDing's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://gopherding.github.io/ title=主页><span>主页</span></a></li><li><a href=https://gopherding.github.io/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://gopherding.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://gopherding.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://gopherding.github.io/about title=关于><span>关于</span></a></li><li><a href=https://gopherding.github.io/links title=友链><span>友链</span></a></li><li><a href=https://www.travellings.cn/go.html title=开往><span>开往</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://gopherding.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://gopherding.github.io/posts/>文章</a>&nbsp;»&nbsp;<a href=https://gopherding.github.io/posts/tech/>技术</a></div><h1 class=post-title>Introduction to Generative AI</h1><div class=post-description>关于CS5494——Generative AI的课程描述</div><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2025-12-15
&nbsp;&nbsp;
</span></span><span id=post_meta_style_3><span class="fa fa-file-word-o"></span>
<span>19120字
&nbsp;&nbsp;
</span></span><span id=post_meta_style_4><span class="fa fa-clock-o"></span>
<span>39分钟
&nbsp;&nbsp;
</span></span><span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>GopherDing
&nbsp;&nbsp;
</span></span><span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta><a href=https://gopherding.github.io/tags/generative-ai/ style="color:var(--secondary) !important">Generative AI</a>
</span></span></span></span><span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;
</span></span><span id=post_meta_style_8><span class="fa fa-commenting-o"></span>
<span><script>window.addEventListener("load",function(){let t=document.documentURI,n="https://gopherding.github.io/",s=t.split(n),e=s[1];e[0]!=="/"&&(e="/"+e),twikoo.getCommentsCount({envId:null,region:null,urls:[e],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})})</script><span id=comment_count></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#cs5494-week-1-introduction-to-generative-ai--perception-models aria-label="CS5494 Week 1: Introduction to Generative AI & Perception Models">CS5494 Week 1: Introduction to Generative AI & Perception Models</a></li><li><a href=#%e7%ac%ac%e4%b8%80%e5%91%a8%e7%94%9f%e6%88%90%e5%bc%8f%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e4%b8%8e%e6%84%9f%e7%9f%a5%e6%a8%a1%e5%9e%8b%e5%af%bc%e8%ae%ba aria-label=第一周：生成式人工智能与感知模型导论>第一周：生成式人工智能与感知模型导论</a><ul><li><a href=#1-%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5%e7%94%9f%e6%88%90%e6%a8%a1%e5%9e%8b%e4%b8%8e%e5%88%a4%e5%88%ab%e6%a8%a1%e5%9e%8b aria-label="1. 核心概念：生成模型与判别模型">1. 核心概念：生成模型与判别模型</a><ul><li><a href=#core-concept-generative-vs-discriminative-models aria-label="Core Concept: Generative vs. Discriminative Models">Core Concept: Generative vs. Discriminative Models</a></li></ul></li><li><a href=#2-%e6%84%9f%e7%9f%a5%e6%a8%a1%e5%9e%8b%e4%b8%8e%e8%a1%a8%e7%a4%ba%e5%ad%a6%e4%b9%a0 aria-label="2. 感知模型与表示学习">2. 感知模型与表示学习</a><ul><li><a href=#perception-models--representation-learning aria-label="Perception Models & Representation Learning">Perception Models & Representation Learning</a></li></ul></li><li><a href=#3-%e6%b7%b1%e5%ba%a6%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e7%9a%84%e6%bc%94%e8%bf%9b-deep-neural-networks-evolution aria-label="3. 深度神经网络的演进 (Deep Neural Networks Evolution)">3. 深度神经网络的演进 (Deep Neural Networks Evolution)</a><ul><li><a href=#from-lenet-to-transformers aria-label="From LeNet to Transformers">From LeNet to Transformers</a><ul><li><a href=#a-%e5%8d%b7%e7%a7%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c-cnns-%e7%9a%84%e5%b4%9b%e8%b5%b7 aria-label="A. 卷积神经网络 (CNNs) 的崛起">A. 卷积神经网络 (CNNs) 的崛起</a></li><li><a href=#b-%e7%aa%81%e7%a0%b4%e7%93%b6%e9%a2%88%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e5%bd%92%e4%b8%80%e5%8c%96-initialization--normalization aria-label="B. 突破瓶颈：初始化与归一化 (Initialization & Normalization)">B. 突破瓶颈：初始化与归一化 (Initialization & Normalization)</a></li><li><a href=#c-%e6%ae%8b%e5%b7%ae%e7%bd%91%e7%bb%9c-resnet-2015 aria-label="C. 残差网络 (ResNet, 2015)">C. 残差网络 (ResNet, 2015)</a></li><li><a href=#d-transformer-2017--vit-2020 aria-label="D. Transformer (2017) & ViT (2020)">D. Transformer (2017) & ViT (2020)</a></li></ul></li></ul></li><li><a href=#4-%e7%94%9f%e6%88%90%e6%a8%a1%e5%9e%8b%e7%9a%84%e6%a1%86%e6%9e%b6 aria-label="4. 生成模型的框架">4. 生成模型的框架</a><ul><li><a href=#framework-of-generative-models aria-label="Framework of Generative Models">Framework of Generative Models</a></li></ul></li><li><a href=#5-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary aria-label="5. 专有名词表 (Glossary)">5. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li><li><a href=#cs5494-week-2-basics-of-probability-distributions aria-label="CS5494 Week 2: Basics of Probability Distributions">CS5494 Week 2: Basics of Probability Distributions</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e5%91%a8%e6%a6%82%e7%8e%87%e5%88%86%e5%b8%83%e5%9f%ba%e7%a1%80 aria-label=第二周：概率分布基础>第二周：概率分布基础</a><ul><li><a href=#1-%e7%94%9f%e6%88%90%e6%a8%a1%e5%9e%8b-vs-%e5%88%a4%e5%88%ab%e6%a8%a1%e5%9e%8b-%e8%bf%9b%e9%98%b6%e7%89%88 aria-label="1. 生成模型 vs. 判别模型 (进阶版)">1. 生成模型 vs. 判别模型 (进阶版)</a><ul><li><a href=#generative-vs-discriminative-models-revisited aria-label="Generative vs. Discriminative Models (Revisited)">Generative vs. Discriminative Models (Revisited)</a></li></ul></li><li><a href=#2-%e6%a0%b8%e5%bf%83%e6%8c%91%e6%88%98%e7%bb%b4%e6%95%b0%e7%81%be%e9%9a%be aria-label="2. 核心挑战：维数灾难">2. 核心挑战：维数灾难</a><ul><li><a href=#the-core-challenge-curse-of-dimensionality aria-label="The Core Challenge: Curse of Dimensionality">The Core Challenge: Curse of Dimensionality</a></li></ul></li><li><a href=#3-%e7%bb%93%e6%9e%84%e5%8c%96%e6%a8%a1%e5%9e%8b%e8%b4%9d%e5%8f%b6%e6%96%af%e7%bd%91%e7%bb%9c aria-label="3. 结构化模型：贝叶斯网络">3. 结构化模型：贝叶斯网络</a><ul><li><a href=#structured-models-bayesian-networks aria-label="Structured Models: Bayesian Networks">Structured Models: Bayesian Networks</a><ul><li><a href=#a-%e9%93%be%e5%bc%8f%e6%b3%95%e5%88%99-the-chain-rule aria-label="A. 链式法则 (The Chain Rule)">A. 链式法则 (The Chain Rule)</a></li><li><a href=#b-%e6%9d%a1%e4%bb%b6%e7%8b%ac%e7%ab%8b%e6%80%a7%e5%81%87%e8%ae%be-conditional-independence-assumption aria-label="B. 条件独立性假设 (Conditional Independence Assumption)">B. 条件独立性假设 (Conditional Independence Assumption)</a></li><li><a href=#c-%e8%b4%9d%e5%8f%b6%e6%96%af%e7%bd%91%e7%bb%9c-bayesian-networks aria-label="C. 贝叶斯网络 (Bayesian Networks)">C. 贝叶斯网络 (Bayesian Networks)</a></li><li><a href=#d-%e7%bb%8f%e5%85%b8%e6%a1%88%e4%be%8b%e6%9c%b4%e7%b4%a0%e8%b4%9d%e5%8f%b6%e6%96%af-naive-bayes aria-label="D. 经典案例：朴素贝叶斯 (Naive Bayes)">D. 经典案例：朴素贝叶斯 (Naive Bayes)</a></li></ul></li></ul></li><li><a href=#4-%e7%a5%9e%e7%bb%8f%e6%a8%a1%e5%9e%8b%e5%bc%95%e5%85%a5%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0 aria-label="4. 神经模型：引入深度学习">4. 神经模型：引入深度学习</a><ul><li><a href=#neural-models-merging-probability-with-deep-learning aria-label="Neural Models: Merging Probability with Deep Learning">Neural Models: Merging Probability with Deep Learning</a></li></ul></li><li><a href=#5-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary-1 aria-label="5. 专有名词表 (Glossary)">5. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary-1 aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li><li><a href=#cs5494-week-3-autoregressive-models aria-label="CS5494 Week 3: Autoregressive Models">CS5494 Week 3: Autoregressive Models</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e5%91%a8%e8%87%aa%e5%9b%9e%e5%bd%92%e6%a8%a1%e5%9e%8b aria-label=第三周：自回归模型>第三周：自回归模型</a><ul><li><a href=#1-%e6%a0%b8%e5%bf%83%e5%ae%9a%e4%b9%89%e4%bb%80%e4%b9%88%e6%98%af%e8%87%aa%e5%9b%9e%e5%bd%92%e6%a8%a1%e5%9e%8b aria-label="1. 核心定义：什么是自回归模型？">1. 核心定义：什么是自回归模型？</a><ul><li><a href=#core-definition-what-are-autoregressive-models aria-label="Core Definition: What are Autoregressive Models?">Core Definition: What are Autoregressive Models?</a></li></ul></li><li><a href=#2-%e5%85%a8%e5%8f%af%e8%a7%81%e4%bf%a1%e5%bf%b5%e7%bd%91%e7%bb%9c-fvbn aria-label="2. 全可见信念网络 (FVBN)">2. 全可见信念网络 (FVBN)</a><ul><li><a href=#fully-visible-belief-networks-fvbn aria-label="Fully Visible Belief Networks (FVBN)">Fully Visible Belief Networks (FVBN)</a></li></ul></li><li><a href=#3-%e5%be%aa%e7%8e%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c-rnn aria-label="3. 循环神经网络 (RNN)">3. 循环神经网络 (RNN)</a><ul><li><a href=#recurrent-neural-networks-rnn aria-label="Recurrent Neural Networks (RNN)">Recurrent Neural Networks (RNN)</a></li></ul></li><li><a href=#4-%e9%9d%a9%e5%91%bd%e6%80%a7%e7%aa%81%e7%a0%b4attention-%e4%b8%8e-transformer aria-label="4. 革命性突破：Attention 与 Transformer">4. 革命性突破：Attention 与 Transformer</a><ul><li><a href=#the-revolution-attention--transformer aria-label="The Revolution: Attention & Transformer">The Revolution: Attention & Transformer</a><ul><li><a href=#a-%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6-attention-mechanism aria-label="A. 注意力机制 (Attention Mechanism)">A. 注意力机制 (Attention Mechanism)</a></li><li><a href=#b-transformer-%e6%9e%b6%e6%9e%84 aria-label="B. Transformer 架构">B. Transformer 架构</a></li></ul></li></ul></li><li><a href=#5-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary-2 aria-label="5. 专有名词表 (Glossary)">5. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary-2 aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li><li><a href=#cs5494-week-4-large-language-models-decoder-only-architecture aria-label="CS5494 Week 4: Large Language Models (Decoder-only Architecture)">CS5494 Week 4: Large Language Models (Decoder-only Architecture)</a></li><li><a href=#%e7%ac%ac%e5%9b%9b%e5%91%a8%e5%a4%a7%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b%e4%bb%85%e8%a7%a3%e7%a0%81%e5%99%a8%e6%9e%b6%e6%9e%84 aria-label=第四周：大语言模型（仅解码器架构）>第四周：大语言模型（仅解码器架构）</a><ul><li><a href=#1-%e5%ae%8f%e8%a7%82%e6%9e%b6%e6%9e%84decoder-only-%e6%a8%a1%e5%9e%8b aria-label="1. 宏观架构：Decoder-only 模型">1. 宏观架构：Decoder-only 模型</a><ul><li><a href=#macro-architecture-decoder-only-models aria-label="Macro Architecture: Decoder-only Models">Macro Architecture: Decoder-only Models</a></li></ul></li><li><a href=#2-%e9%a2%84%e5%a4%84%e7%90%86%e7%ac%ac%e4%b8%80%e6%ad%a5%e5%88%86%e8%af%8d%e5%99%a8-tokenizer aria-label="2. 预处理第一步：分词器 (Tokenizer)">2. 预处理第一步：分词器 (Tokenizer)</a><ul><li><a href=#preprocessing-step-1-tokenizer aria-label="Preprocessing Step 1: Tokenizer">Preprocessing Step 1: Tokenizer</a></li></ul></li><li><a href=#3-%e9%a2%84%e5%a4%84%e7%90%86%e7%ac%ac%e4%ba%8c%e6%ad%a5%e5%b5%8c%e5%85%a5%e5%b1%82-embedding aria-label="3. 预处理第二步：嵌入层 (Embedding)">3. 预处理第二步：嵌入层 (Embedding)</a><ul><li><a href=#preprocessing-step-2-embedding aria-label="Preprocessing Step 2: Embedding">Preprocessing Step 2: Embedding</a></li></ul></li><li><a href=#4-%e5%85%b3%e9%94%ae%e6%8a%80%e6%9c%af%e4%bd%8d%e7%bd%ae%e7%bc%96%e7%a0%81-positional-embeddingencoding aria-label="4. 关键技术：位置编码 (Positional Embedding/Encoding)">4. 关键技术：位置编码 (Positional Embedding/Encoding)</a><ul><li><a href=#key-technique-positional-embedding aria-label="Key Technique: Positional Embedding">Key Technique: Positional Embedding</a></li></ul></li><li><a href=#5-%e6%a0%b8%e5%bf%83%e6%9c%ba%e5%88%b6%e5%9b%a0%e6%9e%9c%e6%b3%a8%e6%84%8f%e5%8a%9b-causal-attention aria-label="5. 核心机制：因果注意力 (Causal Attention)">5. 核心机制：因果注意力 (Causal Attention)</a><ul><li><a href=#core-mechanism-causal-attention-masked-attention aria-label="Core Mechanism: Causal Attention (Masked Attention)">Core Mechanism: Causal Attention (Masked Attention)</a></li></ul></li><li><a href=#6-%e8%ae%ad%e7%bb%83%e4%b8%8e%e6%8e%a8%e7%90%86-training-vs-inference aria-label="6. 训练与推理 (Training vs. Inference)">6. 训练与推理 (Training vs. Inference)</a><ul><li><a href=#training-phase-vs-generation-phase aria-label="Training Phase vs. Generation Phase">Training Phase vs. Generation Phase</a></li></ul></li><li><a href=#7-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary aria-label="7. 专有名词表 (Glossary)">7. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary-3 aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li><li><a href=#cs5494-week-5-generative-adversarial-networks-gan aria-label="CS5494 Week 5: Generative Adversarial Networks (GAN)">CS5494 Week 5: Generative Adversarial Networks (GAN)</a></li><li><a href=#%e7%ac%ac%e4%ba%94%e5%91%a8%e7%94%9f%e6%88%90%e5%af%b9%e6%8a%97%e7%bd%91%e7%bb%9c aria-label=第五周：生成对抗网络>第五周：生成对抗网络</a><ul><li><a href=#1-%e6%a0%b8%e5%bf%83%e7%9b%b4%e8%a7%89%e5%af%b9%e6%8a%97%e5%8d%9a%e5%bc%88 aria-label="1. 核心直觉：对抗博弈">1. 核心直觉：对抗博弈</a><ul><li><a href=#core-intuition-the-adversarial-game aria-label="Core Intuition: The Adversarial Game">Core Intuition: The Adversarial Game</a></li></ul></li><li><a href=#2-%e6%95%b0%e5%ad%a6%e6%9e%b6%e6%9e%84%e6%9e%81%e5%b0%8f%e6%9e%81%e5%a4%a7%e5%8d%9a%e5%bc%88 aria-label="2. 数学架构：极小极大博弈">2. 数学架构：极小极大博弈</a><ul><li><a href=#mathematical-architecture-minimax-game aria-label="Mathematical Architecture: Minimax Game">Mathematical Architecture: Minimax Game</a></li></ul></li><li><a href=#3-%e7%90%86%e8%ae%ba%e7%97%9b%e7%82%b9%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8e%9f%e5%a7%8b-gan-%e5%be%88%e9%9a%be%e8%ae%ad%e7%bb%83 aria-label="3. 理论痛点：为什么原始 GAN 很难训练？">3. 理论痛点：为什么原始 GAN 很难训练？</a><ul><li><a href=#theoretical-pain-point-why-is-vanilla-gan-hard-to-train aria-label="Theoretical Pain Point: Why is Vanilla GAN Hard to Train?">Theoretical Pain Point: Why is Vanilla GAN Hard to Train?</a><ul><li><a href=#a-%e4%bc%a0%e7%bb%9f%e7%9a%84%e8%b7%9d%e7%a6%bb%e5%ba%a6%e9%87%8fkl-%e6%95%a3%e5%ba%a6%e4%b8%8e-js-%e6%95%a3%e5%ba%a6 aria-label="A. 传统的距离度量：KL 散度与 JS 散度">A. 传统的距离度量：KL 散度与 JS 散度</a></li><li><a href=#b-%e6%a2%af%e5%ba%a6%e6%b6%88%e5%a4%b1%e9%97%ae%e9%a2%98-vanishing-gradient-problem aria-label="B. 梯度消失问题 (Vanishing Gradient Problem)">B. 梯度消失问题 (Vanishing Gradient Problem)</a></li></ul></li></ul></li><li><a href=#4-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88wasserstein-gan-wgan aria-label="4. 解决方案：Wasserstein GAN (WGAN)">4. 解决方案：Wasserstein GAN (WGAN)</a><ul><li><a href=#the-solution-wasserstein-gan aria-label="The Solution: Wasserstein GAN">The Solution: Wasserstein GAN</a></li></ul></li><li><a href=#5-%e8%bf%9b%e9%98%b6%e5%ba%94%e7%94%a8cyclegan aria-label="5. 进阶应用：CycleGAN">5. 进阶应用：CycleGAN</a><ul><li><a href=#advanced-application-cyclegan aria-label="Advanced Application: CycleGAN">Advanced Application: CycleGAN</a></li></ul></li><li><a href=#6-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary aria-label="6. 专有名词表 (Glossary)">6. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary-4 aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li><li><a href=#cs5494-week-6-variational-autoencoder-vae aria-label="CS5494 Week 6: Variational Autoencoder (VAE)">CS5494 Week 6: Variational Autoencoder (VAE)</a></li><li><a href=#%e7%ac%ac%e5%85%ad%e5%91%a8%e5%8f%98%e5%88%86%e8%87%aa%e7%bc%96%e7%a0%81%e5%99%a8 aria-label=第六周：变分自编码器>第六周：变分自编码器</a><ul><li><a href=#1-%e5%89%8d%e7%bd%ae%e6%a6%82%e5%bf%b5%e8%87%aa%e7%bc%96%e7%a0%81%e5%99%a8-autoencoder-ae aria-label="1. 前置概念：自编码器 (Autoencoder, AE)">1. 前置概念：自编码器 (Autoencoder, AE)</a><ul><li><a href=#precursor-autoencoder aria-label="Precursor: Autoencoder">Precursor: Autoencoder</a></li></ul></li><li><a href=#2-%e6%a0%b8%e5%bf%83%e7%90%86%e8%ae%ba%e6%bd%9c%e5%8f%98%e9%87%8f%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9a%be%e8%a7%a3%e6%80%a7 aria-label="2. 核心理论：潜变量模型与难解性">2. 核心理论：潜变量模型与难解性</a><ul><li><a href=#latent-variable-models--intractability aria-label="Latent Variable Models & Intractability">Latent Variable Models & Intractability</a></li></ul></li><li><a href=#3-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e5%8f%98%e5%88%86%e6%8e%a8%e6%96%ad%e4%b8%8e-elbo-%e9%87%8d%e7%82%b9%e9%9a%be%e7%82%b9 aria-label="3. 解决方案：变分推断与 ELBO (重点/难点)">3. 解决方案：变分推断与 ELBO (重点/难点)</a><ul><li><a href=#solution-variational-inference--elbo aria-label="Solution: Variational Inference & ELBO">Solution: Variational Inference & ELBO</a><ul><li><a href=#a-%e5%8f%98%e5%88%86%e6%8e%a8%e6%96%ad-variational-inference aria-label="A. 变分推断 (Variational Inference)">A. 变分推断 (Variational Inference)</a></li><li><a href=#b-elbo-%e8%af%81%e6%8d%ae%e4%b8%8b%e7%95%8c aria-label="B. ELBO (证据下界)">B. ELBO (证据下界)</a></li></ul></li></ul></li><li><a href=#4-vae-%e7%9a%84%e6%a8%a1%e5%9e%8b%e6%9e%b6%e6%9e%84%e4%b8%8e%e6%8d%9f%e5%a4%b1%e5%87%bd%e6%95%b0 aria-label="4. VAE 的模型架构与损失函数">4. VAE 的模型架构与损失函数</a><ul><li><a href=#vae-architecture--loss-function aria-label="VAE Architecture & Loss Function">VAE Architecture & Loss Function</a></li></ul></li><li><a href=#5-%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82%e9%87%8d%e5%8f%82%e6%95%b0%e5%8c%96%e6%8a%80%e5%b7%a7-reparameterization-trick aria-label="5. 实现细节：重参数化技巧 (Reparameterization Trick)">5. 实现细节：重参数化技巧 (Reparameterization Trick)</a><ul><li><a href=#implementation-the-reparameterization-trick aria-label="Implementation: The Reparameterization Trick">Implementation: The Reparameterization Trick</a></li></ul></li><li><a href=#6-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary-1 aria-label="6. 专有名词表 (Glossary)">6. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary-5 aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li><li><a href=#cs5494-week-7-diffusion-models-ddpm aria-label="CS5494 Week 7: Diffusion Models (DDPM)">CS5494 Week 7: Diffusion Models (DDPM)</a></li><li><a href=#%e7%ac%ac%e4%b8%83%e5%91%a8%e6%89%a9%e6%95%a3%e6%a8%a1%e5%9e%8b-ddpm aria-label="第七周：扩散模型 (DDPM)">第七周：扩散模型 (DDPM)</a><ul><li><a href=#1-%e6%a0%b8%e5%bf%83%e7%9b%b4%e8%a7%89%e6%af%81%e6%8e%89%e5%ae%83%e5%86%8d%e5%a4%8d%e5%8e%9f%e5%ae%83 aria-label="1. 核心直觉：毁掉它，再复原它">1. 核心直觉：毁掉它，再复原它</a><ul><li><a href=#core-intuition-destroy-and-restore aria-label="Core Intuition: Destroy and Restore">Core Intuition: Destroy and Restore</a></li></ul></li><li><a href=#2-%e5%89%8d%e5%90%91%e8%bf%87%e7%a8%8b%e5%8a%a0%e5%99%aa-the-forward-process aria-label="2. 前向过程：加噪 (The Forward Process)">2. 前向过程：加噪 (The Forward Process)</a><ul><li><a href=#adding-noise-systematically aria-label="Adding Noise systematically">Adding Noise systematically</a></li></ul></li><li><a href=#3-%e5%8f%8d%e5%90%91%e8%bf%87%e7%a8%8b%e5%8e%bb%e5%99%aa-the-reverse-process aria-label="3. 反向过程：去噪 (The Reverse Process)">3. 反向过程：去噪 (The Reverse Process)</a><ul><li><a href=#denoising-with-neural-networks aria-label="Denoising with Neural Networks">Denoising with Neural Networks</a></li></ul></li><li><a href=#4-%e6%a0%b8%e5%bf%83%e9%9a%be%e7%82%b9%e8%ae%ad%e7%bb%83%e7%9b%ae%e6%a0%87%e6%98%af%e4%bb%80%e4%b9%88 aria-label="4. 核心难点：训练目标是什么？">4. 核心难点：训练目标是什么？</a><ul><li><a href=#the-hard-part-what-is-the-loss-function aria-label="The Hard Part: What is the Loss Function?">The Hard Part: What is the Loss Function?</a><ul><li><a href=#a-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e7%9b%b4%e6%8e%a5%e7%94%b1-x_t-%e6%8e%a8-x_t-1 aria-label="A. 为什么不能直接由 $x_t$ 推 $x_{t-1}$？">A. 为什么不能直接由 $x_t$ 推 $x_{t-1}$？</a></li><li><a href=#b-%e7%ae%80%e5%8c%96%e7%9a%84%e8%ae%ad%e7%bb%83%e7%9b%ae%e6%a0%87-simplified-loss-%e6%9c%80%e9%87%8d%e8%a6%81%e7%bb%93%e8%ae%ba aria-label="B. 简化的训练目标 (Simplified Loss) [⭐最重要结论]">B. 简化的训练目标 (Simplified Loss) [⭐最重要结论]</a></li></ul></li></ul></li><li><a href=#5-%e6%8e%a8%e7%90%86%e7%ae%97%e6%b3%95%e6%80%8e%e4%b9%88%e7%94%9f%e6%88%90%e5%9b%be%e7%89%87 aria-label="5. 推理算法：怎么生成图片？">5. 推理算法：怎么生成图片？</a><ul><li><a href=#inference-sampling-algorithm aria-label="Inference: Sampling Algorithm">Inference: Sampling Algorithm</a></li></ul></li><li><a href=#6-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary-2 aria-label="6. 专有名词表 (Glossary)">6. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary-6 aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li><li><a href=#cs5494-week-8-ai-agent aria-label="CS5494 Week 8: AI Agent">CS5494 Week 8: AI Agent</a></li><li><a href=#%e7%ac%ac%e5%85%ab%e5%91%a8%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e6%99%ba%e8%83%bd%e4%bd%93 aria-label=第八周：人工智能智能体>第八周：人工智能智能体</a><ul><li><a href=#1-%e6%a0%b8%e5%bf%83%e5%ae%9a%e4%b9%89%e4%bb%80%e4%b9%88%e6%98%af-ai-agent aria-label="1. 核心定义：什么是 AI Agent？">1. 核心定义：什么是 AI Agent？</a><ul><li><a href=#core-definition-what-is-an-ai-agent aria-label="Core Definition: What is an AI Agent?">Core Definition: What is an AI Agent?</a></li></ul></li><li><a href=#2-%e6%a0%b8%e5%bf%83%e8%83%bd%e5%8a%9b%e4%b8%80%e8%a7%84%e5%88%92%e4%b8%8e%e6%80%9d%e8%80%83-planning--reasoning aria-label="2. 核心能力一：规划与思考 (Planning & Reasoning)">2. 核心能力一：规划与思考 (Planning & Reasoning)</a><ul><li><a href=#core-capability-1-how-ai-thinks aria-label="Core Capability 1: How AI Thinks?">Core Capability 1: How AI Thinks?</a><ul><li><a href=#a-%e8%a7%82%e5%af%9f-%e6%80%9d%e8%80%83-%e8%a1%8c%e5%8a%a8%e5%be%aa%e7%8e%af-obs-think-act-loop aria-label="A. 观察-思考-行动循环 (Obs-Think-Act Loop)">A. 观察-思考-行动循环 (Obs-Think-Act Loop)</a></li><li><a href=#b-react-%e6%a1%86%e6%9e%b6-reasoning--acting-%e9%87%8d%e7%82%b9 aria-label="B. ReAct 框架 (Reasoning + Acting) [重点]">B. ReAct 框架 (Reasoning + Acting) [重点]</a></li></ul></li></ul></li><li><a href=#3-%e6%a0%b8%e5%bf%83%e8%83%bd%e5%8a%9b%e4%ba%8c%e5%b7%a5%e5%85%b7%e4%bd%bf%e7%94%a8-tool-use aria-label="3. 核心能力二：工具使用 (Tool Use)">3. 核心能力二：工具使用 (Tool Use)</a><ul><li><a href=#core-capability-2-how-ai-uses-tools aria-label="Core Capability 2: How AI Uses Tools?">Core Capability 2: How AI Uses Tools?</a></li></ul></li><li><a href=#4-%e6%a0%b8%e5%bf%83%e8%83%bd%e5%8a%9b%e4%b8%89%e8%ae%b0%e5%bf%86%e4%b8%8e%e7%bb%8f%e9%aa%8c-memory--experience aria-label="4. 核心能力三：记忆与经验 (Memory & Experience)">4. 核心能力三：记忆与经验 (Memory & Experience)</a><ul><li><a href=#core-capability-3-adjusting-behavior-via-experience aria-label="Core Capability 3: Adjusting Behavior via Experience">Core Capability 3: Adjusting Behavior via Experience</a></li></ul></li><li><a href=#5-%e8%bf%9b%e9%98%b6%e6%a6%82%e5%bf%b5agentic-ai-%e4%b8%8e%e5%a4%9a%e6%99%ba%e8%83%bd%e4%bd%93 aria-label="5. 进阶概念：Agentic AI 与多智能体">5. 进阶概念：Agentic AI 与多智能体</a><ul><li><a href=#advanced-concept-agentic-ai-systems aria-label="Advanced Concept: Agentic AI Systems">Advanced Concept: Agentic AI Systems</a></li></ul></li><li><a href=#6-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary-3 aria-label="6. 专有名词表 (Glossary)">6. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary-7 aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li><li><a href=#cs5494-week-9-3d-vision--generation aria-label="CS5494 Week 9: 3D Vision & Generation">CS5494 Week 9: 3D Vision & Generation</a></li><li><a href=#%e7%ac%ac%e4%b9%9d%e5%91%a8%e4%b8%89%e7%bb%b4%e8%a7%86%e8%a7%89%e4%b8%8e%e7%94%9f%e6%88%90 aria-label=第九周：三维视觉与生成>第九周：三维视觉与生成</a><ul><li><a href=#1-%e6%a0%b8%e5%bf%83%e7%97%9b%e7%82%b93d-%e8%a1%a8%e7%a4%ba%e7%9a%84%e5%a4%9a%e6%a0%b7%e6%80%a7 aria-label="1. 核心痛点：3D 表示的多样性">1. 核心痛点：3D 表示的多样性</a><ul><li><a href=#core-pain-point-diversity-of-3d-representations aria-label="Core Pain Point: Diversity of 3D Representations">Core Pain Point: Diversity of 3D Representations</a><ul><li><a href=#a-%e6%98%be%e5%bc%8f%e8%a1%a8%e7%a4%ba-explicit-representations aria-label="A. 显式表示 (Explicit Representations)">A. 显式表示 (Explicit Representations)</a></li><li><a href=#b-%e9%9a%90%e5%bc%8f%e8%a1%a8%e7%a4%ba-implicit-representations-%e9%87%8d%e7%82%b9 aria-label="B. 隐式表示 (Implicit Representations) [重点]">B. 隐式表示 (Implicit Representations) [重点]</a></li></ul></li></ul></li><li><a href=#2-%e6%a0%b8%e5%bf%83%e6%9e%b6%e6%9e%84pointnet-%e5%a4%84%e7%90%86%e7%82%b9%e4%ba%91 aria-label="2. 核心架构：PointNet (处理点云)">2. 核心架构：PointNet (处理点云)</a><ul><li><a href=#core-architecture-pointnet-processing-point-clouds aria-label="Core Architecture: PointNet (Processing Point Clouds)">Core Architecture: PointNet (Processing Point Clouds)</a></li></ul></li><li><a href=#3-%e9%9d%a9%e5%91%bd%e6%80%a7%e6%8a%80%e6%9c%afnerf-%e7%a5%9e%e7%bb%8f%e8%be%90%e5%b0%84%e5%9c%ba aria-label="3. 革命性技术：NeRF (神经辐射场)">3. 革命性技术：NeRF (神经辐射场)</a><ul><li><a href=#revolutionary-tech-nerf-neural-radiance-fields aria-label="Revolutionary Tech: NeRF (Neural Radiance Fields)">Revolutionary Tech: NeRF (Neural Radiance Fields)</a></li></ul></li><li><a href=#4-3d-%e7%94%9f%e6%88%90dreamfusion-%e4%b8%8e-sds aria-label="4. 3D 生成：DreamFusion 与 SDS">4. 3D 生成：DreamFusion 与 SDS</a><ul><li><a href=#3d-generation-dreamfusion--sds aria-label="3D Generation: DreamFusion & SDS">3D Generation: DreamFusion & SDS</a></li></ul></li><li><a href=#5-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary-3 aria-label="5. 专有名词表 (Glossary)">5. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary-8 aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li><li><a href=#cs5494-week-10-large-foundation-models-vlm--vla aria-label="CS5494 Week 10: Large Foundation Models (VLM & VLA)">CS5494 Week 10: Large Foundation Models (VLM & VLA)</a></li><li><a href=#%e7%ac%ac%e5%8d%81%e5%91%a8%e5%a4%9a%e6%a8%a1%e6%80%81%e5%9f%ba%e7%a1%80%e6%a8%a1%e5%9e%8b%e4%b8%8e%e5%85%b7%e8%ba%ab%e6%99%ba%e8%83%bd aria-label=第十周：多模态基础模型与具身智能>第十周：多模态基础模型与具身智能</a><ul><li><a href=#1-%e8%8c%83%e5%bc%8f%e8%bd%ac%e5%8f%98%e4%bb%8e%e4%b8%93%e7%94%a8%e6%a8%a1%e5%9e%8b%e5%88%b0%e5%9f%ba%e7%a1%80%e6%a8%a1%e5%9e%8b aria-label="1. 范式转变：从专用模型到基础模型">1. 范式转变：从专用模型到基础模型</a><ul><li><a href=#paradigm-shift-from-specialized-to-foundation-models aria-label="Paradigm Shift: From Specialized to Foundation Models">Paradigm Shift: From Specialized to Foundation Models</a></li></ul></li><li><a href=#2-%e8%a7%86%e8%a7%89-%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b-vlm-clip aria-label="2. 视觉-语言模型 (VLM): CLIP">2. 视觉-语言模型 (VLM): CLIP</a><ul><li><a href=#vision-language-models-vlm-clip aria-label="Vision-Language Models (VLM): CLIP">Vision-Language Models (VLM): CLIP</a></li></ul></li><li><a href=#3-%e8%ae%a9-llm-%e7%9c%8b%e6%87%82%e5%9b%be-llava aria-label="3. 让 LLM 看懂图: LLaVA">3. 让 LLM 看懂图: LLaVA</a><ul><li><a href=#making-llm-see-llava-large-language-and-vision-assistant aria-label="Making LLM See: LLaVA (Large Language-and-Vision Assistant)">Making LLM See: LLaVA (Large Language-and-Vision Assistant)</a></li></ul></li><li><a href=#4-%e8%a7%86%e8%a7%89%e5%88%86%e5%89%b2%e5%9f%ba%e5%ba%a7-sam aria-label="4. 视觉分割基座: SAM">4. 视觉分割基座: SAM</a><ul><li><a href=#vision-foundation-model-sam-segment-anything-model aria-label="Vision Foundation Model: SAM (Segment Anything Model)">Vision Foundation Model: SAM (Segment Anything Model)</a></li></ul></li><li><a href=#5-%e5%85%b7%e8%ba%ab%e6%99%ba%e8%83%bd-vla-%e6%a8%a1%e5%9e%8b-robotic-foundation-models aria-label="5. 具身智能: VLA 模型 (Robotic Foundation Models)">5. 具身智能: VLA 模型 (Robotic Foundation Models)</a><ul><li><a href=#embodied-ai-vision-language-action-models-vla aria-label="Embodied AI: Vision-Language-Action Models (VLA)">Embodied AI: Vision-Language-Action Models (VLA)</a><ul><li><a href=#a-rt-1-robotic-transformer-1 aria-label="A. RT-1 (Robotic Transformer 1)">A. RT-1 (Robotic Transformer 1)</a></li><li><a href=#b-rt-2-%e4%ba%92%e8%81%94%e7%bd%91%e7%9f%a5%e8%af%86%e8%bf%81%e7%a7%bb-internet-knowledge-transfer aria-label="B. RT-2: 互联网知识迁移 (Internet Knowledge Transfer)">B. RT-2: 互联网知识迁移 (Internet Knowledge Transfer)</a></li><li><a href=#c-rt-x--openvla aria-label="C. RT-X / OpenVLA">C. RT-X / OpenVLA</a></li></ul></li></ul></li><li><a href=#6-%e4%b8%93%e6%9c%89%e5%90%8d%e8%af%8d%e8%a1%a8-glossary-4 aria-label="6. 专有名词表 (Glossary)">6. 专有名词表 (Glossary)</a><ul><li><a href=#%e6%80%bb%e7%bb%93-summary-9 aria-label="总结 (Summary)">总结 (Summary)</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=cs5494-week-1-introduction-to-generative-ai--perception-models>CS5494 Week 1: Introduction to Generative AI & Perception Models<a hidden class=anchor aria-hidden=true href=#cs5494-week-1-introduction-to-generative-ai--perception-models>#</a></h2><h2 id=第一周生成式人工智能与感知模型导论>第一周：生成式人工智能与感知模型导论<a hidden class=anchor aria-hidden=true href=#第一周生成式人工智能与感知模型导论>#</a></h2><h3 id=1-核心概念生成模型与判别模型>1. 核心概念：生成模型与判别模型<a hidden class=anchor aria-hidden=true href=#1-核心概念生成模型与判别模型>#</a></h3><h4 id=core-concept-generative-vs-discriminative-models>Core Concept: Generative vs. Discriminative Models<a hidden class=anchor aria-hidden=true href=#core-concept-generative-vs-discriminative-models>#</a></h4><p>这是本节课最重要的理论基础，理解它们的区别是入门的关键。</p><p><strong>1. 判别模型 (Discriminative Models)</strong></p><ul><li><strong>功能 (Function)</strong>: 学习如何区分或预测。就像给作业打分的老师，看到一个输入（试卷），给出一个输出（分数）。<ul><li><em>Analogy</em>: Like a teacher grading an exam. Given an input (exam paper), it produces an output (score).</li></ul></li><li><strong>数学表达 (Mathematical Form)</strong>: 建模条件概率 $P(y|x)$。即给定输入 $x$（如一张照片），预测标签 $y$（如“猫”或“狗”）的概率。<ul><li><em>Math</em>: Models the conditional probability $P(y|x)$. Given input $x$, predict the probability of label $y$.</li></ul></li><li><strong>局限 (Limitation)</strong>: 它们无法创造新数据，只能对现有数据进行分类或回归。</li></ul><p><strong>2. 生成模型 (Generative Models)</strong></p><ul><li><strong>功能 (Function)</strong>: 学习数据的<strong>底层分布 (Underlying Distribution)</strong>，从而能够创造出与训练数据相似但全新的数据。就像一个画家，看过很多猫之后，在一张白纸上画出一只从未存在过的猫。<ul><li><em>Analogy</em>: Like an artist who, after seeing many cats, draws a new cat that never existed before on a blank piece of paper.</li></ul></li><li><strong>数学表达 (Mathematical Form)</strong>: 建模联合概率分布 $P(x,y)$ 或数据本身的分布 $P(x)$。<ul><li><em>Math</em>: Models the joint probability distribution $P(x,y)$ or the data distribution $P(x)$ itself.</li></ul></li><li><strong>核心目标 (Core Goal)</strong>: 能够从学习到的分布中<strong>采样 (Sample)</strong>，生成逼真的新样本（图像、文本、音频）。</li></ul><hr><h3 id=2-感知模型与表示学习>2. 感知模型与表示学习<a hidden class=anchor aria-hidden=true href=#2-感知模型与表示学习>#</a></h3><h4 id=perception-models--representation-learning>Perception Models & Representation Learning<a hidden class=anchor aria-hidden=true href=#perception-models--representation-learning>#</a></h4><p>课件中强调，为了做好生成（Generation），首先要解决感知（Perception）的问题。感知模型的核心就是<strong>表示学习</strong>。</p><p><strong>什么是表示学习？ (What is Representation Learning?)</strong></p><ul><li><strong>定义</strong>: 将原始数据（Raw Data）转化为机器更容易理解和处理的形式（Feature/Embedding）。<ul><li><em>Definition</em>: Converting raw data into a form (features/embeddings) that is easier for machines to understand and process.</li></ul></li><li><strong>过程</strong>: 从原始像素（Pixels）$\rightarrow$ 抽象特征（Abstraction）$\rightarrow$ 概念（Concepts）。<ul><li><em>Process</em>: From raw pixels $\rightarrow$ Abstract features $\rightarrow$ High-level concepts.</li></ul></li><li><strong>重要性</strong>: 好的表示（Representation）能让模型“理解”数据的本质，而不仅仅是死记硬背。AlphaGo 的成功就归功于它能比人类更好地表示棋盘局势。</li></ul><hr><h3 id=3-深度神经网络的演进-deep-neural-networks-evolution>3. 深度神经网络的演进 (Deep Neural Networks Evolution)<a hidden class=anchor aria-hidden=true href=#3-深度神经网络的演进-deep-neural-networks-evolution>#</a></h3><h4 id=from-lenet-to-transformers>From LeNet to Transformers<a hidden class=anchor aria-hidden=true href=#from-lenet-to-transformers>#</a></h4><p>这部分回顾了深度学习过去十年的关键突破，正是这些技术让现在的 GenAI 成为可能。</p><h5 id=a-卷积神经网络-cnns-的崛起>A. 卷积神经网络 (CNNs) 的崛起<a hidden class=anchor aria-hidden=true href=#a-卷积神经网络-cnns-的崛起>#</a></h5><ul><li><strong>LeNet (1989/1998)</strong>: 引入了<strong>卷积 (Convolution)</strong> 和 <strong>池化 (Pooling)</strong> 的概念。利用权值共享（Weight Sharing）大大减少了参数量，适合处理图像。</li><li><strong>AlexNet (2012)</strong>: 深度学习的爆发点。引入了 <strong>ReLU 激活函数</strong>（解决了梯度消失问题）和 <strong>Dropout</strong>，并使用了 GPU 加速训练。</li><li><strong>VGG (2014)</strong>: 证明了**“越深越好” (Deeper is better)**。它用连续的 3x3 小卷积核代替了大卷积核，加深了网络结构。</li></ul><h5 id=b-突破瓶颈初始化与归一化-initialization--normalization>B. 突破瓶颈：初始化与归一化 (Initialization & Normalization)<a hidden class=anchor aria-hidden=true href=#b-突破瓶颈初始化与归一化-initialization--normalization>#</a></h5><p>随着网络变深，训练变得极其困难（梯度爆炸或消失）。</p><ul><li><strong>初始化 (Initialization)</strong>: Xavier 和 Kaiming Initialization 提供了科学的参数初始值设定方法，让信号能更稳定地在网络中传播。</li><li><strong>批归一化 (Batch Normalization, BN)</strong>: 强制将每一层的输入拉回到标准的分布。这被认为是训练深层网络的“神技”，大大加速了收敛。</li></ul><h5 id=c-残差网络-resnet-2015>C. 残差网络 (ResNet, 2015)<a hidden class=anchor aria-hidden=true href=#c-残差网络-resnet-2015>#</a></h5><ul><li><strong>问题</strong>: 当网络非常深时（如 100 层），简单堆叠层数反而会导致性能下降（Degradation problem）。</li><li><strong>解决方案</strong>: 引入 <strong>Shortcut Connection (跳跃连接)</strong>，让数据可以直接跨层传递。<ul><li><em>Mechanism</em>: The network learns the residual (difference) $F(x)$ instead of the original mapping. Mathematically: $y = F(x) + x$.</li></ul></li><li><strong>意义</strong>: 使得训练成百上千层的网络成为可能，是现代大模型（包括 GPT 系列）的基石结构。</li></ul><h5 id=d-transformer-2017--vit-2020>D. Transformer (2017) & ViT (2020)<a hidden class=anchor aria-hidden=true href=#d-transformer-2017--vit-2020>#</a></h5><ul><li><strong>Transformer</strong>: 抛弃了循环（RNN）和卷积（CNN），完全依赖 <strong>Attention Mechanism (注意力机制)</strong>。每一个 token 都能看到所有其他 token，拥有<strong>全局上下文 (Global Context)</strong>。</li><li><strong>Vision Transformer (ViT)</strong>: 将图像切成小块（Patches），像处理文字一样处理图像。这统一了视觉和语言的模型架构。</li></ul><hr><h3 id=4-生成模型的框架>4. 生成模型的框架<a hidden class=anchor aria-hidden=true href=#4-生成模型的框架>#</a></h3><h4 id=framework-of-generative-models>Framework of Generative Models<a hidden class=anchor aria-hidden=true href=#framework-of-generative-models>#</a></h4><p>课件最后总结了构建一个生成模型的五个关键要素：</p><ol><li><strong>形式化 (Formulation)</strong>: 将问题定义为概率建模问题（如何描述 $P(x)$？）。</li><li><strong>表示 (Representation)</strong>: 使用深度神经网络（如 ResNet, Transformer）来拟合复杂的数据分布。</li><li><strong>目标函数 (Objective Function)</strong>: 定义“生成得好不好”的标准（Loss Function），衡量预测分布与真实分布的差异。</li><li><strong>优化 (Optimization)</strong>: 调整网络参数以最小化目标函数（通常使用反向传播）。</li><li><strong>推断 (Inference)</strong>: 训练好后，如何采样（Sampler）生成新数据？</li></ol><hr><h3 id=5-专有名词表-glossary>5. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#5-专有名词表-glossary>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>生成模型</strong></td><td style=text-align:left>Generative Model</td><td style=text-align:left>学习数据分布 $P(x)$ 以生成新样本的模型。如 GPT, Stable Diffusion。</td></tr><tr><td style=text-align:left><strong>判别模型</strong></td><td style=text-align:left>Discriminative Model</td><td style=text-align:left>学习条件概率 $P(y|x)$ 以分类或预测标签的模型。如垃圾邮件分类器。</td></tr><tr><td style=text-align:left><strong>表示学习</strong></td><td style=text-align:left>Representation Learning</td><td style=text-align:left>自动从原始数据中提取有效特征的过程，将高维数据映射到低维、抽象的特征空间。</td></tr><tr><td style=text-align:left><strong>卷积神经网络</strong></td><td style=text-align:left>CNN (Convolutional Neural Network)</td><td style=text-align:left>专门处理网格数据（如图像）的神经网络，利用卷积层提取局部特征。</td></tr><tr><td style=text-align:left><strong>残差学习</strong></td><td style=text-align:left>Residual Learning</td><td style=text-align:left>ResNet 的核心。通过引入“跳跃连接”，让网络学习残差（差异）而不是完整的映射，解决了深层网络的退化问题。</td></tr><tr><td style=text-align:left><strong>批归一化</strong></td><td style=text-align:left>Batch Normalization (BN)</td><td style=text-align:left>在每一层网络的激活前对数据进行归一化处理，防止分布偏移，加速训练。</td></tr><tr><td style=text-align:left><strong>注意力机制</strong></td><td style=text-align:left>Attention Mechanism</td><td style=text-align:left>Transformer 的核心。允许模型在处理一个元素时，动态关注序列中的其他相关元素（无论距离多远）。</td></tr><tr><td style=text-align:left><strong>反向传播</strong></td><td style=text-align:left>Backpropagation</td><td style=text-align:left>训练神经网络的核心算法。根据输出误差，反向计算梯度并更新网络参数。</td></tr><tr><td style=text-align:left><strong>概率分布</strong></td><td style=text-align:left>Probability Distribution</td><td style=text-align:left>描述随机变量取值可能性的数学函数。生成模型本质上就是在拟合这个复杂的函数。</td></tr><tr><td style=text-align:left><strong>推断</strong></td><td style=text-align:left>Inference</td><td style=text-align:left>模型训练完成后，利用模型进行预测或生成新数据的过程。</td></tr></tbody></table><h4 id=总结-summary>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary>#</a></h4><p>这份课件的核心逻辑是：<strong>Generative AI 的本质是概率分布的建模，而为了通过机器学习好这个分布，我们需要强大的 Deep Learning 模型（如 ResNet, Transformer）作为支撑。</strong> 所以第一周花了很多时间复习深度学习的基础架构。</p><hr><h2 id=cs5494-week-2-basics-of-probability-distributions>CS5494 Week 2: Basics of Probability Distributions<a hidden class=anchor aria-hidden=true href=#cs5494-week-2-basics-of-probability-distributions>#</a></h2><h2 id=第二周概率分布基础>第二周：概率分布基础<a hidden class=anchor aria-hidden=true href=#第二周概率分布基础>#</a></h2><h3 id=1-生成模型-vs-判别模型-进阶版>1. 生成模型 vs. 判别模型 (进阶版)<a hidden class=anchor aria-hidden=true href=#1-生成模型-vs-判别模型-进阶版>#</a></h3><h4 id=generative-vs-discriminative-models-revisited>Generative vs. Discriminative Models (Revisited)<a hidden class=anchor aria-hidden=true href=#generative-vs-discriminative-models-revisited>#</a></h4><p>上周讲了概念，这周从数学角度深入对比。</p><ul><li><p><strong>判别模型 (Discriminative Models)</strong>:</p><ul><li><strong>目标 (Goal)</strong>: 直接区分 $y$（标签）。建立 $x$ 到 $y$ 的映射。</li><li><strong>数学 (Math)</strong>: 建模条件概率 <strong>$P(y|x)$</strong>。</li><li><strong>决策边界 (Decision Boundary)</strong>: 它只关心怎么把两类数据分开，不关心数据长什么样。</li><li><em>Analogy</em>: Like learning a rule to distinguish cats from dogs without knowing how to draw them.</li></ul></li><li><p><strong>生成模型 (Generative Models)</strong>:</p><ul><li><strong>目标 (Goal)</strong>: 描述数据 $x$ 是如何生成的。</li><li><strong>数学 (Math)</strong>: 建模联合概率 <strong>$P(x, y)$</strong> 或边缘概率 <strong>$P(x)$</strong>。</li><li><strong>贝叶斯公式 (Bayes&rsquo; Rule)</strong>: 生成模型可以通过贝叶斯公式转化为判别模型：
$$P(y|x) = \frac{P(x|y)P(y)}{P(x)}$$</li><li><strong>优势 (Advantage)</strong>: 课件特别提到，生成模型在<strong>缺失数据 (Missing Data)</strong> 的情况下依然有效。因为它可以对未观察到的变量进行边缘化 (Marginalize)，而判别模型必须依赖完整的 $x$。</li></ul></li></ul><hr><h3 id=2-核心挑战维数灾难>2. 核心挑战：维数灾难<a hidden class=anchor aria-hidden=true href=#2-核心挑战维数灾难>#</a></h3><h4 id=the-core-challenge-curse-of-dimensionality>The Core Challenge: Curse of Dimensionality<a hidden class=anchor aria-hidden=true href=#the-core-challenge-curse-of-dimensionality>#</a></h4><p>这是本节课提出的最根本问题：为什么生成模型这么难做？</p><ul><li><strong>问题描述 (Problem)</strong>: 假设我们要为一个简单的 $28 \times 28$ 黑白像素图像（如 MNIST 数字）建模联合分布。<ul><li>每个像素有 2 种状态（0 或 1）。</li><li>总共有 $784$ 个像素。</li><li>那么这幅图可能的状态总数是 <strong>$2^{784}$</strong>。</li><li><em>Concept</em>: The number of possible configurations grows exponentially with the number of variables (pixels).</li></ul></li><li><strong>结论 (Conclusion)</strong>: 我们不可能列出一张表来记录每一个可能图像的概率。所需的参数量远远超过了宇宙中原子的数量。</li><li><strong>解决方案 (Solution)</strong>: 我们必须引入<strong>假设 (Assumptions)</strong> 和 <strong>结构 (Structure)</strong> 来减少参数量。</li></ul><hr><h3 id=3-结构化模型贝叶斯网络>3. 结构化模型：贝叶斯网络<a hidden class=anchor aria-hidden=true href=#3-结构化模型贝叶斯网络>#</a></h3><h4 id=structured-models-bayesian-networks>Structured Models: Bayesian Networks<a hidden class=anchor aria-hidden=true href=#structured-models-bayesian-networks>#</a></h4><p>为了解决维数灾难，我们引入了“条件独立性”假设。</p><h5 id=a-链式法则-the-chain-rule>A. 链式法则 (The Chain Rule)<a hidden class=anchor aria-hidden=true href=#a-链式法则-the-chain-rule>#</a></h5><p>任何复杂的联合分布都可以分解为条件概率的乘积：
$$P(x_1, x_2, x_3, x_4) = P(x_1) P(x_2|x_1) P(x_3|x_1, x_2) P(x_4|x_1, x_2, x_3)$$</p><ul><li><strong>解释</strong>: 就像讲故事，后面的情节取决于前面的铺垫。</li><li><strong>问题</strong>: 即使分解了，参数量并没有减少。最后几项依然非常复杂。</li></ul><h5 id=b-条件独立性假设-conditional-independence-assumption>B. 条件独立性假设 (Conditional Independence Assumption)<a hidden class=anchor aria-hidden=true href=#b-条件独立性假设-conditional-independence-assumption>#</a></h5><p>这是贝叶斯网络的核心。我们假设：<strong>每个变量只依赖于它的少数几个“父节点”，而不是之前的所有变量。</strong></p><ul><li><em>Key Idea</em>: Variable $x_i$ is independent of its non-descendants given its parents.</li></ul><h5 id=c-贝叶斯网络-bayesian-networks>C. 贝叶斯网络 (Bayesian Networks)<a hidden class=anchor aria-hidden=true href=#c-贝叶斯网络-bayesian-networks>#</a></h5><ul><li><strong>定义</strong>: 一个有向无环图 (DAG)，其中节点代表变量，边代表依赖关系。</li><li><strong>公式</strong>: $P(x_1, &mldr;, x_n) = \prod_{i=1}^{n} P(x_i | \text{Parents}(x_i))$</li><li><strong>效果</strong>: 极大地减少了参数量。<ul><li><strong>全连接 (Fully Connected)</strong>: 每个变量都依赖所有前序变量 $\rightarrow$ 参数爆炸。</li><li><strong>稀疏连接 (Sparse)</strong>: 每个变量只依赖 1-2 个父节点 $\rightarrow$ 参数可控。</li></ul></li></ul><h5 id=d-经典案例朴素贝叶斯-naive-bayes>D. 经典案例：朴素贝叶斯 (Naive Bayes)<a hidden class=anchor aria-hidden=true href=#d-经典案例朴素贝叶斯-naive-bayes>#</a></h5><ul><li>这是贝叶斯网络的一个极端特例。</li><li><strong>假设</strong>: 给定类别 $y$ 后，所有的特征 $x_i$ 都是<strong>相互独立</strong>的。<ul><li><em>Assumption</em>: All features are independent given the class label.</li></ul></li><li><strong>局限</strong>: 这个假设太强了（现实中像素之间肯定有关联），所以它生成的图片通常全是噪点，效果不好。但它作为分类器效果还不错。</li></ul><hr><h3 id=4-神经模型引入深度学习>4. 神经模型：引入深度学习<a hidden class=anchor aria-hidden=true href=#4-神经模型引入深度学习>#</a></h3><h4 id=neural-models-merging-probability-with-deep-learning>Neural Models: Merging Probability with Deep Learning<a hidden class=anchor aria-hidden=true href=#neural-models-merging-probability-with-deep-learning>#</a></h4><p>传统的图模型（如贝叶斯网络）需要专家手工设计依赖关系图，这很难。现在的趋势是结合神经网络。</p><ul><li><strong>参数化 (Parameterization)</strong>:
在贝叶斯网络中，我们需要用表格或简单函数来表示 $P(x_i | \text{Parents}(x_i))$。
在神经模型中，我们用一个<strong>神经网络</strong>来拟合这个条件概率函数。<ul><li><em>Mechanism</em>: Use a neural network to output the probability distribution parameters.</li></ul></li><li><strong>非线性依赖 (Non-linear Dependence)</strong>:
线性模型（如逻辑回归）假设变量间是线性关系。而神经网络通过激活函数（如 Sigmoid, ReLU）引入了非线性，能够捕捉更复杂的数据关系。
$$y = \sigma(Wx + b)$$</li><li><strong>从图到网 (From Graphs to Nets)</strong>:
我们可以重复堆叠神经层，构建深层网络。这实际上是在学习更复杂的、隐含的依赖结构，而不需要人工显式地画出每一条边。</li></ul><hr><h3 id=5-专有名词表-glossary-1>5. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#5-专有名词表-glossary-1>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>联合分布</strong></td><td style=text-align:left>Joint Distribution</td><td style=text-align:left>$P(x, y)$ 或 $P(x_1, &mldr;, x_n)$。描述所有变量同时取特定值的概率。这是生成模型的核心。</td></tr><tr><td style=text-align:left><strong>条件概率</strong></td><td style=text-align:left>Conditional Probability</td><td style=text-align:left>$P(A|B)$。在事件 B 发生的条件下，事件 A 发生的概率。</td></tr><tr><td style=text-align:left><strong>边缘化</strong></td><td style=text-align:left>Marginalization</td><td style=text-align:left>通过对某些变量求和（或积分），从联合分布中得到子集变量分布的过程。常用于处理缺失数据。</td></tr><tr><td style=text-align:left><strong>维数灾难</strong></td><td style=text-align:left>Curse of Dimensionality</td><td style=text-align:left>随着数据维度（特征数量）增加，数据空间呈指数级爆炸，导致数据变得极其稀疏，难以建模。</td></tr><tr><td style=text-align:left><strong>链式法则</strong></td><td style=text-align:left>Chain Rule (Probability)</td><td style=text-align:left>概率论基本定理，允许将联合概率分解为一系列条件概率的乘积。</td></tr><tr><td style=text-align:left><strong>贝叶斯网络</strong></td><td style=text-align:left>Bayesian Network</td><td style=text-align:left>一种概率图模型，使用有向无环图 (DAG) 来表示变量间的条件依赖关系。</td></tr><tr><td style=text-align:left><strong>条件独立</strong></td><td style=text-align:left>Conditional Independence</td><td style=text-align:left>如果已知变量 Z，变量 X 和 Y 互不影响，则称 X 和 Y 关于 Z 条件独立。这是简化模型的关键。</td></tr><tr><td style=text-align:left><strong>朴素贝叶斯</strong></td><td style=text-align:left>Naive Bayes</td><td style=text-align:left>一种简单的生成模型，假设特征之间相互独立。常作为基准模型 (Baseline)。</td></tr><tr><td style=text-align:left><strong>有向无环图</strong></td><td style=text-align:left>DAG (Directed Acyclic Graph)</td><td style=text-align:left>贝叶斯网络的结构基础，图中的边是有方向的，且不存在闭环。</td></tr><tr><td style=text-align:left><strong>逻辑函数</strong></td><td style=text-align:left>Logistic Function (Sigmoid)</td><td style=text-align:left>$\sigma(z) = \frac{1}{1+e^{-z}}$。常用于神经网络中将输出压缩到 (0,1) 之间，表示概率。</td></tr></tbody></table><h4 id=总结-summary-1>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary-1>#</a></h4><p>Week 2 告诉你：<strong>因为世界太复杂（维数灾难），我们不能蛮力记录所有可能性。</strong> 我们必须<strong>偷懒</strong>——要么假设变量之间没那么多关系（贝叶斯网络），要么用一个强大的黑盒（神经网络）去拟合这些关系。现代 GenAI 正是选择了后者。</p><hr><h2 id=cs5494-week-3-autoregressive-models>CS5494 Week 3: Autoregressive Models<a hidden class=anchor aria-hidden=true href=#cs5494-week-3-autoregressive-models>#</a></h2><h2 id=第三周自回归模型>第三周：自回归模型<a hidden class=anchor aria-hidden=true href=#第三周自回归模型>#</a></h2><h3 id=1-核心定义什么是自回归模型>1. 核心定义：什么是自回归模型？<a hidden class=anchor aria-hidden=true href=#1-核心定义什么是自回归模型>#</a></h3><h4 id=core-definition-what-are-autoregressive-models>Core Definition: What are Autoregressive Models?<a hidden class=anchor aria-hidden=true href=#core-definition-what-are-autoregressive-models>#</a></h4><p>自回归模型是生成式 AI 中最主流的一派（GPT 中的 &ldquo;G&rdquo; 就是 Generative，实际上是 Autoregressive 的）。</p><ul><li><p><strong>基本思想 (Basic Idea)</strong>:
将生成高维数据（如一张图或一段话）的任务，拆解为<strong>序列生成 (Sequential Generation)</strong> 任务。即：根据前面所有的内容，预测下一个内容。</p><ul><li><em>Concept</em>: Decompose the task of generating high-dimensional data into a <strong>sequential generation</strong> task. Predict the next token based on all previous tokens.</li></ul></li><li><p><strong>数学基础：链式法则 (Mathematical Foundation: Chain Rule)</strong>
我们利用概率链式法则，将联合分布分解为条件概率的乘积，<strong>不引入任何独立性假设</strong>：
$$P(x_1, &mldr;, x_n) = \prod_{i=1}^{n} P(x_i | x_1, &mldr;, x_{i-1})$$</p><ul><li><em>Explanation</em>: $x_i$ depends on <strong>all</strong> previous variables $x_{&lt;i}$. This is different from Naive Bayes (which assumes independence).</li></ul></li></ul><hr><h3 id=2-全可见信念网络-fvbn>2. 全可见信念网络 (FVBN)<a hidden class=anchor aria-hidden=true href=#2-全可见信念网络-fvbn>#</a></h3><h4 id=fully-visible-belief-networks-fvbn>Fully Visible Belief Networks (FVBN)<a hidden class=anchor aria-hidden=true href=#fully-visible-belief-networks-fvbn>#</a></h4><p>这是一个理论模型，用来解释自回归过程的图结构。</p><ul><li><strong>结构 (Structure)</strong>:
这是一个有向无环图 (DAG)。每一个节点 $x_i$ 都连接到它之前的所有节点 ($x_1$ 到 $x_{i-1}$)。<ul><li><em>Structure</em>: Every node $x_i$ is connected to all its predecessors.</li></ul></li><li><strong>参数化 (Parameterization)</strong>:
既然 $x_i$ 依赖于前面所有 $x$，我们需要一个函数来拟合这个关系：
$$P(x_i | x_{&lt;i}) = f(x_{&lt;i}; \theta)$$<ul><li><strong>线性方法</strong>: 使用逻辑回归 (Logistic Regression)。能力有限，处理不了复杂图片。</li><li><strong>非线性方法</strong>: 使用神经网络 (Neural Networks)，如 <strong>NADE (Neural Autoregressive Distribution Estimation)</strong>。NADE 通过共享权重的方法，用神经网络来预测像素的条件概率。</li></ul></li></ul><hr><h3 id=3-循环神经网络-rnn>3. 循环神经网络 (RNN)<a hidden class=anchor aria-hidden=true href=#3-循环神经网络-rnn>#</a></h3><h4 id=recurrent-neural-networks-rnn>Recurrent Neural Networks (RNN)<a hidden class=anchor aria-hidden=true href=#recurrent-neural-networks-rnn>#</a></h4><p>当我们要处理<strong>序列数据 (Sequential Data)</strong>（如文本、音频），而不是固定大小的图片时，FVBN 这种固定结构的图就不够用了。我们需要 RNN。</p><ul><li><p><strong>核心机制：隐状态 (Core Mechanism: Hidden State)</strong>
RNN 引入了一个“记忆单元”——隐状态 $h_t$。
$$h_t = \sigma(W x_t + U h_{t-1})$$</p><ul><li>$x_t$: 当前的输入（这个字）。</li><li>$h_{t-1}$: 上一步的记忆（上文的意思）。</li><li>$h_t$: 更新后的记忆（包含当前字和上文的意思）。</li><li><em>Function</em>: The hidden state acts as a summary of the entire history up to time $t$.</li></ul></li><li><p><strong>RNN 的致命弱点 (Issues with RNNs)</strong>:</p><ol><li><strong>信息瓶颈 (Information Bottleneck)</strong>: 所有的历史信息（哪怕是一本书）都必须被压缩进一个固定大小的向量 $h_t$ 中，导致信息丢失。</li><li><strong>梯度消失 (Vanishing Gradients)</strong>: 也就是“长时记忆遗忘”。模型很难记住很久以前出现的词。</li><li><strong>无法并行 (Sequential Computation)</strong>: 必须算完 $t-1$ 才能算 $t$，训练速度非常慢。</li></ol></li></ul><hr><h3 id=4-革命性突破attention-与-transformer>4. 革命性突破：Attention 与 Transformer<a hidden class=anchor aria-hidden=true href=#4-革命性突破attention-与-transformer>#</a></h3><h4 id=the-revolution-attention--transformer>The Revolution: Attention & Transformer<a hidden class=anchor aria-hidden=true href=#the-revolution-attention--transformer>#</a></h4><p>这是本周课件的<strong>重中之重</strong>，也是现代 LLM 的基石。</p><h5 id=a-注意力机制-attention-mechanism>A. 注意力机制 (Attention Mechanism)<a hidden class=anchor aria-hidden=true href=#a-注意力机制-attention-mechanism>#</a></h5><p>为了解决 RNN “记不住”的问题，我们引入了 Attention。</p><ul><li><strong>原理 (Principle)</strong>: 在预测下一个词时，模型不再只依赖那个被压缩的 $h_t$，而是可以<strong>直接“回头看”</strong> 原始输入序列中的每一个词，并根据相关性给予不同的权重。<ul><li><em>Analogy</em>: Instead of reading the whole book and trying to summarize it in one sentence (RNN), you can flip back to any previous page to find the relevant information when needed.</li></ul></li></ul><h5 id=b-transformer-架构>B. Transformer 架构<a hidden class=anchor aria-hidden=true href=#b-transformer-架构>#</a></h5><p>Transformer 彻底抛弃了 RNN 的循环结构，完全基于 Attention。</p><ul><li><strong>自注意力 (Self-Attention)</strong>:
序列中的每个词都会去“关注”序列中的其他所有词，计算它们之间的关联。<ul><li><strong>Query (Q), Key (K), Value (V)</strong>: 这是 Attention 的核心计算公式。
$$Attention(Q, K, V) = \text{softmax}(\frac{QK^T}{\sqrt{d_k}})V$$</li></ul></li><li><strong>掩码自注意力 (Masked Self-Attention)</strong>:<ul><li><strong>关键点</strong>: 在训练生成模型时，我们不能让模型“偷看”到后面的答案。</li><li><em>Explanation</em>: We apply a mask (setting future positions to $-\infty$) so that when predicting position $t$, the model can only attend to positions $1$ to $t-1$. This preserves the autoregressive property.</li></ul></li><li><strong>优势 (Advantages)</strong>:<ol><li><strong>并行计算 (Parallelization)</strong>: 不用像 RNN 那样排队算，可以一次性输入整个句子，利用 GPU 疯狂加速。</li><li><strong>全局视野 (Global Context)</strong>:无论两个词距离多远，它们之间的交互距离都是 1（直接相连）。</li></ol></li></ul><hr><h3 id=5-专有名词表-glossary-2>5. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#5-专有名词表-glossary-2>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>自回归模型</strong></td><td style=text-align:left>Autoregressive Model</td><td style=text-align:left>根据之前的序列值来预测当前值的模型。比如根据前文预测下一个字。</td></tr><tr><td style=text-align:left><strong>链式法则</strong></td><td style=text-align:left>Chain Rule</td><td style=text-align:left>概率论定理，允许将 $P(A, B, C)$ 分解为 $P(A)P(B|A)P(C|A,B)$。是自回归模型的数学基础。</td></tr><tr><td style=text-align:left><strong>全可见信念网络</strong></td><td style=text-align:left>FVBN (Fully Visible Belief Network)</td><td style=text-align:left>一种概率图模型，每个变量都依赖于它之前的所有变量。</td></tr><tr><td style=text-align:left><strong>循环神经网络</strong></td><td style=text-align:left>RNN (Recurrent Neural Network)</td><td style=text-align:left>专门处理序列数据的神经网络，具有“记忆”功能（隐状态），能捕捉时间依赖性。</td></tr><tr><td style=text-align:left><strong>梯度消失</strong></td><td style=text-align:left>Vanishing Gradient</td><td style=text-align:left>深度网络（尤其是 RNN）训练中的常见问题，指反向传播时梯度变得极小，导致模型无法学习长距离依赖。</td></tr><tr><td style=text-align:left><strong>注意力机制</strong></td><td style=text-align:left>Attention Mechanism</td><td style=text-align:left>允许模型在处理当前任务时，动态地关注输入序列中不同部分的技术。</td></tr><tr><td style=text-align:left><strong>自注意力</strong></td><td style=text-align:left>Self-Attention</td><td style=text-align:left>Attention 的一种变体，指一个序列内部的元素之间互相进行 Attention 计算，以捕捉序列内部的关联。</td></tr><tr><td style=text-align:left><strong>掩码</strong></td><td style=text-align:left>Masking</td><td style=text-align:left>在 Transformer 训练中，通过遮挡未来的 Token，防止模型“作弊”（看到未来），从而强制模型学习预测下一个词。</td></tr><tr><td style=text-align:left><strong>Transformer</strong></td><td style=text-align:left>Transformer</td><td style=text-align:left>由 Google 提出的基于 Attention 机制的深度学习模型架构，是 BERT、GPT 等现代大模型的基础。</td></tr></tbody></table><h4 id=总结-summary-2>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary-2>#</a></h4><p>Week 3 的逻辑链条是：
<strong>我们要生成序列 $\rightarrow$ 最初用简单的统计方法 (N-gram) $\rightarrow$ 后来用 RNN (但有记忆瓶颈且慢) $\rightarrow$ 现在用 Transformer (通过 Attention 机制解决了记忆和速度问题)</strong>。</p><p>理解了 <strong>Masked Self-Attention</strong>，你就理解了 GPT (Generative Pre-trained Transformer) 为什么能像接龙一样一个个字地生成文本。</p><hr><h2 id=cs5494-week-4-large-language-models-decoder-only-architecture>CS5494 Week 4: Large Language Models (Decoder-only Architecture)<a hidden class=anchor aria-hidden=true href=#cs5494-week-4-large-language-models-decoder-only-architecture>#</a></h2><h2 id=第四周大语言模型仅解码器架构>第四周：大语言模型（仅解码器架构）<a hidden class=anchor aria-hidden=true href=#第四周大语言模型仅解码器架构>#</a></h2><h3 id=1-宏观架构decoder-only-模型>1. 宏观架构：Decoder-only 模型<a hidden class=anchor aria-hidden=true href=#1-宏观架构decoder-only-模型>#</a></h3><h4 id=macro-architecture-decoder-only-models>Macro Architecture: Decoder-only Models<a hidden class=anchor aria-hidden=true href=#macro-architecture-decoder-only-models>#</a></h4><p>这是本周最重要的概念。原始的 Transformer (2017) 是 Encoder-Decoder 架构（用于翻译）。但后来的 GPT 系列（包括 Llama, DeepSeek）发现，做<strong>生成任务</strong>只需要<strong>Decoder</strong>。</p><ul><li><strong>Decoder-only 的逻辑</strong>:
我们不需要把输入压缩成一个向量再解压（Encoder-Decoder），而是直接进行“接龙”。每一个 token 既是输入也是输出的一部分。<ul><li><em>Concept</em>: Instead of encoding text into a vector and then decoding it, we treat the task as a continuous sequence generation.</li><li><strong>结构 (Structure)</strong>: 它是多个 <strong>Decoder Block</strong> 的堆叠（Stack）。每个 Block 包含两个核心组件：<ol><li><strong>Masked Self-Attention</strong> (带掩码的自注意力)</li><li><strong>Feed Forward Neural Network (FFN/MLP)</strong> (前馈神经网络)</li></ol></li></ul></li></ul><hr><h3 id=2-预处理第一步分词器-tokenizer>2. 预处理第一步：分词器 (Tokenizer)<a hidden class=anchor aria-hidden=true href=#2-预处理第一步分词器-tokenizer>#</a></h3><h4 id=preprocessing-step-1-tokenizer>Preprocessing Step 1: Tokenizer<a hidden class=anchor aria-hidden=true href=#preprocessing-step-1-tokenizer>#</a></h4><p>模型看不懂单词，只能看懂数字。Tokenizer 的作用就是把文本切块并转化为数字 ID。</p><ul><li><strong>为什么不是按字符（Character）切？</strong><ul><li>“apple”按字符切是 5 个 ID。序列太长，且单个字母没有语义。</li></ul></li><li><strong>为什么不是按单词（Word）切？</strong><ul><li>英语单词太多了（几十万个），词表（Vocabulary）会爆炸，且无法处理生僻词（OOV - Out of Vocabulary）。</li></ul></li><li><strong>最佳方案：子词分词 (Sub-word Tokenization)</strong><ul><li><strong>BPE (Byte Pair Encoding)</strong>: 这是目前最主流的方法。它会统计语料中出现频率最高的“字符对”，把它们合并成一个新的 token。</li><li><em>Mechanism</em>: Frequently occurring character pairs are merged into a single token. e.g., &ldquo;learning&rdquo; might be split into &ldquo;learn&rdquo; + &ldquo;ing&rdquo;.</li><li><strong>优势</strong>: 既控制了词表大小（通常 3万-10万），又能通过组合来表示任何词。</li></ul></li></ul><hr><h3 id=3-预处理第二步嵌入层-embedding>3. 预处理第二步：嵌入层 (Embedding)<a hidden class=anchor aria-hidden=true href=#3-预处理第二步嵌入层-embedding>#</a></h3><h4 id=preprocessing-step-2-embedding>Preprocessing Step 2: Embedding<a hidden class=anchor aria-hidden=true href=#preprocessing-step-2-embedding>#</a></h4><p>把 Tokenizer 给出的数字 ID（例如 &ldquo;cat&rdquo; -> 4521）变成一个高维向量。</p><ul><li><strong>语义空间 (Semantic Space)</strong>:
Embedding 将离散的 ID 映射到一个连续的向量空间。在这个空间里，语义相近的词距离更近。<ul><li><em>Example</em>: Vector(&ldquo;King&rdquo;) - Vector(&ldquo;Man&rdquo;) + Vector(&ldquo;Woman&rdquo;) $\approx$ Vector(&ldquo;Queen&rdquo;).</li></ul></li><li><strong>查表 (Lookup Table)</strong>:
本质上是一个巨大的矩阵，模型通过 ID 去在这个矩阵里查找对应的行。</li></ul><hr><h3 id=4-关键技术位置编码-positional-embeddingencoding>4. 关键技术：位置编码 (Positional Embedding/Encoding)<a hidden class=anchor aria-hidden=true href=#4-关键技术位置编码-positional-embeddingencoding>#</a></h3><h4 id=key-technique-positional-embedding>Key Technique: Positional Embedding<a hidden class=anchor aria-hidden=true href=#key-technique-positional-embedding>#</a></h4><p>这是 Transformer 架构中最天才但也最难理解的设计之一。</p><ul><li><p><strong>问题 (The Problem)</strong>:
Attention 机制本质上是“词袋模型”（Bag of Words）。它计算的是两两之间的关联，如果不加干预，“我爱你”和“你爱我”在 Attention 看来是一样的。<strong>模型不知道词的顺序。</strong></p><ul><li><em>Concept</em>: Attention is permutation invariant. It has no inherent notion of sequence order.</li></ul></li><li><p><strong>解决方案 (The Solution)</strong>:
我们需要给每个 token 的向量里“加”一点信息，告诉模型它在第几个位置。
$$Input = TokenEmbedding + PositionalEmbedding$$</p></li><li><p><strong>正弦/余弦位置编码 (Sinusoidal/Cosinusoidal PE)</strong>:
课件中特别提到了这个经典方法（原始 Transformer 使用）。</p><ul><li><strong>原理</strong>: 使用不同频率的正弦和余弦波来表示位置。</li><li><em>Reasoning</em>: 就像时钟的指针，秒针转得快，分针转得慢。通过不同频率的波组合，可以唯一地标识每一个绝对位置。</li><li><strong>公式</strong>: $PE_{(pos, 2i)} = \sin(pos / 10000^{2i/d_{model}})$</li></ul></li></ul><hr><h3 id=5-核心机制因果注意力-causal-attention>5. 核心机制：因果注意力 (Causal Attention)<a hidden class=anchor aria-hidden=true href=#5-核心机制因果注意力-causal-attention>#</a></h3><h4 id=core-mechanism-causal-attention-masked-attention>Core Mechanism: Causal Attention (Masked Attention)<a hidden class=anchor aria-hidden=true href=#core-mechanism-causal-attention-masked-attention>#</a></h4><p>这是 GPT (Decoder-only) 和 BERT (Encoder-only) 的根本区别。</p><ul><li><p><strong>不能偷看未来 (No Peeking at the Future)</strong>:
在做文本生成（自回归）时，当我们预测第 $t$ 个词，我们只能看到 $1$ 到 $t-1$ 个词。如果让模型看到了第 $t+1$ 个词，那就是作弊，训练出来的模型毫无用处。</p></li><li><p><strong>掩码矩阵 (Mask Matrix)</strong>:
我们在计算 Attention Score 时，人为地把“未来”位置的分数设为负无穷（$-\infty$）。这样经过 Softmax 后，未来的权重就变成了 0。</p><ul><li><em>Visual</em>: 这通常表现为一个<strong>下三角矩阵 (Lower Triangular Matrix)</strong>。</li><li><em>Result</em>: <code>Token 3</code> can attend to <code>Token 1, 2, 3</code>, but NOT <code>Token 4, 5</code>.</li></ul></li></ul><hr><h3 id=6-训练与推理-training-vs-inference>6. 训练与推理 (Training vs. Inference)<a hidden class=anchor aria-hidden=true href=#6-训练与推理-training-vs-inference>#</a></h3><h4 id=training-phase-vs-generation-phase>Training Phase vs. Generation Phase<a hidden class=anchor aria-hidden=true href=#training-phase-vs-generation-phase>#</a></h4><p>这两个阶段在操作上有显著区别，课件最后专门做了对比。</p><ul><li><p><strong>训练阶段 (Training)</strong>: <strong>并行 (Parallel)</strong></p><ul><li>我们已经拥有完整的句子（Ground Truth）。虽然我们要模拟“不能看未来”，但我们可以一次性把整句话输入进去，通过 Mask 矩阵并行计算所有位置的 Loss。这叫 <strong>Teacher Forcing</strong>。</li><li><em>Advantage</em>: Very fast, utilizes GPU parallelism.</li></ul></li><li><p><strong>生成/推理阶段 (Generation/Inference)</strong>: <strong>串行 (Sequential)</strong></p><ul><li>我们真的不知道下一个词是什么。只能生成一个词，把它加到输入里，再生成下一个。</li><li><strong>KV Cache</strong>: 为了加速，我们会把之前算过的 Key 和 Value 存起来，不用每次都重算以前的词。</li></ul></li></ul><hr><h3 id=7-专有名词表-glossary>7. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#7-专有名词表-glossary>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>仅解码器架构</strong></td><td style=text-align:left>Decoder-only Architecture</td><td style=text-align:left>像 GPT 这样的架构，去掉了 Transformer 的编码器，专注于自回归生成的结构。</td></tr><tr><td style=text-align:left><strong>分词器</strong></td><td style=text-align:left>Tokenizer</td><td style=text-align:left>将文本分割成 Token（数字 ID）的组件。常见算法有 BPE (Byte Pair Encoding)。</td></tr><tr><td style=text-align:left><strong>嵌入</strong></td><td style=text-align:left>Embedding</td><td style=text-align:left>将离散的 Token ID 转化为连续的高维向量，捕捉词义。</td></tr><tr><td style=text-align:left><strong>位置编码</strong></td><td style=text-align:left>Positional Embedding (PE)</td><td style=text-align:left>注入到 Embedding 中的位置信息，使 Attention 机制能够识别词序。常见有 Sinusoidal PE。</td></tr><tr><td style=text-align:left><strong>因果注意力</strong></td><td style=text-align:left>Causal Attention</td><td style=text-align:left>也叫 Masked Attention。通过掩码确保模型在预测当前词时，只能关注到之前的词，不能关注未来的词。</td></tr><tr><td style=text-align:left><strong>掩码</strong></td><td style=text-align:left>Mask</td><td style=text-align:left>在 Attention 矩阵中将特定区域（如上三角区域）设为负无穷，以屏蔽信息。</td></tr><tr><td style=text-align:left><strong>Teacher Forcing</strong></td><td style=text-align:left>Teacher Force</td><td style=text-align:left>训练时的一种策略，不管模型上一步预测得对不对，下一步输入都强制使用真实的正确答案。这允许并行训练。</td></tr><tr><td style=text-align:left><strong>自回归</strong></td><td style=text-align:left>Autoregressive</td><td style=text-align:left>每一个输出都依赖于之前的输出。即 $P(x_t</td></tr><tr><td style=text-align:left><strong>前馈神经网络</strong></td><td style=text-align:left>FFN / MLP</td><td style=text-align:left>Transformer Block 中的全连接层部分，负责处理和整合 Attention 提取的信息。</td></tr></tbody></table><h4 id=总结-summary-3>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary-3>#</a></h4><p>Week 4 告诉你如何把之前的理论拼装成一个 ChatGPT：</p><ol><li>用 <strong>Tokenizer</strong> 切碎文字。</li><li>用 <strong>Embedding</strong> 变成向量。</li><li>用 <strong>Positional Encoding</strong> 标记顺序。</li><li>进入 <strong>Decoder Block</strong>，利用 <strong>Causal Attention</strong> 确保只看历史不看未来。</li><li>层层堆叠，最后算出下一个词的概率。</li></ol><hr><h2 id=cs5494-week-5-generative-adversarial-networks-gan>CS5494 Week 5: Generative Adversarial Networks (GAN)<a hidden class=anchor aria-hidden=true href=#cs5494-week-5-generative-adversarial-networks-gan>#</a></h2><h2 id=第五周生成对抗网络>第五周：生成对抗网络<a hidden class=anchor aria-hidden=true href=#第五周生成对抗网络>#</a></h2><h3 id=1-核心直觉对抗博弈>1. 核心直觉：对抗博弈<a hidden class=anchor aria-hidden=true href=#1-核心直觉对抗博弈>#</a></h3><h4 id=core-intuition-the-adversarial-game>Core Intuition: The Adversarial Game<a hidden class=anchor aria-hidden=true href=#core-intuition-the-adversarial-game>#</a></h4><p>GAN (Goodfellow et al., 2014) 的核心思想不同于显式地去计算概率密度 $P(x)$（像 PixelRNN 或 GPT 那样），而是通过两个神经网络的<strong>对抗</strong>来隐式地学习分布。</p><ul><li><p><strong>比喻 (Analogy)</strong>:</p><ul><li><strong>生成器 (Generator, G)</strong>: 就像一个<strong>伪钞制造者 (Counterfeiter)</strong>。它的目标是制造出连警察都分不清真假的假钞。</li><li><strong>判别器 (Discriminator, D)</strong>: 就像<strong>警察 (Police)</strong>。它的目标是准确地鉴别出哪张是真钞，哪张是假钞。</li><li><strong>过程</strong>: 随着博弈的进行，警察的眼力越来越好，造假者的技术也必须越来越高超。最终，造出来的假钞逼真到警察无法分辨（概率为 0.5）。</li></ul></li><li><p><strong>隐式密度估计 (Implicit Density Estimation)</strong>:
GAN 不会直接告诉你这张图出现的概率是多少，它只会给你生成这张图。</p><ul><li><em>Concept</em>: GANs learn a mechanism to sample from the distribution without explicitly defining the probability density function.</li></ul></li></ul><hr><h3 id=2-数学架构极小极大博弈>2. 数学架构：极小极大博弈<a hidden class=anchor aria-hidden=true href=#2-数学架构极小极大博弈>#</a></h3><h4 id=mathematical-architecture-minimax-game>Mathematical Architecture: Minimax Game<a hidden class=anchor aria-hidden=true href=#mathematical-architecture-minimax-game>#</a></h4><p>理解 GAN 的关键在于它的目标函数（Loss Function）。这是一个<strong>极小极大 (Minimax)</strong> 问题。</p><p>$$\min_G \max_D V(D, G) = \mathbb{E}<em>{x \sim p</em>{data}}[\log D(x)] + \mathbb{E}<em>{z \sim p</em>{z}}[\log(1 - D(G(z)))]$$</p><ul><li><p><strong>判别器 D 的视角 (Max D)</strong>:</p><ul><li>它想让 $\log D(x)$ 变大（把真图 $x$ 判为 1）。</li><li>它想让 $\log(1 - D(G(z)))$ 变大（把假图 $G(z)$ 判为 0）。</li><li><em>Goal</em>: Maximize the probability of correctly assigning labels to both real and fake examples.</li></ul></li><li><p><strong>生成器 G 的视角 (Min G)</strong>:</p><ul><li>它想让 $D(G(z))$ 接近 1，从而使 $\log(1 - D(G(z)))$ 变得极小（负无穷）。</li><li>即：骗过判别器。</li><li><em>Goal</em>: Minimize the probability that the discriminator is correct.</li></ul></li></ul><hr><h3 id=3-理论痛点为什么原始-gan-很难训练>3. 理论痛点：为什么原始 GAN 很难训练？<a hidden class=anchor aria-hidden=true href=#3-理论痛点为什么原始-gan-很难训练>#</a></h3><h4 id=theoretical-pain-point-why-is-vanilla-gan-hard-to-train>Theoretical Pain Point: Why is Vanilla GAN Hard to Train?<a hidden class=anchor aria-hidden=true href=#theoretical-pain-point-why-is-vanilla-gan-hard-to-train>#</a></h4><p>课件花了很大篇幅讨论距离度量（Metric）的问题。这是理解 WGAN 的前置知识。</p><h5 id=a-传统的距离度量kl-散度与-js-散度>A. 传统的距离度量：KL 散度与 JS 散度<a hidden class=anchor aria-hidden=true href=#a-传统的距离度量kl-散度与-js-散度>#</a></h5><ul><li><strong>KL 散度 (KL Divergence)</strong>: 衡量两个分布 $P$ 和 $Q$ 的差异。它是不对称的。</li><li><strong>JS 散度 (Jensen-Shannon Divergence)</strong>: KL 散度的对称版本。原始 GAN 的优化目标本质上是在最小化生成分布与真实分布之间的 JS 散度。</li></ul><h5 id=b-梯度消失问题-vanishing-gradient-problem>B. 梯度消失问题 (Vanishing Gradient Problem)<a hidden class=anchor aria-hidden=true href=#b-梯度消失问题-vanishing-gradient-problem>#</a></h5><ul><li><strong>现象</strong>: 当生成器生成的图像很差，或者真实分布与生成分布<strong>没有重叠 (No Overlap)</strong> 时（在高维空间中这很常见），JS 散度是一个常数（$\log 2$）。</li><li><strong>后果</strong>: 常数的梯度是 0。这意味着<strong>生成器得不到任何反馈</strong>，不知道往哪个方向改才能变好。<ul><li><em>Explanation</em>: If the real and fake distributions are disjoint, the JS divergence is constant. This causes vanishing gradients, meaning the generator learns nothing.</li></ul></li></ul><hr><h3 id=4-解决方案wasserstein-gan-wgan>4. 解决方案：Wasserstein GAN (WGAN)<a hidden class=anchor aria-hidden=true href=#4-解决方案wasserstein-gan-wgan>#</a></h3><h4 id=the-solution-wasserstein-gan>The Solution: Wasserstein GAN<a hidden class=anchor aria-hidden=true href=#the-solution-wasserstein-gan>#</a></h4><p>为了解决梯度消失，我们引入了一种新的距离度量——<strong>推土机距离 (Earth-Mover Distance)</strong>，即 Wasserstein Distance。</p><ul><li><p><strong>直观理解 (Intuition)</strong>:
想象把“生成分布”看作一堆土，把“真实分布”看作一个坑。Wasserstein 距离就是把这堆土搬到那个坑里所需的<strong>最小工作量</strong>（距离 $\times$ 土量）。</p><ul><li><em>Analogy</em>: The minimum cost to transport mass from one distribution to transform it into the other.</li></ul></li><li><p><strong>优势 (Advantages)</strong>:
即使两个分布完全不重叠，Wasserstein 距离依然是一个平滑的数值（代表距离多远），而不是常数。这能提供<strong>持续的、有意义的梯度</strong>，指导生成器慢慢靠近真实分布。</p><ul><li><em>Benefit</em>: Provides meaningful gradients even when distributions are disjoint, stabilizing training.</li></ul></li><li><p><strong>实现细节 (Implementation Detail)</strong>:
为了计算 Wasserstein 距离，我们需要限制判别器（此时改叫 Critic）的能力，要求它满足 <strong>1-Lipschitz 连续性</strong>。在代码中通常通过<strong>权重剪裁 (Weight Clipping)</strong> 或 <strong>梯度惩罚 (Gradient Penalty, WGAN-GP)</strong> 来实现。</p></li></ul><hr><h3 id=5-进阶应用cyclegan>5. 进阶应用：CycleGAN<a hidden class=anchor aria-hidden=true href=#5-进阶应用cyclegan>#</a></h3><h4 id=advanced-application-cyclegan>Advanced Application: CycleGAN<a hidden class=anchor aria-hidden=true href=#advanced-application-cyclegan>#</a></h4><p>课件最后提到了 CycleGAN，这是解决<strong>无配对图像翻译 (Unpaired Image-to-Image Translation)</strong> 的神器。</p><ul><li><strong>场景</strong>: 你想把“马”变成“斑马”，但你没有同一匹马变成斑马前后的对比照。你只有一堆马的照片和一堆斑马的照片。</li><li><strong>循环一致性损失 (Cycle Consistency Loss)</strong>:<ul><li>思路：如果我把马变成斑马，再把斑马变回马，它应该长得和原来一模一样。</li><li>公式：$F(G(x)) \approx x$</li><li><em>Mechanism</em>: Translating an image to the other domain and back should yield the original image. This constraint prevents mode collapse and ensures the content is preserved.</li></ul></li></ul><hr><h3 id=6-专有名词表-glossary>6. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#6-专有名词表-glossary>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>生成对抗网络</strong></td><td style=text-align:left>GAN (Generative Adversarial Network)</td><td style=text-align:left>由生成器和判别器组成的对抗式生成模型框架。</td></tr><tr><td style=text-align:left><strong>极小极大博弈</strong></td><td style=text-align:left>Minimax Game</td><td style=text-align:left>博弈论术语。在 GAN 中指生成器试图最小化判别器的准确率，而判别器试图最大化自己的准确率。</td></tr><tr><td style=text-align:left><strong>KL 散度</strong></td><td style=text-align:left>KL Divergence</td><td style=text-align:left>衡量两个概率分布差异的非对称指标。</td></tr><tr><td style=text-align:left><strong>JS 散度</strong></td><td style=text-align:left>JS Divergence (Jensen-Shannon)</td><td style=text-align:left>KL 散度的对称平滑版本。原始 GAN 实际上是在优化这个指标。</td></tr><tr><td style=text-align:left><strong>模式崩溃</strong></td><td style=text-align:left>Mode Collapse</td><td style=text-align:left>GAN 训练中的常见失败模式。生成器发现只能生成某一种特定的样本（如只生成同一张脸）就能骗过判别器，从而失去了多样性。</td></tr><tr><td style=text-align:left><strong>Wasserstein 距离</strong></td><td style=text-align:left>Wasserstein Distance (Earth-Mover)</td><td style=text-align:left>一种衡量分布距离的方法。相比 JS 散度，它在分布不重叠时也能提供有效的梯度，极大稳定了 GAN 的训练。</td></tr><tr><td style=text-align:left><strong>1-Lipschitz 连续</strong></td><td style=text-align:left>1-Lipschitz Continuity</td><td style=text-align:left>数学约束，要求函数的变化率不能超过某个常数（斜率不超过 1）。这是 WGAN 成立的必要条件。</td></tr><tr><td style=text-align:left><strong>循环一致性</strong></td><td style=text-align:left>Cycle Consistency</td><td style=text-align:left>CycleGAN 的核心概念。要求 $X \rightarrow Y \rightarrow X$ 的变换结果应还原为 $X$，保证了翻译过程中内容的保留。</td></tr><tr><td style=text-align:left><strong>隐式密度</strong></td><td style=text-align:left>Implicit Density</td><td style=text-align:left>与显式定义 $P(x)$ 不同，模型不直接计算概率值，而是通过采样机制间接反映数据分布。</td></tr></tbody></table><h4 id=总结-summary-4>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary-4>#</a></h4><p>Week 5 的核心教训是：<strong>虽然 GAN 生成的图片很逼真，但训练它非常困难（不稳定）。</strong>
为了让 GAN 听话，我们需要更高级的数学工具（Wasserstein 距离）来替代传统的概率度量（JS 散度），从而保证生成器在任何时候都能收到“改进方向”的信号。</p><hr><h2 id=cs5494-week-6-variational-autoencoder-vae>CS5494 Week 6: Variational Autoencoder (VAE)<a hidden class=anchor aria-hidden=true href=#cs5494-week-6-variational-autoencoder-vae>#</a></h2><h2 id=第六周变分自编码器>第六周：变分自编码器<a hidden class=anchor aria-hidden=true href=#第六周变分自编码器>#</a></h2><h3 id=1-前置概念自编码器-autoencoder-ae>1. 前置概念：自编码器 (Autoencoder, AE)<a hidden class=anchor aria-hidden=true href=#1-前置概念自编码器-autoencoder-ae>#</a></h3><h4 id=precursor-autoencoder>Precursor: Autoencoder<a hidden class=anchor aria-hidden=true href=#precursor-autoencoder>#</a></h4><p>在讲 VAE 之前，课件先回顾了普通的自编码器。</p><ul><li><strong>结构 (Structure)</strong>:<ul><li><strong>Encoder (编码器)</strong>: 把高维输入 $x$（如一张图）压缩成低维向量 $z$（Latent Code）。</li><li><strong>Decoder (解码器)</strong>: 把 $z$ 还原回 $x$。</li><li><em>Analogy</em>: 就像把文件压缩成 zip (Encoder)，再解压出来 (Decoder)。</li></ul></li><li><strong>瓶颈层 (Bottleneck)</strong>:<ul><li>中间的 $z$ 维度远小于 $x$（例如 784维 $\rightarrow$ 20维）。这迫使模型学会提取“精华”特征，而不是死记硬背。</li></ul></li><li><strong>局限性 (Limitation)</strong>:<ul><li><strong>它不是生成模型</strong>。AE 学习到的潜在空间（Latent Space）是不连续的。如果你在两个训练过的 $z$ 之间随机取一个点，解码出来的可能是一堆乱码。它只能“复读”，不能“创造”。</li></ul></li></ul><hr><h3 id=2-核心理论潜变量模型与难解性>2. 核心理论：潜变量模型与难解性<a hidden class=anchor aria-hidden=true href=#2-核心理论潜变量模型与难解性>#</a></h3><h4 id=latent-variable-models--intractability>Latent Variable Models & Intractability<a hidden class=anchor aria-hidden=true href=#latent-variable-models--intractability>#</a></h4><p>为了让模型能“创造”，我们需要引入概率。我们假设图片 $x$ 是由某个看不见的隐变量 $z$ 生成的。</p><ul><li><strong>生成过程 (Generation Process)</strong>:<ol><li>先从标准正态分布中采样一个 $z \sim \mathcal{N}(0, I)$。</li><li>通过神经网络生成 $x = g(z)$。</li></ol></li><li><strong>数学难题 (The Math Problem)</strong>:<ul><li>为了训练这个模型，我们需要最大化数据的对数似然 $\log P(x)$。</li><li>根据概率公式：$P(x) = \int P(x|z)P(z) dz$。</li><li><strong>难点 (Hard Point)</strong>: 这个积分<strong>极其难算 (Intractable)</strong>。因为 $z$ 的可能性无穷无尽，我们不可能遍历所有的 $z$ 来算出 $P(x)$。</li><li><em>Concept</em>: We cannot calculate the marginal likelihood because integrating over all possible latent variables is computationally impossible.</li></ul></li></ul><hr><h3 id=3-解决方案变分推断与-elbo-重点难点>3. 解决方案：变分推断与 ELBO (重点/难点)<a hidden class=anchor aria-hidden=true href=#3-解决方案变分推断与-elbo-重点难点>#</a></h3><h4 id=solution-variational-inference--elbo>Solution: Variational Inference & ELBO<a hidden class=anchor aria-hidden=true href=#solution-variational-inference--elbo>#</a></h4><p>既然算不出真实的 $P(x)$，我们退而求其次，去寻找一个<strong>下界 (Lower Bound)</strong>，只要把这个下界推得越高，真实的概率也就越高。</p><h5 id=a-变分推断-variational-inference>A. 变分推断 (Variational Inference)<a hidden class=anchor aria-hidden=true href=#a-变分推断-variational-inference>#</a></h5><p>我们无法知道真实的后验概率 $P(z|x)$（即：给定这张图，它对应的 $z$ 到底是多少？）。
所以，我们引入一个新的分布 <strong>$Q(z|x)$</strong>（由神经网络 Encoder 拟合）来<strong>近似</strong>真实的 $P(z|x)$。</p><h5 id=b-elbo-证据下界>B. ELBO (证据下界)<a hidden class=anchor aria-hidden=true href=#b-elbo-证据下界>#</a></h5><p>这是本周最核心的公式。通过数学推导（Jensen不等式），我们可以得出：</p><p>$$\log P(x) \ge \text{ELBO}$$</p><p><strong>ELBO 的组成 (The Decomposition of ELBO)</strong>:
$$\text{ELBO} = \mathbb{E}<em>{z \sim Q}[\log P(x|z)] - D</em>{KL}(Q(z|x) || P(z))$$</p><p>这行公式对应了 VAE 的两个 Loss 部分，非常关键，请仔细看下面的深度解释。</p><hr><h3 id=4-vae-的模型架构与损失函数>4. VAE 的模型架构与损失函数<a hidden class=anchor aria-hidden=true href=#4-vae-的模型架构与损失函数>#</a></h3><h4 id=vae-architecture--loss-function>VAE Architecture & Loss Function<a hidden class=anchor aria-hidden=true href=#vae-architecture--loss-function>#</a></h4><p>VAE 把上面的数学公式变成了具体的神经网络架构。</p><ul><li><p><strong>第一部分：重建损失 (Reconstruction Loss)</strong></p><ul><li>对应公式：$\mathbb{E}_{z \sim Q}[\log P(x|z)]$</li><li><strong>含义</strong>: 就像普通的 Autoencoder 一样，要求解码出来的图 $\hat{x}$ 和原图 $x$ 越像越好。</li><li><em>Intuition</em>: Make sure the output looks like the input.</li></ul></li><li><p><strong>第二部分：正则化项 (KL Divergence Regularization)</strong> [⚠️难点]</p><ul><li>对应公式：$D_{KL}(Q(z|x) || P(z))$</li><li><strong>含义</strong>: 强迫 Encoder 输出的分布 $Q(z|x)$ 尽可能接近标准正态分布 $P(z) = \mathcal{N}(0, 1)$。</li><li><strong>为什么要这么做？ (Why?)</strong>:
如果不加这一项，模型会“作弊”，它会把每个数据的 $z$ 记得离得远远的（互不重叠），退化成普通的 Autoencoder。
加上这一项，所有图片的 $z$ 都被迫挤在一个标准圆里。这样，$z$ 空间就变得<strong>连续</strong>了。你在这个圆里随便插值采样，都能生成一张像模像样的新图。</li></ul></li></ul><hr><h3 id=5-实现细节重参数化技巧-reparameterization-trick>5. 实现细节：重参数化技巧 (Reparameterization Trick)<a hidden class=anchor aria-hidden=true href=#5-实现细节重参数化技巧-reparameterization-trick>#</a></h3><h4 id=implementation-the-reparameterization-trick>Implementation: The Reparameterization Trick<a hidden class=anchor aria-hidden=true href=#implementation-the-reparameterization-trick>#</a></h4><p>这是课件中提到“Variational parameters”时隐含的一个关键工程技巧，也是考试常考点。</p><ul><li><strong>问题</strong>: VAE 中需要进行采样 ($z \sim \mathcal{N}(\mu, \sigma^2)$)。由于“采样”这个操作是随机的，不可导，导致无法进行反向传播（Backpropagation）。</li><li><strong>技巧</strong>: 我们把随机性转移到一个独立的变量 $\epsilon$ 上。
$$z = \mu + \sigma \odot \epsilon, \quad \text{where } \epsilon \sim \mathcal{N}(0, 1)$$</li><li><strong>效果</strong>: 现在 $\mu$ 和 $\sigma$ 变成了确定性的参数，梯度可以直接传导给 Encoder，而随机性只在常数 $\epsilon$ 里。</li></ul><hr><h3 id=6-专有名词表-glossary-1>6. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#6-专有名词表-glossary-1>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>自编码器</strong></td><td style=text-align:left>Autoencoder (AE)</td><td style=text-align:left>一种神经网络，旨在学习将输入压缩为低维编码，再将其重建回原始输入。</td></tr><tr><td style=text-align:left><strong>变分自编码器</strong></td><td style=text-align:left>VAE (Variational Autoencoder)</td><td style=text-align:left>在 AE 基础上引入概率生成模型的概念，通过学习数据的潜在分布来生成新数据。</td></tr><tr><td style=text-align:left><strong>潜变量模型</strong></td><td style=text-align:left>Latent Variable Model</td><td style=text-align:left>假设观测数据 $x$ 是由不可见的潜变量 $z$ 生成的概率模型。</td></tr><tr><td style=text-align:left><strong>变分推断</strong></td><td style=text-align:left>Variational Inference</td><td style=text-align:left>用一个简单的分布 $Q$ 去近似难以计算的复杂后验分布 $P$ 的方法。</td></tr><tr><td style=text-align:left><strong>证据下界</strong></td><td style=text-align:left>ELBO (Evidence Lower Bound)</td><td style=text-align:left>对数似然函数的一个下界。训练 VAE 的本质就是最大化 ELBO。</td></tr><tr><td style=text-align:left><strong>KL 散度</strong></td><td style=text-align:left>KL Divergence</td><td style=text-align:left>衡量两个概率分布之间差异的指标。在 VAE 中用于拉近 $Q(z|x)$ 和 $P(z)$ 的距离。</td></tr><tr><td style=text-align:left><strong>难解性</strong></td><td style=text-align:left>Intractability</td><td style=text-align:left>指计算量过大（通常是指数级或无穷积分），无法在有限时间内精确算出结果。</td></tr><tr><td style=text-align:left><strong>重参数化技巧</strong></td><td style=text-align:left>Reparameterization Trick</td><td style=text-align:left>将随机变量分解为确定性部分和随机噪声部分（$z=\mu+\sigma\epsilon$），使采样过程变得可导。</td></tr><tr><td style=text-align:left><strong>后验分布</strong></td><td style=text-align:left>Posterior Distribution</td><td style=text-align:left>$P(z|x)$。即“看到这张图后，推断它的潜在特征是什么”。</td></tr><tr><td style=text-align:left><strong>先验分布</strong></td><td style=text-align:left>Prior Distribution</td><td style=text-align:left>$P(z)$。我们预先假设的潜变量分布，VAE 中通常假设为标准正态分布 $\mathcal{N}(0, 1)$。</td></tr></tbody></table><h4 id=总结-summary-5>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary-5>#</a></h4><p>Week 6 告诉你：<strong>为了让神经网络具备创造力，我们不能让它死记硬背坐标（固定数值），而要让它学习范围（概率分布）。</strong>
VAE 通过 <strong>ELBO</strong> 将“生成难题”转化为了“优化难题”，并通过 <strong>KL 散度</strong> 保证了学习到的空间是平滑、连续的，从而能生成新的图片。</p><hr><h2 id=cs5494-week-7-diffusion-models-ddpm>CS5494 Week 7: Diffusion Models (DDPM)<a hidden class=anchor aria-hidden=true href=#cs5494-week-7-diffusion-models-ddpm>#</a></h2><h2 id=第七周扩散模型-ddpm>第七周：扩散模型 (DDPM)<a hidden class=anchor aria-hidden=true href=#第七周扩散模型-ddpm>#</a></h2><h3 id=1-核心直觉毁掉它再复原它>1. 核心直觉：毁掉它，再复原它<a hidden class=anchor aria-hidden=true href=#1-核心直觉毁掉它再复原它>#</a></h3><h4 id=core-intuition-destroy-and-restore>Core Intuition: Destroy and Restore<a hidden class=anchor aria-hidden=true href=#core-intuition-destroy-and-restore>#</a></h4><p>扩散模型的灵感来源于非平衡热力学。想象一滴墨水滴入清水中，随着时间推移，墨水分子会扩散，直到整杯水变成均匀的浑浊颜色。</p><ul><li><p><strong>前向过程 (Forward Process / Diffusion)</strong>:</p><ul><li>就像墨水扩散。我们往一张清晰的图片上<strong>一步步加噪点</strong>。</li><li>最后（比如加了 1000 步后），图片变成了一张纯粹的、没有任何信息的<strong>高斯噪声 (Gaussian Noise)</strong>。</li><li><em>Analogy</em>: Slowly adding static to a TV screen until the image is gone.</li></ul></li><li><p><strong>反向过程 (Reverse Process / Denoising)</strong>:</p><ul><li>这是模型的任务。如果我们能学会**“时间倒流”**，从这一张纯噪声中，一步步把噪点拿掉，就能变回一张清晰的图。</li><li>因为是从纯噪声（随机数）开始“去噪”，每次生成的图都不一样，这就是<strong>生成</strong>的过程。</li><li></li></ul></li></ul><hr><h3 id=2-前向过程加噪-the-forward-process>2. 前向过程：加噪 (The Forward Process)<a hidden class=anchor aria-hidden=true href=#2-前向过程加噪-the-forward-process>#</a></h3><h4 id=adding-noise-systematically>Adding Noise systematically<a hidden class=anchor aria-hidden=true href=#adding-noise-systematically>#</a></h4><p>这是一个<strong>固定</strong>的过程，不需要任何神经网络训练。我们规定好每一步加多少噪声（这叫 Noise Schedule，$\beta_t$）。</p><ul><li><p><strong>单步加噪</strong>:
$$q(x_t | x_{t-1}) = \mathcal{N}(x_t; \sqrt{1-\beta_t}x_{t-1}, \beta_t I)$$</p><ul><li>意思就是：现在的图 $x_t$ = 稍微暗一点的上一张图 $x_{t-1}$ + 一点点新的噪声。</li></ul></li><li><p><strong>任意步加噪 (The &ldquo;Jump&rdquo; Property)</strong>: [重要考点]
我们不需要一步步算。数学上可以证明，我们可以直接算出第 $t$ 步的图 $x_t$ 长什么样（基于原图 $x_0$）：
$$x_t = \sqrt{\bar{\alpha}_t} x_0 + \sqrt{1 - \bar{\alpha}_t} \epsilon$$</p><ul><li>$\epsilon \sim \mathcal{N}(0, I)$ 是这一步的总噪声。</li><li>$\bar{\alpha}_t$ 是一个随时间 $t$ 变小的系数（信号保留比例）。</li><li><strong>直觉</strong>: $x_t$ 就是“原图”和“噪声”的加权混合。$t$ 越大，原图成分越少，噪声成分越多。</li></ul></li></ul><hr><h3 id=3-反向过程去噪-the-reverse-process>3. 反向过程：去噪 (The Reverse Process)<a hidden class=anchor aria-hidden=true href=#3-反向过程去噪-the-reverse-process>#</a></h3><h4 id=denoising-with-neural-networks>Denoising with Neural Networks<a hidden class=anchor aria-hidden=true href=#denoising-with-neural-networks>#</a></h4><p>这是我们需要训练的部分。我们想求 $q(x_{t-1} | x_t)$，即：给定现在的脏图，它上一时刻长什么样？
但这个分布太复杂了，算不出来。</p><ul><li><strong>解决方案</strong>: 用神经网络 $p_\theta(x_{t-1} | x_t)$ 去<strong>拟合</strong>它。</li><li><strong>假设</strong>: 当每一步加的噪声极小时，反向过程也可以近似为一个<strong>高斯分布</strong>：
$$p_\theta(x_{t-1} | x_t) = \mathcal{N}(x_{t-1}; \mu_\theta(x_t, t), \Sigma_\theta(x_t, t))$$</li><li><strong>任务</strong>: 神经网络只需要输入一张脏图 $x_t$ 和时间 $t$，然后预测出这个高斯分布的<strong>均值 $\mu_\theta$</strong> 即可（方差通常设为固定值）。</li></ul><hr><h3 id=4-核心难点训练目标是什么>4. 核心难点：训练目标是什么？<a hidden class=anchor aria-hidden=true href=#4-核心难点训练目标是什么>#</a></h3><h4 id=the-hard-part-what-is-the-loss-function>The Hard Part: What is the Loss Function?<a hidden class=anchor aria-hidden=true href=#the-hard-part-what-is-the-loss-function>#</a></h4><p>这部分是课件中公式最多的地方，也是理解 DDPM (Denoising Diffusion Probabilistic Models) 的关键。</p><h5 id=a-为什么不能直接由-x_t-推-x_t-1>A. 为什么不能直接由 $x_t$ 推 $x_{t-1}$？<a hidden class=anchor aria-hidden=true href=#a-为什么不能直接由-x_t-推-x_t-1>#</a></h5><p>因为从 $x_t$ 回到 $x_{t-1}$ 有无数种可能，直接训很难收敛。
但是，如果我们<strong>知道原图 $x_0$</strong>，那么从 $x_t$ 推导 $x_{t-1}$ 就变得<strong>确定且简单</strong>了。
这就引出了扩散模型最天才的数学推导——<strong>后验分布 $q(x_{t-1} | x_t, x_0)$</strong>。</p><h5 id=b-简化的训练目标-simplified-loss-最重要结论>B. 简化的训练目标 (Simplified Loss) [⭐最重要结论]<a hidden class=anchor aria-hidden=true href=#b-简化的训练目标-simplified-loss-最重要结论>#</a></h5><p>虽然数学推导（ELBO）很复杂，但 Ho et al. (2020) 发现，训练扩散模型其实只需要做一件事：
<strong>预测噪声 (Predict the Noise)</strong>。</p><ol><li>随机抽一张原图 $x_0$。</li><li>随机生成一个噪声 $\epsilon$。</li><li>把噪声加到图上得到 $x_t$（利用第2节的公式）。</li><li>把 $x_t$ 丢给神经网络，让它猜：<strong>“刚才加在这个图里的噪声 $\epsilon$ 长什么样？”</strong></li><li><strong>Loss Function</strong>:
$$L_{simple} = || \epsilon - \epsilon_\theta(\underbrace{\sqrt{\bar{\alpha}_t} x_0 + \sqrt{1 - \bar{\alpha}<em>t} \epsilon}</em>{输入 x_t}, t) ||^2$$<ul><li>即：真实噪声 $\epsilon$ 与预测噪声 $\epsilon_\theta$ 的<strong>均方误差 (MSE)</strong>。</li></ul></li></ol><p><strong>总结</strong>: 扩散模型本质上就是一个**“猜噪声”的去噪自编码器 (Denoising Autoencoder)**。</p><hr><h3 id=5-推理算法怎么生成图片>5. 推理算法：怎么生成图片？<a hidden class=anchor aria-hidden=true href=#5-推理算法怎么生成图片>#</a></h3><h4 id=inference-sampling-algorithm>Inference: Sampling Algorithm<a hidden class=anchor aria-hidden=true href=#inference-sampling-algorithm>#</a></h4><p>训练好模型（会猜噪声）后，我们怎么生成新图？</p><ol><li><strong>从纯噪声开始</strong>: $x_T \sim \mathcal{N}(0, I)$。</li><li><strong>循环 $T$ 步 (例如 1000 步)</strong>: 从 $T$ 倒数到 $1$。<ul><li>计算当前步预测的噪声 $\epsilon_\theta(x_t, t)$。</li><li><strong>去噪公式 (核心)</strong>:
$$x_{t-1} = \frac{1}{\sqrt{\alpha_t}} (x_t - \frac{1 - \alpha_t}{\sqrt{1 - \bar{\alpha}<em>t}} \epsilon</em>\theta(x_t, t)) + \sigma_t z$$</li><li><strong>解释</strong>: 把预测出来的噪声从图里减掉一部分，然后<strong>再加回一点点随机噪声 $z$</strong> (Langevin Dynamics)。</li><li><em>Why add noise back?</em> 为了保持生成的随机性和多样性，防止模型坍缩到单一结果。</li></ul></li><li><strong>结束</strong>: 得到 $x_0$，就是生成的精美图片。</li></ol><hr><h3 id=6-专有名词表-glossary-2>6. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#6-专有名词表-glossary-2>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>扩散模型</strong></td><td style=text-align:left>Diffusion Model</td><td style=text-align:left>一类通过反转噪声扩散过程来生成数据的生成模型。</td></tr><tr><td style=text-align:left><strong>DDPM</strong></td><td style=text-align:left>Denoising Diffusion Probabilistic Models</td><td style=text-align:left>2020年提出的经典扩散模型算法，证明了预测噪声等价于优化 ELBO。</td></tr><tr><td style=text-align:left><strong>前向过程</strong></td><td style=text-align:left>Forward Process</td><td style=text-align:left>逐步向数据添加高斯噪声直到其变为纯噪声的过程。$q(x_t|x_{t-1})$。</td></tr><tr><td style=text-align:left><strong>反向过程</strong></td><td style=text-align:left>Reverse Process</td><td style=text-align:left>逐步去除噪声以恢复数据的过程。$p_\theta(x_{t-1}|x_t)$。</td></tr><tr><td style=text-align:left><strong>噪声调度</strong></td><td style=text-align:left>Noise Schedule ($\beta_t$)</td><td style=text-align:left>控制每一步添加多少噪声的超参数。</td></tr><tr><td style=text-align:left><strong>ELBO</strong></td><td style=text-align:left>Evidence Lower Bound</td><td style=text-align:left>变分推断中的证据下界。扩散模型的 Loss 本质上是在最大化 ELBO。</td></tr><tr><td style=text-align:left><strong>重参数化技巧</strong></td><td style=text-align:left>Reparameterization Trick</td><td style=text-align:left>在扩散模型中指 $x_t = \sqrt{\bar{\alpha}_t}x_0 + \sqrt{1-\bar{\alpha}_t}\epsilon$，它允许我们将随机性剥离，直接对噪声进行求导。</td></tr><tr><td style=text-align:left><strong>马尔可夫链</strong></td><td style=text-align:left>Markov Chain</td><td style=text-align:left>一个随机过程，其中未来的状态仅取决于当前状态（与过去无关）。扩散过程是一个马尔可夫链。</td></tr><tr><td style=text-align:left><strong>U-Net</strong></td><td style=text-align:left>U-Net</td><td style=text-align:left>扩散模型中最常用的神经网络架构，形状像个 U，擅长处理图像的细节和整体特征。</td></tr><tr><td style=text-align:left><strong>Langevin 动力学</strong></td><td style=text-align:left>Langevin Dynamics</td><td style=text-align:left>一种物理过程，扩散模型的采样过程（去噪+加随机扰动）在数学上类似于 Langevin 动力学采样。</td></tr></tbody></table><h4 id=总结-summary-6>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary-6>#</a></h4><p>Week 7 的核心逻辑是：
<strong>生成 = 去噪。</strong>
我们不需要像 GAN 那样用判别器去“逼”模型生成，也不需要像 VAE 那样把分布压缩到潜空间。
我们只需要教会神经网络一件事：<strong>看到一张全是噪点的图，请告诉我，刚才加进去的噪点长什么样？</strong> 只要它能把噪点预测出来，我们把它减掉，图就变清晰了。</p><hr><h2 id=cs5494-week-8-ai-agent>CS5494 Week 8: AI Agent<a hidden class=anchor aria-hidden=true href=#cs5494-week-8-ai-agent>#</a></h2><h2 id=第八周人工智能智能体>第八周：人工智能智能体<a hidden class=anchor aria-hidden=true href=#第八周人工智能智能体>#</a></h2><h3 id=1-核心定义什么是-ai-agent>1. 核心定义：什么是 AI Agent？<a hidden class=anchor aria-hidden=true href=#1-核心定义什么是-ai-agent>#</a></h3><h4 id=core-definition-what-is-an-ai-agent>Core Definition: What is an AI Agent?<a hidden class=anchor aria-hidden=true href=#core-definition-what-is-an-ai-agent>#</a></h4><p>传统的 LLM (如 ChatGPT) 就像一个“大脑在缸中”，它什么都知道，但什么都做不了（除了说话）。AI Agent 就是给这个大脑装上了<strong>手脚（工具）<strong>和</strong>长期记忆</strong>。</p><ul><li><p><strong>公式 (The Formula)</strong>:
$$Agent = LLM + Planning + Memory + Tools$$
[cite_start][cite: 3]</p></li><li><p><strong>区别 (Difference)</strong>:</p><ul><li><strong>Generative AI (Chatbot)</strong>:<ul><li><strong>模式</strong>: 输入 Prompt $\rightarrow$ 输出文字/图片。</li><li><strong>特点</strong>: <strong>Reactive (被动反应)</strong>。你不问，它不说。</li><li><em>Analogy</em>: Like a library. [cite_start]It contains knowledge but sits still until you open a book. [cite: 53]</li></ul></li><li><strong>AI Agent</strong>:<ul><li><strong>模式</strong>: 设定目标 Goal $\rightarrow$ 自主规划 $\rightarrow$ 使用工具 $\rightarrow$ 完成任务。</li><li><strong>特点</strong>: <strong>Proactive (主动)</strong>。它可以为了一个目标进行多步操作。</li><li><em>Analogy</em>: Like a personal assistant. [cite_start]You say &ldquo;plan a trip,&rdquo; and it books flights, hotels, and restaurants on its own. [cite: 54]</li></ul></li></ul></li></ul><hr><h3 id=2-核心能力一规划与思考-planning--reasoning>2. 核心能力一：规划与思考 (Planning & Reasoning)<a hidden class=anchor aria-hidden=true href=#2-核心能力一规划与思考-planning--reasoning>#</a></h3><h4 id=core-capability-1-how-ai-thinks>Core Capability 1: How AI Thinks?<a hidden class=anchor aria-hidden=true href=#core-capability-1-how-ai-thinks>#</a></h4><p>这是本课的难点。模型通过什么方式来“思考”下一步该做什么？</p><h5 id=a-观察-思考-行动循环-obs-think-act-loop>A. 观察-思考-行动循环 (Obs-Think-Act Loop)<a hidden class=anchor aria-hidden=true href=#a-观察-思考-行动循环-obs-think-act-loop>#</a></h5><p>Agent 不会直接跳到结论，而是经历一个循环：</p><ol><li><strong>观察 (Observation)</strong>: 现在的状态是什么？（比如：棋盘现在长什么样？）</li><li><strong>思考 (Thought)</strong>: 基于观察，我该怎么做？</li><li>[cite_start]<strong>行动 (Action)</strong>: 执行操作（比如：下棋，或者搜索谷歌）。[cite: 3]</li></ol><h5 id=b-react-框架-reasoning--acting-重点>B. ReAct 框架 (Reasoning + Acting) [重点]<a hidden class=anchor aria-hidden=true href=#b-react-框架-reasoning--acting-重点>#</a></h5><p>课件中隐含的 ReAct 概念是 Agent 的核心工作流。</p><ul><li><strong>原理</strong>: 要求 LLM 在执行动作之前，先显式地把<strong>思考过程 (Chain of Thought)</strong> 写出来。</li><li><strong>例子</strong>:<ul><li><em>用户</em>: &ldquo;马斯克现在的身价是多少？&rdquo;</li><li><em>Agent 思考</em>: &ldquo;我需要查最新的数据，因为我的训练数据可能过时了。&rdquo; (Reasoning)</li><li><em>Agent 行动</em>: <code>Search("Elon Musk net worth today")</code> (Acting)</li><li><em>Agent 观察</em>: &ldquo;搜索结果显示 2500亿美元。&rdquo; (Observation)</li><li><em>Agent 回答</em>: &ldquo;马斯克目前身价约2500亿美元。&rdquo;</li></ul></li></ul><hr><h3 id=3-核心能力二工具使用-tool-use>3. 核心能力二：工具使用 (Tool Use)<a hidden class=anchor aria-hidden=true href=#3-核心能力二工具使用-tool-use>#</a></h3><h4 id=core-capability-2-how-ai-uses-tools>Core Capability 2: How AI Uses Tools?<a hidden class=anchor aria-hidden=true href=#core-capability-2-how-ai-uses-tools>#</a></h4><p>LLM 本身无法联网，也不擅长精确数学运算。我们需要教它使用外部工具。</p><ul><li><p><strong>函数调用 (Function Calling)</strong>:</p><ul><li><strong>原理</strong>: 我们不直接把工具给 LLM，而是给它一本<strong>说明书 (System Prompt)</strong>。</li><li>[cite_start]<em>Prompt 示例</em>: &ldquo;如果你遇到不懂的问题，你可以输出 <code>&lt;tool>Search(query)&lt;/tool></code> 来使用搜索引擎。&rdquo; [cite: 27]</li><li><strong>流程</strong>:<ol><li>LLM 输出一段特定的文本（如 XML 标签）。</li><li>系统拦截这段文本，去运行真正的 Python 代码或 API。</li><li>系统把运行结果（比如天气是 30度）塞回给 LLM。</li><li>[cite_start]LLM 根据结果生成最终回答。 [cite: 29, 33, 34]</li></ol></li></ul></li><li><p><strong>自我判断 (Judgment)</strong>:</p><ul><li><strong>难点</strong>: 工具不总是对的。Agent 需要具备<strong>批判性思维</strong>。</li><li><em>Case</em>: 如果天气 API 返回 &ldquo;500°C&rdquo;，LLM 不应直接复述，而应该判断 &ldquo;这数据不合理，可能是工具出错了&rdquo;。</li><li>[cite_start]<em>Concept</em>: <strong>Internal Knowledge (自身常识)</strong> vs. <strong>External Knowledge (工具结果)</strong>。Agent 需要权衡这两者。 [cite: 49, 50, 52]</li></ul></li></ul><hr><h3 id=4-核心能力三记忆与经验-memory--experience>4. 核心能力三：记忆与经验 (Memory & Experience)<a hidden class=anchor aria-hidden=true href=#4-核心能力三记忆与经验-memory--experience>#</a></h3><h4 id=core-capability-3-adjusting-behavior-via-experience>Core Capability 3: Adjusting Behavior via Experience<a hidden class=anchor aria-hidden=true href=#core-capability-3-adjusting-behavior-via-experience>#</a></h4><p>如果 Agent 每次任务结束就重置，它永远不会进步。它需要记忆。</p><ul><li><strong>短期记忆 (Short-term Memory)</strong>: 上下文窗口 (Context Window)，记录当前的对话历史。</li><li><strong>长期记忆 (Long-term Memory)</strong>:<ul><li>[cite_start]<strong>RAG (检索增强生成)</strong>: 将过往的经验存入向量数据库 (Vector DB)。当遇到类似任务时，检索出相关的经验供 LLM 参考。 [cite: 15, 19]</li><li>[cite_start]<strong>反思 (Reflection)</strong>: Agent 在行动后，会生成一段“反思总结”，存入记忆。比如 &ldquo;上次我直接搜索失败了，下次应该先拆解问题&rdquo;。 [cite: 21]</li></ul></li></ul><hr><h3 id=5-进阶概念agentic-ai-与多智能体>5. 进阶概念：Agentic AI 与多智能体<a hidden class=anchor aria-hidden=true href=#5-进阶概念agentic-ai-与多智能体>#</a></h3><h4 id=advanced-concept-agentic-ai-systems>Advanced Concept: Agentic AI Systems<a hidden class=anchor aria-hidden=true href=#advanced-concept-agentic-ai-systems>#</a></h4><p>这是从“单个员工”到“公司团队”的跨越。</p><ul><li><strong>Agentic AI System</strong>:
不是单打独斗，而是多个 Agent 协作。</li><li>[cite_start]<strong>工作流示例 (Youtube -> Rednote)</strong>: [cite: 55]<ol><li><strong>Agent 1 (听录员)</strong>: 把视频转成文字。</li><li><strong>Agent 2 (标题党)</strong>: 根据文字起一个吸引人的标题。</li><li><strong>Agent 3 (写手)</strong>: 撰写正文。</li><li><strong>Agent 4 (编辑)</strong>: 润色和排版。</li></ol></li><li><strong>优势</strong>: 术业有专攻，每个 Agent 只需要专注于一个小任务，整体效果更好。</li></ul><hr><h3 id=6-专有名词表-glossary-3>6. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#6-专有名词表-glossary-3>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>人工智能智能体</strong></td><td style=text-align:left>AI Agent</td><td style=text-align:left>一个拥有感知、规划能力的系统，能使用工具自主完成目标。公式：LLM + 规划 + 记忆 + 工具。</td></tr><tr><td style=text-align:left><strong>被动反应</strong></td><td style=text-align:left>Reactive</td><td style=text-align:left>传统的 GenAI 模式，只有收到指令才会有输出，不会主动发起行动。</td></tr><tr><td style=text-align:left><strong>函数调用</strong></td><td style=text-align:left>Function Calling</td><td style=text-align:left>允许 LLM 输出特定格式的指令来触发外部代码（如查天气、搜网页）的技术。</td></tr><tr><td style=text-align:left><strong>检索增强生成</strong></td><td style=text-align:left>RAG (Retrieval-Augmented Generation)</td><td style=text-align:left>结合了搜索（检索）和生成的技术。让 LLM 在回答前先去“翻书”（数据库），从而减少胡说八道。</td></tr><tr><td style=text-align:left><strong>思维链</strong></td><td style=text-align:left>Chain of Thought (CoT)</td><td style=text-align:left>提示工程技术，引导模型一步步把逻辑写出来，能显著提升复杂推理任务的准确率。</td></tr><tr><td style=text-align:left><strong>ReAct 框架</strong></td><td style=text-align:left>ReAct (Reason+Act)</td><td style=text-align:left>一种通过交替进行“推理”和“行动”来解决任务的模式。是 Agent 的核心思考方式。</td></tr><tr><td style=text-align:left><strong>多智能体系统</strong></td><td style=text-align:left>Multi-Agent System</td><td style=text-align:left>由多个扮演不同角色的 Agent 组成的系统，它们像人类团队一样协作完成复杂任务。</td></tr><tr><td style=text-align:left><strong>幻觉</strong></td><td style=text-align:left>Hallucination</td><td style=text-align:left>LLM 一本正经地胡说八道。通过使用工具（如搜索、计算器）可以有效减少幻觉。</td></tr></tbody></table><h4 id=总结-summary-7>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary-7>#</a></h4><p>Week 8 的核心在于**“Action”**。
如果说前几周是教你造一个“全知全能的哲学家”（GenAI），这周就是教你把这个哲学家变成一个“能干活的打工人”（Agent）。
关键在于：</p><ol><li><strong>给它工具</strong>（Function Call）。</li><li><strong>教它流程</strong>（ReAct Loop: 观察->思考->行动）。</li><li><strong>给它记忆</strong>（RAG/Database），让它能从经验中学习。</li></ol><hr><h2 id=cs5494-week-9-3d-vision--generation>CS5494 Week 9: 3D Vision & Generation<a hidden class=anchor aria-hidden=true href=#cs5494-week-9-3d-vision--generation>#</a></h2><h2 id=第九周三维视觉与生成>第九周：三维视觉与生成<a hidden class=anchor aria-hidden=true href=#第九周三维视觉与生成>#</a></h2><h3 id=1-核心痛点3d-表示的多样性>1. 核心痛点：3D 表示的多样性<a hidden class=anchor aria-hidden=true href=#1-核心痛点3d-表示的多样性>#</a></h3><h4 id=core-pain-point-diversity-of-3d-representations>Core Pain Point: Diversity of 3D Representations<a hidden class=anchor aria-hidden=true href=#core-pain-point-diversity-of-3d-representations>#</a></h4><p>在 2D 中，我们只有一种标准格式：像素网格 (Pixel Grid)。但在 3D 中，没有统一的标准，我们需要根据任务选择不同的<strong>数据结构</strong>。</p><h5 id=a-显式表示-explicit-representations>A. 显式表示 (Explicit Representations)<a hidden class=anchor aria-hidden=true href=#a-显式表示-explicit-representations>#</a></h5><p>直接定义物体的几何形状。</p><ol><li><p><strong>体素 (Voxels)</strong>:</p><ul><li><strong>定义</strong>: 3D 版的像素 (Volume Pixel)。就像《我的世界》(Minecraft) 里的方块。</li><li><strong>优点</strong>: 规则结构，可以直接用 3D 卷积神经网络 (3D CNN) 处理。</li><li><strong>缺点</strong>: <strong>内存爆炸</strong>。分辨率每增加 1 倍，内存消耗增加 8 倍 ($O(N^3)$)。这就叫“维数灾难”。</li><li></li></ul></li><li><p><strong>点云 (Point Clouds)</strong>:</p><ul><li><strong>定义</strong>: 一堆 $(x, y, z)$ 坐标点的集合。通常由激光雷达 (LiDAR) 采集。</li><li><strong>特点</strong>: <strong>无序性 (Unordered)</strong>。点的顺序不影响形状，这对神经网络是个挑战（后面会讲 PointNet）。</li><li><strong>缺点</strong>: 没有表面信息，放大看全是洞。</li></ul></li><li><p><strong>网格 (Meshes)</strong>:</p><ul><li><strong>定义</strong>: 由顶点 (Vertices)、边 (Edges) 和面 (Faces) 组成的集合。是游戏和电影工业的标准。</li><li><strong>缺点</strong>: 拓扑结构复杂，神经网络很难直接生成（很难处理“这就多了一个洞”这种拓扑变化）。</li><li></li></ul></li></ol><h5 id=b-隐式表示-implicit-representations-重点>B. 隐式表示 (Implicit Representations) [重点]<a hidden class=anchor aria-hidden=true href=#b-隐式表示-implicit-representations-重点>#</a></h5><p>不直接存储点，而是存储一个<strong>数学函数</strong>。</p><ul><li><strong>思想</strong>: 定义一个函数 $f(x, y, z)$。</li><li><strong>SDF (Signed Distance Function)</strong>: 函数返回该点距离物体表面的距离。负数在内部，正数在外部，0 就是表面。</li><li><strong>优点</strong>: 分辨率无限，可以表示极其复杂的拓扑结构。</li></ul><hr><h3 id=2-核心架构pointnet-处理点云>2. 核心架构：PointNet (处理点云)<a hidden class=anchor aria-hidden=true href=#2-核心架构pointnet-处理点云>#</a></h3><h4 id=core-architecture-pointnet-processing-point-clouds>Core Architecture: PointNet (Processing Point Clouds)<a hidden class=anchor aria-hidden=true href=#core-architecture-pointnet-processing-point-clouds>#</a></h4><p>这是深度学习处理 3D 点云的开山之作。</p><ul><li><strong>难点</strong>: 点云是无序的。输入 $(Point A, Point B)$ 和 $(Point B, Point A)$ 应该代表同一个物体。普通的 CNN 或 RNN 对顺序敏感，无法处理。</li><li><strong>PointNet 的解决方案</strong>:<ol><li><strong>共享 MLP (Shared MLP)</strong>: 对每一个点单独进行特征提取（映射到高维空间），每个点用的权重是一样的。</li><li><strong>对称函数 (Symmetric Function)</strong>: 使用 <strong>Max Pooling</strong>。不管输入的点顺序怎么变，取“最大值”这个操作得到的结果永远是一样的。</li></ol><ul><li><em>Mechanism</em>: Map each point individually to a higher dimension, then aggregate them using a symmetric operation (max pooling) to get a global feature vector.</li></ul></li></ul><hr><h3 id=3-革命性技术nerf-神经辐射场>3. 革命性技术：NeRF (神经辐射场)<a hidden class=anchor aria-hidden=true href=#3-革命性技术nerf-神经辐射场>#</a></h3><h4 id=revolutionary-tech-nerf-neural-radiance-fields>Revolutionary Tech: NeRF (Neural Radiance Fields)<a hidden class=anchor aria-hidden=true href=#revolutionary-tech-nerf-neural-radiance-fields>#</a></h4><p>这是本周课件最硬核、也是现代 3D 生成的基石。它不仅是一种表示，更是一种渲染技术。</p><ul><li><p><strong>核心定义</strong>:
NeRF 不是存网格，而是训练一个<strong>全连接神经网络 (MLP)</strong> 来隐式地存储场景。
$$F_\theta(x, y, z, \theta, \phi) \rightarrow (r, g, b, \sigma)$$</p><ul><li><strong>输入</strong>: 空间坐标 $(x, y, z)$ + 观看角度 $(\theta, \phi)$。</li><li><strong>输出</strong>: 该点的颜色 $(r, g, b)$ + <strong>密度 (Density $\sigma$)</strong>。</li></ul></li><li><p><strong>体渲染 (Volumetric Rendering)</strong>:
怎么把这个神经网络变成一张图片？</p><ol><li><strong>光线投射 (Ray Marching)</strong>: 从相机位置向屏幕的每个像素发射一条射线。</li><li><strong>采样 (Sampling)</strong>: 在这条射线上取很多采样点。</li><li><strong>查询 (Query)</strong>: 把每个采样点的坐标丢给 MLP，问它：“这里有什么颜色？密度多少？”</li><li><strong>积分 (Integration)</strong>: 根据密度把颜色累加起来。密度大的地方会遮挡后面的点。</li></ol><ul><li><em>Analogy</em>: 就像在雾中看东西。视线穿过雾气（累加颜色），直到被厚实的东西挡住。</li></ul></li><li><p><strong>优势</strong>: 生成的视图具有<strong>照片级真实感 (Photorealistic)</strong>，且视点连续变化。</p></li><li><p><strong>劣势</strong>: 渲染极慢（生成一张图要查询几百万次网络）。</p></li></ul><hr><h3 id=4-3d-生成dreamfusion-与-sds>4. 3D 生成：DreamFusion 与 SDS<a hidden class=anchor aria-hidden=true href=#4-3d-生成dreamfusion-与-sds>#</a></h3><h4 id=3d-generation-dreamfusion--sds>3D Generation: DreamFusion & SDS<a hidden class=anchor aria-hidden=true href=#3d-generation-dreamfusion--sds>#</a></h4><p>我们有很强的 2D 生成模型（如 Stable Diffusion），但没有很多 3D 数据来训练 3D 模型。怎么办？
<strong>DreamFusion (2023)</strong> 提出了一种“借鸡生蛋”的方法。</p><ul><li><strong>核心逻辑</strong>: 用 2D 模型当“老师”，指导 3D 模型“画画”。</li><li><strong>流程 (Process)</strong>:<ol><li>初始化一个随机的 NeRF（看起来像一团雾）。</li><li><strong>渲染 (Render)</strong>: 从某个角度拍一张这团雾的照片。</li><li><strong>打分 (Critic)</strong>: 把照片丢给 2D Diffusion Model (比如 Stable Diffusion)，再加上文字提示（如 &ldquo;一只红色的青蛙&rdquo;）。</li><li><strong>SDS Loss (Score Distillation Sampling)</strong>: 2D 模型会告诉 3D 模型：“这看起来不像青蛙，你应该把这里的像素变红一点”。（计算梯度）</li><li><strong>更新 (Update)</strong>: 根据建议修改 NeRF 的参数。</li><li>重复几千次，直到 3D 模型从各个角度看都像一只青蛙。</li></ol></li></ul><hr><h3 id=5-专有名词表-glossary-3>5. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#5-专有名词表-glossary-3>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>体素</strong></td><td style=text-align:left>Voxel (Volumetric Pixel)</td><td style=text-align:left>3D 空间中的规则网格单位，相当于 2D 图片中的像素。常用于医疗影像或简单的 3D 模型。</td></tr><tr><td style=text-align:left><strong>点云</strong></td><td style=text-align:left>Point Cloud</td><td style=text-align:left>3D 空间中一组数据点 $(x,y,z)$ 的集合。由激光雷达扫描生成，数据稀疏且无序。</td></tr><tr><td style=text-align:left><strong>网格</strong></td><td style=text-align:left>Mesh</td><td style=text-align:left>由多边形（通常是三角形）组成的 3D 物体表面表示法。由顶点、边和面构成。</td></tr><tr><td style=text-align:left><strong>SDF</strong></td><td style=text-align:left>Signed Distance Function</td><td style=text-align:left>符号距离函数。一种隐式表示，记录空间中任意一点到最近物体表面的距离（内部为负，外部为正）。</td></tr><tr><td style=text-align:left><strong>NeRF</strong></td><td style=text-align:left>NeRF (Neural Radiance Fields)</td><td style=text-align:left>神经辐射场。用神经网络来表示 3D 场景，通过输入坐标和视角输出颜色和密度，能渲染出极高保真的新视角图像。</td></tr><tr><td style=text-align:left><strong>体渲染</strong></td><td style=text-align:left>Volumetric Rendering</td><td style=text-align:left>一种基于光线穿过介质（如烟雾、云层）的物理特性的图像生成技术。NeRF 使用它将 3D 密度场转化为 2D 图像。</td></tr><tr><td style=text-align:left><strong>光线投射</strong></td><td style=text-align:left>Ray Casting / Marching</td><td style=text-align:left>图形学技术。从相机向屏幕像素发射光线，检测光线与物体的交互。</td></tr><tr><td style=text-align:left><strong>PointNet</strong></td><td style=text-align:left>PointNet</td><td style=text-align:left>专门处理点云数据的神经网络架构，解决了点云无序性的问题。</td></tr><tr><td style=text-align:left><strong>DreamFusion</strong></td><td style=text-align:left>DreamFusion</td><td style=text-align:left>Google 提出的文本生成 3D 模型。它不需要 3D 训练数据，而是利用预训练的 2D 扩散模型来优化 3D 结构。</td></tr><tr><td style=text-align:left><strong>SDS</strong></td><td style=text-align:left>Score Distillation Sampling</td><td style=text-align:left>分数蒸馏采样。DreamFusion 的核心算法，用于从 2D 扩散模型中提取梯度信息来更新 3D 参数。</td></tr></tbody></table><h4 id=总结-summary-8>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary-8>#</a></h4><p>Week 9 的核心在于**“升维”**。</p><ul><li><strong>存数据</strong>: 既然存不下所有像素（体素太贵），我们就存点（点云），或者存皮（网格），或者最现代的方法——存<strong>函数 (NeRF)</strong>。</li><li><strong>生成数据</strong>: 既然没有 3D 数据集，我们就用 2D 的 AI 去“监考” 3D 的 AI，让它凭空捏出一个 3D 模型 (DreamFusion)。</li></ul><hr><h2 id=cs5494-week-10-large-foundation-models-vlm--vla>CS5494 Week 10: Large Foundation Models (VLM & VLA)<a hidden class=anchor aria-hidden=true href=#cs5494-week-10-large-foundation-models-vlm--vla>#</a></h2><h2 id=第十周多模态基础模型与具身智能>第十周：多模态基础模型与具身智能<a hidden class=anchor aria-hidden=true href=#第十周多模态基础模型与具身智能>#</a></h2><h3 id=1-范式转变从专用模型到基础模型>1. 范式转变：从专用模型到基础模型<a hidden class=anchor aria-hidden=true href=#1-范式转变从专用模型到基础模型>#</a></h3><h4 id=paradigm-shift-from-specialized-to-foundation-models>Paradigm Shift: From Specialized to Foundation Models<a hidden class=anchor aria-hidden=true href=#paradigm-shift-from-specialized-to-foundation-models>#</a></h4><p>课件开篇首先强调了 AI 开发模式的根本性变化。</p><ul><li><strong>过去 (The Past)</strong>: 为每个任务训练一个专用模型。<ul><li>做分类训练一个 ResNet，做分割训练一个 U-Net，做翻译训练一个 LSTM。</li><li><em>Analogy</em>: 就像家里买了打蛋器、榨汁机、绞肉机，每个机器只能干一件事。</li></ul></li><li><strong>现在 (The Present)</strong>: 基础模型 (Foundation Models)。<ul><li>在大规模数据上预训练一个<strong>通用的模型</strong>（如 GPT-4, Gemini），然后通过微调 (Fine-tuning) 或提示 (Prompting) 适应各种下游任务。</li><li><em>Analogy</em>: 就像一个全能的大厨，你给他什么指令，他就能做什么菜。</li></ul></li></ul><hr><h3 id=2-视觉-语言模型-vlm-clip>2. 视觉-语言模型 (VLM): CLIP<a hidden class=anchor aria-hidden=true href=#2-视觉-语言模型-vlm-clip>#</a></h3><h4 id=vision-language-models-vlm-clip>Vision-Language Models (VLM): CLIP<a hidden class=anchor aria-hidden=true href=#vision-language-models-vlm-clip>#</a></h4><p>CLIP (Contrastive Language-Image Pre-training) 是连接文字和图片最重要的桥梁。</p><ul><li><strong>核心思想 (Core Idea)</strong>:
CLIP 不再像传统分类模型那样预测固定的 1000 个类别（ImageNet），而是<strong>学习图片和文字描述之间的匹配关系</strong>。</li><li><strong>训练方法：对比学习 (Contrastive Learning)</strong>: [重点]<ol><li>输入：一对对图片和对应的文字说明 (Image-Text Pairs)。</li><li>模型包含一个 Image Encoder 和一个 Text Encoder。</li><li><strong>拉近 (Pull)</strong>: 只有正确的图文对，它们生成的向量在空间中应该靠得很近。</li><li><strong>推远 (Push)</strong>: 错误的图文组合（比如“狗的图”配“猫的字”），向量应该互相排斥。</li></ol><ul><li><em>Concept</em>: Maximizing the cosine similarity for $N$ real pairs, while minimizing it for $N^2 - N$ incorrect pairings.</li></ul></li><li><strong>能力</strong>: <strong>Zero-shot Classification (零样本分类)</strong>。CLIP 不需要重新训练就能识别从未见过的物体，只要你告诉它那个物体的名字（文字）。</li></ul><hr><h3 id=3-让-llm-看懂图-llava>3. 让 LLM 看懂图: LLaVA<a hidden class=anchor aria-hidden=true href=#3-让-llm-看懂图-llava>#</a></h3><h4 id=making-llm-see-llava-large-language-and-vision-assistant>Making LLM See: LLaVA (Large Language-and-Vision Assistant)<a hidden class=anchor aria-hidden=true href=#making-llm-see-llava-large-language-and-vision-assistant>#</a></h4><p>CLIP 只能做匹配，不能像 ChatGPT 那样聊天。LLaVA 是通过<strong>视觉指令微调 (Visual Instruction Tuning)</strong> 把视觉能力嫁接到 LLM 上。</p><ul><li><strong>架构 (Architecture)</strong>:
$$LLaVA = VisionEncoder + Projection + LLM$$<ul><li><strong>Vision Encoder</strong>: 用 CLIP 把图片变成向量特征。</li><li><strong>Projection Layer (投影层)</strong>: [难点]<ul><li>LLM 只能看懂文本向量空间，看不懂图片向量空间。</li><li>投影层就是一个“翻译官”（通常是个简单的 MLP），把图片特征<strong>映射</strong>到 LLM 的文本特征空间中。</li></ul></li><li><strong>LLM</strong>: 也就是 Llama 或 Vicuna。对它来说，投影后的图片特征就像是一堆“外语单词”。</li></ul></li><li><strong>训练</strong>:
通过问答对（例如：“这张图里有什么？”-“有一只猫”）来训练，让 LLM 学会理解这些“视觉单词”的含义。</li></ul><hr><h3 id=4-视觉分割基座-sam>4. 视觉分割基座: SAM<a hidden class=anchor aria-hidden=true href=#4-视觉分割基座-sam>#</a></h3><h4 id=vision-foundation-model-sam-segment-anything-model>Vision Foundation Model: SAM (Segment Anything Model)<a hidden class=anchor aria-hidden=true href=#vision-foundation-model-sam-segment-anything-model>#</a></h4><p>SAM 是 Meta 发布的图像分割领域的“GPT”。</p><ul><li><strong>痛点</strong>: 以前做分割（把物体抠出来）需要针对特定物体训练，且标注数据极难。</li><li><strong>Promptable Segmentation (可提示分割)</strong>:
SAM 不需要你告诉它具体的类别，你只需要给它一个<strong>提示 (Prompt)</strong>：<ul><li>点一下 (Point)</li><li>画个框 (Box)</li><li>写行字 (Text)
它就能把对应的物体抠出来。</li></ul></li><li><strong>意义</strong>: 解决了视觉任务中最繁琐的分割问题，成为各种高级视觉任务的预处理工具。</li></ul><hr><h3 id=5-具身智能-vla-模型-robotic-foundation-models>5. 具身智能: VLA 模型 (Robotic Foundation Models)<a hidden class=anchor aria-hidden=true href=#5-具身智能-vla-模型-robotic-foundation-models>#</a></h3><h4 id=embodied-ai-vision-language-action-models-vla>Embodied AI: Vision-Language-Action Models (VLA)<a hidden class=anchor aria-hidden=true href=#embodied-ai-vision-language-action-models-vla>#</a></h4><p>这是本节课最高阶的内容。我们不仅要 AI 看图说话 (VLM)，还要它<strong>看图干活</strong>。</p><h5 id=a-rt-1-robotic-transformer-1>A. RT-1 (Robotic Transformer 1)<a hidden class=anchor aria-hidden=true href=#a-rt-1-robotic-transformer-1>#</a></h5><ul><li><strong>核心创新</strong>: <strong>动作 Token 化 (Tokenizing Actions)</strong>。<ul><li>Transformer 本质上是预测下一个单词 (Token)。</li><li>RT-1 把机器人的动作（手臂移动 x, y, z，夹爪开合）离散化成一个个数字 Token。</li><li>这样，控制机器人就变成了“文本生成”问题：输入是图片，输出是“动作单词”。</li><li><em>Concept</em>: Treating physical motor control as a sequence modeling problem, just like language.</li></ul></li></ul><h5 id=b-rt-2-互联网知识迁移-internet-knowledge-transfer>B. RT-2: 互联网知识迁移 (Internet Knowledge Transfer)<a hidden class=anchor aria-hidden=true href=#b-rt-2-互联网知识迁移-internet-knowledge-transfer>#</a></h5><ul><li><strong>问题</strong>: 机器人数据很少（很难让机器人实际抓 100 万次杯子），但互联网图片/文字数据很多。</li><li><strong>Co-training (联合训练)</strong>:
RT-2 把互联网上的 VQA 数据（看图问答）和机器人操作数据<strong>混在一起训练</strong>。</li><li><strong>涌现能力 (Emergent Capabilities)</strong>: [难点]<ul><li>如果你教机器人“抓苹果”，它会抓苹果。</li><li>但如果你让它“<strong>抓那个灭绝的动物</strong>”（桌上有恐龙玩具和苹果），RT-1 会傻掉。</li><li>RT-2 知道“恐龙是灭绝动物”（来自互联网知识），也知道“怎么抓东西”（来自机器人数据），所以它能推断出要去抓恐龙玩具。</li><li><em>Takeaway</em>: Semantic knowledge from the web is transferred to physical control.</li></ul></li></ul><h5 id=c-rt-x--openvla>C. RT-X / OpenVLA<a hidden class=anchor aria-hidden=true href=#c-rt-x--openvla>#</a></h5><ul><li><strong>跨形态 (Cross-Embodiment)</strong>: 不同的机器人（有的单臂，有的双臂，有的长有的短）如何共用一个模型？</li><li>通过标准化动作空间，汇集全世界不同机器人的数据训练出一个通用的 VLA 模型。</li></ul><hr><h3 id=6-专有名词表-glossary-4>6. 专有名词表 (Glossary)<a hidden class=anchor aria-hidden=true href=#6-专有名词表-glossary-4>#</a></h3><table><thead><tr><th style=text-align:left>中文术语</th><th style=text-align:left>English Term</th><th style=text-align:left>详细解释 / Detailed Explanation</th></tr></thead><tbody><tr><td style=text-align:left><strong>基础模型</strong></td><td style=text-align:left>Foundation Model</td><td style=text-align:left>在海量数据上预训练的大规模模型，具有强大的泛化能力，可适应多种下游任务（如 GPT-4, Llama）。</td></tr><tr><td style=text-align:left><strong>多模态</strong></td><td style=text-align:left>Multimodal</td><td style=text-align:left>指模型能同时处理多种媒体数据，如文本、图像、音频、视频等。</td></tr><tr><td style=text-align:left><strong>对比学习</strong></td><td style=text-align:left>Contrastive Learning</td><td style=text-align:left>CLIP 的核心训练方法。通过拉近正样本对（匹配的图文）、推远负样本对来学习特征表示。</td></tr><tr><td style=text-align:left><strong>零样本分类</strong></td><td style=text-align:left>Zero-shot Classification</td><td style=text-align:left>模型无需针对特定类别进行微调，仅凭类别的语义描述就能识别样本的能力。</td></tr><tr><td style=text-align:left><strong>视觉指令微调</strong></td><td style=text-align:left>Visual Instruction Tuning</td><td style=text-align:left>LLaVA 的训练方法。将图像特征映射到语言空间，并通过指令-回复对来微调 LLM，使其具备多模态对话能力。</td></tr><tr><td style=text-align:left><strong>具身智能</strong></td><td style=text-align:left>Embodied AI</td><td style=text-align:left>拥有物理实体（如机器人）的 AI，不仅能进行数字计算，还能与物理世界进行交互（感知+行动）。</td></tr><tr><td style=text-align:left><strong>VLA 模型</strong></td><td style=text-align:left>VLA (Vision-Language-Action)</td><td style=text-align:left>视觉-语言-动作模型。VLM 的进阶版，输出不仅是文本，还可以是机器人的控制指令。</td></tr><tr><td style=text-align:left><strong>动作 Token 化</strong></td><td style=text-align:left>Action Tokenization</td><td style=text-align:left>将连续的机器人动作（如电压、角度、坐标）转化为离散的数字 Token，以便 Transformer 处理。</td></tr><tr><td style=text-align:left><strong>联合训练</strong></td><td style=text-align:left>Co-training</td><td style=text-align:left>在 RT-2 中使用的方法，同时使用互联网图文数据和机器人操作数据进行训练，以实现知识迁移。</td></tr><tr><td style=text-align:left><strong>跨形态</strong></td><td style=text-align:left>Cross-Embodiment</td><td style=text-align:left>指一个模型能够控制身体结构完全不同的多种机器人（如不同品牌、不同自由度的机械臂）。</td></tr></tbody></table><h4 id=总结-summary-9>总结 (Summary)<a hidden class=anchor aria-hidden=true href=#总结-summary-9>#</a></h4><p>Week 10 告诉你 AI 的终极形态：</p><ol><li><strong>CLIP</strong> 让电脑学会了把“图”和“字”对上号。</li><li><strong>LLaVA</strong> 让 LLM 长了眼睛，能看图说话。</li><li><strong>SAM</strong> 提供了像素级的精确视觉能力。</li><li><strong>RT-2 / VLA</strong> 把这一切装进了机器人的身体里，利用大模型学到的世界知识（语义），去指导物理世界的行动（操作）。
<strong>从“读万卷书”（LLM）到“行万里路”（VLA），这就是 AI 的未来。</strong></li></ol></div><footer class=post-footer><nav class=paginav><a class=prev href=https://gopherding.github.io/posts/read/%E6%98%A5/><span class=title>« 上一页</span><br><span>春</span>
</a><a class=next href=https://gopherding.github.io/posts/life/red-beacon/><span class=title>下一页 »</span><br><span>Red Beacon</span></a></nav></footer></div><style>.comments_details summary::marker{font-size:20px;content:'👉展开评论';color:var(--content)}.comments_details[open] summary::marker{font-size:20px;content:'👇关闭评论';color:var(--content)}</style><div><details class=comments_details><summary style="cursor:pointer;margin:50px 0 20px;width:130px"><span style=font-size:20px;color:var(--content)>...</span></summary><div id=tcomment></div></details><script>window.addEventListener("load",function(){twikoo.init({envId:null,el:"#tcomment",lang:"zh-CN",region:null,path:window.TWIKOO_MAGIC_PATH||window.location.pathname})})</script></div></article></main><footer class=footer><span>Copyright
&copy;
2021-2026
<a href=https://gopherding.github.io/ style=color:#939393;text-decoration:none;border-bottom:none;box-shadow:none>GopherDing's Blog</a>
All Rights Reserved. Generated with
<a href=https://gohugo.io/ rel="nofollow noopener" target=_blank style=text-decoration:none;border-bottom:none;box-shadow:none>Hugo</a>
.Version 0.147.9.</span><br><span id=busuanzi_container><span class="fa fa-user"></span> <span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye"></span> <span id=busuanzi_value_site_pv></span></span></footer><script src=/js/typewriter.js></script><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>100){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString()+`\r

————————————————\r
版权声明：本文为「GopherDing's Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r
原文链接：`+location.href,s=window.getSelection().toString()+`\r

————————————————\r
版权声明：本文为「GopherDing's Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r
原文链接：`+location.href;t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function s(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent+`\r
————————————————\r
版权声明：本文为「GopherDing's Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r
原文链接：`+location.href;navigator.clipboard.writeText(t),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>