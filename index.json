[{"content":"CDN失效的解决办法：在Edge中发现页面加载缓慢，本地hugo server -D发现本地依旧缓慢，Edge中F12发现原先的CDN失效，每次请求时间很长。现在，我将把整个发现和解决问题的过程分享出来，希望能帮助到有类似困扰的朋友。\n问题发现 在一次日常浏览自己的 Hugo 博客时，我明显感觉到页面加载速度变得异常缓慢。打开浏览器的开发者工具，在网络面板中发现 Font Awesome 图标无法正常显示，jQuery 相关的交互功能也失效了。查看网络请求，发现引入的 CDN 资源加载时间过长，甚至出现了请求超时的情况。具体涉及的 CDN 代码如下：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 排查过程 寻找代码位置 搜索相关的 CDN 链接关键词，最终在一个模板文件（HUGO\\geo-hugo-papermod\\layouts\\partials\\extend_head.html）中找到了这些代码：\n{{- /* Head custom content area start */ -}} {{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} {{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} {{- /* Head custom content area end */ -}} {{- /* Head custom content area start */ -}} {{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} {{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} {{- /* Head custom content area end */ -}} {{ if (.Params.mermaid) }} \u0026lt;script defer src=\u0026#34;https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var _hmt = _hmt || []; (function() { var hm = document.createElement(\u0026#34;script\u0026#34;); hm.src = \u0026#34;\u0026#34;; var s = document.getElementsByTagName(\u0026#34;script\u0026#34;)[0]; s.parentNode.insertBefore(hm, s); })(); \u0026lt;/script\u0026gt; 分析可能原因 经过分析，我认为 CDN 资源加载缓慢或失效可能是由以下几个原因导致的：\n网络问题：CDN 服务器可能由于维护、故障或网络拥堵等原因，导致资源无法正常访问。 缓存问题：浏览器缓存了旧的资源文件，或者 Hugo 本身的缓存机制影响了新资源的加载。 配置问题：Hugo 的配置文件或模板文件可能存在错误，导致资源链接不正确。 解决办法 更换 CDN 服务 为了避免原 CDN 服务器的问题，我决定更换 CDN 服务。对于 Font Awesome，我将链接替换为 cdnjs 的 CDN：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt; 对于 jQuery，我也使用 cdnjs 的 CDN：\n\u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 清除缓存 为了确保浏览器加载的是新的资源，我清除了浏览器缓存。同时，为了避免 Hugo 缓存的影响，我使用 hugo server -D --gc 命令重新启动开发服务器，其中 --gc 选项会触发垃圾回收，清除无用的缓存文件。\n综合修改后的代码 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 注意：不能直接改public文件夹下的index.html，重启Hugo后会覆盖之，解铃还需系铃人！\n","permalink":"https://gopherding.github.io/posts/blog/cdn%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","summary":"CDN失效的解决办法：在Edge中发现页面加载缓慢，本地hugo server -D发现本地依旧缓慢，Edge中F12发现原先的CDN失效，每次请求时间很长。现在，我将把整个发现和解决问题的过程分享出来，希望能帮助到有类似困扰的朋友。 问题发现 在一次日常浏览自己的 Hugo 博客时，我明显感觉到页面加载速","title":"CDN失效的解决办法"},{"content":"在 Go 语言中，sync.RWMutex 读写锁的实现原理涉及多个关键部分，下面从其核心数据结构、获取读锁、获取写锁、释放读锁和释放写锁等方面详细介绍：\n核心数据结构 type RWMutex struct { w Mutex // 用于保护写操作的互斥锁 writerSem uint32 // 写操作的信号量 readerSem uint32 // 读操作的信号量 readerCount int32 // 当前读操作的数量 readerWait int32 // 写操作等待时需要等待的读操作数量 } w：这是一个普通的互斥锁（Mutex），用于保护对 readerCount 和 readerWait 等字段的并发访问，确保在修改这些关键状态时的原子性。 writerSem：写操作的信号量，用于阻塞和唤醒等待的写操作 goroutine。当写操作需要等待读操作完成时，会通过这个信号量进入阻塞状态；当所有读操作完成后，会通过这个信号量唤醒等待的写操作。 readerSem：读操作的信号量，用于阻塞和唤醒等待的读操作 goroutine。当写操作正在进行时，新的读操作会通过这个信号量进入阻塞状态；当写操作完成后，会通过这个信号量唤醒等待的读操作。 readerCount：记录当前正在进行的读操作的数量。读操作开始时会增加这个计数器，读操作结束时会减少这个计数器。 readerWait：记录写操作等待时需要等待的读操作数量。当写操作请求锁时，会将当前的 readerCount 值赋给 readerWait，表示写操作需要等待这些读操作完成。 获取读锁（RLock 方法） func (rw *RWMutex) RLock() { if atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0 { // 有写操作正在进行或者有写操作在等待，当前读操作需要阻塞 runtime_SemacquireMutex(\u0026amp;rw.readerSem, false, 0) } } 调用 atomic.AddInt32(\u0026amp;rw.readerCount, 1) 原子地将 readerCount 加 1，表示有一个新的读操作开始。 如果 readerCount 变为负数，说明有写操作正在进行或者有写操作在等待（因为在写操作请求锁时，会将 readerCount 减去一个特定的常量 rwmutexMaxReaders，使其变为负数），此时当前读操作会调用 runtime_SemacquireMutex 方法，通过 readerSem 信号量进入阻塞状态，直到写操作完成。 获取写锁（Lock 方法） func (rw *RWMutex) Lock() { // 先获取互斥锁，保证对后续操作的独占访问 rw.w.Lock() // 记录当前需要等待的读操作数量 r := atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders if r != 0 \u0026amp;\u0026amp; atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0 { // 有读操作正在进行，当前写操作需要阻塞 runtime_SemacquireMutex(\u0026amp;rw.writerSem, false, 0) } } 首先调用 rw.w.Lock() 获取互斥锁，确保在修改 readerCount 和 readerWait 时的原子性。 调用 atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) 将 readerCount 减去一个特定的常量 rwmutexMaxReaders，使其变为负数，表示有写操作正在请求锁。然后加上 rwmutexMaxReaders 得到当前正在进行的读操作数量 r。 如果 r 不为 0，说明有读操作正在进行，将 r 赋值给 readerWait，表示写操作需要等待这些读操作完成。如果 readerWait 不为 0，当前写操作会调用 runtime_SemacquireMutex 方法，通过 writerSem 信号量进入阻塞状态，直到所有读操作完成。 释放读锁（RUnlock 方法） func (rw *RWMutex) RUnlock() { if r := atomic.AddInt32(\u0026amp;rw.readerCount, -1); r \u0026lt; 0 { // 有写操作在等待，检查是否所有读操作都完成了 if atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0 { // 所有读操作都完成了，唤醒等待的写操作 runtime_Semrelease(\u0026amp;rw.writerSem, false, 1) } } } 调用 atomic.AddInt32(\u0026amp;rw.readerCount, -1) 原子地将 readerCount 减 1，表示一个读操作结束。 如果 readerCount 为负数，说明有写操作在等待。此时将 readerWait 减 1，如果 readerWait 变为 0，说明所有读操作都完成了，调用 runtime_Semrelease 方法，通过 writerSem 信号量唤醒等待的写操作。 释放写锁（Unlock 方法） func (rw *RWMutex) Unlock() { // 恢复读操作计数器 r := atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders) // 唤醒所有等待的读操作 for i := 0; i \u0026lt; int(r); i++ { runtime_Semrelease(\u0026amp;rw.readerSem, false, 0) } // 释放互斥锁 rw.w.Unlock() } 调用 atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders) 将 readerCount 恢复为正数，表示写操作结束。 根据 readerCount 的值，循环调用 runtime_Semrelease 方法，通过 readerSem 信号量唤醒所有等待的读操作。 最后调用 rw.w.Unlock() 释放互斥锁，允许其他操作继续进行。 总结 Go 语言的 sync.RWMutex 读写锁通过使用互斥锁、信号量和计数器等机制，实现了对共享资源的读写分离控制。多个读操作可以并发进行，提高了系统的并发性能；而写操作具有独占性，保证了数据的一致性和完整性。在实际应用中，根据不同的场景合理使用读写锁，可以有效地提高程序的性能和并发处理能力。\n说人话版： 核心规则和数据 把读写锁想象成图书馆的管理规则，而图书馆里的书就是共享资源。读写锁有几个重要的 “规则记录本”（对应代码里的数据）：\n普通门锁钥匙（w）：这就像是一把特殊的钥匙，只有拿到它才能去修改 “规则记录本” 上的内容，保证记录信息的准确性。 写操作等待室门铃（writerSem）：当有读者想要修改图书内容（写操作），但前面有其他读者正在看书（读操作）时，他就得去等待室，等待室的门铃响了才代表可以进去修改图书。 读操作等待室门铃（readerSem）：要是有读者想进图书馆看书（读操作），但刚好有人在修改图书（写操作），他就得去另一个等待室，等门铃响了才能进去看书。 正在看书的读者数量（readerCount）：记录当前有多少读者正在图书馆里看书。 修改图书的人要等的看书读者数量（readerWait）：当有读者想要修改图书时，要先看看有多少人正在看书，把这个数量记下来，等这些人都看完书才能去修改。 获取读锁（读者想进图书馆看书） 图书馆门口有个计数器，代表正在看书的读者数量。有新读者想进来时，计数器加 1。 如果发现计数器变成负数了（这就好像图书馆挂出了 “有人正在修改图书，暂时不能进” 的牌子），那新读者就得去读操作等待室等着，等门铃响了才能进去。 获取写锁（读者想修改图书内容） 想修改图书的读者得先拿到普通门锁钥匙，这样才能去改 “规则记录本” 上的信息。 他会先看一下当前有多少读者正在看书，把这个数量记下来当作要等的人数。同时，他会把计数器改成负数，告诉后面来的读者 “有人要修改图书啦，先别进”。 如果还有读者正在看书，那想修改图书的读者就得去写操作等待室等着，等门铃响了才能去修改。 释放读锁（读者看完书离开图书馆） 读者看完书离开时，计数器减 1。 如果发现计数器是负数（说明有人在等着修改图书），那就看一下要等的看书读者数量，如果这个数量变成 0 了，就按一下写操作等待室的门铃，告诉等着修改图书的人可以进来了。 释放写锁（读者修改完图书） 读者修改完图书后，把计数器恢复成正常的正数，代表可以有新读者进来看书了。 根据计数器上记录的之前因为修改图书而在等待的读者数量，挨个按读操作等待室的门铃，让他们进来看书。 最后把普通门锁钥匙还回去，其他人又可以来修改 “规则记录本” 了。 通过这样的方式，读写锁实现了多个读者可以同时看书（多个读操作并发），但有人修改图书时其他人不能看也不能改（写操作独占），提高了图书馆（程序）的使用效率。\n","permalink":"https://gopherding.github.io/posts/tech/go%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"在 Go 语言中，sync.RWMutex 读写锁的实现原理涉及多个关键部分，下面从其核心数据结构、获取读锁、获取写锁、释放读锁和释放写锁等方面详细介绍： 核心数据结构 type RWMutex struct { w Mutex // 用于保护写操作的互斥锁 writerSem uint32 // 写操作的信号量 readerSem uint32 // 读操作的信号量 readerCount int32 // 当前读操作的数量 readerWait int32 // 写操作等待时需要等","title":"Go读写锁的实现"},{"content":"• 编程语言：Go, Java, JavaScript, Python, C, SQL\n• Web开发技术：Gin, Hertz, Spring Framework, Ajax, HTML, CSS\n• 数据库相关：Gorm, Xorm, MongoDB, MySQL, Redis, PostgreSQL, HBase\n• RPC框架、服务治理与Web服务器：gRPC, Kitex, Nacos, Etcd, PolarisMesh, Nginx\n• 容器编排与集群监控部署：Docker, Kubernetes, Rancher, Helm3, Prometheus, Grafana\n• 分布式与消息队列：Raft, Gossip, ZAB, CAP , BASE, MapReduce, NSQ, Kafka, Zookeeper\n• 开源工具及云平台相关：Git, Gerrit, Hadoop, Elasticsearch, ESXI, OpenWrt, ShadowsocksR, WireShark, GitLab CI/CD, Argo CD, Jupyter Notebook, Alibaba Cloud( ECS, SLB, RDS )\nGolang选手，有一定的团队合作经验和长期Devops经验，对行业头部技术始终保持敏感，对不确定性保持积极态度，同时对重要的事情有判断力和担当，相信 \u0026ldquo;Less is More\u0026rdquo;。\n• Programming languages: Go, Java, JavaScript, Python, C, SQL\n• Web development technologies: Gin, Hertz, Spring Framework, Ajax, HTML, CSS\n• Database-related: Gorm, Xorm, MongoDB, MySQL, Redis, PostgreSQL, HBase\n• RPC frameworks, service governance, and web servers: gRPC, Kitex, Nacos, Etcd, PolarisMesh, Nginx\n• Container orchestration, cluster monitoring, and deployment: Docker, Kubernetes, Rancher, Helm3, Prometheus, Grafana\n• Distributed systems and message queues: Raft, Gossip, ZAB, CAP, BASE, MapReduce, NSQ, Kafka, Zookeeper\n• Open-source tools and cloud platforms: Git, Gerrit, Hadoop, Elasticsearch, ESXI, OpenWrt, ShadowsocksR, WireShark, GitLab CI/CD, Argo CD, Jupyter Notebook, Alibaba Cloud (ECS, SLB, RDS)\nA Go developer with some experience in teamwork and extensive DevOps experience! I\u0026rsquo;m always sensitive to the leading technologies in the industry, maintain a positive attitude towards uncertainties, and have the ability to make judgments and take responsibility when it comes to important matters. I believe in the principle of \u0026ldquo;Less is More\u0026rdquo;.\n","permalink":"https://gopherding.github.io/about/","summary":"• 编程语言：Go, Java, JavaScript, Python, C, SQL • Web开发技术：Gin, Hertz, Spring Framework, Ajax, HTML, CSS • 数据库相关：Gorm, Xorm, MongoDB, MySQL, Redis, PostgreSQL, HBase • RPC框架、服务治理与Web服务器：gRPC, Kitex, Nacos, Etcd, PolarisMesh, Nginx • 容器编排与集群监控部署：Docker, Kubernetes, Rancher, Helm3, Prometheus, Grafana • 分布式与消息队列：Raft, Gossip, ZAB, CAP , BASE, MapReduce, NSQ, Kafka, Zookeeper • 开源工具及云平台相关","title":"🙋🏻‍♂️关于"},{"content":"非常推荐去看原文↓\n字节跳动技术团队\n单元化概述 概念：将业务按维度划分成单元，理想情况下单元自包含，能独立处理业务流程，数据分散在各单元且组合完整，流量按分区维度调度，保证同一分区数据写入同一单元。 原因：解决资源限制、合规要求和容灾需求，同时带来业务体验提升、成本降低、隔离风险等收益。 挑战：包括机房延迟、数据同步、流量路由、数据正确性、成本和管理复杂度等问题。 字节跳动异地单元化架构 架构设计：围绕客户端选路、接入层纠偏、计算层纠偏、存储访问层管控构建流量调度和管控能力，确保流量和数据访问正确性，生产环境已接入众多核心微服务和实例。 关键问题及解决方式 单元维度选择：综合业务特性和核心问题，选择 Region 维度构建单元，形成同城容灾 + 异地多活架构。 分区维度选择：常见以用户（UserID）或 Region 为分区维度，需考虑数据不重叠、流量调度灵活性、路由计算轻量和单元内调用闭环等因素。 流量单元化调度：通过映射表和表达式管理分区和单元映射，在客户端、接入层、计算层和存储层根据必要性进行路由信息计算和纠偏。 复杂业务调度适配：区分本地服务和中心服务，不同服务类型决定流量调度方式和数据同步方式，降低业务理解和管理复杂度。 多单元数据管理：单元间数据同步分单向和双向，考虑防回环和唯一 Key 冲突处理，通过实时增量比对和周期全量比对保证数据同步一致性，重点检测和处理热键。 数据多活正确性保证：日常态通过存储访问中间件识别和拦截异常单元化流量；切流态采用两阶段配置变更 + 存储访问禁写避免数据脏写，同时优化配置下发时效、防止路由死循环并检查各层状态。 切流可靠性和风险控制：包括优化配置下发时效、防止路由死循环和检查业务架构各层状态。 跨地区 RPC 质量提升：通过跨单元 RPC 通道收敛和跨单元网络分级 QoS 管控优化跨地区 RPC 质量。 未来演进思考 多单元研发成本和效率优化：降低多 Region 视角下的研发和业务管理成本。 极致成本优化：计算资源和存储资源成本在异地单元化架构下有望进一步优化。 复杂单元化架构演进：应对区域增多和业务发展带来的流量调度、数据单元化和同步模型的变化，解决数据识别和搬迁问题。 完善数据多活能力：满足电商、支付类等高数据一致性要求业务的需求，发展跨 Region 强一致数据库。 ","permalink":"https://gopherding.github.io/posts/tech/%E5%8D%95%E5%85%83%E5%8C%96%E6%9E%B6%E6%9E%84%E5%9C%A8%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E7%9A%84%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/","summary":"非常推荐去看原文↓ 字节跳动技术团队 单元化概述 概念：将业务按维度划分成单元，理想情况下单元自包含，能独立处理业务流程，数据分散在各单元且组合完整，流量按分区维度调度，保证同一分区数据写入同一单元。 原因：解决资源限制、合规要求和容灾需求，同时带来业务体验提升、成本降低、隔离风险等收益","title":"单元化架构在字节跳动的落地实践"},{"content":"匆匆 燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候。但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？——是有人偷了他们罢：那是谁？又藏在何处呢？是他们自己逃走了罢：\n现在又到了哪里呢？我不知道他们给了我多少日子；但我的手确乎是渐渐空虚了。在默默里算着，八千多个日子已经从我手中溜去；像针尖上一滴水滴在大海里，我的日子滴在时间的流里，没有声音，也没有影子。我不禁头涔涔而泪潸潸了。\n去的尽管去了，来的尽管来着；去来的中间，又怎样地匆匆呢？早上我起来的时候，小屋里射进两三方斜斜的太阳。太阳他有脚啊，轻轻悄悄地挪移了；我也茫茫然跟着旋转。于是——洗手的时候，日子从水盆里过去；吃饭的时候，日子从饭碗里过去；默默时，便从凝然的双眼前过去。我觉察他去的匆匆了，伸出手遮挽时，他又从遮挽着的手边过去，天黑时，我躺在床上，他便伶伶俐俐地从我身上跨过，从我脚边飞去了。等我睁开眼和太阳再见，这算又溜走了一日。我掩着面叹息。但是新来的日子的影儿又开始在叹息里闪过了。\n在逃去如飞的日子里，在千门万户的世界里的我能做些什么呢？只有徘徊罢了，只有匆匆罢了；在八千多日的匆匆里，除徘徊外，又剩些什么呢？过去的日子如轻烟，被微风吹散了，如薄雾，被初阳蒸融了；我留着些什么痕迹呢？我何曾留着像游丝样的痕迹呢？我赤裸裸来到这世界，转眼间也将赤裸裸的回去罢？但不能平的，为什么偏要白白走这一遭啊？\n你聪明的，告诉我，我们的日子为什么一去不复返呢？\n1922年3月28日\n","permalink":"https://gopherding.github.io/posts/read/%E5%8C%86%E5%8C%86/","summary":"匆匆 燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候。但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？——是有人偷了他们罢：那是谁？又藏在何处呢？是他们自己逃走了罢： 现在又到了哪里呢？我不知道他们给了我多少日子；但我的手确乎是渐渐空虚了。在默默里算着，","title":"匆匆"},{"content":"Sonnet 18: Shall I compare thee to a summer’s day? By William Shakespeare\nShall I compare thee to a summer’s day?\nThou art more lovely and more temperate:\nRough winds do shake the darling buds of May,\nAnd summer’s lease hath all too short a date;\nSometime too hot the eye of heaven shines,\nAnd often is his gold complexion dimm\u0026rsquo;d;\nAnd every fair from fair sometime declines,\nBy chance or nature’s changing course untrimm\u0026rsquo;d;\nBut thy eternal summer shall not fade,\nNor lose possession of that fair thou ow’st;\nNor shall death brag thou wander’st in his shade,\nWhen in eternal lines to time thou grow’st:\nSo long as men can breathe or eyes can see,\nSo long lives this, and this gives life to thee.\n","permalink":"https://gopherding.github.io/posts/read/sonnet-18/","summary":"Sonnet 18: Shall I compare thee to a summer’s day? By William Shakespeare Shall I compare thee to a summer’s day? Thou art more lovely and more temperate: Rough winds do shake the darling buds of May, And summer’s lease hath all too short a date; Sometime too hot the eye of heaven shines, And often is his gold complexion dimm\u0026rsquo;d; And every fair from fair sometime declines, By chance or nature’s changing course untrimm\u0026rsquo;d; But thy eternal summer shall not fade, Nor lose possession of that fair thou ow’st; Nor shall death brag thou wander’st in his shade,","title":"Sonnet 18"},{"content":"详解及图片来源：https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\n","permalink":"https://gopherding.github.io/posts/tech/%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/","summary":"详解及图片来源：https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw","title":"常见消息队列的技术选型"},{"content":"一、GitLab CI/CD 概述： GitLab CI/CD 是 GitLab 提供的一套持续集成和持续部署（CI/CD）解决方案。它与 GitLab 紧密集成，可以在代码提交到 GitLab 仓库后自动触发构建、测试和部署流程。 通过在项目中定义 .gitlab-ci.yml 文件，开发人员可以配置各种 CI/CD 任务，如编译代码、运行测试、构建容器镜像和部署应用程序等。 主要功能： 持续集成：自动检测代码变更并触发构建和测试流程，确保代码的质量和稳定性。 持续部署：支持将应用程序部署到不同的环境，如开发、测试和生产环境。可以通过定义部署策略和流程来确保部署的可靠性和安全性。 集成其他工具：可以与各种工具和服务集成，如 Docker、Kubernetes、Jenkins 等，以实现更复杂的 CI/CD 流程。 可视化和监控：提供可视化的管道界面，方便用户查看 CI/CD 流程的状态和进度。同时，还可以设置监控和报警机制，及时发现和解决问题。 适用场景： 适用于使用 GitLab 作为代码托管平台的团队，特别是那些需要在同一个平台上管理代码、问题跟踪和 CI/CD 流程的团队。 对于小型到中型规模的项目，GitLab CI/CD 提供了一个简单而强大的解决方案，可以快速搭建和管理 CI/CD 流程。 二、Argo CD 概述： Argo CD 是一个用于实现 GitOps 持续部署的工具。它遵循 GitOps 原则，将应用程序的期望状态定义在 Git 存储库中，并通过监控 Git 存储库的变化来自动同步和部署应用程序。 Argo CD 可以与各种 Git 存储库和 Kubernetes 集群集成，实现应用程序的自动化部署和管理。 主要功能： GitOps 驱动：通过将应用程序的配置和部署定义存储在 Git 存储库中，实现了应用程序的版本控制和可追溯性。开发人员可以通过提交代码到 Git 存储库来触发应用程序的部署，而运维人员可以通过查看 Git 历史记录来了解应用程序的变更情况。 多环境管理：支持在不同的环境中部署应用程序，如开发、测试和生产环境。可以通过定义不同的 Git 存储库或分支来实现环境之间的隔离和差异管理。 应用程序同步和部署：自动监控 Git 存储库的变化，并将应用程序的配置和部署定义同步到 Kubernetes 集群中。可以实现自动化的部署、升级和回滚等操作，提高部署的效率和可靠性。 可视化和监控：提供可视化的界面，方便用户查看应用程序的状态和部署历史。同时，还可以设置监控和报警机制，及时发现和解决问题。 适用场景： 适用于采用 GitOps 原则进行应用程序部署和管理的团队。特别是对于大型企业和复杂的分布式系统，Argo CD 可以提供更好的可扩展性和管理性。 对于需要在多个环境中部署应用程序的团队，Argo CD 的多环境管理功能可以帮助实现环境之间的一致性和可重复性。 三、两者的比较 一、功能定位 Argo CD： 主要聚焦于持续部署（CD），遵循 GitOps 理念，将应用的期望状态定义在 Git 仓库中，并自动同步和部署到 Kubernetes 集群。 强调对 Kubernetes 资源的管理和部署，确保集群中的应用状态与 Git 仓库中的定义保持一致。 GitLab CI/CD： 提供完整的持续集成（CI）和持续部署流程。 涵盖从代码提交触发的构建、测试，到部署到各种环境的全过程。不仅限于 Kubernetes，还可以部署到其他平台。 二、工作流程 Argo CD： 监控 Git 仓库的变化，当发现应用配置发生改变时，自动将新的配置同步到 Kubernetes 集群中。 通常与 Kubernetes 紧密结合，通过 Kubernetes API 进行资源的管理和部署。 GitLab CI/CD： 通过在项目中定义.gitlab-ci.yml文件，配置一系列的 CI/CD 任务。 当代码提交到 GitLab 仓库后，触发流水线执行任务，包括构建、测试、部署等步骤。 三、适用场景 Argo CD： 适用于以 Kubernetes 为基础的云原生应用部署场景。 对于希望采用 GitOps 方式管理 Kubernetes 应用的团队来说非常合适。 GitLab CI/CD： 适用于各种软件开发项目，无论是传统的应用还是云原生应用。 尤其对于使用 GitLab 作为代码托管和项目管理平台的团队，能够提供一站式的 CI/CD 解决方案。 四、集成性 Argo CD： 主要与 Kubernetes 集成，也可以与一些其他工具配合使用，但相对来说集成范围较窄。 GitLab CI/CD： 可以与众多工具集成，如 Docker、Jenkins、Ansible 等，具有更广泛的集成能力。 五、配置复杂度 Argo CD： 配置相对较为复杂，需要对 Kubernetes 和 GitOps 有一定的了解。 涉及到 Kubernetes 资源的定义和管理，以及 Git 仓库的配置。 GitLab CI/CD： 配置相对较为直观，通过.gitlab-ci.yml文件进行任务定义，对于熟悉 YAML 格式的开发人员来说比较容易上手。 ","permalink":"https://gopherding.github.io/posts/tech/gitlab-cicd-%E5%92%8C-argo-cd/","summary":"一、GitLab CI/CD 概述： GitLab CI/CD 是 GitLab 提供的一套持续集成和持续部署（CI/CD）解决方案。它与 GitLab 紧密集成，可以在代码提交到 GitLab 仓库后自动触发构建、测试和部署流程。 通过在项目中定义 .gitlab-ci.yml 文件，开发人员可以配置各种 CI/CD 任务，如编译代码、运行测试、构建容器镜像和部署应用程序等。 主要功能： 持续集成：自","title":"GitLab CICD 和 Argo CD"},{"content":"中国人失掉自信力了吗 从公开的文字上看起来：两年以前，我们总自夸着 “地大物博”，是事实；不久就不再自夸了，只希望着国联，也是事实；现在是既不夸自己，也不信国联，改为一味求神拜佛，怀古伤今了 —— 却也是事实。\n于是有人慨叹曰：中国人失掉自信力了。\n如果单据这一点现象而论，自信其实是早就失掉了的。先前信 “地”，信 “物”，后来信 “国联”，都没有相信过 “自己”。假使这也算一种 “信”，那也只能说中国人曾经有过 “他信力”，自从对国联失望之后，便把这他信力都失掉了。\n失掉了他信力，就会疑，一个转身，也许能够只相信了自己，倒是一条新生路，但不幸的是逐渐玄虚起来了。信 “地” 和 “物”，还是切实的东西，国联就渺茫，不过这还可以令人不久就省悟到依赖它的不可靠。一到求神拜佛，可就玄虚之至了，有益或是有害，一时就找不出分明的结果来，它可以令人更长久的麻醉着自己。\n中国人现在是在发展着 “自欺力”。\n“自欺” 也并非现在的新东西，现在只不过日见其明显，笼罩了一切罢了。然而，在这笼罩之下，我们有并不失掉自信力的中国人在。\n我们从古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人，…… 虽是等于为帝王将相作家谱的所谓 “正史”，也往往掩不住他们的光耀，这就是中国的脊梁。\n这一类的人们，就是现在也何尝少呢？他们有确信，不自欺；他们在前仆后继的战斗，不过一面总在被摧残，被抹杀，消灭于黑暗中，不能为大家所知道罢了。说中国人失掉了自信力，用以指一部分人则可，倘若加于全体，那简直是诬蔑。\n要论中国人，必须不被搽在表面的自欺欺人的脂粉所诓骗，却看看他的筋骨和脊梁。自信力的有无，状元宰相的文章是不足为据的，要自己去看地底下。\n九月二十五日\n","permalink":"https://gopherding.github.io/posts/read/%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%A4%B1%E6%8E%89%E8%87%AA%E4%BF%A1%E5%8A%9B%E4%BA%86%E5%90%97/","summary":"中国人失掉自信力了吗 从公开的文字上看起来：两年以前，我们总自夸着 “地大物博”，是事实；不久就不再自夸了，只希望着国联，也是事实；现在是既不夸自己，也不信国联，改为一味求神拜佛，怀古伤今了 —— 却也是事实。 于是有人慨叹曰：中国人失掉自信力了。 如果单据这一点现象而论，自信其实是早就失掉","title":"中国人失掉自信力了吗"},{"content":"看个帖子：\n一、什么是 PGO PGO 即配置文件引导优化。它通过在实际运行场景中收集程序的执行信息，然后利用这些信息来指导编译器进行更有针对性的优化，从而使生成的可执行程序在特定的使用场景下具有更好的性能表现。\n二、工作原理 首先，使用一个特殊的构建标志来编译程序，这个版本的程序在运行时会收集执行信息并生成一个配置文件。 在运行过程中，程序会记录函数的调用次数、执行时间等信息，这些信息会被写入到配置文件中。 然后，使用这个配置文件再次编译程序。 编译器会根据配置文件中的信息，对那些频繁执行的代码路径进行更积极的优化，比如内联函数调用、优化循环等。同时，也可以根据执行频率调整代码布局，以提高缓存命中率。 三、优势 性能提升：通过针对实际使用场景进行优化，可以显著提高程序的执行速度和响应时间。 例如，在一个高并发的网络服务中，PGO 可以优化那些频繁被调用的处理函数，减少处理时间，提高服务的吞吐量。 资源利用效率提高：可以使程序更有效地利用 CPU 和内存等资源。 因为优化后的代码可能会减少不必要的计算和内存访问，从而降低资源消耗。 四、使用方法 收集配置文件（Profiling）：\n确保你的程序中导入了net/http/pprof包，这会在程序运行时自动添加一个用于获取 CPU 配置文件的端点，通常是/debug/pprof/profile。 在程序运行一段时间后，通过访问http://localhost:8080/debug/pprof/profile（其中localhost:8080是你的程序运行的地址和端口，根据实际情况替换），并设置合适的查询参数（如seconds=30表示收集 30 秒的运行数据）来获取配置文件。这会生成一个cpu.pprof文件。 生成 PGO 配置文件：\n将获取到的cpu.pprof文件重命名为default.pgo（或者其他你指定的文件名）。如果使用-pgo参数指定了特定的配置文件路径，就不需要重命名。 编译时开启 PGO：使用go build命令编译程序时，添加\n-pgo 参数来启用 PGO 优化。\n如果使用auto模式（推荐），编译器会自动寻找程序主目录下名为default.pgo的配置文件并应用优化。例如：go build -pgo=auto -o your_program。 也可以手动指定配置文件的路径，如：go build -pgo=/path/to/your/profile.pgo -o your_program，这里/path/to/your/profile.pgo是你指定的配置文件的完整路径。 五、注意事项 配置文件的代表性：为了获得最佳的优化效果，收集配置文件时的运行场景应该尽可能接近实际的生产环境。如果收集配置文件的场景与实际使用场景差异较大，可能会导致优化效果不佳。 重新编译：每次程序的行为发生重大变化时，可能需要重新收集配置文件并进行优化编译，以确保优化的准确性。 兼容性：不同版本的 Go 编译器对 PGO 的支持可能会有所不同。在升级 Go 版本时，需要重新评估 PGO 的效果，并可能需要进行一些调整。 ","permalink":"https://gopherding.github.io/posts/tech/pgo%E7%9B%B8%E5%85%B3/","summary":"看个帖子： 一、什么是 PGO PGO 即配置文件引导优化。它通过在实际运行场景中收集程序的执行信息，然后利用这些信息来指导编译器进行更有针对性的优化，从而使生成的可执行程序在特定的使用场景下具有更好的性能表现。 二、工作原理 首先，使用一个特殊的构建标志来编译程序，这个版本的程序在运行时会收集执行","title":"Golang的PGO优化"},{"content":"游褒禅山记 宋·王安石\n褒禅山亦谓之华山，唐浮图慧褒始舍于其址，而卒葬之；以故其后名之曰“褒禅”。今所谓慧空禅院者，褒之庐冢也。距其院东五里，所谓华山洞者，以其乃华山之阳名之也。距洞百余步，有碑仆道，其文漫灭，独其为文犹可识曰“花山”。今言“华”如“华实”之“华”者，盖音谬也。\n其下平旷，有泉侧出，而记游者甚众，所谓前洞也。由山以上五六里，有穴窈然，入之甚寒，问其深，则其好游者不能穷也，谓之后洞。余与四人拥火以入，入之愈深，其进愈难，而其见愈奇。有怠而欲出者，曰：“不出，火且尽。”遂与之俱出。盖余所至，比好游者尚不能十一，然视其左右，来而记之者已少。盖其又深，则其至又加少矣。方是时，余之力尚足以入，火尚足以明也。既其出，则或咎其欲出者，而余亦悔其随之，而不得极夫游之乐也。\n于是余有叹焉。古人之观于天地、山川、草木、虫鱼、鸟兽，往往有得，以其求思之深而无不在也。夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！\n余于仆碑，又以悲夫古书之不存，后世之谬其传而莫能名者，何可胜道也哉！此所以学者不可以不深思而慎取之也。\n四人者：庐陵萧君圭君玉，长乐王回深父，余弟安国平父、安上纯父。\n至和元年七月某日，临川王某记。\n","permalink":"https://gopherding.github.io/posts/read/%E6%B8%B8%E8%A4%92%E7%A6%85%E5%B1%B1%E8%AE%B0/","summary":"游褒禅山记 宋·王安石 褒禅山亦谓之华山，唐浮图慧褒始舍于其址，而卒葬之；以故其后名之曰“褒禅”。今所谓慧空禅院者，褒之庐冢也。距其院东五里，所谓华山洞者，以其乃华山之阳名之也。距洞百余步，有碑仆道，其文漫灭，独其为文犹可识曰“花山”。今言“华”如“华实”之“华”者，盖音谬也。 其下平","title":"游褒禅山记"},{"content":"如何设计一个高并发系统?\n一、页面静态化 模板引擎 html/template：Go 标准库自带的模板引擎，用于生成 HTML 页面。它具有简单易用、安全（防止跨站脚本攻击等）的特点，适合用于页面静态化。 jet：这是一个高性能的 Go 模板引擎，语法简洁，在性能上有一定优势。 二、缓存 内存缓存 go - cache：这是一个简单的内存缓存库，适合在 Go 应用中缓存一些临时数据，例如短时间内频繁访问的数据。它提供了基本的缓存操作，如设置、获取和删除。 groupcache：由 Google 开发，用于在分布式环境下实现高效的内存缓存。它可以在多台机器之间共享缓存数据，减少数据库或其他后端存储的访问压力。 三、异步 消息队列客户端 go - kafka - client：用于在 Go 应用中与 Kafka 消息队列进行交互。通过它可以实现异步消息的发送和接收，将耗时的操作异步处理，例如日志记录、事件通知等。 rabbitmq - go：这是 RabbitMQ 的 Go 语言客户端库，支持 AMQP 协议，允许 Go 程序与 RabbitMQ 进行通信，实现异步消息处理机制。 异步编程 Go 语言原生支持：Go 语言的goroutine和channel机制天然支持异步编程。通过go关键字可以轻松启动一个异步执行的函数（goroutine），而channel用于在goroutine之间进行通信和同步数据。 四、多线程处理（Go 中的 goroutine 类似多线程概念） 标准库并发原语 goroutine：Go 语言中轻量级的并发执行单元，类似于线程，但比传统线程更轻量，创建和销毁的开销较小。可以通过go关键字轻松启动一个goroutine来并发执行函数。 channel：用于在goroutine之间进行数据传递和同步。有缓冲通道和无缓冲通道之分，可以根据实际需求选择合适的通道类型来实现并发控制和数据共享。 sync 包：包含了如Mutex（互斥锁）、RWMutex（读写锁）、WaitGroup（用于等待一组goroutine完成）等并发原语，用于解决并发访问共享资源时的同步问题。 五、分库分表 数据库操作库 gorm：一个功能强大且易用的 Go 语言 ORM（对象关系映射）库。虽然它本身不直接提供分库分表功能，但可以通过自定义插件或者在业务逻辑层根据一定规则（如哈希算法、范围划分等）来实现数据的分库分表操作。 xorm：另一个 Go 语言的 ORM 库，类似 gorm，通过结合一些分库分表的策略和算法，可以在 Go 应用中实现数据库的分库分表。 六、池化技术 数据库连接池 go - sql - driver/mysql：这是 MySQL 数据库的 Go 语言驱动，配合database/sql标准库，可以通过设置连接池参数来实现数据库连接池功能，例如设置最大连接数、空闲连接数等。 pgx：这是一个高性能的 PostgreSQL 数据库的 Go 语言驱动，也支持连接池机制，通过合理配置连接池参数，可以优化数据库连接的管理和使用。 资源池（通用池化框架） go - pool：这是一个通用的资源池框架，可以用于创建各种类型的资源池，例如数据库连接池、网络连接池等。它提供了资源的获取、释放、空闲资源管理等功能。 七、读写分离 数据库中间件（结合 Go 应用） vitess：这是一个用于 MySQL 水平扩展的数据库中间件，支持读写分离、分库分表等功能。虽然它本身是用 C++ 编写的，但可以通过 Go 语言编写客户端来与之交互，实现 Go 应用中的读写分离操作。 Sharding -Sphere（Go - Sharding -Sphere）：Sharding -Sphere 有 Go 语言的客户端实现，它可以帮助 Go 应用实现数据库的读写分离以及分库分表等操作。 八、索引 数据库索引操作（通过数据库驱动实现） 在使用数据库驱动（如 go - sql - driver/mysql、pgx 等）操作数据库时：可以在 SQL 语句中使用CREATE INDEX、ALTER TABLE ADD INDEX等语句来创建索引。这与具体的数据库（如 MySQL、PostgreSQL 等）的索引操作语法相关，Go 语言通过执行这些 SQL 语句来操作数据库索引。 九、批处理 数据库批处理（通过数据库驱动实现） go - sql - driver/mysql 等数据库驱动：在 Go 语言中操作数据库时，可以使用数据库驱动提供的批处理功能。例如，在插入多条记录时，可以使用exec方法的批处理模式，将多条INSERT语句一次性提交给数据库执行，提高数据处理效率。 大数据批处理（结合大数据框架） Go - Hadoop：Go 语言有一些用于与 Hadoop 生态系统交互的库，例如可以使用 Go - Hadoop 来编写 MapReduce 程序，实现大数据的批处理操作。虽然 Go 不是 Hadoop 原生支持的编程语言，但通过这些库可以在 Go 语言中利用 Hadoop 的批处理能力。 十、集群 Web 服务器集群（Go 服务器框架） Gin：这是一个轻量级的 Go Web 框架，在构建 Web 服务器集群时，可以将多个 Gin 实例部署在不同的服务器上，通过负载均衡器（如 Nginx）将请求分发到这些 Gin 服务器上，实现集群服务。 Beego：一个全功能的 Go Web 框架，同样可以用于构建 Web 服务器集群。它具有丰富的功能，如路由、模板引擎、数据库访问等，方便在集群环境中部署和运行。 分布式集群（结合分布式框架） etcd：这是一个分布式键值存储系统，由 CoreOS 开发，用于分布式系统中的配置管理、服务发现等。Go 语言是 etcd 的开发语言，在 Go 应用中可以方便地使用 etcd 来构建分布式集群，实现节点间的通信和协调。 Consul：这是 HashiCorp 开发的一个用于实现分布式系统服务发现和配置的工具。Go 应用可以通过 Consul 的 Go 语言客户端来参与到分布式集群中，实现服务注册、发现和健康检查等功能。 十一、负载均衡 软件负载均衡（Go 实现） go - reverseproxy：这是一个用 Go 语言实现的简单反向代理库，可以作为负载均衡器的基础。它可以将接收到的请求转发到后端的多个服务器上，通过一定的负载均衡算法（如轮询、随机等）来分配请求。 Fabio：这是一个基于 Go 语言的快速、简单的 HTTP 和 TCP 负载均衡器，它可以自动发现后端服务，并根据配置的策略进行负载均衡。 十二、限流 限流框架 uber - go/ratelimit：这是由 Uber 开源的一个简单的 Go 语言限流库，它基于令牌桶算法实现，可以用于限制对某些资源（如 API 接口）的访问频率。 go - limiter：这是一个 Go 语言的通用限流库，支持多种限流算法，如漏桶算法、令牌桶算法等，可以根据实际需求选择合适的算法来实现对系统流量的控制。 十三、服务降级 微服务框架（Go - Micro 等） Go - Micro：这是一个用于构建微服务的 Go 语言框架，它提供了服务发现、配置管理、消息传递等功能。在 Go - Micro 中，可以通过编写降级逻辑来实现服务降级，例如当某个服务不可用时，返回默认值或者调用备用服务。 Kratos：这是由字节跳动开源的一个 Go 语言的微服务框架，它注重性能和可靠性。在 Kratos 框架中，可以通过设计合理的服务治理策略来实现服务降级操作，保障系统在高负载或部分服务故障时的可用性。 十四、故障转移 数据库故障转移（结合数据库特性和 Go 应用） 通过 MySQL 等数据库的复制和高可用性机制：在 Go 应用中，当使用 MySQL 数据库时，可以利用 MySQL 的主从复制和故障转移机制（如 MySQL MHA 等）。Go 语言通过数据库驱动和相关的监控逻辑来检测数据库主节点的故障，并在故障发生时切换到从节点继续服务。 etcd 的故障转移机制：如前文所述，etcd 是一个分布式键值存储系统，具有自动的故障转移机制。Go 应用在使用 etcd 进行分布式协调和存储时，可以依赖 etcd 的故障转移特性来保障系统的稳定性。 十五、异地多活 数据库异地多活（结合分布式数据库和 Go 应用） TiDB：这是一个开源的分布式数据库，具有水平扩展、强一致性等特点。在 Go 应用中，可以使用 TiDB 来实现数据库的异地多活，通过合理配置 TiDB 的集群和数据复制策略，保障数据在不同地域的数据中心都能正常访问和更新。 CockroachDB：这是一个分布式的 SQL 数据库，旨在提供全球范围内的分布式数据存储和处理能力。Go 语言可以通过 CockroachDB 的 Go 客户端来操作数据库，实现异地多活的数据库架构。 应用层异地多活（结合微服务和网络架构） 通过 Go - Micro 等微服务框架和网络优化策略：在微服务架构中，Go 应用可以通过 Go - Micro 等框架实现服务的跨地域部署。同时，结合网络优化技术（如低延迟网络、网络隧道等）和数据同步机制，可以保障应用服务在不同地域的数据中心都能稳定运行，实现异地多活。 十六、压测 性能测试工具（Go 编写） hey：这是一个用 Go 语言编写的 HTTP 性能测试工具，类似于ab（ApacheBench）。它可以对 Web 应用的 HTTP 接口进行压力测试，测量响应时间、吞吐量等性能指标。 vegeta：这是另一个高性能的 HTTP 负载测试工具，由 Go 语言实现。它可以生成不同负载的 HTTP 请求，用于测试 Go Web 应用以及其他基于 HTTP 协议的服务的性能和稳定性。 十七、监控 系统监控（Go 实现） prometheus/client_golang：这是 Prometheus 监控系统的 Go 语言客户端库。Go 应用可以通过这个库来暴露自身的性能指标（如 CPU 使用率、内存占用、请求处理时间等），方便 Prometheus 进行数据采集和监控。 expvar：这是 Go 标准库中的一个包，用于在运行时暴露应用程序的变量。虽然它比较简单，但可以用于一些基础的监控需求，例如查看当前应用中的连接数、请求数等。 应用性能监控（APM） jaeger - client - go：这是 Jaeger 分布式追踪系统的 Go 语言客户端。通过在 Go 应用中集成 jaeger - client - go，可以实现对应用程序的性能追踪和故障排查，监控请求在各个服务和组件之间的流转情况。 opentelemetry - go：这是 OpenTelemetry 项目的 Go 语言实现，它提供了一套标准的、跨语言的应用性能监控和分布式追踪的工具和接口。Go 应用可以使用 opentelemetry - go 来实现全面的 APM 功能。 ","permalink":"https://gopherding.github.io/posts/tech/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/","summary":"如何设计一个高并发系统? 一、页面静态化 模板引擎 html/template：Go 标准库自带的模板引擎，用于生成 HTML 页面。它具有简单易用、安全（防止跨站脚本攻击等）的特点，适合用于页面静态化。 jet：这是一个高性能的 Go 模板引擎，语法简洁，在性能上有一定优势。 二、缓存 内存缓存 go - cach","title":"如何设计一个高并发系统"},{"content":" Here’s to the crazy ones. 向那些疯狂的家伙致敬 The misfits. 他们特立独行 The rebels. 他们桀骜不驯 The troublemakers. 他们惹是生非 The round pegs in the square holes. 他们格格不入 The ones who see things differently. 他们用与众不同的眼光看待事物 They’re not fond of rules. 他们不喜欢墨守成规 And they have no respect for the status quo. 他们也不愿安于现状 You can quote them, disagree with them, 你可以赞美他们，否定他们 glorify or vilify them. 颂扬抑或是诋毁他们 About the only thing you can’t do is ignore them. 但是唯独不能漠视他们 Because they change things. 因为他们改变了事物 They push the human race forward. 他们让人类向前跨越了一大步 And while some may see them as the crazy ones, 有人视他们为疯子 we see genius. 而我们却视他们为天才 Because the people who are crazy enough to think they can change the world, 因为，只有疯狂到认为自己能够改变世界的人 are the ones who do. 才能真正的改变世界 ","permalink":"https://gopherding.github.io/posts/read/heres-to-the-crazy-ones/","summary":"Here’s to the crazy ones. 向那些疯狂的家伙致敬 The misfits. 他们特立独行 The rebels. 他们桀骜不驯 The troublemakers. 他们惹是生非 The round pegs in the square holes. 他们格格不入 The ones who see things differently. 他们用与众不同的眼光看待事物 They’re not fond of rules. 他们不喜欢墨守成规 And they have no respect for the status quo. 他们也不愿安于现状 You can quote them, disagree with them, 你可以赞美他们，否定他们 glorify or vilify them. 颂扬","title":"Here’s to the crazy ones"},{"content":"项脊轩志 明·归有光\n项脊轩，旧南阁子也。室仅方丈，可容一人居。百年老屋，尘泥渗漉，雨泽下注；每移案，顾视无可置者。又北向，不能得日，日过午已昏。余稍为修葺，使不上漏。前辟四窗，垣墙周庭，以当南日，日影反照，室始洞然。又杂植兰桂竹木于庭，旧时栏楯，亦遂增胜。借书满架，偃仰啸歌，冥然兀坐，万籁有声；而庭阶寂寂，小鸟时来啄食，人至不去。三五之夜，明月半墙，桂影斑驳，风移影动，珊珊可爱。(借书 一作：积书；阶寂寂 一作：堦寂寂)\n然余居于此，多可喜，亦多可悲。先是庭中通南北为一。迨诸父异爨，内外多置小门墙，往往而是，东犬西吠，客逾庖而宴，鸡栖于厅。庭中始为篱，已为墙，凡再变矣。家有老妪，尝居于此。妪，先大母婢也，乳二世，先妣抚之甚厚。室西连于中闺，先妣尝一至。妪每谓余曰：“某所，而母立于兹。”妪又曰：“汝姊在吾怀，呱呱而泣；娘以指叩门扉曰：‘儿寒乎？欲食乎？’吾从板外相为应答。”语未毕，余泣，妪亦泣。余自束发读书轩中，一日，大母过余曰：“吾儿，久不见若影，何竟日默默在此，大类女郎也？”比去，以手阖门，自语曰：“吾家读书久不效，儿之成，则可待乎！”顷之，持一象笏至，曰：“此吾祖太常公宣德间执此以朝，他日汝当用之！”瞻顾遗迹，如在昨日，令人长号不自禁。(内外多置小门墙，往往而是 一作：内外多置小门，墙往往而是)\n轩东故尝为厨，人往，从轩前过。余扃牖而居，久之，能以足音辨人。轩凡四遭火，得不焚，殆有神护者。\n项脊生曰：“蜀清守丹穴，利甲天下，其后秦皇帝筑女怀清台；刘玄德与曹操争天下，诸葛孔明起陇中。方二人之昧昧于一隅也，世何足以知之，余区区处败屋中，方扬眉、瞬目，谓有奇景。人知之者，其谓与坎井之蛙何异？”\n余既为此志，后五年，吾妻来归，时至轩中，从余问古事，或凭几学书。吾妻归宁，述诸小妹语曰：“闻姊家有阁子，且何谓阁子也？”其后六年，吾妻死，室坏不修。其后二年，余久卧病无聊，乃使人复葺南阁子，其制稍异于前。然自后余多在外，不常居。\n庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。\n","permalink":"https://gopherding.github.io/posts/read/%E9%A1%B9%E8%84%8A%E8%BD%A9%E5%BF%97/","summary":"项脊轩志 明·归有光 项脊轩，旧南阁子也。室仅方丈，可容一人居。百年老屋，尘泥渗漉，雨泽下注；每移案，顾视无可置者。又北向，不能得日，日过午已昏。余稍为修葺，使不上漏。前辟四窗，垣墙周庭，以当南日，日影反照，室始洞然。又杂植兰桂竹木于庭，旧时栏楯，亦遂增胜。借书满架，偃仰啸歌，冥然兀","title":"项脊轩志"},{"content":"有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生竞态问题（数据竞态race condition）。\n原则：对一个共享资源的读和写操作必须是原子化的——同一时刻只能有一个 goroutine 对共享资源进行读和写操作。\n互斥锁： Go 语言中使用sync包中提供的Mutex类型来实现互斥锁。\nfunc (m *Mutex) Lock() 获取互斥锁 func (m *Mutex) Unlock() 释放互斥锁 使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。\n锁的两种模式 互斥锁在设计上主要有两种模式： 正常模式和饥饿模式。\n之所以引入了饥饿模式，是为了保证goroutine获取互斥锁的公平性。所谓公平性，其实就是多个goroutine在获取锁时，goroutine获取锁的顺序，和请求锁的顺序一致，则为公平。\n正常模式下，所有阻塞在等待队列中的goroutine会按顺序进行锁获取，当唤醒一个等待队列中的goroutine时，此goroutine并不会直接获取到锁，而是会和新请求锁的goroutine竞争。 通常新请求锁的goroutine更容易获取锁，这是因为新请求锁的goroutine正在占用cpu片执行，大概率可以直接执行到获取到锁的逻辑。\n饥饿模式下， 新请求锁的goroutine不会进行锁获取，而是加入到队列尾部阻塞等待获取锁。\n饥饿模式的触发条件： 当一个goroutine等待锁的时间超过1ms时，互斥锁会切换到饥饿模式 饥饿模式的取消条件： 当获取到锁的这个goroutine是等待锁队列中的最后一个goroutine，互斥锁会切换到正常模式 当获取到锁的这个goroutine的等待时间在1ms之内，互斥锁会切换到正常模式 sync.Mutex的数据结构 Go中的sync.Mutex的结构体为：\ntype Mutex struct { state int32 sema uint32 } Sync.Mutex由两个字段构成，state用来表示当前互斥锁处于的状态，sema用于控制锁状态的信号量。相信各位道友读完这两个字段的描述后，好像懂了，又好像没懂。下面我们详细理解下这两个字段到底都作了哪些事。\n互斥锁state主要记录了如下四种状态：\n![image-20240320224646795](C:\\Users\\GEORGE DING\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240320224646795.png)\nwaiter_num： 记录了当前等待抢这个锁的goroutine数量\nstarving： 当前锁是否处于饥饿状态 (后文会详解锁的饥饿状态) 0: 正常状态 1: 饥饿状态\nwoken： 当前锁是否有goroutine已被唤醒。 0：没有goroutine被唤醒； 1: 有goroutine正在加锁过程\nlocked： 当前锁是否被goroutine持有。 0: 未被持有 1: 已被持有\nsema信号量的作用：\n当持有锁的gorouine释放锁后，会释放sema信号量，这个信号量会唤醒之前抢锁阻塞的gorouine来获取锁。\nTo know much more, here （Mutex底层结构）!\n读写互斥锁： 互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用sync包中的RWMutex类型。\n方法名 功能 func (rw *RWMutex) Lock() 获取写锁 func (rw *RWMutex) Unlock() 释放写锁 func (rw *RWMutex) RLock() 获取读锁 func (rw *RWMutex) RUnlock() 释放读锁 func (rw *RWMutex) RLocker() Locker 返回一个实现Locker接口的读写锁 当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。\n即：读锁可读不可写，写锁读写均不可。\nsync.WaitGroup 方法名 功能 func (wg * WaitGroup) Add(delta int) 计数器+delta (wg *WaitGroup) Done() 计数器-1 (wg *WaitGroup) Wait() 阻塞直到计数器变为0 sync.WaitGroup 内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done 方法将计数器减1。通过调用 Wait 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。\nsync.Once 在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。\nGo语言中的sync包中提供了一个针对只执行一次场景的解决方案——sync.Once，sync.Once只有一个Do方法，其签名如下：\nfunc (o *Once) Do(f func()) sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次，源码如下：\nfunc (o *Once) doSlow(f func()) { o.m.Lock() defer o.m.Unlock() if o.done.Load() == 0 { defer o.done.Store(1) f() } } sync.Map 先来看一下源码注释罢：\n// The Map type is optimized for two common use cases: (1) when the entry for a given // key is only ever written once but read many times, as in caches that only grow, // or (2) when multiple goroutines read, write, and overwrite entries for disjoint // sets of keys. In these two cases, use of a Map may significantly reduce lock // contention compared to a Go map paired with a separate Mutex or RWMutex. 使用方法：\nfunc main() { var m sync.Map // 1. 写入 m.Store(\u0026#34;qwe\u0026#34;, 18) m.Store(\u0026#34;asd\u0026#34;, 20) // 2. 读取 age, _ := m.Load(\u0026#34;qwe\u0026#34;) fmt.Println(age.(int)) // 3. 遍历 m.Range(func(key, value interface{}) bool { name := key.(string) age := value.(int) fmt.Println(name, age) return true }) // 4. 删除 m.Delete(\u0026#34;qwe\u0026#34;) age, ok := m.Load(\u0026#34;qwe\u0026#34;) fmt.Println(age, ok) // 5. 读取或写入，这个 key 已经存在，因此写入不成功，并且读出原值。 m.LoadOrStore(\u0026#34;asd\u0026#34;, 100) age, _ = m.Load(\u0026#34;asd\u0026#34;) fmt.Println(age) } 方法名 功能 func (m *Map) Store(key, value interface{}) 存储key-value数据 func (m *Map) Load(key interface{}) (value interface{}, ok bool) 查询key对应的value func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) 查询或存储key对应的value func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) 查询并删除key func (m *Map) Delete(key interface{}) 删除key func (m *Map) Range(f func(key, value interface{}) bool) 对map中的每个key-value依次调用f 浅浅看一下源码罢：\ntype Map struct { mu Mutex // readOnly,`read` 是 atomic.Value 类型，可以并发地读。但如果需要更新 `read`，则需要加锁保护。对于 read 中存储的 entry 字段，可能会被并发地 CAS 更新。但是如果要更新一个之前已被删除的 entry，则需要先将其状态从 expunged 改为 nil，再拷贝到 dirty 中，然后再更新。 read atomic.Value //`dirty` 是一个非线程安全的原始 map。包含新写入的 key，并且包含 `read` 中的所有未被删除的 key。这样，可以快速地将 `dirty` 提升为 `read` 对外提供服务。如果 `dirty` 为 nil，那么下一次写入时，会新建一个新的 `dirty`，这个初始的 `dirty` 是 `read` 的一个拷贝，但除掉了其中已被删除的 key。 dirty map[interface{}]*entry //每当从 read 中读取失败，都会将 `misses` 的计数值加 1，当加到一定阈值以后，需要将 dirty 提升为 read，以期减少 miss 的情形。 misses int } sync.map 适用于读多写少的场景。对于写多的场景，会导致 read map 缓存失效，需要加锁，导致冲突变多；而且由于未命中 read map 次数过多，导致 dirty map 提升为 read map，这是一个 O(N) 的操作，会进一步降低性能。\n总之： sync.map 是线程安全的，读取，插入，删除也都保持着常数级的时间复杂度。 通过读写分离，降低锁时间来提高效率，适用于读多写少的场景。 Range 操作需要提供一个函数，参数是 k,v，返回值是一个布尔值：f func(key, value interface{}) bool。 调用 Load 或 LoadOrStore 函数时，如果在 read 中没有找到 key，则会将 misses 值原子地增加 1，当 misses 增加到和 dirty 的长度相等时，会将 dirty 提升为 read。以期减少“读 miss”。 新写入的 key 会保存到 dirty 中，如果这时 dirty 为 nil，就会先新创建一个 dirty，并将 read 中未被删除的元素拷贝到 dirty。 当 dirty 为 nil 的时候，read 就代表 map 所有的数据；当 dirty 不为 nil 的时候，dirty 才代表 map 所有的数据。 ","permalink":"https://gopherding.github.io/posts/tech/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E9%94%81/","summary":"有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生竞态问题（数据竞态race condition）。 原则：对一个共享资源的读和写操作必须是原子化的——同一时刻只能有一个 goroutine 对共享资源进行读和写操作。 互斥锁： Go 语言中使用sync包中提供的Mutex类","title":"同步并发\u0026锁"},{"content":" ","permalink":"https://gopherding.github.io/posts/tech/postgresql%E5%92%8Cmysql%E5%8C%BA%E5%88%AB/","summary":"","title":"PostgreSQL和MySQL区别"},{"content":"一、内部结构 sync.Map主要由两个数据结构组成：\n一个原生的map：用于存储实际的键值对。这个map在读取时无需加锁，但在写入时需要加锁。 一个read结构体：包含一个只读的原生map（称为dirty map）和一个misses计数器。这个read结构体在读取操作时被优先使用，因为读取它无需加锁，只有在发生读未命中且misses计数达到一定阈值时，才会将dirty map中的内容写入到主map中并重置read结构体。 二、读写操作 读操作： 首先尝试从read结构体中的dirty map读取键对应的值。如果找到了值，直接返回。 如果在dirty map中未找到值，再尝试从主map中读取。如果找到了值，更新read结构体中的dirty map并返回值。 如果在主map中也未找到值，增加misses计数器。如果misses计数器达到一定阈值，会将dirty map中的内容写入主map，并重置read结构体和misses计数器。 写操作： 首先锁定主map，然后进行写入操作。 同时，如果read结构体中的dirty map为空，将主map复制一份到dirty map中，以便后续的读操作可以更快地访问。 三、并发安全 一、读写分离设计 内部包含两个主要的数据结构： 一个是普通的map，用于存储实际的键值对，称为 “dirty map”。这个map在写操作时会被锁定，以确保写操作的原子性和一致性。 另一个是只读的map结构，在执行读操作时优先从这个结构中读取数据，无需加锁，从而允许多个线程并发读取。 二、写操作的同步机制 互斥锁保护： 当进行写操作（存储新的键值对、更新现有键值对或删除键值对）时，会获取一个互斥锁，确保同一时刻只有一个线程可以对 “dirty map” 进行写操作。 这样可以防止多个线程同时修改map时可能导致的数据不一致和竞争条件。 三、读操作的优化与同步 优先从只读map读取：\n读操作首先尝试从只读的map中获取键对应的值，因为这个map不需要加锁，所以多个线程可以同时进行读操作，提高了读操作的并发性能。 动态更新只读map：\n如果读操作在只读map中未找到键对应的值，会尝试从 “dirty map” 中读取。如果在 “dirty map” 中找到了值，会将这个值更新到只读map中，以便后续的读操作可以更快地获取到这个值。 misses计数器：\n每次读操作在只读map和 “dirty map” 中都未找到值时，会增加一个misses计数器。当misses计数器达到一定阈值时，会触发将 “dirty map” 中的内容复制到只读map中，并重置misses计数器。这个机制确保了在一段时间内如果读操作频繁未命中，会动态地更新只读map，以提高后续读操作的效率。 四、删除操作的安全处理 标记删除：\n当执行删除操作时，会在 “dirty map” 中标记键值对为已删除状态。这样在后续的读操作中，如果在只读map中未找到键对应的值，并且在 “dirty map” 中发现该键被标记为已删除，就可以确定该键不存在于map中。 ","permalink":"https://gopherding.github.io/posts/tech/%E5%AF%B9sync.map%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/","summary":"一、内部结构 sync.Map主要由两个数据结构组成： 一个原生的map：用于存储实际的键值对。这个map在读取时无需加锁，但在写入时需要加锁。 一个read结构体：包含一个只读的原生map（称为dirty map）和一个misses计数器。这个read结构体在读取操作时被优先使用，因为","title":"对sync.Map的一些看法"},{"content":"与妻书 林觉民\n意映卿卿如晤，吾今以此书与汝永别矣！吾作此书时，尚是世中一人；汝看此书时，吾已成为阴间一鬼。吾作此书，泪珠和笔墨齐下，不能竟书而欲搁笔，又恐汝不察吾衷，谓吾忍舍汝而死，谓吾不知汝之不欲吾死也，故遂忍悲为汝言之。\n吾至爱汝，即此爱汝一念，使吾勇就死也。吾自遇汝以来，常愿天下有情人都成眷属；然遍地腥云，满街狼犬，称心快意，几家能彀？司马青衫，吾不能学太上之忘情也。语云：仁者 “老吾老，以及人之老；幼吾幼，以及人之幼”。吾充吾爱汝之心，助天下人爱其所爱，所以敢先汝而死，不顾汝也。汝体吾此心，于啼泣之余，亦以天下人为念，当亦乐牺牲吾身与汝身之福利，为天下人谋永福也。汝其勿悲！\n汝忆否？四五年前某夕，吾尝语曰：“与使吾先死也，无宁汝先吾而死。” 汝初闻言而怒，后经吾婉解，虽不谓吾言为是，而亦无词相答。吾之意盖谓以汝之弱，必不能禁失吾之悲，吾先死，留汝而无所依，吾心不忍，故宁请汝先死，吾担悲也。嗟夫！谁知吾卒先汝而死乎？\n吾真真不能忘汝也！回忆后街之屋，入门穿廊，过前后厅，又三四折，有小厅，厅旁一室，为吾与汝双栖之所。初婚三四个月，适冬之望日前后，窗外疏梅筛月影，依稀掩映；吾与汝并肩携手，低低切切，何事不语？何情不诉？及今思之，空余泪痕。又回忆六七年前，吾之逃家复归也，汝泣告我：“望今后有远行，必以告妾，妾愿随君行。” 吾亦既许汝矣。前十余日回家，即欲乘便以此行之事语汝，及与汝相对，又不能启口，且以汝之有身也，更恐不胜悲，故惟日日呼酒买醉。\n嗟夫！当时余心之悲，盖不能以寸管形容之。吾诚愿与汝相守以死，第以今日事势观之，天灾可以死，盗贼可以死，瓜分之日可以死，奸官污吏虐民可以死，吾辈处今日之中国，无时无地不可以死，到那时使吾眼睁睁看汝死，或者使汝眼睁睁看吾死，吾能之乎？抑汝能之乎？即可不死，而离散不相见，徒使两地眼成穿而骨化石，试问古来几对夫妻能到此境？此吾所以敢率性就死不顾汝也。吾今死无余憾，国事成不成自有同志者在。依新已五岁，转眼成人，汝其善抚之，使之肖我。汝腹中之物，吾疑其女也，女必像汝，吾心甚慰。或又是男，则亦教其以父志为志，则吾死后尚有二意映在也。甚幸，甚幸！吾家后日当甚贫，贫无所苦，清静过日而已。\n吾今与汝无言矣。吾居九泉之下遥闻汝哭声，当哭相和也。吾平日不信有鬼，今则又望其真有。今人又言心电感应有道，吾亦望其言是实，则吾之死，吾灵尚依依旁汝也，汝不必以无侣悲。\n吾平生未尝以吾所志语汝，是吾不是处；然语之，又恐汝日日为吾担忧。吾牺牲百死而不辞，而使汝担忧，的的非吾所忍。吾爱汝至，所以为汝谋者惟恐未尽。汝幸而偶我，又何不幸而生今日之中国！吾幸而得汝，又何不幸而生今日之中国！卒不忍独善其身。嗟夫！巾短情长，所未尽者，尚有万千，汝可以模拟得之。吾今不能见汝矣！汝不能舍吾，吾亦不能舍汝，汝当体吾此心，于啼泣之余，亦以天下人为念，当亦乐牺牲吾身与汝身之福利，为天下人谋永福也。汝其勿悲！\n","permalink":"https://gopherding.github.io/posts/read/%E4%B8%8E%E5%A6%BB%E4%B9%A6/","summary":"与妻书 林觉民 意映卿卿如晤，吾今以此书与汝永别矣！吾作此书时，尚是世中一人；汝看此书时，吾已成为阴间一鬼。吾作此书，泪珠和笔墨齐下，不能竟书而欲搁笔，又恐汝不察吾衷，谓吾忍舍汝而死，谓吾不知汝之不欲吾死也，故遂忍悲为汝言之。 吾至爱汝，即此爱汝一念，使吾勇就死也。吾自遇汝以来，常愿天","title":"与妻书"},{"content":"Kubernetes 针对 Pod 资源对象主要有以下两种健康监测机制：\n一、就绪性探测（Readiness Probe） 作用： 确定容器是否准备好服务请求。当一个 Pod 中的容器的就绪性探测成功时，该容器才会被视为准备好接收流量，被添加到服务的后端列表中。如果就绪性探测失败，容器将从服务的后端列表中移除，新的请求不会被分发到该容器，直到它再次变为就绪状态。 实现方式： HTTP GET 探测：向容器内指定的路径和端口发送 HTTP GET 请求。如果响应的状态码在 200 到 399 之间，则认为容器就绪。 TCP 套接字探测：尝试与容器内指定的端口建立 TCP 连接。如果连接成功，则认为容器就绪。 Exec 探测：在容器内执行指定的命令。如果命令的退出状态码为 0，则认为容器就绪。 二、存活态探测（Liveness Probe） 作用： 检查容器是否正在运行。如果存活态探测失败，Kubernetes 会尝试重启容器，以确保应用持续运行。 实现方式： HTTP GET 探测：与就绪性探测的 HTTP GET 方式类似，但目的是检查容器的运行状态而不是准备接收请求的状态。 TCP 套接字探测：与就绪性探测的 TCP 套接字方式类似，用于判断容器是否在运行。 Exec 探测：在容器内执行指定的命令，根据命令的退出状态码判断容器是否存活。 两者区别： 目的不同： 就绪性探测主要关注容器是否准备好接收请求，决定容器是否应该被纳入服务的后端列表。 存活态探测主要关注容器是否正在运行，以确保应用的持续可用性，如果容器出现问题则尝试重启。 影响不同： 就绪性探测失败只会影响容器是否接收新的请求，不会导致容器被重启。 存活态探测失败可能会导致容器被重启。 触发时机不同： 就绪性探测在容器启动后以及在容器运行过程中定期进行，以确保容器始终处于可以接收请求的状态。 存活态探测在容器运行期间持续进行，以检测容器是否出现故障。 ","permalink":"https://gopherding.github.io/posts/tech/k8s%E9%92%88%E5%AF%B9pod%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%81%A5%E5%BA%B7%E7%9B%91%E6%B5%8B%E6%9C%BA%E5%88%B6/","summary":"Kubernetes 针对 Pod 资源对象主要有以下两种健康监测机制： 一、就绪性探测（Readiness Probe） 作用： 确定容器是否准备好服务请求。当一个 Pod 中的容器的就绪性探测成功时，该容器才会被视为准备好接收流量，被添加到服务的后端列表中。如果就绪性探测失败，容器将从服务的后端列表中移除，新的请求不会","title":"K8s针对pod资源对象的健康监测机制"},{"content":" 环境准备 安装 Rancher：在控制平面服务器上安装 Rancher，可以通过容器方式安装。例如，使用 Docker 运行 Rancher 服务器容器，运行命令如下： docker run -d --restart=unless -stopped -p 80:80 -p 443:443 rancher/rancher:latest 配置 Kubernetes 集群接入 Rancher：对于要管理的每个 Kubernetes 集群，获取集群的 Kube - config 文件等信息，然后在 Rancher 界面中将集群添加进来。 安装 Helm 3：在可以访问 Kubernetes 集群的机器上安装 Helm 3，具体安装步骤根据操作系统不同而不同。例如，在 Linux 系统上，可以使用官方提供的脚本安装： curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get -helm -3.sh chmod 700 get_helm.sh ./get_helm.sh 使用 Helm 3 部署应用并关联 ConfigMap（以一个简单的 Web 应用为例） 创建 Helm Chart： 首先创建一个新的 Helm Chart 目录结构。可以使用helm create my - web - app命令来创建一个名为my - web - app的基本 Chart 模板。 在values.yaml文件中定义应用的配置参数，例如： app: config: port: 8080 db - connection - string: \u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34; 在templates目录下创建configmap.yaml文件来定义 ConfigMap，内容如下： apiVersion: v1 kind: ConfigMap metadata: name: {{.Release.Name}} - config - map data: app - port: \u0026#34;{{.Values.app.config.port}}\u0026#34; db - connection - string: \u0026#34;{{.Values.app.config.db - connection - string}}\u0026#34; 在templates目录下的deployment.yaml文件中，挂载 ConfigMap 到容器中。修改volumes和volumeMounts部分，示例如下： apiVersion: apps/v1 kind: Deployment metadata: name: {{.Release.Name}} - deployment spec: replicas: 1 selector: matchLabels: app: {{.Release.Name}} template: metadata: labels: app: {{.Release.Name}} spec: containers: - name: my - web - app - container image: my - web - app - image:latest ports: - containerPort: {{.Values.app.config.port}} volumeMounts: - name: config - volume mountPath: /app/config volumes: - name: config - volume configMap: name: {{.Release.Name}} - config - map 部署应用到多集群： 使用 Helm 3 将应用部署到 Rancher 管理的多个 Kubernetes 集群。例如，在每个集群对应的上下文中，运行以下命令： helm install my - web - app my - web - app - chart - path -n my - namespace 这样就将应用部署到了多个集群中，并且每个集群中的应用都关联了一个 ConfigMap，其中包含应用的配置信息。 实现 ConfigMap 热更新 更新 ConfigMap 内容： 在 Rancher 界面中，找到对应的 ConfigMap 资源（可以通过命名空间和名称来查找），或者通过 Kubernetes 命令行kubectl edit configmap my - web - app - config - map -n my - namespace来编辑 ConfigMap 的内容。例如，修改app - port的值为8081。 使应用感知 ConfigMap 更新（以支持热重载的应用为例）： 对于支持热重载配置文件的应用，应用内部需要有相应的机制来监听配置文件的变化。例如，一些基于 Spring Boot 的 Java 应用，可以通过配置spring - cloud - config - monitor来实现配置文件的热重载。在应用代码中，需要读取挂载的 ConfigMap 中的配置文件路径下的配置内容，并且在文件变化时重新加载配置。 对于不支持热重载的应用： 可以通过更新应用的 Deployment 来触发容器的重新创建。例如，通过修改 Deployment 的annotations或者labels等元数据信息，使得 Deployment 触发滚动更新。可以使用kubectl patch deployment my - web - app - deployment -n my - namespace -p '{\u0026quot;spec\u0026quot;:{\u0026quot;template\u0026quot;:{\u0026quot;metadata\u0026quot;:{\u0026quot;annotations\u0026quot;:{\u0026quot;date\u0026quot;:\u0026quot;'$(date +%s)'\u0026quot;}}}}}'命令来更新 Deployment 的元数据，从而触发滚动更新，让容器重新加载新的 ConfigMap 配置。 跨集群同步和监控更新过程 在 Rancher 中同步更新： Rancher 提供了集群组和全局资源的功能。可以将多个集群组成一个集群组，然后通过集群组来同步某些资源的更新。对于 ConfigMap，可以尝试将其定义为集群组的共享资源（部分高级版本功能支持），这样在一个集群中更新 ConfigMap 后，Rancher 可以辅助将更新同步到其他集群。 监控更新状态： 在 Rancher 界面中，利用其内置的监控和告警功能，监控应用在各个集群中的更新过程。可以查看应用的 Pod 状态、资源使用情况等指标。同时，设置告警规则，例如当应用的更新失败或者出现大量 Pod 异常时，及时收到通知。也可以通过 Kubernetes 原生的监控工具（如 Prometheus 集成到 Rancher）来深入监控应用的更新过程和配置生效情况。 ","permalink":"https://gopherding.github.io/posts/tech/rancher+helm3+-configmap%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%83%AD%E6%9B%B4%E6%96%B0/","summary":"环境准备 安装 Rancher：在控制平面服务器上安装 Rancher，可以通过容器方式安装。例如，使用 Docker 运行 Rancher 服务器容器，运行命令如下： docker run -d --restart=unless -stopped -p 80:80 -p 443:443 rancher/rancher:latest 配置 Kubernetes 集群接入 Rancher：对于要管理的每个 Kubernetes 集群，获取集群的 Kube - config 文件等信息，然后在 Rancher 界面中将集群添加进来。 安装 Helm 3：在可以","title":"Rancher+Helm3 + ConfigMap集群配置项热更新"},{"content":"k8s Helm3详解 （部署，自定义，仓库）\nHelm 的核心概念 Chart：Helm 的 Chart 是一个软件包，它包含了一组定义 Kubernetes 资源的 YAML 文件。Chart 可以看作是 Kubernetes 应用的模板，它描述了如何部署一个应用，包括所需的 Deployments、Services、ConfigMaps 等资源。\nRepository：Helm 的 Repository 是一个存储 Chart 的仓库。用户可以从这些仓库中搜索、下载和安装 Chart。每个 Repository 都有一个索引文件，列出了可用的 Chart 和它们的版本。\nRelease：当使用 helm install 命令部署一个 Chart 到 Kubernetes 集群时，Helm 会创建一个 Release。Release 是 Chart 在集群中的一个实例，它代表了特定版本的应用部署。用户可以对同一个 Chart 创建多个 Release，每个 Release 都有自己的配置和状态。\nHelm 3 与 Helm 2 的区别 Helm 2：在 Helm 2 中，采用了客户端-服务器模型，其中客户端是 Helm，服务器端是 Tiller。Tiller 作为 Kubernetes 集群中的一个 Deployment 运行，负责管理 Helm 的 Release 和执行 Kubernetes 操作。\nHelm 3：Helm 3 移除了 Tiller，简化了架构。现在，Helm 客户端直接与 Kubernetes API 服务器通信，执行所有的 Kubernetes 操作。这减少了复杂性，并提高了安全性，因为不再需要在集群中运行一个具有广泛权限的 Tiller 服务。\n","permalink":"https://gopherding.github.io/posts/tech/helm3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","summary":"k8s Helm3详解 （部署，自定义，仓库） Helm 的核心概念 Chart：Helm 的 Chart 是一个软件包，它包含了一组定义 Kubernetes 资源的 YAML 文件。Chart 可以看作是 Kubernetes 应用的模板，它描述了如何部署一个应用，包括所需的 Deployments、Services、ConfigMaps 等资源。 Repository","title":"Helm3的使用方法"},{"content":"Cluster Autoscaler 和 Horizontal Pod Autoscaler（HPA）在 Kubernetes 中有着不同的作用，主要区别如下：\n一、作用对象 Cluster Autoscaler： 作用于 Kubernetes 集群中的节点（node）。它会根据整个集群的资源需求情况，自动调整节点的数量。例如，当集群中的 Pod 由于资源不足而无法被调度时，Cluster Autoscaler 会自动添加新的节点到集群中，以提供更多的资源供 Pod 运行。 你在管理一个大规模的分布式应用时，如果发现应用的负载持续增加，导致现有节点无法满足 Pod 的资源需求，Cluster Autoscaler 就会发挥作用，自动增加节点来承载更多的工作负载。 Horizontal Pod Autoscaler： 作用于特定的 Deployment、ReplicaSet 或 StatefulSet 中的 Pod 副本数量。它根据 Pod 的资源使用情况（如 CPU 使用率、内存使用率等）自动调整 Pod 的副本数量。例如，如果一个 Deployment 中的 Pod 的平均 CPU 使用率超过了预设的阈值，HPA 会自动增加 Pod 的副本数量，以分担负载。 当你的应用面临不同的负载变化时，HPA 可以动态地调整 Pod 的数量，确保应用始终有足够的资源来处理请求，同时避免资源浪费。 二、调整方式 Cluster Autoscaler： 通过添加或删除节点来调整集群的资源容量。这通常涉及到云服务提供商的 API 调用，以启动新的虚拟机实例作为节点加入集群，或者删除不再需要的节点以节省成本。例如，在 AWS 上使用 Kubernetes，Cluster Autoscaler 可以调用 AWS EC2 API 来启动或终止 EC2 实例作为 Kubernetes 节点。 调整过程相对较慢，因为涉及到节点的创建和初始化等操作。但是，它可以从根本上解决集群资源不足的问题，适用于大规模的资源需求变化。 Horizontal Pod Autoscaler： 直接调整 Pod 的副本数量。当需要增加资源时，它会创建更多的 Pod 副本；当资源需求减少时，它会减少 Pod 的副本数量。这个过程相对较快，因为 Pod 的创建和销毁通常比节点的创建和删除要快得多。 调整的粒度相对较细，可以根据具体的应用负载变化进行快速响应。但是，它只能在现有节点的资源范围内进行调整，如果整个集群的资源都不足，就需要 Cluster Autoscaler 来添加新的节点。 三、应用场景 Cluster Autoscaler： 适用于大规模的资源需求变化，尤其是当现有节点无法满足应用的资源需求时。例如，在处理突发的高流量事件、大规模数据处理任务等情况下，Cluster Autoscaler 可以快速增加节点数量，以确保应用的可用性和性能。 对于长期运行的大规模分布式系统，Cluster Autoscaler 可以根据负载的变化自动调整节点数量，以实现资源的优化配置和成本控制。 Horizontal Pod Autoscaler： 适用于应用负载变化较为频繁，但资源需求变化相对较小的情况。例如，Web 应用、API 服务等，这些应用的负载可能会随着用户请求的数量而变化，但通常不需要大规模的资源扩展。 可以帮助优化资源使用，确保应用在不同负载下都能高效运行，同时避免资源浪费。 综上所述，Cluster Autoscaler 和 Horizontal Pod Autoscaler 在 Kubernetes 中分别从不同的层面调整资源，以满足应用的需求。它们可以结合使用，共同实现 Kubernetes 集群的自动扩缩容，提高资源利用率和和应用的可靠性。\n","permalink":"https://gopherding.github.io/posts/tech/cluster-autoscaler%E5%92%8Chorizontal-pod-autoscaler%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"Cluster Autoscaler 和 Horizontal Pod Autoscaler（HPA）在 Kubernetes 中有着不同的作用，主要区别如下： 一、作用对象 Cluster Autoscaler： 作用于 Kubernetes 集群中的节点（node）。它会根据整个集群的资源需求情况，自动调整节点的数量。例如，当集群中的 Pod 由于资源不足而无法被调度时，Cluster Autoscaler 会自动添加新的节点到","title":"Cluster Autoscaler和Horizontal Pod Autoscaler的区别"},{"content":"一、Nacos 配置中心 配置管理深度： 提供细粒度的配置管理，可以针对不同的服务、不同的环境进行独立的配置设置。例如，一个微服务架构中的多个服务可以各自拥有独特的配置项，同时在不同的开发、测试、生产环境下又可以有不同的配置值。 支持配置的版本控制，能够方便地回滚到特定版本的配置。这对于在配置变更出现问题时进行快速恢复非常有用。 动态更新机制： 当配置发生变化时，Nacos 能够实时地将更新推送给订阅了该配置的服务实例。这种主动推送的方式可以确保服务快速响应配置变化，无需等待服务的定期拉取或手动触发更新。 支持配置的监听机制，服务可以在运行时持续监听配置的变化，一旦有更新立即应用新配置，保证服务的灵活性和适应性。 服务发现集成： 与服务发现功能紧密集成，不仅可以管理配置，还能帮助服务之间进行高效的发现和通信。例如，服务在启动时可以从 Nacos 中获取所需的配置信息，同时注册自己的服务实例，方便其他服务发现和调用。 对于动态扩缩容的场景，新加入的服务实例可以自动注册到 Nacos，并获取最新的配置，实现无缝的服务扩展。 二、ConfigMap Kubernetes 内集成度： 作为 Kubernetes 的原生资源对象，与 Kubernetes 的其他组件（如 Pod、Deployment 等）紧密集成。可以通过 Kubernetes 的声明式配置文件轻松定义和管理 ConfigMap，并将其挂载到容器中。 与 Kubernetes 的命名空间概念结合，方便在不同的命名空间中管理不同的配置集，实现一定程度的环境隔离。 配置简单性： 主要适用于存储相对简单的键值对形式的配置数据。对于不太复杂的应用配置场景，ConfigMap 提供了一种简洁的方式来传递配置信息给容器。 不具备复杂的配置版本管理和动态推送功能，但可以通过更新 Kubernetes 资源来实现配置的变更，不过这种方式相对较为繁琐。 资源管理角度： ConfigMap 的管理与 Kubernetes 的资源管理体系一致，可以利用 Kubernetes 的工具和命令进行查看、修改和删除等操作。同时，Kubernetes 的控制器可以自动管理依赖于 ConfigMap 的资源，确保配置的一致性。 三、Helm 应用打包与部署： 专注于将整个应用打包为可重复使用的 Chart。一个 Chart 可以包含多个 Kubernetes 资源对象（如 Deployment、Service、ConfigMap 等），以及应用的特定配置和依赖关系。 通过 Helm，可以方便地将复杂的应用部署到不同的 Kubernetes 环境中，实现一键式部署和升级。例如，一个包含多个微服务的应用可以通过一个 Helm Chart 进行统一管理和部署。 版本管理与回滚： 对应用的版本管理非常强大。每次安装或升级应用时，Helm 会记录版本信息，方便在需要时进行回滚到特定版本。这对于在生产环境中进行应用的迭代更新非常重要，可以降低更新风险。 可以轻松比较不同版本的 Chart 之间的差异，帮助用户了解应用的变更历史。 社区与可扩展性： Helm 拥有活跃的社区，有大量的开源 Chart 可供使用。用户可以从 Helm 仓库中获取各种常见应用的 Chart，并根据自己的需求进行定制。 支持自定义插件和扩展，可以根据特定的需求开发自己的 Helm 插件，增强 Helm 的功能。同时，也可以将自己开发的 Chart 分享到社区，供其他用户使用。 总之： 一、功能特点 Nacos 配置中心： 集中管理配置，支持多环境、多项目配置。 强大的动态配置更新和推送机制，实时生效。 集成服务发现功能，适用于复杂微服务架构。 支持多种配置格式，配置管理细粒度高，有版本控制。 ConfigMap： Kubernetes 原生资源，与集群紧密集成。 存储简单键值对配置，适用于不太复杂的场景。 配置变更需更新资源或重启容器，动态性较弱。 遵循 Kubernetes 资源管理体系，方便与其他资源协同管理。 Helm： 应用包管理工具，将多个资源打包为 Chart。 方便应用的一键部署、升级和回滚，版本管理强大。 可从社区获取大量 Chart，也支持自定义扩展。 二、适用场景 Nacos 配置中心： 复杂微服务架构，对配置动态更新和服务发现有高要求。 跨多个环境、项目的统一配置管理。 ConfigMap： Kubernetes 集群内简单应用的配置分发。 对配置管理要求不高的小型应用场景。 Helm： 复杂应用在不同环境的快速部署和管理。 需要频繁更新、升级的应用。 技术选型建议： 如果你的应用是一个简单的 Kubernetes 应用，对配置管理要求不高，且不需要复杂的动态更新和服务发现功能，那么可以优先选择 ConfigMap。它与 Kubernetes 紧密集成，使用方便，对于小型项目或不太复杂的场景足够满足需求。 对于复杂的微服务架构，特别是需要集中管理配置、实现动态配置更新和服务发现的情况，Nacos 配置中心是一个不错的选择。它能够提供更强大的配置管理和服务协调能力，有助于提高微服务系统的灵活性和可维护性。 当你需要快速部署和管理复杂的 Kubernetes 应用，尤其是在不同环境中频繁进行应用的更新和升级时，Helm 是一个很好的工具。它可以将应用打包为可重复使用的 Chart，方便进行版本管理和部署，提高部署效率和可维护性。 ","permalink":"https://gopherding.github.io/posts/tech/k8s%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B/","summary":"一、Nacos 配置中心 配置管理深度： 提供细粒度的配置管理，可以针对不同的服务、不同的环境进行独立的配置设置。例如，一个微服务架构中的多个服务可以各自拥有独特的配置项，同时在不同的开发、测试、生产环境下又可以有不同的配置值。 支持配置的版本控制，能够方便地回滚到特定版本的配置。这对于","title":"K8s的配置中心选型"},{"content":"无头服务（Headless Service）在 Kubernetes 中是一种特殊类型的服务，它没有 Cluster IP，直接通过 DNS 解析到后端的 Pod。以下是使用无头服务的步骤：\n一、创建无头服务的 YAML 文件 以下是一个简单的无头服务的 YAML 配置示例：\napiVersion: v1 kind: Service metadata: name: my-headless-service spec: clusterIP: None selector: app: my-app 在这个配置中：\nclusterIP: None表示这是一个无头服务。 selector指定了这个服务应该将流量路由到具有app: my-app标签的 Pod。 二、应用无头服务 使用kubectl apply -f命令来应用这个 YAML 文件：\nkubectl apply -f headless-service.yaml 三、使用无头服务 直接通过 DNS 访问后端 Pod： Kubernetes 会为无头服务创建一个 DNS 条目，格式为\u0026lt;service-name\u0026gt;.\u0026lt;namespace\u0026gt;.svc.cluster.local。这个 DNS 条目会解析到后端的 Pod IP 地址。 例如，如果你的无头服务名为my-headless-service，在同一命名空间中，可以通过my-headless-service.\u0026lt;namespace\u0026gt;.svc.cluster.local来访问后端的 Pod。 在应用程序中使用： 如果你的应用程序在 Kubernetes 集群内部运行，可以直接使用这个 DNS 条目来访问无头服务后端的 Pod。 例如，在一个 Java 应用程序中，可以使用java.net.InetAddress类来解析这个 DNS 条目，并建立连接到后端的 Pod。 四、无头服务的常见用途 有状态应用： 对于有状态应用，如数据库集群或分布式存储系统，无头服务可以用于确保每个实例都有一个唯一的 DNS 名称，方便应用程序进行发现和连接。 自定义负载均衡： 通过直接访问后端 Pod，应用程序可以实现自己的负载均衡策略，而不是依赖 Kubernetes 的默认负载均衡。 ","permalink":"https://gopherding.github.io/posts/tech/%E6%97%A0%E5%A4%B4%E6%9C%8D%E5%8A%A1headless-service/","summary":"无头服务（Headless Service）在 Kubernetes 中是一种特殊类型的服务，它没有 Cluster IP，直接通过 DNS 解析到后端的 Pod。以下是使用无头服务的步骤： 一、创建无头服务的 YAML 文件 以下是一个简单的无头服务的 YAML 配置示例： apiVersion: v1 kind: Service metadata: name: my-headless-service spec: clusterIP: None selector: app: my-app 在这个配置中： clusterIP: None表示这是一个无头服务。 sel","title":"无头服务(Headless Service)"},{"content":"一、区别 ClusterIP： 访问范围：仅在集群内部可访问。 特点：分配的虚拟 IP 地址稳定，适合集群内部服务之间的通信。不需要暴露服务到外部网络，安全性相对较高。 负载均衡方式：由 Kubernetes 内部机制实现，通常是通过 iptables 规则或 IPVS 规则。 NodePort： 访问范围：可以通过集群中任何节点的 IP 地址和特定的端口从外部访问。 特点：相对简单直接地将服务暴露到外部，但需要管理节点上的端口范围，可能会与其他服务的端口冲突。 负载均衡方式：Kubernetes 将外部请求分发到各个节点，节点再转发到内部服务，最终由内部负载均衡机制将请求路由到后端 Pod。 LoadBalancer： 访问范围：通过云提供商的外部负载均衡器从外部访问，通常具有高可用性和高性能。 特点：在云环境中方便使用，但依赖于特定的云提供商，可能会产生额外的费用。 负载均衡方式：云提供商的负载均衡器将流量分发到各个节点，Kubernetes 内部机制处理节点到服务的路由。 Ingress： 访问范围：通过定义的域名和路径从外部访问，可以根据不同的规则将请求路由到不同的服务。 特点：提供了更灵活的路由和负载均衡功能，可以整合多种服务到一个入口点。需要部署和配置 Ingress 控制器。 负载均衡方式：Ingress 控制器根据配置的规则进行反向代理，将请求转发到相应的服务。 二、技术选型要点 考虑访问需求： 如果服务仅需要在集群内部被访问，ClusterIP 是一个合适的选择。例如，数据库服务通常只需要被集群内的其他应用访问。 如果需要从外部访问服务，并且对高可用性和性能要求不高，可以考虑 NodePort。比如，在开发和测试环境中，可能会使用 NodePort 来临时暴露服务。 如果在云环境中，并且需要高可用性和高性能的外部访问，可以选择 LoadBalancer。对于面向公众的关键业务应用，LoadBalancer 可能是更好的选择。 如果有多个服务需要统一的入口点，并且需要灵活的路由规则，Ingress 是一个很好的选择。例如，一个微服务架构的应用，可以使用 Ingress 来管理不同服务的访问。 考虑安全性： ClusterIP 由于仅在集群内部可访问，相对来说安全性较高。如果服务包含敏感信息，不希望被外部直接访问，可以选择 ClusterIP，并通过其他安全机制（如 VPN）来实现外部的有限访问。 NodePort 和 LoadBalancer 将服务直接暴露到外部网络，需要采取额外的安全措施，如使用身份验证、授权和加密等。 Ingress 可以通过配置 SSL/TLS 证书来实现加密通信，并可以结合其他安全策略来保护服务。 考虑资源和成本： ClusterIP 不需要额外的资源和成本，仅依赖于 Kubernetes 集群的内部网络。 NodePort 需要管理节点上的端口资源，并且可能会与其他服务冲突。在大规模集群中，端口管理可能会变得复杂。 LoadBalancer 通常会产生额外的费用，具体费用取决于云提供商。在选择 LoadBalancer 时，需要考虑成本效益。 Ingress 控制器的资源消耗取决于具体的实现和配置。一些 Ingress 控制器可能需要较多的资源，特别是在处理大量并发请求时。 考虑可维护性和灵活性： ClusterIP 和 NodePort 相对简单，易于理解和维护。但它们的灵活性有限，不太适合复杂的访问场景。 LoadBalancer 由云提供商管理，通常具有高可用性和可维护性。但在跨云或混合云环境中，可能会受到限制。 Ingress 提供了丰富的功能和灵活性，可以根据不同的需求进行定制。但需要部署和配置 Ingress 控制器，增加了一定的复杂性。 ","permalink":"https://gopherding.github.io/posts/tech/k8s%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/","summary":"一、区别 ClusterIP： 访问范围：仅在集群内部可访问。 特点：分配的虚拟 IP 地址稳定，适合集群内部服务之间的通信。不需要暴露服务到外部网络，安全性相对较高。 负载均衡方式：由 Kubernetes 内部机制实现，通常是通过 iptables 规则或 IPVS 规则。 NodePort： 访问范围：可以通过集群中任何节点的 IP 地址和特定的","title":"K8s的几种服务访问的技术选型"},{"content":" 环境搭建 安装 Prometheus 下载安装包：从 Prometheus 官方网站（https://prometheus.io/download/）下载适合你操作系统的二进制文件。例如，在 Linux 系统下： wget https://github.com/prometheus/prometheus/releases/download/v2.34.0/prometheus - 2.34.0.linux - amd64.tar.gz 解压并配置： tar -zxvf prometheus - 2.34.0.linux - amd64.tar.gz cd prometheus - 2.34.0.linux - amd64 编辑prometheus.yml配置文件，这是 Prometheus 的核心配置文件。可以在其中定义要监控的目标，例如监控本地主机的节点信息（Node Exporter）和应用程序暴露的自定义指标。以下是一个简单的示例：\nglobal: scrape_interval: 15s # 抓取间隔 scrape_configs: - job_name: \u0026#39;node\u0026#39; static_configs: - targets: [\u0026#39;localhost:9100\u0026#39;] # 假设Node Exporter在9100端口暴露指标 - job_name: \u0026#39;my_app\u0026#39; static_configs: - targets: [\u0026#39;localhost:8080/metrics\u0026#39;] # 假设应用在8080端口的/metrics路径暴露指标 启动 Prometheus： ./prometheus --config.file=prometheus.yml 安装 Grafana 下载安装包：从 Grafana 官方网站（https://grafana.com/grafana/download）下载适合你操作系统的安装包。例如，对于 Linux 系统下的安装包： wget https://dl.grafana.com/oss/release/grafana - 8.3.0 - 1.x86_64.rpm 安装并启动： sudo yum -y install grafana - 8.3.0 - 1.x86_64.rpm sudo systemctl start grafana - server Prometheus 数据采集与存储 指标采集：Prometheus 按照prometheus.yml配置文件中定义的scrape_interval，定期从目标（如localhost:9100的 Node Exporter 和localhost:8080/metrics的应用自定义指标）抓取指标数据。这些指标数据是基于 Prometheus 的指标格式定义的，例如node_cpu_usage（节点 CPU 使用率）、my_app_request_count（应用请求计数）等。 数据存储：Prometheus 将采集到的指标数据存储在本地的时间序列数据库中。存储的数据结构基于时间戳和指标名称，以及对应的标签（用于区分不同维度的数据）。例如，node_cpu_usage{instance=\u0026quot;localhost:9100\u0026quot;, cpu=\u0026quot;cpu0\u0026quot;}表示在localhost:9100这个实例上，CPU0 的使用率指标。 Grafana 数据可视化 添加数据源： 登录 Grafana Web 界面（默认地址是http://localhost:3000，初始用户名和密码是admin）。 在Configuration - Data Sources中添加 Prometheus 数据源。填写 Prometheus 服务器的地址（如http://localhost:9090），然后点击Save \u0026amp; Test确保连接成功。 创建仪表盘（Dashboard）： 在 Grafana 中，可以通过导入已有的仪表盘模板或者自己创建仪表盘。例如，要创建一个简单的节点 CPU 使用率监控仪表盘，点击+ - Dashboard - Add new panel。 在面板编辑中，选择数据源为之前添加的 Prometheus，在查询编辑器（Query Editor）中输入 PromQL（Prometheus Query Language）查询，如node_cpu_usage来获取节点 CPU 使用率指标。 根据需要设置图表的类型（如折线图、柱状图等）、时间范围、坐标轴标签等可视化参数，然后保存仪表盘。 实现自动监控报警 配置 Prometheus Alertmanager 下载安装 Alertmanager：从 Prometheus 官方网站（https://prometheus.io/download/）下载 Alertmanager 二进制文件。例如，在 Linux 系统下： wget https://github.com/prometheus/alertmanager/releases/download/v0.23.0/alertmanager - 0.23.0.linux - amd64.tar.gz 解压并配置： tar -zxvf alertmanager - 0.23.0.linux - amd64.tar.gz cd alertmanager - 0.23.0.linux - amd64 编辑alertmanager.yml配置文件，这是 Alertmanager 的核心配置文件。以下是一个简单的配置示例，用于发送邮件报警：\nglobal: smtp_smarthost: \u0026#39;smtp.example.com:587\u0026#39; # 邮件服务器地址和端口 smtp_from: \u0026#39;alerts@example.com\u0026#39; # 发件人邮箱 smtp_auth_username: \u0026#39;alerts@example.com\u0026#39; # 用于认证的用户名 smtp_auth_password: \u0026#39;password\u0026#39; # 认证密码 route: receiver: \u0026#39;email - receiver\u0026#39; group_by: [\u0026#39;alertname\u0026#39;] group_wait: 30s group_interval: 5m repeat_interval: 1h receivers: - name: \u0026#39;email - receiver\u0026#39; email_configs: - to: \u0026#39;admin@example.com\u0026#39; # 收件人邮箱 subject: \u0026#39;Prometheus Alert\u0026#39; 启动 Alertmanager： ./alertmanager --config.file=alertmanager.yml 在 Prometheus 中配置报警规则： 编辑 Prometheus 的prometheus.yml配置文件，添加报警规则文件的路径，例如： rule_files: - \u0026#34;alert.rules.yml\u0026#34; 创建alert.rules.yml文件，定义报警规则。例如，当节点 CPU 使用率超过 80% 时触发报警： groups: - name: cpu - usage - alerts rules: - alert: HighCPUUsage expr: node_cpu_usage \u0026gt; 0.8 for: 2m # 持续时间达到2分钟才触发报警 labels: severity: critical annotations: summary: \u0026#34;High CPU Usage Detected\u0026#34; description: \u0026#34;CPU usage on the node has exceeded 80% for more than 2 minutes.\u0026#34; 默认端口：9090\n文档：https://prometheus.ac.cn/docs/prometheus/latest/getting_started/#using-the-expression-browser\n使用说明：https://blog.csdn.net/qq_31725371/article/details/114697770\n","permalink":"https://gopherding.github.io/posts/tech/%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"环境搭建 安装 Prometheus 下载安装包：从 Prometheus 官方网站（https://prometheus.io/download/）下载适合你操作系统的二进制文件。例如，在 Linux 系统下： wget https://github.com/prometheus/prometheus/releases/download/v2.34.0/prometheus - 2.34.0.linux - amd64.tar.gz 解压并配置： tar -zxvf prometheus - 2.34.0.linux - amd64.tar.gz cd prometheus - 2.34.0.linux - amd64 编辑prometheus.yml配置文件，这是 Prometheus 的核心配置文件。可以在其中定","title":"自动监控报警的实现"},{"content":"在 Kubernetes 中使用自定义的应用程序指标（通过 Prometheus 等监控系统暴露的指标）结合 Horizontal Pod Autoscaler（HPA）进行自动扩容，可以按照以下步骤进行操作：\n一、准备工作 安装 Prometheus 和相关组件： 在 Kubernetes 集群中安装 Prometheus 服务器、服务发现组件（如 Prometheus Operator）等，以便收集和存储应用程序的指标数据。 确保 Prometheus 能够正确地发现和监控目标应用程序的指标。 应用程序暴露指标： 在应用程序中集成指标暴露功能，例如使用 Prometheus client libraries 来暴露自定义的应用程序指标。 确保应用程序能够正确地将指标数据暴露给 Prometheus。 二、配置 Prometheus 和 HPA 创建 ServiceMonitor： 如果使用 Prometheus Operator，创建一个 ServiceMonitor 对象来定义 Prometheus 应该监控的目标服务。 ServiceMonitor 通常指定要监控的服务的标签选择器、端口和指标路径等信息。 例如： apiVersion: monitoring.coreos.com/v1 # 声明此资源对象的 API 版本来自 CoreOS 的监控组件 kind: ServiceMonitor # 表明这是一个 ServiceMonitor（服务监控器）资源对象 metadata: name: my-app-monitor # 此服务监控器的名称为 my-app-monitor spec: selector: # 用于选择要监控的服务的标签选择器 matchLabels: app: my-app # 选择具有标签 app: my-app 的服务进行监控 endpoints: # 定义要监控的服务的端点信息 - port: web # 要监控的服务的端口名为 web path: /metrics # 指标数据的路径为 /metrics，即 Prometheus 从这里获取指标数据 创建 HPA： 使用自定义指标创建一个 HPA 对象，指定要监控的指标名称、目标值和扩缩容规则。 例如： apiVersion: autoscaling/v2beta2 # 声明此资源对象的 API 版本为 autoscaling/v2beta2 kind: HorizontalPodAutoscaler # 表明这是一个 HorizontalPodAutoscaler（水平 Pod 自动扩缩器）资源对象 metadata: name: my-app-hpa # 此自动扩缩器的名称为 my-app-hpa spec: scaleTargetRef: # 指定要进行自动扩缩的目标资源 apiVersion: apps/v1 # 目标资源的 API 版本为 apps/v1 kind: Deployment # 目标资源的种类是 Deployment（部署） name: my-app # 目标 Deployment 的名称为 my-app metrics: - type: Pods # 指标类型为 Pods，表示基于 Pod 的指标进行扩缩容 pods: metric: name: my_custom_metric # 要使用的自定义指标名称为 my_custom_metric target: type: AverageValue # 目标值的类型为平均值 averageValue: 100 # 目标平均值为 100，即当自定义指标的平均值达到 100 时触发扩缩容操作 三、验证和调整 验证指标收集： 通过 Prometheus 的 Web UI 或查询接口验证 Prometheus 是否正确地收集了应用程序的自定义指标。 可以使用 PromQL 查询语言来检查指标的可用性和值。 观察自动扩容： 模拟应用程序的负载变化，观察 HPA 是否根据自定义指标自动调整 Pod 的数量。 可以通过增加负载生成工具（如ab、hey等）的并发请求数量来模拟高负载情况，观察 Pod 数量是否自动增加。 调整参数： 根据实际应用的需求和性能测试结果，调整 HPA 的参数，如目标值、最大和最小副本数等。 同时，也可以调整应用程序的指标暴露方式和阈值，以确保自动扩容机制能够有效地响应负载变化。 总之，使用自定义的应用程序指标结合 Prometheus 和 HPA 可以实现更加灵活和精确的自动扩容机制。通过正确地配置 Prometheus 和 HPA，并验证指标的收集和自动扩容的效果，可以提高应用程序的可用性和资源利用率。\n","permalink":"https://gopherding.github.io/posts/tech/hpa%E5%92%8Cprometheus%E8%81%94%E5%8A%A8/","summary":"在 Kubernetes 中使用自定义的应用程序指标（通过 Prometheus 等监控系统暴露的指标）结合 Horizontal Pod Autoscaler（HPA）进行自动扩容，可以按照以下步骤进行操作： 一、准备工作 安装 Prometheus 和相关组件： 在 Kubernetes 集群中安装 Prometheus 服务器、服务发现组件（如 Prometheus Operator）等，以便收集和存储应用程序的指标数据。 确保 Prometheus 能够正确","title":"HPA和Prometheus联动自动扩容"},{"content":"","permalink":"https://gopherding.github.io/posts/tech/%E6%A8%A1%E6%9D%BF---%E5%89%AF%E6%9C%AC/","summary":"","title":"XXXXXXXXXXXXXX"},{"content":"","permalink":"https://gopherding.github.io/posts/tech/%E6%A8%A1%E6%9D%BF/","summary":"","title":"XXXXXXXXXXXXXX"},{"content":"一、蓝绿部署（Blue-Green Deployment） 概念： 准备两套完全相同的生产环境，分别称为蓝色环境和绿色环境。其中一个环境（比如蓝色）处于当前的生产状态，为用户提供服务；另一个环境（绿色）则用于部署新版本的应用。 过程： 首先在绿色环境中部署新版本应用，并进行充分的测试。 当准备好切换时，通过更改负载均衡器或路由规则，将所有流量从蓝色环境切换到绿色环境，此时绿色环境成为生产环境，而蓝色环境可以用于下一次的版本部署或回滚操作。 优点： 可以实现零停机时间发布，用户在切换过程中基本无感知。 方便回滚，如果新版本出现问题，可以快速将流量切换回蓝色环境。 缺点： 需要双倍的硬件资源来维持两套环境。 二、金丝雀发布（Canary Release） 概念： 先将一小部分用户流量导向新版本的应用（通常称为金丝雀版本），同时大部分用户流量仍然指向旧版本应用。通过观察金丝雀版本的性能和稳定性，来决定是否逐步扩大新版本的部署范围。 过程： 选择一小部分用户（可以通过 IP 地址、用户 ID 等方式），将他们的流量导向金丝雀版本。 监控金丝雀版本的关键指标，如响应时间、错误率、吞吐量等。 如果金丝雀版本表现良好，则逐步增加金丝雀版本的流量比例，直到全部用户都使用新版本。如果出现问题，则可以快速回滚到旧版本。 优点： 降低了发布风险，因为只有一小部分用户受到影响。 可以早期发现新版本中的问题，避免大规模故障。 缺点： 需要有良好的流量控制机制和监控系统来支持。 三、滚动发布（Rolling Deployment） 概念： 逐步更新生产环境中的应用实例，而不是一次性全部更新。通常是一个实例一个实例地进行更新，确保在任何时候都有部分旧版本的实例在运行，以保证服务的连续性。 过程： 首先更新一个或几个应用实例，然后对这些实例进行测试和观察。 如果更新后的实例运行正常，则继续更新下一批实例，直到所有实例都更新到新版本。 优点： 可以实现相对平滑的发布过程，对用户的影响较小。 不需要额外的硬件资源。 缺点： 发布过程相对较长，如果新版本存在严重问题，可能需要较长时间才能发现和回滚。 四、A/B 测试发布（A/B Testing Deployment） 概念： 将用户随机分为两组或多组，分别让他们访问不同版本的应用，通过比较不同版本的性能和用户反馈，来决定哪个版本更优。 过程： 确定要测试的变量，比如不同的界面设计、功能特性等。 将用户随机分配到不同的版本组中。 收集和分析用户行为数据、性能指标等，以评估不同版本的效果。 根据测试结果，选择最优版本进行全面发布。 优点： 可以帮助确定最优的版本，提高用户体验和业务效果。 可以同时测试多个变量，寻找最佳组合。 缺点： 需要有完善的用户分组和数据收集分析机制。 测试过程可能会比较复杂和耗时。 ","permalink":"https://gopherding.github.io/posts/tech/%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5/","summary":"一、蓝绿部署（Blue-Green Deployment） 概念： 准备两套完全相同的生产环境，分别称为蓝色环境和绿色环境。其中一个环境（比如蓝色）处于当前的生产状态，为用户提供服务；另一个环境（绿色）则用于部署新版本的应用。 过程： 首先在绿色环境中部署新版本应用，并进行充分的测试。 当准","title":"版本更新发布策略"},{"content":" 创建初始 Deployment 和 Service： 首先，创建一个基本的 Deployment，它包含旧版本的应用容器。同时创建一个对应的 Service，将流量路由到这个 Deployment。 例如： apiVersion: apps/v1 kind: Deployment metadata: name: my-app spec: replicas: 3 selector: matchLabels: app: my-app template: metadata: labels: app: my-app spec: containers: - name: my-app-container image: old-version-image --- apiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 创建新的 Deployment 进行金丝雀发布： 创建一个新的 Deployment，其中包含新版本的应用容器。可以设置较少的副本数，比如 1 个副本，作为金丝雀版本。 例如： apiVersion: apps/v1 kind: Deployment metadata: name: my-app-canary spec: replicas: 1 selector: matchLabels: app: my-app-canary template: metadata: labels: app: my-app-canary spec: containers: - name: my-app-container image: new-version-image 修改 Service 以包含金丝雀 Deployment： 修改 Service 的 selector，使其同时选择旧版本和金丝雀版本的 Pod。这样，一部分流量会被路由到金丝雀版本的 Pod。 例如： apiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 修改为：\napiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app | app: my-app-canary ports: - protocol: TCP port: 80 targetPort: 8080 监控和评估： 通过监控工具观察金丝雀版本的性能、错误率等指标。如果金丝雀版本表现良好，可以逐渐增加金丝雀版本的副本数，同时减少旧版本的副本数，直到完全切换到新版本。 ","permalink":"https://gopherding.github.io/posts/tech/%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","summary":"创建初始 Deployment 和 Service： 首先，创建一个基本的 Deployment，它包含旧版本的应用容器。同时创建一个对应的 Service，将流量路由到这个 Deployment。 例如： apiVersion: apps/v1 kind: Deployment metadata: name: my-app spec: replicas: 3 selector: matchLabels: app: my-app template: metadata: labels: app: my-app spec: containers: - name: my-app-container image: old-version-image --- apiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 创建新的 Deployment 进行金","title":"金丝雀发布的使用方法"},{"content":"一、Pod 定义 apiVersion: v1 kind: Pod metadata: name: my-pod labels: app: my-app spec: containers: - name: my-container image: my-image ports: - containerPort: 8080 apiVersion：指定 Kubernetes API 的版本，对于 Pod 通常是 v1。\nkind：表明资源的类型，这里是 Pod。\nmetadata：包含 Pod 的元数据信息。 name：Pod 的名称，在集群中必须是唯一的。 labels：用于标识 Pod 的标签，可以用于选择器和分组。 spec：定义 Pod 的具体规格。 containers：列出 Pod 中的容器。 name：容器的名称。\nimage：容器使用的镜像名称。\nports：容器暴露的端口列表。 containerPort：容器内部监听的端口号。 二、Deployment 定义 apiVersion: apps/v1 kind: Deployment metadata: name: my-deployment spec: replicas: 3 selector: matchLabels: app: my-app template: metadata: labels: app: my-app spec: containers: - name: my-container image: my-image ports: - containerPort: 8080 apiVersion：对于 Deployment，通常是 apps/v1。\nkind：资源类型为 Deployment。\nmetadata： name：Deployment 的名称。 spec： replicas：指定要创建的 Pod 副本数量。 selector：用于选择要管理的 Pod 的标签选择器。 template：定义 Pod 的模板，与 Pod 的定义类似。 三、Service 定义 apiVersion: v1 kind: Service metadata: name: my-service spec: selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 type: ClusterIP apiVersion：通常是 v1。\nkind：资源类型为 Service。\nmetadata： name：Service 的名称。 spec： selector：选择要关联的 Pod 的标签。\nports ：定义服务的端口。\nprotocol：协议类型，通常是 TCP 或 UDP。 port：服务对外暴露的端口。 targetPort：后端 Pod 上的端口。 type：服务的类型，可以是 ClusterIP、NodePort、LoadBalancer 等。\n","permalink":"https://gopherding.github.io/posts/tech/k8s%E7%9A%84yaml%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%A7%A3%E6%9E%90/","summary":"一、Pod 定义 apiVersion: v1 kind: Pod metadata: name: my-pod labels: app: my-app spec: containers: - name: my-container image: my-image ports: - containerPort: 8080 apiVersion：指定 Kubernetes API 的版本，对于 Pod 通常是 v1。 kind：表明资源的类型，这里是 Pod。 metadata：包含 Pod 的元数据信息。 name：Pod 的名称，在集群中必须是唯一的。 labels：用于标识 Pod 的标签，可以用于选择","title":"K8s的Yaml文件内容解析"},{"content":" 命令 用途 示例 kubectl get 获取 Kubernetes 资源的信息。 kubectl get pods（列出所有 Pod）；kubectl get services（列出所有 Service）。 kubectl describe 提供特定 Kubernetes 资源的详细信息。 kubectl describe pod \u0026lt;pod-name\u0026gt;（描述特定 Pod）；kubectl describe service \u0026lt;service-name\u0026gt;（描述特定 Service）。 kubectl create 创建 Kubernetes 资源。 kubectl create -f deployment.yaml（从 YAML 文件创建 Deployment）；kubectl create service clusterip my-service --tcp=80:8080（创建 ClusterIP 类型 Service）。 kubectl delete 删除 Kubernetes 资源。 kubectl delete pod \u0026lt;pod-name\u0026gt;（删除特定 Pod）；kubectl delete -f deployment.yaml（根据 YAML 文件删除相应资源）。 kubectl logs 查看 Pod 中容器的日志。 kubectl logs \u0026lt;pod-name\u0026gt;。 kubectl exec 在 Pod 中的容器中执行命令。 kubectl exec -it \u0026lt;pod-name\u0026gt; -- /bin/bash（在特定 Pod 的容器中启动交互式 Bash shell）。 kubectl rollout status 查看 Deployment 的滚动更新状态。 kubectl rollout status deployment/\u0026lt;deployment-name\u0026gt;。 kubectl rollout undo 回滚 Deployment 到上一个版本。 kubectl rollout undo deployment/\u0026lt;deployment-name\u0026gt;。 kubectl get namespaces 列出所有的命名空间。 kubectl create namespace \u0026lt;namespace-name\u0026gt; 创建一个新的命名空间。 kubectl -n \u0026lt;namespace-name\u0026gt; \u0026lt;command\u0026gt; 在特定的命名空间中执行命令。 kubectl -n my-namespace get pods（在 “my-namespace” 命名空间中列出 Pod）。 kubectl get nodes 列出所有的 Kubernetes 节点。 kubectl describe node \u0026lt;node-name\u0026gt; 描述特定的节点，包括其状态、资源使用情况等信息。 ","permalink":"https://gopherding.github.io/posts/tech/kuberctl%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/","summary":"命令 用途 示例 kubectl get 获取 Kubernetes 资源的信息。 kubectl get pods（列出所有 Pod）；kubectl get services（列出所有 Service）。 kubectl describe 提供特定 Kubernetes 资源的详细信息。 kubectl describe pod \u0026lt;pod-name\u0026gt;（描述特定 Pod）；kubectl describe service \u0026lt;service-name\u0026gt;（描述特","title":"kuberctl命令速查表"},{"content":"k8s主要由master节点和node节点构成。\nmaster节点负责管理集群，node节点是容器应用真正运行的地方。\nmaster节点包含的组件有：kube-api-server、kube-controller-manager、kube-scheduler、etcd。\nnode节点包含的组件有：kubelet、kube-proxy、container-runtime。\nkube-api-server： 以下简称api-server，api-server是k8s最重要的核心组件之一，它是k8s集群管理的统一访问入口，提供了RESTful API接口, 实现了认证、授权和准入控制等安全功能；api-server还是其他组件之间的数据交互和通信的枢纽，其他组件彼此之间并不会直接通信，其他组件对资源对象的增、删、改、查和监听操作都是交由api-server处理后，api-server再提交给etcd数据库做持久化存储，只有api-server才能直接操作etcd数据库，其他组件都不能直接操作etcd数据库，其他组件都是通过api-server间接的读取，写入数据到etcd。\nkube-controller-manager： 以下简称controller-manager，controller-manager是k8s中各种控制器的的管理者，是k8s集群内部的管理控制中心，也是k8s自动化功能的核心；controller-manager内部包含replication controller、node controller、deployment controller、endpoint controller等各种资源对象的控制器，每种控制器都负责一种特定资源的控制流程，而controller-manager正是这些controller的核心管理者。\nkube-scheduler： 以下简称scheduler，scheduler负责集群资源调度，其作用是将待调度的pod通过一系列复杂的调度算法计算出最合适的node节点，然后将pod绑定到目标节点上。shceduler会根据pod的信息，全部节点信息列表，过滤掉不符合要求的节点，过滤出一批候选节点，然后给候选节点打分，选分最高的就是最佳节点，scheduler就会把目标pod安置到该节点。\nEtcd： etcd是一个分布式的键值对存储数据库，主要是用于保存k8s集群状态数据，比如，pod，service等资源对象的信息；etcd可以是单个也可以有多个，多个就是etcd数据库集群，etcd通常部署奇数个实例，在大规模集群中，etcd有5个或7个节点就足够了；另外说明一点，etcd本质上可以不与master节点部署在一起，只要master节点能通过网络连接etcd数据库即可。\nkubelet： 每个node节点上都有一个kubelet服务进程，kubelet作为连接master和各node之间的桥梁，负责维护pod和容器的生命周期，当监听到master下发到本节点的任务时，比如创建、更新、终止pod等任务，kubelet 即通过控制docker来创建、更新、销毁容器； 每个kubelet进程都会在api-server上注册本节点自身的信息，用于定期向master汇报本节点资源的使用情况。\nkube-proxy： kube-proxy运行在node节点上，在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作，kube-proxy会监听api-server中从而获取service和endpoint的变化情况，创建并维护路由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上。\ncontainer-runtime： 容器运行时环境，即运行容器所需要的一系列程序，目前k8s支持的容器运行时有很多，如docker、rkt或其他，比较受欢迎的是docker，但是新版的k8s已经宣布弃用docker。\n","permalink":"https://gopherding.github.io/posts/tech/k8s%E7%9A%84%E7%BB%84%E4%BB%B6%E6%9E%84%E6%88%90/","summary":"k8s主要由master节点和node节点构成。 master节点负责管理集群，node节点是容器应用真正运行的地方。 master节点包含的组件有：kube-api-server、kube-controller-manager、kube-scheduler、etcd。 node节点包","title":"K8s的组件构成"},{"content":"三阶段提交（3PC - Three - Phase Commit） 定义和工作原理 3PC 是在 2PC 的基础上进行改进的分布式事务协议，主要是为了减少 2PC 中的阻塞问题和单点故障风险。它分为三个阶段： CanCommit 阶段：事务协调者向所有参与者发送一个 CanCommit 请求，询问参与者是否可以提交事务。参与者接收到请求后，根据自身的状态（如资源是否充足、本地事务是否能够执行等）返回 Yes 或 No 响应。这个阶段主要是初步检查参与者是否有能力执行事务，并不涉及事务的实际执行和资源预留。 PreCommit 阶段：如果协调者收到所有参与者的 Yes 响应，就会进入 PreCommit 阶段。协调者向参与者发送 PreCommit 请求，要求参与者执行事务操作，但与 2PC 不同的是，此时参与者并不立即提交事务，而是和 2PC 的准备阶段一样，执行事务操作并记录 Redo 和 Undo 信息，然后向协调者返回 ACK 响应。如果协调者收到任何一个参与者的 No 响应，就会向所有参与者发送 abort 请求，要求参与者回滚事务，整个事务流程结束。 DoCommit 阶段：当协调者收到所有参与者在 PreCommit 阶段返回的 ACK 响应后，就会向参与者发送 DoCommit 请求，要求参与者提交事务。参与者收到请求后正式提交事务，释放资源。如果协调者在规定时间内没有收到所有参与者的 ACK 响应，或者在发送 DoCommit 请求后没有收到参与者的提交成功反馈，协调者会重新发送 DoCommit 请求或者判定事务失败并要求参与者回滚事务。 与 2PC 的区别 在协调者和参与者中都引入了超时机制（2PC只有协调者才有超时机制），并且把2PC的第一个阶段拆分成了两步（询问 \u0026amp; 执行事务操作并记录 Redo 和 Undo 信息）\n解决阻塞问题 2PC：在准备阶段后，如果协调者出现故障，参与者会一直等待协调者的指令，导致事务阻塞。 3PC：引入了 CanCommit 阶段进行初步询问，并且在 PreCommit 阶段参与者在未收到 DoCommit 请求时可以自动回滚事务，减少了等待协调者指令导致的阻塞情况。例如，在 PreCommit 阶段，如果参与者长时间未收到 DoCommit 请求，它可以基于超时机制自行决定回滚事务，避免了长时间的资源占用。 降低单点故障影响 2PC：协调者在事务过程中扮演着至关重要的角色，一旦协调者故障，可能会导致整个事务处理陷入混乱。 3PC：虽然协调者仍然很重要，但由于有更多的阶段和更灵活的回滚机制，即使协调者在某个阶段出现故障，参与者可以基于当前阶段的状态进行一定程度的自我处理，降低了对协调者的依赖。例如，在 CanCommit 阶段，如果协调者故障，参与者可以简单地结束事务流程而不会产生像 2PC 中那样的阻塞。 提高可靠性 2PC：因为同步阻塞和单点故障问题，在出现网络故障或节点故障时，数据不一致的风险相对较高。 3PC：通过三次阶段的通信和更灵活的处理机制，在一定程度上提高了事务处理的可靠性，减少了数据不一致的可能性。例如，在 DoCommit 阶段，如果部分参与者未收到提交请求，3PC 可以通过重新发送请求或者回滚机制来尽量保证事务的一致性。 ","permalink":"https://gopherding.github.io/posts/tech/3-pc%E5%92%8C2-pc%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"三阶段提交（3PC - Three - Phase Commit） 定义和工作原理 3PC 是在 2PC 的基础上进行改进的分布式事务协议，主要是为了减少 2PC 中的阻塞问题和单点故障风险。它分为三个阶段： CanCommit 阶段：事务协调者向所有参与者发送一个 CanCommit 请求，询问参与者是否可以提交事务。参与者接收到请求后，根据自身的状态（如资源是否充足","title":"3-PC和2-PC的区别"},{"content":"详见6.8小节 柔性事务主要分为补偿型和通知型，\n补偿型事务又分：TCC、Saga；\n通知型事务分：MQ事务消息、最大努力通知型。\nTCC其实本质和3 PC是差不多的： T就是Try，两个C分别是Confirm和Cancel。 Try就是尝试，请求链路中每个参与者依次执行Try逻辑，如果都成功，就再执行Confirm逻辑，如果有失败，就执行Cancel逻辑。 柔性事务概述 柔性事务是相对于传统的刚性事务而言的一种事务处理机制。刚性事务遵循 ACID（原子性、一致性、隔离性、持久性）原则，适用于单数据库系统等场景，能严格保证事务的正确性和数据的一致性。而柔性事务主要用于分布式系统环境，在这种环境下，严格遵循 ACID 原则会带来性能下降、可用性降低等问题。柔性事务通过放宽对 ACID 某些特性的要求，同时采用补偿机制等手段来确保分布式系统在高并发、高可用等复杂场景下数据的最终一致性。\n柔性事务的常见模式 补偿事务（Compensating Transaction） 定义：补偿事务是一种事后补偿的机制。当一个分布式事务中的某个操作（或一组操作）失败时，通过执行一个与之相对应的补偿操作来撤销之前已经执行成功的部分操作，从而达到最终的一致性。例如，在一个电商系统中，当订单创建成功后需要调用库存系统扣减库存，如果库存扣减失败，就需要执行一个补偿操作，如将已经创建的订单状态修改为无效，以保证系统数据的一致性。 工作流程：首先，事务开始执行各个子事务（可以是不同服务或数据库中的操作），每个子事务在执行过程中记录必要的业务信息（如操作日志、上下文信息等）。当某个子事务失败时，系统根据之前记录的信息触发补偿事务。补偿事务会按照预定的规则和业务逻辑，对已经成功执行的子事务进行反向操作。 TCC 事务（Try - Confirm - Cancel） 《Life beyond Distributed Transactions:an Apostate’s Opinion》 定义：TCC 是一种更细粒度的柔性事务模式。它将事务分为三个阶段：Try（尝试）、Confirm（确认）和 Cancel（取消）。在 Try 阶段，业务系统进行资源的预留（如冻结资金、锁定库存等），但不进行实际的业务操作。如果 Try 阶段所有操作都成功，就进入 Confirm 阶段，此时对之前预留的资源进行真正的业务处理（如扣除资金、扣减库存等）。如果在 Try 阶段有任何操作失败，就进入 Cancel 阶段，释放之前预留的资源。 工作流程：以一个在线支付场景为例，在 Try 阶段，支付系统会冻结用户账户中的相应金额，同时订单系统会锁定商品库存。如果这些操作都成功，就进入 Confirm 阶段，支付系统扣除冻结的金额，订单系统扣减锁定的库存，完成订单交易。如果在 Try 阶段，例如库存锁定失败，就进入 Cancel 阶段，支付系统解冻之前冻结的金额，取消本次交易。 基于消息的最终一致性（Message - Based Eventually Consistent）（即通知型） 定义：这种模式利用消息中间件来实现分布式事务的最终一致性。在分布式系统中，当一个业务操作完成后，通过发送消息到消息中间件来通知其他相关的业务系统进行后续操作。消息的发送和接收是异步的，接收消息的系统可能会因为网络延迟、系统故障等原因不能立即处理消息，但最终会在系统恢复正常后处理消息，从而达到数据的最终一致性。 工作流程：例如，在一个电商系统中，当用户下单成功后，订单系统会发送一个消息到消息中间件，通知库存系统和物流系统。库存系统收到消息后进行库存扣减，物流系统收到消息后安排发货。如果库存系统或物流系统在收到消息时出现故障，消息中间件会保留消息，直到系统恢复正常后重新发送消息，确保各个业务系统的数据最终达到一致。 柔性事务的应用场景和优势 应用场景 微服务架构：在微服务架构中，不同的微服务可能使用不同的数据库，并且服务之间的调用通过网络进行。柔性事务能够适应这种分布式、异构的环境，保证跨微服务的业务操作最终达到数据一致性。 高并发系统：对于高并发的电商、金融等系统，严格的刚性事务可能会因为锁机制等导致性能瓶颈。柔性事务通过异步操作、补偿机制等方式，可以在保证数据最终一致性的前提下，提高系统的并发处理能力。 优势 提高系统可用性：与刚性事务相比，柔性事务不会因为某个子事务的短暂故障（如网络抖动、某个服务的临时不可用）而导致整个事务失败，通过补偿机制或异步处理可以继续完成事务，从而提高了系统的可用性。 提升性能：避免了刚性事务中大量的同步等待和锁竞争，例如在 TCC 事务的 Try 阶段只是进行资源预留，不像刚性事务那样直接进行资源的占有和操作，减少了对系统资源的占用，提升了系统的性能。 ","permalink":"https://gopherding.github.io/posts/tech/%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1/","summary":"详见6.8小节 柔性事务主要分为补偿型和通知型， 补偿型事务又分：TCC、Saga； 通知型事务分：MQ事务消息、最大努力通知型。 TCC其实本质和3 PC是差不多的： T就是Try，两个C分别是Confirm和Cancel。 Try就是尝试，请求链路中每个参与者依次执行Try逻辑，如果都成功","title":"柔性事务"},{"content":"两阶段提交（Two-Phase Commit，2PC）是一种用于保证分布式系统中多个节点上的事务一致性的协议。（强一致、中心化的原子提交协议）\n一、协议流程 准备阶段（Prepare Phase）： 协调者向所有参与者节点发送一个准备请求，询问它们是否能够提交事务。 参与者接收到准备请求后，执行事务中的所有操作，但不提交事务。此时，参与者会将事务的执行结果记录下来，并锁定资源，防止其他事务对这些资源进行修改。 参与者根据事务的执行情况，向协调者回复一个响应，表明它是否能够提交事务。如果参与者能够提交事务，它会回复 “同意”；否则，它会回复 “不同意”。 提交阶段（Commit Phase）： 如果协调者接收到所有参与者的 “同意” 回复，它会向所有参与者发送一个提交请求，要求它们提交事务。 参与者接收到提交请求后，正式提交事务，并释放锁定的资源。 如果协调者接收到任何一个参与者的 “不同意” 回复，或者在一定时间内没有接收到所有参与者的回复，它会向所有参与者发送一个回滚请求，要求它们回滚事务。 参与者接收到回滚请求后，回滚事务，并释放锁定的资源。 二、特点和作用 保证事务的原子性和一致性：通过两阶段提交协议，分布式系统中的多个节点可以在一个事务中同时进行操作，并保证这些操作要么全部成功提交，要么全部回滚，从而保证了事务的原子性和一致性。 协调者的关键作用：协调者在两阶段提交协议中起着关键的作用，它负责发起事务、收集参与者的回复、决定事务的提交或回滚，并向参与者发送相应的请求。如果协调者出现故障，整个事务可能会处于不确定状态，需要采取一些恢复措施来保证事务的一致性。 参与者的独立性：参与者在两阶段提交协议中相对独立，它们只需要根据协调者的请求进行相应的操作，并向协调者回复自己的状态。参与者之间不需要直接通信，这降低了系统的复杂性。 三、应用场景和局限性 应用场景：两阶段提交协议通常用于分布式数据库系统、分布式事务处理系统等需要保证事务一致性的场景。例如，在银行转账系统中，从一个账户向另一个账户转账可能涉及多个数据库节点的操作，需要使用两阶段提交协议来保证事务的一致性。 局限性：两阶段提交协议也存在一些局限性，例如： 性能问题：两阶段提交协议需要在多个节点之间进行多次通信，这会导致较高的延迟和较低的性能。特别是在网络延迟较大或参与者节点较多的情况下，性能问题可能会更加严重。 单点故障：协调者在两阶段提交协议中起着关键的作用，如果协调者出现故障，整个事务可能会处于不确定状态。为了解决这个问题，需要采用一些高可用的协调者实现，如使用主备协调者、分布式协调者等。 阻塞问题：在两阶段提交协议中，如果参与者在准备阶段回复了 “同意”，但在提交阶段出现故障，协调者可能会一直等待参与者的回复，从而导致整个事务被阻塞。为了解决这个问题，需要采用一些超时机制和重试机制来保证事务的顺利进行。 ","permalink":"https://gopherding.github.io/posts/tech/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/","summary":"两阶段提交（Two-Phase Commit，2PC）是一种用于保证分布式系统中多个节点上的事务一致性的协议。（强一致、中心化的原子提交协议） 一、协议流程 准备阶段（Prepare Phase）： 协调者向所有参与者节点发送一个准备请求，询问它们是否能够提交事务。 参与者接收到准备请求后，","title":"两阶段提交"},{"content":"荷塘月色 这几天心里颇不宁静。今晚在院子里坐着乘凉，忽然想起日日走过的荷塘，在这满月的光里，总该另有一番样子吧。月亮渐渐地升高了，墙外马路上孩子们的欢笑，已经听不见了；妻在屋里拍着闰儿，迷迷糊糊地哼着眠歌。我悄悄地披了大衫，带上门出去。\n沿着荷塘，是一条曲折的小煤屑路。这是一条幽僻的路；白天也少人走，夜晚更加寂寞。荷塘四面，长着许多树，蓊蓊郁郁的。路的一旁，是些杨柳，和一些不知道名字的树。没有月光的晚上，这路上阴森森的，有些怕人。今晚却很好，虽然月光也还是淡淡的。\n路上只我一个人，背着手踱着。这一片天地好像是我的；我也像超出了平常的自己，到了另一个世界里。我爱热闹，也爱冷静；爱群居，也爱独处。像今晚上，一个人在这苍茫的月下，什么都可以想，什么都可以不想，便觉是个自由的人。白天里一定要做的事，一定要说的话，现在都可不理。这是独处的妙处；我且受用这无边的荷香月色好了。\n曲曲折折的荷塘上面，弥望的是田田的叶子。叶子出水很高，像亭亭的舞女的裙。层层的叶子中间，零星地点缀着些白花，有袅娜地开着的，有羞涩地打着朵儿的；正如一粒粒的明珠，又如碧天里的星星，又如刚出浴的美人。微风过处，送来缕缕清香，仿佛远处高楼上渺茫的歌声似的。这时候叶子与花也有一丝的颤动，像闪电般，霎时传过荷塘的那边去了。叶子本是肩并肩密密地挨着，这便宛然有了一道凝碧的波痕。叶子底下是脉脉的流水，遮住了，不能见一些颜色；而叶子却更见风致了。\n月光如流水一般，静静地泻在这一片叶子和花上。薄薄的青雾浮起在荷塘里。叶子和花仿佛在牛乳中洗过一样；又像笼着轻纱的梦。虽然是满月，天上却有一层淡淡的云，所以不能朗照；但我以为这恰是到了好处 —— 酣畅淋漓的月光，反倒有些俗气了。月光是隔了树照过来的，高处丛生的灌木，落下参差的斑驳的黑影，峭楞楞如鬼一般；弯弯的杨柳的稀疏的倩影，却又像是画在荷叶上。塘中的月色并不均匀；但光与影有着和谐的旋律，如梵婀玲上奏着的名曲。\n荷塘的四面，远远近近，高高低低都是树，而杨柳最多。这些树将一片荷塘重重围住；只在小路一旁，漏着几段空隙，像是特为月光留下的。树色一例是阴阴的，乍看像一团烟雾；但细细看去，却又分明。树梢上隐隐约约的是一带远山，只有些大意罢了。树缝里也有几点路灯光，没精打采的，是渴睡人的眼。这时候最热闹的，要数树上的蝉声与水里的蛙声；但热闹是它们的，我什么也没有。\n忽然想起采莲的事情来了。采莲是江南的旧俗，似乎很早就有，而六朝时为盛；从诗歌里可以约略知道。采莲的是少年男女，他们划着小船，唱着艳歌：\n于是妖童媛女，荡舟心许；鹢首徐回，兼传羽杯；棹将移而藻挂，船欲动而萍开。尔其纤腰束素，迁延顾步；夏始春余，叶嫩花初，恐沾裳而浅笑，畏倾舟而敛裾。\n可见当时嬉游的光景了。这真是有趣的事，可惜我们现在早已无福消受了。\n于是又记起《西洲曲》里的句子：\n采莲南塘秋，莲花过人头。低头弄莲子，莲子清如水。\n今晚若有采莲人，定会从荷塘的这边，荡舟到那边，满船盛着采莲的收获，也许是莲子，也许是莲藕。只是不知他们是否也会像我一样，被这荷塘月色所陶醉？\n我且受用这无边的荷香月色好了。\n但热闹是它们的，我什么也没有。\n忽然想起回家，我的妻还等着我呢。我悄悄地披了大衫，带上门出去。\n","permalink":"https://gopherding.github.io/posts/read/%E8%8D%B7%E5%A1%98%E6%9C%88%E8%89%B2/","summary":"荷塘月色 这几天心里颇不宁静。今晚在院子里坐着乘凉，忽然想起日日走过的荷塘，在这满月的光里，总该另有一番样子吧。月亮渐渐地升高了，墙外马路上孩子们的欢笑，已经听不见了；妻在屋里拍着闰儿，迷迷糊糊地哼着眠歌。我悄悄地披了大衫，带上门出去。 沿着荷塘，是一条曲折的小煤屑路。这是一条幽僻的","title":"荷塘月色"},{"content":"服务网格（Service Mesh）是用于处理服务间通信的基础设施层，它在微服务架构中扮演着重要的角色，为微服务之间的通信提供了可靠、高效、安全且易于管理的解决方案。以下是关于服务网格的详细介绍：\n概念和架构 概念：服务网格是一种专用的基础设施层，它在微服务架构中实现了服务间通信的标准化、可靠性和安全性。它将服务间通信的逻辑从微服务代码中分离出来，以独立的组件形式（称为边车代理，Sidecar Proxy）部署在每个微服务的旁边，负责处理服务之间的流量路由、负载均衡、熔断限流、安全认证等通信相关的功能，使得微服务开发者可以专注于业务逻辑的实现，而无需过多关注底层的通信细节。\n架构组成： 边车代理（Sidecar Proxy）：这是服务网格的核心组件，与每个微服务实例紧密绑定，形成一个边车模式。边车代理负责拦截微服务实例的所有入站和出站流量，对流量进行处理和控制，如根据配置的路由规则将请求转发到目标服务实例、对请求进行负载均衡、监控流量指标等。常见的边车代理有 Istio 中的 Envoy、Linkerd 中的 Linkerd-proxy 等。 控制平面（Control Plane）：控制平面负责管理和配置整个服务网格中的边车代理。它提供了一系列的 API 和配置接口，用于定义服务间的路由策略、负载均衡策略、安全策略等，并将这些配置信息下发到各个边车代理中。控制平面还负责收集边车代理上报的监控数据、流量指标等信息，以便进行集中的管理和分析。例如，Istio 的控制平面包含了 Pilot（负责服务发现和流量管理）、Citadel（负责安全认证和密钥管理）、Galley（负责配置验证和分发）等组件。 主要功能 流量管理： 路由规则配置：服务网格允许管理员通过控制平面定义灵活的路由规则，根据请求的不同特征（如请求路径、请求头、源 IP 等）将流量路由到不同版本的服务实例上。这使得在进行服务升级、A/B 测试、灰度发布等操作时更加方便和可控。例如，可以将 10% 的流量路由到新开发的服务版本上进行测试，而将其余 90% 的流量保持在旧版本上，根据测试结果逐步调整流量分配比例。 负载均衡：边车代理可以对多个服务实例进行负载均衡，根据不同的负载均衡算法（如轮询、随机、加权轮询等）将请求均匀地分配到各个实例上，确保每个实例的负载相对均衡，提高系统的整体性能和可靠性。同时，服务网格还可以根据实例的实时状态（如 CPU 利用率、内存使用情况等）动态调整负载均衡策略，将请求优先分配到负载较轻的实例上。 熔断限流：当某个服务实例出现故障或响应延迟过高时，服务网格可以自动触发熔断机制，暂时停止将请求路由到该故障实例，避免故障扩散影响整个系统。同时，通过限流策略可以限制对某个服务的并发请求数量，防止因大量请求导致服务过载。例如，当一个服务每秒能够处理的最大请求数量为 100 时，可以设置限流规则，当并发请求超过 100 时，直接拒绝多余的请求，保护服务的稳定性。 安全通信： 身份认证和授权：服务网格可以为微服务之间的通信提供身份认证机制，确保只有经过授权的服务才能相互通信。常见的认证方式包括基于 TLS 证书的双向认证、基于令牌（如 JWT）的认证等。在认证通过后，还可以根据预定义的授权策略（如基于角色的访问控制，RBAC）限制服务对其他服务资源的访问权限，增强系统的安全性。 加密通信：所有微服务之间的通信流量都可以通过服务网格进行加密，防止数据在传输过程中被窃取或篡改。边车代理可以自动处理 TLS 加密和解密的过程，对开发者透明，无需在微服务代码中显式实现加密逻辑。这在处理敏感数据（如用户信息、财务数据等）的传输时尤为重要。 监控和可观测性： 流量指标收集：服务网格能够收集详细的流量指标，如请求数量、响应时间、错误率等，不仅可以针对整个服务进行统计，还可以细分到每个服务实例、每个接口甚至每个请求路径。这些指标数据对于了解系统的运行状态、发现性能瓶颈和故障排查非常有帮助。 分布式链路追踪：通过与分布式链路追踪系统集成，服务网格可以跟踪每个请求在微服务之间的传播路径，记录请求经过的各个服务实例、处理时间等信息，形成完整的调用链路。这使得开发者可以清晰地了解一个请求从发起端到最终响应的整个过程，便于快速定位问题所在，尤其是在复杂的微服务架构中，当出现性能问题或故障时，分布式链路追踪能够大大缩短排查问题的时间。 日志管理：服务网格可以统一管理微服务的日志输出，将分散在各个服务实例中的日志信息进行集中收集和存储。同时，还可以根据请求的上下文信息（如请求 ID）将相关的日志关联起来，方便进行综合分析。例如，当一个请求在多个服务中流转时，通过服务网格可以将这些服务产生的与该请求相关的日志整合在一起，更好地理解请求的处理过程和可能出现的问题。 优势 解耦微服务通信逻辑：将服务间通信的复杂逻辑从微服务代码中分离出来，使得微服务可以更加专注于业务逻辑的实现，降低了微服务之间的耦合度。当需要修改通信相关的功能（如路由策略、安全策略等）时，无需修改微服务代码，只需要在控制平面进行配置更新即可，提高了系统的可维护性和灵活性。 增强系统的可靠性和弹性：通过熔断限流、负载均衡等功能，服务网格可以有效地应对服务故障、网络波动和流量高峰等情况，提高系统的整体可靠性和弹性。即使某个服务实例出现问题，也不会导致整个系统崩溃，能够自动进行故障隔离和流量转移，确保系统的持续稳定运行。 统一的安全管理：提供了统一的安全机制，包括身份认证、授权和加密通信等，使得在微服务架构中实现全面的安全防护变得更加容易。可以集中管理安全策略，确保所有微服务之间的通信都符合安全要求，降低了安全漏洞的风险，保护了系统和用户数据的安全。 强大的监控和可观测性：丰富的监控和可观测性功能有助于深入了解系统的运行状况，及时发现性能问题和潜在故障。开发者可以根据收集到的流量指标、链路追踪信息和日志数据进行性能优化、故障排查和容量规划，提高系统的整体质量和可管理性。 挑战和限制 性能开销：由于引入了边车代理，服务网格会在一定程度上增加系统的性能开销。边车代理需要处理所有的流量拦截、转发和其他相关操作，这可能会导致额外的延迟和资源消耗。在对性能要求极高的场景下（如高频交易系统、实时通信系统等），需要仔细评估服务网格带来的性能影响，并进行优化。 复杂性增加：服务网格本身的架构和功能相对复杂，引入了新的概念、组件和配置方式。这需要团队具备一定的技术能力和学习成本来理解、部署和管理服务网格。同时，在多团队协作开发微服务的环境中，需要统一的管理和协调机制，确保各个团队正确使用和配置服务网格，避免因配置错误或不一致导致的问题。 资源占用：除了性能开销外，服务网格的边车代理和控制平面组件还会占用一定的系统资源（如 CPU、内存、网络带宽等）。在大规模部署微服务的情况下，需要合理规划资源分配，确保服务网格组件不会过度占用资源，影响其他业务应用的正常运行。 与现有系统的集成难度：如果企业已经有一套成熟的微服务架构和相关的技术栈，将服务网格集成到现有系统中可能会面临一些挑战。可能需要对现有系统进行一定的改造和适配，以确保服务网格能够与现有组件（如注册中心、配置中心、负载均衡器等）协同工作。此外，在与一些不兼容的技术或框架集成时，可能需要额外的开发工作来解决兼容性问题。 应用场景 微服务架构的演进和扩展：在微服务架构不断发展和规模不断扩大的过程中，服务网格可以帮助企业更好地管理日益复杂的服务间通信。随着微服务数量的增加、服务之间的依赖关系变得更加复杂，服务网格提供的流量管理、安全保障和监控能力能够确保系统的稳定性和可扩展性，使得企业可以更加灵活地演进和扩展其微服务架构。 多云和混合云环境部署：当企业的微服务部署在多云或混合云环境中时，服务网格可以提供统一的通信管理和安全策略。它可以跨越不同的云平台和数据中心，确保微服务之间的通信顺畅和安全，屏蔽底层基础设施的差异，使得企业在多云环境下的应用部署和管理更加便捷。 对服务通信质量和安全性要求较高的行业：如金融、医疗、电商等行业，对服务间通信的可靠性、安全性和性能要求非常严格。服务网格可以满足这些行业的需求，通过提供强大的流量管理、加密通信和身份认证等功能，保障关键业务系统的稳定运行，保护用户敏感信息的安全，提高客户满意度和企业信誉。 ","permalink":"https://gopherding.github.io/posts/tech/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/","summary":"服务网格（Service Mesh）是用于处理服务间通信的基础设施层，它在微服务架构中扮演着重要的角色，为微服务之间的通信提供了可靠、高效、安全且易于管理的解决方案。以下是关于服务网格的详细介绍： 概念和架构 概念：服务网格是一种专用的基础设施层，它在微服务架构中实现了服务间通信的标准","title":"服务网格"},{"content":"一、UUID（通用唯一识别码） 原理 UUID 是一种由数字和字母组成的 128 位标识符。它通过一定的算法生成，通常基于时间戳、MAC 地址（网卡物理地址）等信息。最常用的 UUID 版本是基于随机数生成的版本 4，其生成的 ID 具有全球唯一性。 优点 唯一性高：在全球范围内几乎不可能出现重复的 ID，适合用于分布式系统中不同节点产生的标识。 简单易用：生成算法相对简单，大多数编程语言都有现成的库来生成 UUID。 缺点 不具备顺序性：生成的 ID 是随机的，没有时间顺序或者其他有意义的顺序。这在一些需要根据 ID 排序的场景下，如数据库索引优化，会带来不便。 占用空间较大：128 位的长度在存储和传输时相对占用较多的空间，可能会增加系统的存储成本和网络开销。 二、数据库自增 ID 原理 利用数据库（如 MySQL）的自增主键特性。在数据库中创建一个包含自增主键的表，每次需要生成 ID 时，插入一条记录，数据库会自动为其分配一个唯一的自增 ID。这个 ID 可以作为分布式 ID 使用，多个应用节点可以共享这个数据库来获取 ID。 优点 简单高效：对于小型分布式系统或者对 ID 顺序性有严格要求的场景，数据库自增 ID 是一种简单直接的解决方案。生成的 ID 是顺序递增的，有利于数据库索引和查询性能。 缺点 单点瓶颈：所有 ID 生成请求都依赖于数据库，当系统并发量高时，数据库可能会成为性能瓶颈。因为数据库的写入操作需要加锁来保证自增 ID 的唯一性，大量并发请求可能会导致锁竞争，影响性能。 扩展性差：在分布式环境下，随着系统规模的扩大，单个数据库可能无法满足 ID 生成的需求，需要考虑数据库的高可用和横向扩展问题。 三、雪花算法（Snowflake） 原理 雪花算法是一种分布式 ID 生成算法，它生成的 ID 是一个 64 位的长整型数字。其结构主要包括以下几个部分： 符号位（1 位）：最高位是符号位，通常为 0，表示正数。 时间戳（41 位）：记录了从一个固定的起始时间（如 2016 年 1 月 1 日）到 ID 生成时刻的毫秒数。这部分保证了 ID 的时间顺序性。 工作机器 ID（10 位）：用于区分不同的工作机器，最多可以支持 1024 台机器。 序列号（12 位）：在同一毫秒内，同一机器可以生成的不同 ID，最多可以生成 4096 个不同的 ID。 优点 高并发支持：可以在分布式系统中高并发地生成唯一 ID。在同一毫秒内，不同机器和同一机器都可以生成多个不同的 ID，满足高并发场景的需求。 有序性好：生成的 ID 按照时间顺序递增，这对于数据库索引、日志排序等场景非常有利，可以提高系统的查询和处理效率。 缺点 依赖时间戳：如果系统的时钟出现回拨（如服务器时间被手动调整或者时钟同步出现问题），可能会导致生成的 ID 出现重复或者不符合预期的顺序。需要采取一定的措施来应对时钟回拨问题，如使用备用时间源或者拒绝生成 ID 直到时钟恢复正常。 机器 ID 分配复杂：在大规模分布式系统中，需要合理地分配工作机器 ID，否则可能会出现机器 ID 冲突或者浪费的情况。 四、Redis 自增 ID 原理 利用 Redis 的原子性自增命令（如INCR）来生成 ID。在 Redis 中设置一个键（Key），每次需要生成 ID 时，通过INCR命令对这个键的值进行自增操作。多个应用节点可以共享这个 Redis 实例来获取 ID。 优点 性能高：Redis 是基于内存的高性能数据库，INCR命令是原子操作，能够在高并发环境下快速生成 ID，避免了数据库自增 ID 的锁竞争问题。 简单易用：和数据库自增 ID 类似，实现相对简单，只需要调用 Redis 的自增命令即可。 缺点 单点故障风险：如果 Redis 实例出现故障，可能会导致 ID 生成服务中断。虽然可以通过 Redis 的主从复制和哨兵模式来提高可用性，但仍然存在一定的风险。 数据持久化问题：如果 Redis 没有正确地进行持久化设置，在重启或者故障恢复后，可能会出现 ID 重复或者丢失的情况。 看个大佬\n","permalink":"https://gopherding.github.io/posts/tech/%E5%88%86%E5%B8%83%E5%BC%8Fid%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%86/","summary":"一、UUID（通用唯一识别码） 原理 UUID 是一种由数字和字母组成的 128 位标识符。它通过一定的算法生成，通常基于时间戳、MAC 地址（网卡物理地址）等信息。最常用的 UUID 版本是基于随机数生成的版本 4，其生成的 ID 具有全球唯一性。 优点 唯一性高：在全球范围内几乎不可能出现重复的 ID，适合用于分布式系统","title":"分布式ID业务需求的区分"},{"content":"一、简介 Raft 是一种用于管理复制日志的分布式一致性算法。它的设计目的是在分布式系统中，让一组机器（通常称为节点）能够在面对诸如网络分区、节点故障等各种问题时，就一系列操作达成一致，从而保证数据的一致性。Raft 通过选举一个领导者（Leader）来协调复制日志的工作，并且以简单易懂的原则确保系统的可靠性和容错性。\n二、核心角色 领导者（Leader） 主要职责是接收客户端请求，将请求作为日志条目（Log Entry）添加到自己的日志中，然后并行地将这些日志条目发送给其他节点（追随者）进行复制。 领导者还会发送心跳（Heartbeat）消息给追随者，以维持自己的领导地位。心跳消息可以看作是一种特殊的、没有日志条目的消息，用于告知追随者领导者仍然存活。 追随者（Follower） 接收并保存领导者发送的日志条目。当收到日志条目后，会按照顺序将其追加到自己的日志中。 响应领导者的心跳消息。如果在一定时间内没有收到心跳消息，追随者会认为领导者可能出现故障，从而触发新的领导者选举。 候选人（Candidate） 当追随者在一段时间内没有收到领导者的心跳消息时，它会转变为候选人状态。候选人会发起选举，请求其他节点为自己投票，以争取成为新的领导者。 在选举过程中，候选人会增加自己的任期号（Term），并且向其他节点发送包含自己任期号的请求投票（Request Vote）消息。 三、选举过程 触发选举 当追随者在选举超时（Election Timeout）时间内没有收到领导者的心跳消息时，会触发选举。选举超时是一个随机的时间间隔，这样设计是为了避免多个追随者同时触发选举，造成冲突。 请求投票阶段 成为候选人后，节点会向其他节点发送请求投票消息。消息中包含候选人的任期号和最后一条日志条目的索引（Index）及任期号。 其他节点在收到请求投票消息后，会根据一定的规则来决定是否投票给候选人。规则主要包括：候选人的任期号必须不小于自己当前的任期号；如果自己已经投票给其他候选人，就不会再投票；如果候选人的最后一条日志条目的任期号和索引不小于自己的，就会投票给候选人。 选举获胜 当候选人获得多数（超过半数）节点的投票时，就会成为新的领导者。然后，新领导者会开始向追随者发送心跳消息，以确立自己的领导地位，同时开始接收客户端请求并复制日志。 四、日志复制 日志条目组成 日志条目由索引（Index）、任期号（Term）和命令（Command）组成。索引用于标识日志条目的位置，任期号用于标记该条目所属的领导者任期，命令则是客户端请求对应的操作，如写入一个数据值。 复制流程 领导者接收到客户端请求后，会将日志条目添加到自己的日志中，然后将该条目发送给所有追随者。 追随者收到日志条目后，会检查其合法性。如果日志条目与自己的日志匹配（例如，索引和任期号符合要求），就会将其追加到自己的日志中，并向领导者返回成功确认。如果不匹配，就会拒绝接收。 只有当多数追随者成功复制了该日志条目后，领导者才会将这个日志条目应用到本地状态机（即真正执行命令），并向客户端返回成功响应。这一步确保了在大多数节点都同意的情况下才执行操作，保证了数据的一致性。 五、安全性保证 选举限制 Raft 通过限制选举来保证安全性。在选举过程中，只有拥有最新日志的节点才能成为领导者。这是因为新的领导者必须能够将自己的日志复制到其他节点，而拥有最新日志的节点更有可能保证数据的完整性和一致性。 日志一致性原则 如果两个节点的日志中有相同索引和任期号的条目，那么这些条目之前的所有日志条目都是相同的。这一原则通过领导者在复制日志时的严格检查和追随者的配合来保证。当领导者发现追随者的日志与自己不一致时，会尝试通过发送前序日志条目来使追随者的日志与自己同步。 状态机安全 一旦一个日志条目被应用到状态机，它在所有节点上的相同索引位置的日志条目最终都会被应用。这是通过日志复制的多数原则和严格的一致性检查来实现的，确保了所有节点在相同的操作序列下更新状态机，从而保证了数据的一致性。 六、应用场景 分布式存储系统 如分布式文件系统、分布式数据库等，Raft 可以用于保证数据在多个存储节点之间的一致性。例如，在一个分布式数据库中，当客户端执行写入操作时，通过 Raft 算法确保所有副本节点都按照相同的顺序执行相同的写入命令，避免数据不一致的情况。 分布式配置管理系统 用于管理分布式系统中的配置文件。当配置文件发生更新时，Raft 算法可以确保所有节点都能正确地更新配置，避免因配置不一致导致的系统故障。 集群管理系统 在集群中，用于协调各个节点的状态和任务分配。例如，在一个容器编排系统中，通过 Raft 来保证节点对集群状态的共识，如节点的加入、退出以及任务的调度等操作的一致性。 ","permalink":"https://gopherding.github.io/posts/tech/raft/","summary":"一、简介 Raft 是一种用于管理复制日志的分布式一致性算法。它的设计目的是在分布式系统中，让一组机器（通常称为节点）能够在面对诸如网络分区、节点故障等各种问题时，就一系列操作达成一致，从而保证数据的一致性。Raft 通过选举一个领导者（Leader）来协调复制日志的工作，并且以简单易懂的原","title":"Raft"},{"content":"ZAB（Zookeeper Atomic Broadcast）协议概述 ZAB 协议是为分布式协调服务 ZooKeeper 专门设计的一种原子广播协议，用于保证分布式系统中数据的一致性和主从节点数据的同步。ZooKeeper 在分布式系统中扮演着重要角色，如配置管理、命名服务、分布式锁等，而 ZAB 协议是 ZooKeeper 实现这些功能的核心保障。\nZAB 协议的主要阶段和工作机制 消息广播阶段（Broadcast Phase） 工作原理：在 ZooKeeper 集群中，当客户端发送一个写请求（如创建节点、更新节点数据等）到主节点（Leader）时，主节点会将这个写请求转化为一个事务 Proposal（提议），并为这个提议分配一个全局唯一的递增的事务 ID（zxid）。然后，主节点通过一个 FIFO（先进先出）的队列将提议广播给所有的从节点（Follower）。从节点接收到提议后，会将其写入本地的磁盘事务日志中，然后向主节点发送一个 ACK（确认）消息。当主节点收到超过半数（Quorum）的从节点的 ACK 消息后，就会向所有从节点发送一个提交（Commit）消息，通知它们可以将这个事务应用到内存数据库中，从而完成整个消息广播过程。 示例：假设一个 ZooKeeper 集群有一个主节点和三个从节点，客户端发送一个写请求 “创建节点 /node1”。主节点将这个请求转换为一个带有 zxid 的提议，如 zxid = 100，然后广播给三个从节点。从节点收到提议后记录到事务日志，再发送 ACK 给主节点。当主节点收到至少两个从节点的 ACK 后，发送 Commit 消息，此时所有节点将这个事务应用到内存数据库，完成节点 /node1 的创建。 崩溃恢复阶段（Recovery Phase） 工作原理：当主节点出现故障（如宕机）时，ZAB 协议会进入崩溃恢复阶段。在这个阶段，ZooKeeper 集群会选举出一个新的主节点。选举的依据主要是节点的 zxid 和数据完整程度。拥有最大 zxid 的节点通常有更大的优势成为新的主节点，因为它的数据是最新的。新主节点选举出来后，它需要和其他从节点进行数据同步。新主节点会检查从节点的 zxid，对于从节点中已经提交（Commit）但新主节点还没有的事务，新主节点会将这些事务重新广播给其他从节点，以保证所有节点的数据一致性。对于从节点中未提交的事务（处于 Proposal 阶段），新主节点会根据事务的 zxid 决定是丢弃还是重新广播这些事务。 示例：如果主节点在广播一个事务（zxid = 200）但还没发送 Commit 消息时崩溃，集群开始选举新主节点。假设一个从节点已经收到并记录了这个事务，另一个从节点还没收到。新主节点选举出来后，会根据自己的事务日志和从节点的情况，决定是否重新广播这个事务，确保所有节点的数据最终一致。 ZAB 协议与其他分布式一致性协议的比较 与 Paxos 协议比较 相似点：ZAB 协议和 Paxos 协议都用于解决分布式系统中的一致性问题。它们都通过多轮消息传递和投票机制来达成共识。例如，在节点选举和事务提交过程中，都需要多数节点的同意。 不同点：ZAB 协议相对 Paxos 协议在设计上更偏向于支持 ZooKeeper 的功能特点。ZAB 协议是一个主从模式的协议，有明确的主节点来主导事务的广播，而 Paxos 协议没有这样明确的主从之分，其角色在选举过程中是动态变化的。另外，ZAB 协议在消息广播阶段的流程相对 Paxos 协议更加简洁明了，更适合 ZooKeeper 这种对写操作有一定顺序要求的场景。 与 Raft 协议比较 相似点：Raft 和 ZAB 都有领导者（Leader）的概念，并且在领导者选举和数据复制方面有相似的机制。例如，两者都需要多数节点的支持来选举领导者，并且领导者在数据复制过程中起到关键作用。 不同点：Raft 协议在选举过程中有明确的任期（Term）概念，通过任期来保证选举的顺序和合法性。ZAB 协议则通过 zxid 来保证事务的顺序和节点的更新程度。在数据复制方面，ZAB 协议的消息广播和提交过程与 Raft 协议的日志复制和提交过程在细节上有所不同，ZAB 协议的重点在于保证 ZooKeeper 事务的原子广播和顺序性。 ","permalink":"https://gopherding.github.io/posts/tech/zab/","summary":"ZAB（Zookeeper Atomic Broadcast）协议概述 ZAB 协议是为分布式协调服务 ZooKeeper 专门设计的一种原子广播协议，用于保证分布式系统中数据的一致性和主从节点数据的同步。ZooKeeper 在分布式系统中扮演着重要角色，如配置管理、命名服务、分布式锁等，而 ZAB 协议是 ZooKeeper 实现这些功能的核心保障","title":"ZAB"},{"content":" Gossip 协议概述 Gossip 协议是一种去中心化的、基于消息传播的分布式协议。它模拟了人类社会中流言蜚语（gossip）的传播方式，通过节点之间不断地随机交换信息来达到在分布式系统中传播信息、更新状态和达成共识的目的。这种协议常用于分布式数据库、分布式存储系统和集群管理等场景，以实现数据的一致性、故障检测和成员管理等功能。\n工作原理 信息传播机制 节点交互方式：在一个分布式系统中，每个节点会定期（按照一定的时间间隔）或者在某些事件触发（如自身状态发生变化）时，随机选择系统中的其他节点进行通信。这些节点之间的通信是异步的，它们会互相交换自己所知道的信息。例如，在一个分布式存储系统中，节点 A 可能会随机选择节点 B，并将自己存储的数据版本号、节点的健康状态等信息告诉节点 B。 信息传播内容：传播的信息可以包括系统状态信息（如节点的存活状态、资源利用情况）、数据更新信息（如数据库的写操作记录）等。每个节点都维护一个自己的信息表，记录从其他节点获取到的信息。例如，节点可能会记录集群中有多少个活跃节点、哪些节点存储了特定的数据副本等。 收敛性和最终一致性 收敛过程：随着节点之间不断地进行信息交换，系统中的信息会逐渐在所有节点中扩散。假设最初只有少数节点知道某个新的数据更新，通过 Gossip 协议的反复传播，越来越多的节点会了解到这个更新。例如，在一个分布式缓存系统中，当一个缓存节点更新了某个缓存项的值后，通过 Gossip 协议，其他缓存节点最终也会更新这个缓存项的值。 最终一致性实现：虽然信息传播是随机的，但是从宏观上看，系统会逐渐趋向于一种一致的状态。在足够长的时间和足够多的信息交换次数后，所有节点对于系统的某些关键信息（如数据的最新版本、成员列表等）会达成一致，这就是所谓的最终一致性。不过，这种一致性并不是即时的，可能会存在一定的延迟。 Gossip 协议的应用场景 分布式数据库中的数据同步 在分布式数据库系统（如 Cassandra）中，Gossip 协议用于在节点之间传播数据的更新信息和节点的状态信息。每个节点通过与其他节点的随机通信，了解到数据库的最新写操作记录，从而更新自己的数据副本。例如，当一个节点接收到一个新的插入或更新操作后，它会通过 Gossip 协议将这个信息传播给其他节点，使得整个数据库集群的数据保持最终一致性。 集群成员管理和故障检测 对于集群管理系统（如 Consul），Gossip 协议可以用于维护集群的成员列表和检测节点故障。每个节点定期向其他节点发送自己的存活信息，同时接收其他节点的信息。如果一个节点在一段时间内没有收到某个节点的存活信息，就可以推断该节点可能出现故障。而且，新加入的节点也可以通过 Gossip 协议快速了解集群的现有成员，融入到集群中。例如，当一个新节点加入一个分布式文件存储集群时，它可以通过 Gossip 协议与其他节点交换信息，获取集群的存储架构、数据分布等信息，从而更好地参与集群的工作。 优点和缺点 优点 去中心化和高容错性：由于没有中心控制节点，系统不会因为某个中心节点的故障而瘫痪。即使部分节点出现故障或者网络分区，信息仍然可以通过其他正常节点之间的通信在系统中传播。例如，在一个大规模的分布式传感器网络中，即使部分传感器节点损坏，数据仍然可以在其他节点之间传播和汇总。 简单易实现：Gossip 协议的实现相对简单，不需要复杂的选举机制或者集中式的协调器。节点之间的通信规则比较直观，主要是随机选择和信息交换，降低了系统的实现难度和维护成本。 缺点 消息冗余和网络开销：由于信息传播是随机的，可能会导致相同的信息在节点之间多次传播，产生消息冗余。这会增加网络带宽的占用和系统的资源消耗。例如，在一个网络带宽有限的分布式系统中，过多的 Gossip 消息可能会影响系统的正常通信。 收敛速度慢和一致性延迟：达到最终一致性的时间可能较长，尤其是在大型分布式系统或者网络不稳定的情况下。因为信息传播是基于随机的节点选择，不能保证信息能够快速地在所有节点中传播，可能会导致系统在一段时间内处于不一致的状态。 ","permalink":"https://gopherding.github.io/posts/tech/gossip/","summary":"Gossip 协议概述 Gossip 协议是一种去中心化的、基于消息传播的分布式协议。它模拟了人类社会中流言蜚语（gossip）的传播方式，通过节点之间不断地随机交换信息来达到在分布式系统中传播信息、更新状态和达成共识的目的。这种协议常用于分布式数据库、分布式存储系统和集群管理等场景，以实现数据的一致性、","title":"Gossip"},{"content":"文章一号\n文章二号\n","permalink":"https://gopherding.github.io/posts/tech/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B/","summary":"文章一号 文章二号","title":"注册中心选型"},{"content":"一、数据模型 RDS： 是一种关系型数据库服务，支持常见的关系型数据库引擎如 MySQL、PostgreSQL、Oracle、SQL Server 等。 使用传统的表格结构来存储数据，通过 SQL 语言进行数据查询和操作。 遵循关系型数据库的 ACID（原子性、一致性、隔离性、持久性）特性，适用于对数据一致性要求较高的应用场景。 DynamoDB： 是一种完全托管的 NoSQL 数据库服务，支持键值对和文档数据模型。 可以存储和检索任意类型的数据，无需预先定义模式，具有很高的灵活性。 提供最终一致性和强一致性两种一致性级别，适用于对可扩展性和性能要求较高的应用场景。 二、可扩展性 RDS： 可以通过垂直扩展（增加实例的资源配置）和水平扩展（增加只读副本或使用数据库集群）来提高性能和容量。 水平扩展相对复杂，需要进行一些额外的配置和管理。 DynamoDB： 具有高度可扩展性，可以自动处理大规模的数据和流量。 可以根据实际需求动态调整存储容量和吞吐量，无需进行复杂的扩展操作。 适用于处理高并发、大规模数据的应用场景。 三、性能 RDS： 性能取决于所选择的数据库引擎、实例类型和配置。 对于复杂的查询和事务处理，关系型数据库通常具有较好的性能表现。 但在处理大规模数据和高并发访问时，可能需要进行优化和扩展。 DynamoDB： 设计用于提供低延迟的读写操作，具有很高的性能和吞吐量。 可以快速响应大量的并发请求，适用于对响应时间要求较高的应用场景。 但对于复杂的查询和分析操作，可能不如关系型数据库灵活。 四、成本 RDS： 成本主要取决于实例类型、存储容量、备份和恢复选项等。 关系型数据库通常需要进行较多的管理和维护工作，可能会增加成本。 DynamoDB： 采用按需付费的模式，根据实际使用的存储容量和吞吐量进行计费。 无需进行复杂的管理和维护工作，成本相对较低。 但对于长期存储大量数据的应用场景，成本可能会较高。 五、适用场景 RDS： 适用于传统的企业级应用、事务处理系统、数据分析等场景。 对于需要复杂查询、事务支持和数据一致性的应用，关系型数据库是一个可靠的选择。 DynamoDB： 适用于互联网应用、移动应用、游戏等对可扩展性和性能要求较高的场景。 对于需要快速响应、灵活数据模型和自动扩展的应用，DynamoDB 是一个理想的选择。 ","permalink":"https://gopherding.github.io/posts/tech/rds-dynamodb%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"一、数据模型 RDS： 是一种关系型数据库服务，支持常见的关系型数据库引擎如 MySQL、PostgreSQL、Oracle、SQL Server 等。 使用传统的表格结构来存储数据，通过 SQL 语言进行数据查询和操作。 遵循关系型数据库的 ACID（原子性、一致性、隔离性、持久性）特性，适用于对数据一致性要求","title":"RDS 、DynamoDB的区别"},{"content":"But why, some say, the moon?\n但有人问，为什么选择登月？\nWhy choose this as our goal?\n为什么选择登月作为我们的目标？\nAnd they may well ask why climb the highest mountain?\n那他们也许会问为什么我们要登上最高的山峰？\nWhy, 35 years ago, fly the Atlantic?\n为什么，要在35年前，飞越大西洋？\nWhy does Rice play Texas?\n为什么赖斯大学要与德克萨斯大学竞赛？\nWe choose to go to the moon.\n我们决定登月。\nWe choose to go to the moon.\n我们决定登月。\nWe choose to go to the moon in this decade and do the other things, not because they are easy, but because they are hard, because that goal will serve to organize and measure the best of our energies and skills, because that challenge is one that we are willing to accept, one we are unwilling to postpone, and one which we intend to win, and the others, too.\n我们决定在这十年间登上月球并实现更多梦想，并非它们轻而易举，而正是因为它们困难重重。因为这个目标将促进我们实现最佳的组织并测试我们顶尖的技术和力量，因为这个挑战我们乐于接受，因为这个挑战我们不愿推迟，因为这个挑战我们志在必得，其他的挑战也是如此。\n","permalink":"https://gopherding.github.io/posts/read/we-choose-to-go-to-the-moon/","summary":"But why, some say, the moon? 但有人问，为什么选择登月？ Why choose this as our goal? 为什么选择登月作为我们的目标？ And they may well ask why climb the highest mountain? 那他们也许会问为什么我们要登上最高的山峰？ Why, 35 years ago, fly the Atlantic? 为什么，要在35年前，飞越大西洋？ Why does Rice play Texas? 为什么赖斯大学要与德克萨斯大学竞赛？ We choose to go to the moon. 我们决定登月。 We choose to go to the moon. 我","title":"We choose to go to the moon"},{"content":"Hadoop 的 EditLog 和 FsImage 与 Redis 的 AOF（Append Only File）和 RDB（Redis Database）在某些方面有相似的设计思想。\n一、Redis 的 AOF 和 RDB RDB（Redis Database） 功能与特点： RDB 是 Redis 用来进行数据持久化的一种方式，它是在某个时间点将 Redis 内存中的数据以快照的形式写入到磁盘文件中。这个过程类似于对 Redis 数据的一个完整备份。 例如，当执行 SAVE 或 BGSAVE 命令时，Redis 会将当前内存中的所有数据序列化并写入到一个.rdb 文件中。下次 Redis 启动时，可以通过加载这个.rdb 文件来恢复数据。 存储与恢复： RDB 文件通常存储在磁盘上指定的目录中。在 Redis 启动时，如果配置了使用 RDB 进行数据恢复，它会首先尝试加载这个文件，将其中的数据恢复到内存中，从而快速恢复到上次保存的状态。 例如，如果 Redis 因为某些原因崩溃了，在重新启动时，它可以通过加载最新的.rdb 文件来恢复数据，使得数据的丢失最小化。 AOF（Append Only File） 功能与特点： AOF 则是以日志的形式记录 Redis 服务器所执行的所有写命令。每当 Redis 执行一个写命令时，这个命令就会被追加到 AOF 文件的末尾。这样，即使 Redis 发生故障，也可以通过重新执行 AOF 文件中的命令来恢复数据。 例如，当执行 SET key value 命令时，这个命令会被立即记录到 AOF 文件中。如果 Redis 服务器在后续的运行过程中出现故障，重新启动后，Redis 会读取 AOF 文件，并重新执行其中的所有写命令，以恢复数据到故障发生前的状态。 存储与恢复： AOF 文件也是存储在磁盘上，并且以追加的方式不断增长。为了防止 AOF 文件过大，Redis 提供了一些机制来对 AOF 文件进行重写和压缩，例如可以使用 BGREWRITEAOF 命令来启动 AOF 文件的重写过程。 在 Redis 启动时，如果同时配置了 AOF 和 RDB 进行数据恢复，通常会优先使用 AOF 文件进行恢复，因为 AOF 文件记录了更完整的写命令历史，可以更准确地恢复数据到故障发生前的状态。 二、相似的设计思想 数据持久化与恢复： 共同目标： EditLog + FsImage 和 AOF + RDB 组合的主要目的都是为了实现数据的持久化和故障恢复。在 Hadoop 的 HDFS 中，EditLog 记录元数据的变更操作，FsImage 提供元数据的快照，通过它们可以在 NameNode 故障后恢复文件系统的状态。同样，在 Redis 中，AOF 记录写命令历史，RDB 提供数据的快照，用于在 Redis 服务器故障后恢复数据。 恢复过程相似： 在恢复过程中，两者都需要读取存储在磁盘上的文件来重建数据状态。对于 HDFS，NameNode 读取 FsImage 和 EditLog 来恢复文件系统的元数据；对于 Redis，服务器读取 RDB 文件或重放 AOF 文件中的命令来恢复数据。 例如，如果 HDFS 的 NameNode 或 Redis 服务器发生故障，在重新启动时，它们都可以依靠存储在磁盘上的持久化文件来恢复到故障发生前的状态，确保数据的可用性和完整性。\n动态更新与静态快照结合： 设计理念相似： EditLog 和 AOF 都是用于记录动态的变更操作，而 FsImage 和 RDB 则是提供静态的快照。这种设计思想是将动态的变更记录与静态的快照相结合，既可以快速获取某个时间点的状态（通过快照），又可以通过记录变更操作来实现对数据的逐步更新和恢复。 性能与可靠性平衡： 通过这种方式，可以在一定程度上平衡性能和可靠性。例如，在 HDFS 中，频繁地更新 FsImage 可能会影响性能，而通过 EditLog 记录变更操作并定期合并到 FsImage 中，可以减少对 FsImage 的直接更新，提高性能。在 Redis 中，RDB 可以快速进行数据恢复，但可能会丢失一些最近的写操作，而 AOF 可以记录所有的写命令，保证数据的完整性，但可能会导致 AOF 文件过大。通过合理配置两者的使用，可以在性能和可靠性之间找到平衡。 定期合并与重写： 优化机制类似： HDFS 中的 EditLog 会定期合并到 FsImage 中，以生成新的 FsImage 文件并清空 EditLog，从而减少 EditLog 的大小和提高系统性能。同样，Redis 的 AOF 文件也可以通过重写机制来压缩文件大小，去除重复的和无效的命令，提高数据恢复的效率。 触发条件相似： 两者的合并和重写操作通常都是基于一定的条件触发的。例如，在 HDFS 中，NameNode 可能会定期触发检查点操作来合并 EditLog 和 FsImage；在 Redis 中，可以通过配置自动触发 AOF 重写的条件，如当 AOF 文件大小超过一定阈值或经过一定时间没有重写时。 ","permalink":"https://gopherding.github.io/posts/tech/editlog-+-fsimage-%E5%92%8C-aof-+-rdb-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/","summary":"Hadoop 的 EditLog 和 FsImage 与 Redis 的 AOF（Append Only File）和 RDB（Redis Database）在某些方面有相似的设计思想。 一、Redis 的 AOF 和 RDB RDB（Redis Database） 功能与特点： RDB 是 Redis 用来进行数据持久化的一种方式，它是在某个时间点将 Redis 内存中的数据以快照的形式写入到磁盘文件中","title":"EditLog+FsImage和AOF+RDB设计哲学"},{"content":"再论雷峰塔的倒掉 从崇轩先生的通信（二月份《京报副刊》）里，知道他在轮船上听到两个旅客谈话，说是杭州雷峰塔之所以倒掉，是因为乡下人迷信那塔砖放在自己的家中，凡事都必平安，如意，逢凶化吉，于是这个也挖，那个也挖，挖之久久，便倒了。一个旅客并且再三叹息道：西湖十景这可缺了呵！\n这消息，可又使我有点畅快了，虽然明知道幸灾乐祸，不像一个绅士，但本来不是绅士的，也没有法子来装潢。\n我们中国的许多人，—— 我在此特别郑重声明：并不包括四万万同胞全部！—— 大抵患有一种 “十景病”，至少是 “八景病”，沉重起来的时候大概在清朝。凡看一部县志，这一县往往有十景或八景，如 “远村明月”“萧寺清钟”“古池好水” 之类。而且，“十” 字形的病菌，似乎已经侵入血管，流布全身，其势力早不在 “！” 形惊叹亡国病菌之下了。点心有十样锦，菜有十碗，音乐有十番，阎罗有十殿，药有十全大补，猜拳有全福手福手全，连人的劣迹或罪状，宣布起来也大抵是十条，仿佛犯了九条的时候总不肯歇手。\n现在西湖十景可缺了呵！“凡为天下国家有九经”，九经固古已有之，而九景却颇不习见，所以正是对于十景病的一个针砭，至少也可以使患者感到一种不平常，知道自己的可爱的老病，忽而跑掉了十分之一了。\n但仍有悲哀在里面。其实，这一种势所必至的破坏，也还是徒然的，畅快不过是无聊的自欺。雅人和信士和传统大家，定要苦心孤诣巧语花言地再来补足了十景而后已。\n无破坏即无新建设，大致是的；但有破坏却未必即有新建设。卢梭，斯谛纳尔，尼采，托尔斯泰，伊孛生等辈，若用勃兰兑斯的话来说，乃是 “轨道破坏者”。其实他们不单是破坏，而且是扫除，是大呼猛进，将碍脚的旧轨道不论整条或碎片，一扫而空，并非想挖一块废铁古砖挟回家去，预备卖给旧货店。中国很少这一类人，即使有之，也会被大众的唾沫淹死。\n孔丘先生确是伟大，生在巫鬼势力如此旺盛的时代，偏不肯随俗谈鬼神；但可惜太聪明了，“祭如在祭神如神在”，只用他修《春秋》的照例手段以两个 “如” 字略寓 “俏皮刻薄” 之意，使人一时莫名其妙，看不出他肚皮里的反对来。他肯对子路赌咒，却不肯对鬼神宣战，因为一宣战就不和平，易犯骂人 —— 虽然不过骂鬼 —— 之罪，即不免有《衡论》（见一月份《晨报副镌》）作家 ty 先生似的好人，会替鬼神来奚落他道：为名乎？骂人不能得名。为利乎？骂人不能得利。想引诱女人乎？又不能将蚩尤的脸子印在文章上。何乐而为之也欤？孔丘先生是深通世故的老先生，大约除脸子付印问题以外，还有深心，犯不上来做明目张胆的破坏者，所以只是不谈，而决不骂，于是乎俨然成为中国的圣人，道大，无所不包故也。否则，现在供在圣庙里的，也许不姓孔。\n不过在戏台上罢了，悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。讥讽又不过是喜剧的变简的一支流。但悲壮滑稽，却都是十景病的仇敌，因为都有破坏性，虽然所破坏的方面各不同。中国如十景病尚存，则不但卢梭他们似的疯子决不产生，并且也决不产生一个悲剧作家或喜剧作家或讽刺诗人。所有的，只是喜剧底人物或非喜剧非悲剧底人物，在互相模造的十景中生存，一面各各带了十景病。\n然而十全停滞的生活，世界上是很不多见的事，于是破坏者到了，但并非自己的先觉的破坏者，却是狂暴的强盗，或外来的蛮夷。猃狁早到过中原，五胡来过了，蒙古也来过了；同胞张献忠杀人如草，而满洲兵的一箭，就钻进树丛中死掉了。有人论中国说，倘使没有带着新鲜的血液的野蛮的侵入，真不知自身会腐败到如何！这当然是极刻毒的恶谑，但我们一翻历史，怕不免要有汗流浃背的时候罢。\n外寇来了，暂一震动，终于请他作主子，在他的刀斧下修补老例；内寇来了，也暂一震动，终于请他做主子，或者别拜一个主子，在自己的瓦砾中修补老例。再来翻县志，就看见每一次兵燹之后，所添上的是许多烈妇烈女的氏名。看近来的兵祸，怕又要大举表扬节烈了罢。许多男人们都那里去了？\n凡这一种寇盗式的破坏，结果只能留下一片瓦砾，与建设无关。但当太平时候，就是正在修补老例，并无寇盗时候，即国中暂时没有破坏么？也不然的，其时有奴才式的破坏作用常川活动着。雷峰塔砖的挖去，不过是极近的一条小小的例。龙门的石佛，大半肢体不全，图书馆中的书籍，插图须谨防撕去，凡公物或无主的东西，倘难于移动，能够完全的即很不多。但其毁坏的原因，则非如革除者的志在扫除，也非如寇盗的志在掠夺或单是破坏，仅因目前极小的自利，也肯对于完整的大物暗暗的加一个创伤。人数既多，创伤自然极大，而倒败之后，却难于知道加害的究竟是谁。正如雷峰塔倒掉以后，我们单知道由于乡下人的迷信。共有的塔失去了，乡下人的所得，却不过一块砖，这砖，将来又将为别一自利者所藏，终究至于灭尽。\n倘在民康物阜时候，因为十景病的发作，新的雷峰塔也会再造的罢。但将来的运命，不也就可以推想而知么？如果乡下人还是这样的乡下人，老例还是这样的老例。\n这一种奴才式的破坏，结果也只能留下一片瓦砾，与建设无关。岂但乡下人之于雷峰塔，日日偷挖中华民国的柱石的奴才们，现在正不知有多少！\n瓦砾场上还不足悲，在瓦砾场上修补老例是可悲的。我们要革新的破坏者，因为他内心有理想的光。我们应该知道他和寇盗奴才的分别；应该留心自己堕入后两种。这区别并不烦难，只要观人，省己，凡言动中，思想中，含有借此据为己有的朕兆者是寇盗，含有借此占些目前的小便宜的朕兆者是奴才，无论在前面打着的是怎样鲜明好看的旗子 。\n","permalink":"https://gopherding.github.io/posts/read/%E5%86%8D%E8%AE%BA%E9%9B%B7%E5%B3%B0%E5%A1%94%E7%9A%84%E5%80%92%E6%8E%89/","summary":"再论雷峰塔的倒掉 从崇轩先生的通信（二月份《京报副刊》）里，知道他在轮船上听到两个旅客谈话，说是杭州雷峰塔之所以倒掉，是因为乡下人迷信那塔砖放在自己的家中，凡事都必平安，如意，逢凶化吉，于是这个也挖，那个也挖，挖之久久，便倒了。一个旅客并且再三叹息道：西湖十景这可缺了呵！ 这消息，可","title":"再论雷峰塔的倒掉"},{"content":"战士和苍蝇 Schopenhauer 说过这样的话：要估定人的伟大，则精神上的大和体格上的大，那法则完全相反。后者距离愈远即愈小，前者却见得愈大。正因为近则愈小，而且愈看见缺点和创伤，所以他就和我们一样，不是神道，不是妖怪，不是异兽。他仍然是人，不过如此。但也惟其如此，所以他是伟大的人。\n战士战死了的时候，苍蝇们所首先发见的是他的缺点和伤痕，嘬着，营营地叫着，以为得意，以为比死了的战士更英雄。但是战士已经战死了，不再来挥去他们。于是乎苍蝇们即更其营营地叫，自以为倒是不朽的声音，因为它们的安全，远在战士之上。\n的确的，谁也没有发见过苍蝇们的缺点和创伤。\n然而，有缺点的战士终竟是战士，完美的苍蝇也终竟不过是苍蝇。\n去罢，苍蝇们！虽然生着翅子，还能营营，总不会超过战士的。你们这些虫豸们！\n","permalink":"https://gopherding.github.io/posts/read/%E6%88%98%E5%A3%AB%E5%92%8C%E8%8B%8D%E8%9D%87/","summary":"战士和苍蝇 Schopenhauer 说过这样的话：要估定人的伟大，则精神上的大和体格上的大，那法则完全相反。后者距离愈远即愈小，前者却见得愈大。正因为近则愈小，而且愈看见缺点和创伤，所以他就和我们一样，不是神道，不是妖怪，不是异兽。他仍然是人，不过如此。但也惟其如此，所以他是伟大的人。 战士战死了的时候，","title":"战士和苍蝇"},{"content":"dockerfile 的命令摘要 FROM- 镜像从那里来\nMAINTAINER- 镜像维护者信息\nRUN- 构建镜像执行的命令，每一次RUN都会构建一层\nCMD- 容器启动的命令，如果有多个则以最后一个为准，也可以为ENTRYPOINT提供参数\nVOLUME- 定义数据卷，如果没有定义则使用默认\nUSER- 指定后续执行的用户组和用户\nWORKDIR- 切换当前执行的工作目录\nHEALTHCHECH- 健康检测指令\nARG- 变量属性值，但不在容器内部起作用\nEXPOSE- 暴露端口\nENV- 变量属性值，容器内部也会起作用\nADD- 添加文件，如果是压缩文件也解压\nCOPY- 添加文件，以复制的形式\nENTRYPOINT- 容器进入时执行的命令，追加到后面\n","permalink":"https://gopherding.github.io/posts/tech/dockerfile-%E7%9A%84%E5%91%BD%E4%BB%A4%E6%91%98%E8%A6%81/","summary":"dockerfile 的命令摘要 FROM- 镜像从那里来 MAINTAINER- 镜像维护者信息 RUN- 构建镜像执行的命令，每一次RUN都会构建一层 CMD- 容器启动的命令，如果有多个则以最后一个为准，也可以为ENTRYPOINT提供参数 VOLUME- 定义数据卷，如果没有定义则使用默认 USER- 指定后续执行的用户组和用户 WORKDIR- 切换当前执行的工作目录 HEALTHCHECH- 健康检测指令 ARG- 变量属","title":"dockerfile 的命令摘要"},{"content":" 命令分类 命令 功能描述 示例 镜像操作 docker pull 从镜像仓库下载镜像 docker pull ubuntu:latest docker images 列出本地镜像 docker images docker rmi 删除本地镜像 docker rmi ubuntu:latest docker build 根据 Dockerfile 构建镜像 docker build -t my - app:1.0. 容器操作 docker run 创建并运行容器 docker run -it ubuntu:latest /bin/bash docker run -d nginx docker run -p 8080:80 nginx docker run -v /host - dir:/container - dir ubuntu docker ps 列出正在运行的容器 docker ps docker stop 停止正在运行的容器 docker stop 1234567890ab docker start 启动已停止的容器 docker start 1234567890ab docker restart 重启容器 docker restart 1234567890ab docker rm 删除容器 docker rm 1234567890ab或docker rm -f（强制删除运行中的容器） docker exec 在运行容器内执行命令 docker exec -it 1234567890ab /bin/bash 容器网络操作 docker network create 创建新的 Docker 网络 docker network create my - network docker network ls 列出所有 Docker 网络 docker network ls docker network connect 将容器连接到网络 docker network connect my - network 1234567890ab docker network disconnect 将容器从网络断开连接 docker network disconnect my - network 1234567890ab 其他操作 docker login 登录到 Docker Hub 或其他镜像仓库 docker login docker logout 从 Docker Hub 或其他镜像仓库注销 docker logout docker info 显示 Docker 系统信息 docker info ","permalink":"https://gopherding.github.io/posts/tech/docker%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/","summary":"命令分类 命令 功能描述 示例 镜像操作 docker pull 从镜像仓库下载镜像 docker pull ubuntu:latest docker images 列出本地镜像 docker images docker rmi 删除本地镜像 docker rmi ubuntu:latest docker build 根据 Dockerfile 构建镜像 docker build -t my - app:1.0. 容器操作 docker run 创建并运行容器 docker run -it ubuntu:latest /bin/bash docker run -d nginx docker run -p 8080:80 nginx docker run -v /host - dir:/container - dir ubuntu docker ps 列出正在运行的容器 docker ps docker stop 停止正在运行的容器 docker stop 1234567890ab docker start 启动已停止的容器 docker","title":"Docker命令速查表"},{"content":"娜拉走后怎样 —— 一九二三年十二月二十六日在北京女子高等师范学校文艺会讲\n我今天要讲的是 “娜拉走后怎样？”\n易卜生是十九世纪后半的挪威的一个文人。他的著作，除了几十首诗之外，其余都是剧本。这些剧本里面，有一时期是大抵含有社会问题的，世间也称作 “社会剧”，其中有一篇就是《娜拉》。《娜拉》一名 Ein Puppenheim，中国译作《傀儡家庭》（即《玩偶之家》）。但 Puppe 不单是牵线的傀儡，孩子抱着玩的人形也是；引申开去，别人怎么指挥，他便怎么做的人也是。娜拉当初是满足地生活在所谓幸福的家庭里的，但是她竟觉悟了：自己是丈夫的傀儡，孩子们又是她的傀儡。她于是走了，只听得关门声，接着就是闭幕。这想来大家都知道，不必细说了。\n娜拉要怎样才不走呢？或者说易卜生自己有解答，就是 Die Frau vom Meer，《海的夫人》的。这女人是已经结婚的了，然而先前有一个爱人在海的彼岸，一日突然寻来，叫她一同去。她便告知她的丈夫，要和那外来人会面。临末，她的丈夫说，“现在放你完全自由。（走与不走）你能够自己选择，并且还要自己负责任。” 于是什么事全都改变，她就不走了。这样看来，娜拉倘也得到这样的自由，或者也便可以安住。\n但娜拉毕竟是走了的。走了以后怎样？易卜生并无解答；而且他已经死了。即使不死，他也不负解答的责任。因为易卜生是在做诗，不是为社会提出问题来而且代为解答。就如黄莺一样，因为他自己要歌唱，所以他歌唱，不是要唱给人们听得有趣，有益。\n娜拉走后怎样？—— 别人可是也发表过意见的。一个英国人曾作一篇戏剧，说一个新式的女子走出家庭，再也没有路走，终于堕落，进了妓院了。还有一个中国人，—— 我称他什么呢？上海的文学家罢，—— 说他所见的《娜拉》是和现译本不同，娜拉终于回来了。这样的本子可惜没有第二人看见，除非是易卜生自己寄给他的。但从事理上推想起来，娜拉或者也实在只有两条路：不是堕落，就是回来。因为如果是一匹小鸟，则笼子里固然不自由，而一出笼门，外面便又有鹰，有猫，以及别的什么东西之类；倘使已经关得麻痹了翅子，忘却了飞翔，也诚然是无路可以走。还有一条，就是饿死了，但饿死已经离开了生活，更无所谓问题，所以也不是什么路。\n人生最苦痛的是梦醒了无路可以走。做梦的人是幸福的；倘没有看出可走的路，最要紧的是不要去惊醒他。你看，唐朝的诗人李贺，不是困顿了一世的么？而他临死的时候，却对他的母亲说，“阿妈，上帝造成了白玉楼，叫我做文章落成去了。” 这岂非明明是一个诳，一个梦？然而一个小的和一个老的，一个死的和一个活的，死的高兴地死去，活的放心地活着。说诳和做梦，在这些时候便见得伟大。所以我想，假使寻不出路，我们所要的倒是梦。但是，万不可做将来的梦。阿尔志跋绥夫曾经借了他所做的小说，质问过梦想将来的黄金世界的理想家，因为要造那世界，先唤起许多人们来受苦。他说，“你们将黄金世界预约给他们的子孙了，可是有什么给他们自己呢？” 有是有的，就是将来的希望。但代价也太大了，为了这希望，要使人练敏了感觉来更深切地感到自己的苦痛，叫起灵魂来目睹他自己的腐烂的尸骸。惟有说诳和做梦，这些时候便见得伟大。所以我想，假使寻不出路，我们所要的就是梦；但不要将来的梦，只要目前的梦。\n然而娜拉既然醒了，是很不容易回到梦境的，因此只得走；可是走了以后，有时却也免不掉堕落或回来。否则，就得问：她除了觉醒的心以外，还带了什么去？倘只有一条像诸君一样的紫红的绒绳的围巾，那可是无论宽到二尺或三尺，也完全是不中用。她还须更富有，提包里有准备，直白地说，就是要有钱。\n梦是好的；否则，钱是要紧的。钱这个字很难听，或者要被高尚的君子们所非笑，但我总觉得人们的议论是不但昨天和今天，即使饭前和饭后，也往往有些差别。凡承认饭需钱买，而以说钱为卑鄙者，倘能按一按他的胃，那里面怕总还有鱼肉没有消化完，须得饿他一天之后，再来听他发议论。所以为娜拉计，钱，—— 高雅的说罢，就是经济，是最要紧的了。自由固不是钱所能买到的，但能够为钱而卖掉。人类有一个大缺点，就是常常要饥饿。为补救这缺点起见，为准备不做傀儡起见，在目下的社会里，经济权就见得最要紧了。第一，在家应该先获得男女平均的分配；第二，在社会应该获得男女相等的势力。可惜我不知道这权柄如何取得，单知道仍然要战斗；或者也许比要求参政权更要用剧烈的战斗。\n要求经济权固然是很平凡的事，然而也许比要求高尚的参政权以及博大的女子解放之类更烦难。天下事尽有小作为比大作为更烦难的。譬如现在似的冬天，我们只有这一件棉袄，然而必须救助一个将要冻死的苦人，否则便须坐在菩提树下冥想普度一切人类的方法去。普度一切人类和救活一人，大小实在相去太远了，然而倘叫我挑选，我就立刻到菩提树下去坐着，因为免得脱下唯一的棉袄来冻杀自己。所以在家里说要参政权，是不至于大遭反对的，一说到经济的平匀分配，或不免面前就遇见敌人，这就当然要有剧烈的战斗。\n战斗不算好事情，我们也不能责成人人都是战士，那么，平和的方法也就可贵了，这就是将来利用了亲权来解放自己的子女。中国的亲权是无上的，那时候，就可以将财产平匀地分配子女们，使他们平和而没有冲突地都得到相等的经济权，此后或者去读书，或者去生发，或者为自己去享用，或者为社会去做事，或者去花完，都请便，自己负责任。这虽然也是颇远的梦，可是比黄金世界的梦近得不少了。但第一需要记性。记性不佳，是有益于己而有害于子孙的。人们因为能忘却，所以自己能渐渐地脱离了受过的苦痛，也因为能忘却，所以往往照样地再犯前人的错误。被虐待的儿媳做了婆婆，仍然虐待儿媳；嫌恶学生的官吏，每是先前痛骂官吏的学生；现在压迫子女的，有时也就是十年前的家庭革命者。这也许与年龄和地位都有关系罢，但记性不佳也是一个很大的原因。救济法就是各人去买一本 Note-book 来，将自己现在的思想举动都记上，作为将来年龄和地位都改变了之后的参考。假如憎恶孩子要到公园去的时候，取来一翻，看见上面有一条道，“我想到中央公园去”，那就即刻心平气和了。别的事也一样。\n世间有一种无赖精神，那要义就是韧性。听说拳匪乱后，天津的青皮，就是所谓无赖者很跋扈，譬如给人搬一件行李，他就要两元，对他说这行李小，他说要两元，对他说道路近，他说要两元，对他说不要搬了，他说也仍然要两元。青皮固然是不足为法的，而那韧性却大可以佩服。要求经济权也一样，有人说这事情太陈腐了，就答道要经济权；说是太卑鄙了，就答道要经济权；说是经济制度就要改变了，用不着再操心，也仍然答道要经济权。其实，在现在，一个娜拉的出走，或者也许不至于感到困难的，因为这人物很特别，举动也新鲜，能得到若干人们的同情，帮助着生活。生活在人们的同情之下，已经是不自由了，然而倘有一百个娜拉出走，便连同情也减少，有一千一万个出走，就得到厌恶了，断不如自己握着经济权之为可靠。\n在经济方面得到自由，就不是傀儡了么？也还是傀儡。无非被人所牵的事可以减少，而自己能牵的傀儡可以增多罢了。因为在现在的社会里，不但女人常作男人的傀儡，就是男人和男人，女人和女人，也相互地作傀儡，男人也常作女人的傀儡，这决不是几个女人取得经济权所能救的。但人不能饿着静候理想世界的到来，至少也得留一点残喘，正如涸辙之鲋，急谋升斗之水一样，就要这较为切近的经济权，一面再想别的法。如果经济制度竟改革了，那上文当然完全是废话。然而上文，是又将娜拉当作一个普通的人物而说的，假使她很特别，自己情愿闯出去做牺牲，那就又另是一回事。我们无权去劝诱人做牺牲，也无权去阻止人做牺牲。况且世上也尽有乐于牺牲，乐于受苦的人物。欧洲有一个传说，耶稣去钉十字架时，休息在 Ahasvar 的檐下，Ahasvar 不准他，于是被了咒诅，使他永世不得休息，直到末日裁判的时候。Ahasvar 从此就歇不下，只是走，现在还在走。走是苦的，安息是乐的，他何以不安息呢？虽说背着咒诅，可是大约总该是觉得走比安息还适意，所以始终狂走的罢。只是这牺牲的适意是属于自己的，与志士们之所谓为社会者无涉。\n群众，—— 尤其是中国的，—— 永远是戏剧的看客。牺牲上场，如果显得慷慨，他们就看了悲壮剧；如果显得觳觫，他们就看了滑稽剧。北京的羊肉铺前常有几个人张着嘴看剥羊，仿佛颇愉快，人的牺牲能给与他们的益处，也不过如此。而况事后走不几步，他们并这一点愉快也就忘却了。对于这样的群众没有法，只好使他们无戏可看倒是疗救，正无需乎震骇一时的牺牲，不如深沉的韧性的战斗。\n可惜中国太难改变了，即使搬动一张桌子，改装一个火炉，几乎也要血；而且即使有了血，也未必一定能搬动，能改装。不是很大的鞭子打在背上，中国自己是不肯动弹的。我想这鞭子总要来，好坏是别一问题，然而总要打到的。但是从那里来，怎么地来，我也是不能确切地知道。\n我这讲演也就此完结了。\n","permalink":"https://gopherding.github.io/posts/read/%E5%A8%9C%E6%8B%89%E8%B5%B0%E5%90%8E%E6%80%8E%E6%A0%B7/","summary":"娜拉走后怎样 —— 一九二三年十二月二十六日在北京女子高等师范学校文艺会讲 我今天要讲的是 “娜拉走后怎样？” 易卜生是十九世纪后半的挪威的一个文人。他的著作，除了几十首诗之外，其余都是剧本。这些剧本里面，有一时期是大抵含有社会问题的，世间也称作 “社会剧”，其中有一篇就是《娜拉》。《娜拉》","title":"娜拉走后怎样"},{"content":"《希望》 我的心分外地寂寞。\n然而我的心很平安：没有爱憎，没有哀乐，也没有颜色和声音。\n我大概老了。我的头发已经苍白，不是很明白的事么?我的手颤抖着，不是很明白的事么?那么，我的魂灵的手一定也颤抖着，头发也一定苍白了。\n然而这是许多年前的事了。\n这以前，我的心也曾充满过血腥的歌声：血和铁，火焰和毒，恢复和报仇。而忽而这些都空虚了，但有时故意地填以没奈何的自欺的希望。希望，希望，用这希望的盾，抗拒那空虚中的暗夜的袭来，虽然盾后面也依然是空虚中的暗夜。然而就是如此，陆续地耗尽了我的青春。\n我早先岂不知我的青春已经逝去了?但以为身外的青春固在：星，月光，僵坠的胡蝶，暗中的花，猫头鹰的不祥之言，杜鹃的啼血，笑的渺茫，爱的翔舞……虽然是悲凉漂渺的青春罢，然而究竟是青春。\n然而现在何以如此寂寞? 难道连身外的青春也都逝去，世上的青年也多衰老了么?\n我只得由我来肉薄这空虚中的暗夜了。我放下了希望之盾，我听到 Petofi Sándor (1823—49)的“希望”之歌：\n希望是甚么?是娼妓：\n她对谁都蛊惑，将一切都献给;\n待你牺牲了极多的宝贝……\n你的青春——她就弃掉你。\n这伟大的抒情诗人，匈牙利的爱国者，为了祖国而死在可萨克兵的矛尖上，已经七十五年了。悲哉死也，然而更可悲的是他的诗至今没有死。\n但是，可惨的人生! 桀骜英勇如 Petofi ，也终于对了暗夜止步，回顾着茫茫的东方了。他说：\n绝望之为虚妄，正与希望相同。\n倘使我还得偷生在不明不暗的这“虚妄”中，我就还要寻求那逝去的悲凉漂渺的青春，但不妨在我的身外。因为身外的青春倘一消灭，我身中的迟暮也即凋零了。\n然而现在没有星和月光，没有僵坠的胡蝶以至笑的渺茫，爱的翔舞。然而青年们很平安。\n我只得由我来肉薄这空虚中的暗夜了，纵使寻不到身外的青春，也总得自己来一掷我身中的迟暮。但暗夜又在那里呢?现在没有星，没有月光以至笑的渺茫和爱的翔舞;青年们很平安，而我的面前又竟至于并且没有真的暗夜。\n绝望之为虚妄，正与希望相同!\n一九二五年一月一日。\n","permalink":"https://gopherding.github.io/posts/read/%E5%B8%8C%E6%9C%9B/","summary":"《希望》 我的心分外地寂寞。 然而我的心很平安：没有爱憎，没有哀乐，也没有颜色和声音。 我大概老了。我的头发已经苍白，不是很明白的事么?我的手颤抖着，不是很明白的事么?那么，我的魂灵的手一定也颤抖着，头发也一定苍白了。 然而这是许多年前的事了。 这以前，我的心也曾充满过血腥的歌声：血和铁，","title":"希望"},{"content":"关于知识阶级 我到上海约二十多天，这回来上海并无什么意义，只是跑来跑去偶然到上海就是了。我没有什么学问和思想，可以贡献给诸君。但这次易先生要我来讲几句话；因为我去年亲见易先生在北京和军阀官僚怎样奋斗，而且我也参与其间，所以他要我来，我是不得不来的。\n我不会讲演，也想不出什么可讲的，讲演近于做八股，是极难的，要有讲演的天才才好，在我是不会的。终于想不出什么，只能随便一谈；刚才谈起中国情形，说到 “知识阶级” 四字，我想对于知识阶级发表一点个人的意见，只是我并不是站在引导者的地位，要诸君都相信我的话，我自己走路都走不清楚，如何能引导诸君？\n“知识阶级” 一辞是爱罗先珂七八年前讲演 “知识阶级及其使命” 时提出的，他骂俄国的知识阶级，也骂中国的知识阶级，中国人于是也骂起知识阶级来了；后来便要打倒知识阶级，要利害一点，甚至于要杀知识阶级了。知识就仿佛是罪恶，但是一方面虽有人骂知识阶级；一方面却又有人以此自豪：这种情形是中国所特有的。\n所谓俄国的知识阶级，其实与中国的不同，俄国当革命以前，社会上还欢迎知识阶级。为什么要欢迎呢？因为他确能替平民抱不平，把平民的苦痛告诉大众。他为什么能把平民的苦痛说出来？因为他与平民接近，或自身就是平民。几年前有一位中国大学教授，他很奇怪，为什么有人要描写一个车夫的事情，这就因为大学教授一向住在高大的洋房里，不明白平民的生活。欧洲的著作家往往是平民出身，所以也同样的感受到平民的苦痛，当然能痛痛快快写出来为平民说话，因此平民以为知识阶级对于自身是有益的；于是赞成他，到处都欢迎他，但是他们既受此荣誉，地位就增高了，而同时却把平民忘记了，变成一种特别的阶级。那时他们自以为了不得，到阔人家里去宴会，钱也多了，房子东西都要好的，终于与平民远远的离开了。他享受了高贵的生活，就记不起从前一切的贫苦生活了。—— 所以请诸位不要拍手，拍了手把我的地位一提高，我就要忘记了说话的。他不但不同情于平民或许还要压迫平民，以致变成了平民的敌人，现在贵族阶级不能存在；贵族的知识阶级当然也不能站住了，这是知识阶级缺点之一。\n还有知识阶级不可免避的运命，在革命时代是注重实行的，动的；思想还在其次，直白地说：或者倒有害。至少我个人的意见如此的。唐朝奸臣李林甫有一次看兵操练很勇敢，就有人对着他称赞。他说：“兵好是好，可是无思想，” 这话很不差。因为兵之所以勇敢，就在没有思想，要是有了思想，就会没有勇气了。现在倘叫我去当兵，要我去革命，我一定不去，因为明白了利害是非，就难于实行了。有知识的人，讲讲柏拉图讲讲苏格拉底是不会有危险的。讲柏拉图可以讲一年，讲苏格拉底可以讲三年，他很可以安安稳稳地活下去，但要他去干危险的事情，那就很费踟踌。譬如中国人，凡是做文章，总说 “有利然而又有弊”，这最足以代表知识阶级的思想。其实无论什么都是有弊的，就是吃饭也是有弊的，它能滋养我们这方面是有利的；但是一方面使我们消化器官疲乏，那就不好而有弊了。假使做事要面面顾到，那就什么事都不能做了。\n还有，知识阶级对于别人的行动，往往以为这样也不好，那样也不好。先前俄国皇帝杀革命党，他们反对皇帝；后来革命党杀皇族，他们也起来反对。问他怎么才好呢？他们也没办法。所以在皇帝时代他们吃苦，在革命时代他们也吃苦，这实在是他们本身的缺点。所以我想，知识阶级能否存在还是个问题。\n知识和强有力是冲突的，不能并立的；强有力不许人民有自由思想，因为这能使能力分散，在动物界有很显的例；猴子的社会是最专制的，猴王说一声走，猴子都走了。在原始时代酋长的命令是不能反对的，无怀疑的，在那时酋长带领着群众并吞衰小的部落；于是部落渐渐的大了，团体也大了。一个人就不能支配了。因为各个人思想发达了，各人的思想不一，民族的思想就不能统一，于是命令不行，团体的力量减小，而渐趋灭亡。在古时野蛮民族常侵略文明很发达的民族，在历史上常见的。现在知识阶级在国内的弊病，正与古时一样。\n英国罗素法国罗曼罗兰反对欧战，大家以为他们了不起，其实幸而他们的话没有实行，否则，德国早已打进英国和法国了；因为德国如不能同时实行非战，是没有办法的。俄国托尔斯泰的无抵抗主义之所以不能实行，也是这个原因。他不主张以恶报恶的，他的意思是皇帝叫我们去当兵，我们不去当兵。叫警察去捉；他不去；叫刽子手去杀，他不去杀，大家都不听皇帝的命令，他也没有兴趣；那末做皇帝也无聊起来，天下也就太平了。然而如果一部分的人偏听皇帝的话，那就不行。我从前也很想做皇帝，后来在北京去看到宫殿的房子都是一个刻板的格式，觉得无聊极了。所以我皇帝也不想做了。做人的趣味在和许多朋友有趣的谈天，热烈的讨论。做了皇帝，口出一声，臣民都下跪，只有不绝声的 yes，yes，那有什么趣味？但是还有人做皇帝，因为他和外界隔绝，不知外面还有世界！总之，思想一自由，能力要减少，民族就站不住，他的自身也站不住了！现在思想自由和生存还有冲突，这是知识阶级本身的缺点。\n然而知识阶级将怎么样呢？还是在指挥刀下听令行动，还是发表倾向民众的思想呢？要是发表意见，就要想到什么就说什么。真的知识阶级是不顾利害的，如想到种种利害，就是假的，冒充的知识阶级；只是假知识阶级的寿命倒比较长一点。像今天发表这个主张，明天发表那个意见的人，思想似乎天天在进步；只是真的知识阶级的进步，决不能如此快的。不过他们对于社会永不会满意的，所感受的永远是痛苦，所看到的永远是缺点，他们预备着将来的牺牲，社会也因为有了他们而热闹，不过他的本身 —— 心身方面总是苦痛的；因为这也是旧式社会传下来的遗物。\n至于诸君，是与旧的不同，是二十世纪初叶青年，如在劳动大学一方读书，一方做工，这是新的境遇；或许可以造成新的局面，但是环境是老样子，着着逼人堕落，倘不与这老社会奋斗，还是要回到老路上去的。譬如从前我在学生时代不吸烟，不吃酒，不打牌，没有一点嗜好；后来当了教员，有人发传单说我抽鸦片。我很气，但并不辩明，为要报复他们，前年我在陕西就真的抽一回鸦片，看他们怎样？此次来上海有人在报纸上说我来开书店；又有人说我每年版税有一万多元。但是我也并不辩明；但曾经自己想，与其负空名，倒不如真的去赚这许多进款。\n还有一层，最可怕的情形，就是比较新的思想运动起来时，如与社会无关，作为空谈，那是不要紧的，这也是专制时代所以能容知识阶级存在的原故。因为痛哭流泪与实际是没有关系的，只是思想运动变成实际的社会运动时，那就危险了。往往反为旧势力所扑灭。中国现在也是如此，这现象，革新的人称之为 “反动”。我在文艺史上，却找到一个好名辞，就是 renaissance，在意大利文艺复兴的意义，是把古时好的东西复活，将现存的坏的东西压倒，因为那时候思想太专制腐败了，在古时代确实有些比较好的；因此后来得到了社会上的信仰。现在中国顽固派的复古，把孔子礼教都拉出来了，但是他们拉出来的是好的么？如果是不好的，就是反动，倒退，以后恐怕是倒退的时代了。\n还有，中国人现在胆子格外小了，这是受了共产党的影响。人一听到俄罗斯，一看见红色，就吓得一跳；一听到新思想，一看到俄国的小说，更其害怕，对于较特别的思想，较新思想尤其丧心发抖，总要仔仔细细底想，这有没有变成共产党思想的可能性？！这样的害怕，一动也不敢动，怎样能够有进步呢？这实在是没有力量的表示，比如我们吃东西，吃就吃，若是左思右想，吃牛肉怕不消化，喝茶时又要怀疑，那就不行了，—— 老年人才是如此；有力量，有自信力的人是不至于此的。虽是西洋文明罢，我们能吸收时，就是西洋文明也变成我们自己的了。好像吃牛肉一样，决不会吃了牛肉自己也即变成牛肉的，要是如此胆小，那真是衰弱的知识阶级了，不衰弱的知识阶级，尚且对于将来的存在不能确定；而衰弱的知识阶级是必定要灭亡的。从前或许有，将来一定不能存在的。\n现在比较安全一点的，还有一条路，是不做时评而做艺术家。要为艺术而艺术。住在 “象牙之塔” 里，目下自然要比别处平安。就我自己来说罢，—— 有人说我只会讲自己，这是真的。我先前独自住在厦门大学的一所静寂的大洋房里；到了晚上，我总是孤思默想，想到一切，想到世界怎样，人类怎样，我静静地思想时，自己以为很了不得的样子；但是给蚊子一咬，跳了一跳，把世界人类的大问题全然忘了，离不开的还是我本身。就我自己说起来，是早就有人劝我不要发议论，不要做杂感，你还是创作去吧！因为做了创作在世界史上有名字，做杂感是没有名字的。其实就是我不做杂感，世界史上，还是没有名字的，这得声明一句，是：这些劝我做创作，不要写杂感的人们之中，有几个是别有用意，是被我骂过的。所以要我不再做杂感。但是我不听他，因此在北京终于站不住了，不得不躲到厦门的图书馆上去了。艺术家住在象牙塔中，固然比较地安全，但可惜还是安全不到底。秦始皇，汉武帝想成仙，终于没有成功而死了。危险的临头虽然可怕，但别的运命说不定，“人生必死” 的运命却无法逃避，所以危险也仿佛用不着害怕似的。但我并不想劝青年得到危险，也不劝他人去做牺牲，说为社会死了名望好，高巍巍的镌起铜像来。自己活着的人没有劝别人去死的权利，假使你自己以为死是好的，那末请你自己先去死吧。诸君中恐有钱人不多罢。那末，我们穷人唯一的资本就是生命。以生命来投资，为社会做一点事，总得多赚一点利才好；以生命来做利息小的牺牲，是不值得的。所以我从来不叫人去牺牲，但也不要再爬进象牙之塔和知识阶级里去了，我以为是最稳当的一条路。\n至于有一班从外国留学回来，自称知识阶级，以为中国没有他们就要灭亡的，却不在我所论之内，像这样的知识阶级，我还不知道是些什么东西？！\n今天的说话很没有伦次，望诸君原谅！\n","permalink":"https://gopherding.github.io/posts/read/%E5%85%B3%E4%BA%8E%E7%9F%A5%E8%AF%86%E9%98%B6%E7%BA%A7/","summary":"关于知识阶级 我到上海约二十多天，这回来上海并无什么意义，只是跑来跑去偶然到上海就是了。我没有什么学问和思想，可以贡献给诸君。但这次易先生要我来讲几句话；因为我去年亲见易先生在北京和军阀官僚怎样奋斗，而且我也参与其间，所以他要我来，我是不得不来的。 我不会讲演，也想不出什么可讲的，讲","title":"关于知识阶级"},{"content":"记念刘和珍君 一 中华民国十五年三月二十五日，就是国立北京女子师范大学为十八日在段祺瑞执政府前遇害的刘和珍杨德群两君开追悼会的那一天，我独在礼堂外徘徊，遇见程君，前来问我道，“先生可曾为刘和珍写了一点什么没有？” 我说 “没有”。她就正告我，“先生还是写一点罢；刘和珍生前就很爱看先生的文章。”\n这是我知道的，凡我所编辑的期刊，大概是因为往往有始无终之故罢，销行一向就甚为寥落，然而在这样的生活艰难中，毅然预定了《莽原》全年的就有她。我也早觉得有写一点东西的必要了，这虽然于死者毫不相干，但在生者，却大抵只能如此而已。\n倘使我能够相信真有所谓 “在天之灵”，那自然可以得到更大的安慰，—— 但是，现在，却只能如此而已。\n可是我实在无话可说。我只觉得所住的并非人间。四十多个青年的血，洋溢在我的周围，使我艰于呼吸视听，那里还能有什么言语？长歌当哭，是必须在痛定之后的。而此后几个所谓学者文人的阴险的论调，尤使我觉得悲哀。我已经出离愤怒了。我将深味这非人间的浓黑的悲凉；以我的最大哀痛显示于非人间，使它们快意于我的苦痛，就将这作为后死者的菲薄的祭品，奉献于逝者的灵前。\n二 真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。这是怎样的哀痛者和幸福者？然而造化又常常为庸人设计，以时间的流驶，来洗涤旧迹，仅使留下淡红的血色和微漠的悲哀。在这淡红的血色和微漠的悲哀中，又给人暂得偷生，维持着这似人非人的世界。我不知道这样的世界何时是一个尽头！\n我们还在这样的世上活着；我也早觉得有写一点东西的必要了。离三月十八日也已有两星期，忘却的救主快要降临了罢，我正有写一点东西的必要了。\n三 在四十余被害的青年之中，刘和珍君是我的学生。学生云者，我向来这样想，这样说，现在却觉得有些踌躇了，我应该对她奉献我的悲哀与尊敬。她不是 “苟活到现在的我” 的学生，是为了中国而死的中国的青年。\n她的姓名第一次为我所见，是在去年夏初杨荫榆女士做女子师范大学校长，开除校中六个学生自治会职员的时候。其中的一个就是她；但是我不认识。直到后来，也许已经是刘百昭率领男女武将，强拖出校之后了，才有人指着一个学生告诉我，说：这就是刘和珍。其时我才能将姓名和实体联合起来，心中却暗自诧异。我平素想，能够不为势利所屈，反抗一广有羽翼的校长的学生，无论如何，总该是有些桀骜锋利的，但她却常常微笑着，态度很温和。\n待到偏安于宗帽胡同，赁屋授课之后，她才始来听我的讲义，于是见面的回数就较多了，也还是始终微笑着，态度很温和。待到学校恢复旧观，往日的教职员以为责任已尽，准备陆续引退的时候，我才见她虑及母校前途，黯然至于泣下。此后似乎就不相见。总之，在我的记忆上，那一次就是永别了。\n四 我在十八日早晨，才知道上午有群众向执政府请愿的事；下午便得到噩耗，说卫队居然开枪，死伤至数百人，而刘和珍君即在遇害者之列。但我对于这些传说，竟至于颇为怀疑。我向来是不惮以最坏的恶意，来推测中国人的，然而我还不料，也不信竟会下劣凶残到这地步。况且始终微笑着的和蔼的刘和珍君，更何至于无端在府门前喋血呢？\n然而即日证明是事实了，作证的便是她自己的尸骸。还有一具，是杨德群君的。而且又证明着这不但是杀害，简直是虐杀，因为身体上还有棍棒的伤痕。\n但段政府就有令，说她们是 “暴徒”！但接着就有流言，说她们是受人利用的。惨象，已使我目不忍视了；流言，尤使我耳不忍闻。我还有什么话可说呢？我懂得衰亡民族之所以默无声息的缘由了。沉默呵，沉默呵！不在沉默中爆发，就在沉默中灭亡。\n五 但是，我还有要说的话。我没有亲见；听说，她，刘和珍君，那时是欣然前往的。自然，请愿而已，稍有人心者，谁也不会料到有这样的罗网。但竟在执政府前中弹了，从背部入，斜穿心肺，已是致命的创伤，只是没有便死。同去的张静淑君想扶起她，中了四弹，其一是手枪，立仆；同去的杨德群君又想去扶起她，也被击，弹从左肩入，穿胸偏右出，也立仆。但她还能坐起来，一个兵在她头部及胸部猛击两棍，于是死掉了。\n始终微笑的和蔼的刘和珍君确是死掉了，这是真的，有她自己的尸骸为证；沉勇而友爱的杨德群君也死掉了，有她自己的尸骸为证；只有一样沉勇而友爱的张静淑君还在医院里呻吟。当三个女子从容地转辗于文明人所发明的枪弹的攒射中的时候，这是怎样的一个惊心动魄的伟大呵！中国军人的屠戮妇婴的伟绩，八国联军的惩创学生的武功，不幸全被这几缕血痕抹杀了。\n但是中外的杀人者却居然昂起头来，不知道个个脸上有着血污。\n六 时间永是流驶，街市依旧太平，有限的几个生命，在中国是不算什么的，至多，不过供无恶意的闲人以饭后的谈资，或者给有恶意的闲人作 “流言” 的种子。至于此外的深的意义，我总觉得很寥寥，因为这实在不过是徒手的请愿。人类的血战前行的历史，正如煤的形成，当时用大量的木材，结果却只是一小块，但请愿是不在其中的，更何况是徒手。\n然而既然有了血痕了，当然不觉要扩大。至少，也当浸渍了亲族；师友，爱人的心，纵使时光流驶，洗成绯红，也会在微漠的悲哀中永存微笑的和蔼的旧影。陶潜说过，“亲戚或余悲，他人亦已歌，死去何所道，托体同山阿。” 倘能如此，这也就够了。\n七 我已经说过：我向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是当局者竟会这样地凶残，一是流言家竟至如此之下劣，一是中国的女性临难竟能如是之从容。\n我目睹中国女子的办事，是始于去年的，虽然是少数，但看那干练坚决，百折不回的气概，曾经屡次为之感叹。至于这一回在弹雨中互相救助，虽殒身不恤的事实，则更足为中国女子的勇毅，虽遭阴谋秘计，压抑至数千年，而终于没有消亡的明证了。倘要寻求这一次死伤者对于将来的意义，意义就在此罢。\n苟活者在淡红的血色中，会依稀看见微茫的希望；真的猛士，将更奋然而前行。\n呜呼，我说不出话，但以此记念刘和珍君！\n四月一日\n","permalink":"https://gopherding.github.io/posts/read/%E8%AE%B0%E5%BF%B5%E5%88%98%E5%92%8C%E7%8F%8D%E5%90%9B/","summary":"记念刘和珍君 一 中华民国十五年三月二十五日，就是国立北京女子师范大学为十八日在段祺瑞执政府前遇害的刘和珍杨德群两君开追悼会的那一天，我独在礼堂外徘徊，遇见程君，前来问我道，“先生可曾为刘和珍写了一点什么没有？” 我说 “没有”。她就正告我，“先生还是写一点罢；刘和珍生前就很爱看先生的文","title":"记念刘和珍君"},{"content":"论睁了眼看 虚生先生所做的时事短评中，曾有一个这样的题目：《我们应该有正眼看东西的勇气》（《猛进》十九期）。诚然，必须敢于正视，这才可望敢想，敢说，敢作，敢当。倘使并正视都不敢，此外还能成什么气候。然而，不幸这一种勇气，是我们中国人最所缺乏的东西。\n但现在我所想到的是别一方面 ——\n中国的文人，对于人生，—— 至少是对于社会现象，向来就多没有正视的勇气。我们的圣贤，本来早已教人 “非礼勿视” 的了；而这 “礼” 又非常之严，不但 “正视”，连 “平视”“斜视” 也不许。现在青年的精神未可知，在体质，却大半还是弯腰曲背，低眉顺眼，表示着老牌的老成的子弟，驯良的百姓。\n至于说对外却有大力量，乃是近一月来的新说，还不知道究竟是如何。\n再回到 “正视” 问题去：先既不敢，后便不能，再后，就自然不视，不见了。一辆汽车坏了，停在马路上，一群人围着呆看，所得的结果是一团乌油油的东西。然而由本身的矛盾或社会的别的原因，使文人学者没有勇气正视社会现象，或是不敢正视，或不愿正视，于是就闭眼胡说一通。所以中国的文人学者，对于人生，对于社会现象，也便往往闭了眼睛。\n中国文人的不敢正视人生，大半因为中国人的怯懦。但也有别的原因，例如：怕看真理，怕看人生的真相。因为人生的真相，往往是残酷的，丑恶的，与文人所想象的大不相同。文人想象中的人生，是美妙的，光明的，充满着诗意的。所以他们害怕看到现实的人生，怕看到丑恶的东西。\n像这样的闭着眼睛，中国文人是很不少的。他们写文章，作诗，画画，都是为了逃避现实，或是美化现实。他们把丑恶的东西，写成美好的；把残酷的东西，写成温柔的；把黑暗的东西，写成光明的。他们用这样的方法，来安慰自己，也安慰别人。\n更有一种坏脾气，是相传所谓 “文人相轻”。文人之间，互相看不起，互相攻击。他们不看别人的优点，只看别人的缺点。他们把别人的作品，说得一文不值。他们这样做，并不是因为别人的作品真的不好，而是因为他们自己的嫉妒心。他们嫉妒别人的才华，嫉妒别人的成就。所以他们用攻击别人的方法，来抬高自己。\n中国的文人，还有一种坏脾气，是所谓 “党同伐异”。他们结成党派，互相支持，互相攻击。他们只看党派的利益，不看真理。他们把自己的党派，说得无比正确；把别人的党派，说得无比错误。他们这样做，并不是因为自己的党派真的正确，而是因为他们自己的偏见。他们偏见别人的观点，偏见别人的主张。所以他们用攻击别人的方法，来维护自己的党派。\n但是，闭着眼睛，胡说一通，是没有用的。社会现象，是客观存在的，不管你看与不看，它都在那里。而且，社会现象，是不断变化的，你不看，就会落后，就会被淘汰。所以，文人学者，必须敢于正视社会现象，必须敢于正视人生。\n敢于正视社会现象，敢于正视人生，是一种勇气，也是一种智慧。只有敢于正视，才能了解社会现象的本质，才能了解人生的真相。只有了解了本质和真相，才能找到解决问题的方法，才能找到前进的方向。\n中国的文人学者，要想有所作为，要想为社会做出贡献，就必须睁了眼看。他们必须抛弃怯懦，抛弃嫉妒，抛弃偏见，他们必须正视社会现象，正视人生。只有这样，他们才能写出有价值的文章，画出有价值的画，做出有价值的学问。\n现在，中国的社会，正处在一个大变革的时代。各种社会现象，层出不穷。文人学者，应该睁了眼看，应该勇敢地面对现实，应该积极地参与变革。他们应该用自己的笔，用自己的画，用自己的学问，为社会的变革，为人民的幸福，做出自己的贡献。\n这就是我所要说的 “论睁了眼看”。\n","permalink":"https://gopherding.github.io/posts/read/%E8%AE%BA%E7%9D%81%E4%BA%86%E7%9C%BC%E7%9C%8B/","summary":"论睁了眼看 虚生先生所做的时事短评中，曾有一个这样的题目：《我们应该有正眼看东西的勇气》（《猛进》十九期）。诚然，必须敢于正视，这才可望敢想，敢说，敢作，敢当。倘使并正视都不敢，此外还能成什么气候。然而，不幸这一种勇气，是我们中国人最所缺乏的东西。 但现在我所想到的是别一方面 —— 中国","title":"论睁了眼看"},{"content":"12345，上山打老虎！\n","permalink":"https://gopherding.github.io/posts/life/%E6%A8%A1%E6%9D%BF/","summary":"12345，上山打老虎！","title":"Github Action测试"},{"content":"","permalink":"https://gopherding.github.io/%E6%A8%A1%E6%9D%BF/","summary":"","title":"Golang学习中遇到的那些坑"},{"content":"","permalink":"https://gopherding.github.io/posts/read/%E6%A8%A1%E6%9D%BF---%E5%89%AF%E6%9C%AC-3/","summary":"","title":"XXXXXXXXXXXXXX"},{"content":"","permalink":"https://gopherding.github.io/posts/read/%E6%A8%A1%E6%9D%BF---%E5%89%AF%E6%9C%AC-4/","summary":"","title":"XXXXXXXXXXXXXX"},{"content":"","permalink":"https://gopherding.github.io/posts/read/%E6%A8%A1%E6%9D%BF/","summary":"","title":"XXXXXXXXXXXXXX"},{"content":"本文摘自：https://www.cnblogs.com/you-men/p/13884645.html\n同时参考了：https://zhuanlan.zhihu.com/p/37081073\nnsqd: 是一个进程监听了http,tcp两种协议, 用来创建topic,channel, 分发消息给消费者,向nsqlooup 注册自己的元数据信息(topic、channel、consumer)，自己的服务信息，最核心模块。\nnsqd 是一个守护进程，负责接收，排队，投递消息给客户端。也就是说这个服务是干活的。它可以独立运行，不过通常它是由 nsqlookupd 实例所在集群配置的。\n/* 特性: 1. 对订阅了同一个topic，同一个channel的消费者使用负载均衡策略（不是轮询） 2. 只要channel存在，即使没有该channel的消费者，也会将生产者的message缓存到队列中（注意消息的过期处理） 3. 保证队列中的message至少会被消费一次，即使nsqd退出，也会将队列中的消息暂存磁盘上(结束进程等意外情况除外) 4. 限定内存占用，能够配置nsqd中每个channel队列在内存中缓存的message数量，一旦超出，message将被缓存到磁盘中 5. topic，channel一旦建立，将会一直存在，要及时在管理台或者用代码清除无效的topic和channel，避免资源的浪费 */ nsqlookup: 存储了nsqd的元数据和服务信息(endpoind),向消费者提供服务发现功能, 向nsqadmin提供数据查询功能.\nnsqlookupd 是守护进程负责管理拓扑信息。客户端通过查询 nsqlookupd 来发现指定话题（topic）的生产者，并且 nsqd 节点广播话题（topic）和通道（channel）信息。也就是说nsqlookupd是管理者。\n/* 特性: 1. 唯一性，在一个Nsq服务中只有一个nsqlookupd服务。当然也可以在集群中部署多个nsqlookupd，但它们之间是没有关联的. 2. 去中心化，即使nsqlookupd崩溃，也会不影响正在运行的nsqd服务 3. 充当nsqd和naqadmin信息交互的中间件 4. 提供一个http查询服务，给客户端定时更新nsqd的地址目录. */ nsqadmin: 简单的管理界面,展示了topic, channel以及channel上的消费者,也可以创建topic,channel\n/* 特性: 1. 提供一个对topic和channel统一管理的操作界面以及各种实时监控数据的展示，界面设计的很简洁，操作也很简单 2. 展示所有message的数量 3. 能够在后台创建topic和channel 4. nsqadmin的所有功能都必须依赖于nsqlookupd，nsqadmin只是向nsqlookupd传递用户操作并展示来自nsqlookupd的数据 */ Topic和Channel：\n每个nsqd实例旨在一次处理多个数据流。这些数据流称为“topics”，一个topic具有1个或多个“channels”。每个channel都会收到topic所有消息的副本，实际上下游的服务是通过对应的channel来消费topic消息。\ntopic和channel不是预先配置的。topic在首次使用时创建，方法是将其发布到指定topic，或者订阅指定topic上的channel。channel是通过订阅指定的channel在第一次使用时创建的。\ntopic和channel都相互独立地缓冲数据，防止缓慢的消费者导致其他chennel的积压（同样适用于topic级别）。\nchannel可以并且通常会连接多个客户端。假设所有连接的客户端都处于准备接收消息的状态，则每条消息将被传递到随机客户端。\n生产者向某个topic中发送消息，如果topic有一个或者多个channel，那么该消息会被复制多分发送到每一个channel中。类似 rabbitmq中的fanout类型，channel类似队列。 官方说 nsq 是分布式的消息队列服务，但是在我看来只有channel到消费者这部分提现出来分布式的感觉，nsqd 这个模块其实就是单点的，nsqd 将 topic、channel、以及消息都存储在了本地磁盘，官方还建议一个生产者使用一个 nsqd，这样不仅浪费资源还没有数据备份的保障。一旦 nsqd 所在的主机磁损坏，数据都将丢失。 总而言之,消息是从topic--\u0026gt; channel (每个channel接受该topic的所有消息的副本)多播的,但是从channel --\u0026gt; consumers均匀分布 (每个消费者接受该channel的一部分消息) ","permalink":"https://gopherding.github.io/posts/tech/nsq%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/","summary":"本文摘自：https://www.cnblogs.com/you-men/p/13884645.html 同时参考了：https://zhuanlan.zhihu.com/p/37081073 nsqd: 是一个进程监听了http,tcp两种协议, 用来创建topic,channel, 分发消息给","title":"NSQ组件介绍"},{"content":" 架构设计 Kafka 分布式架构的分层结构：Kafka 具有高度分布式的架构，包含生产者（Producer）、消费者（Consumer）、Broker（服务器节点）和 Zookeeper（用于管理集群配置、选举等元数据）。生产者将消息发送到 Broker，消费者从 Broker 获取消息。其中，Broker 采用分区（Partition）机制，每个主题（Topic）可以被划分为多个分区，消息被均匀地分配到这些分区中进行存储和处理。 集群协调机制：依赖 Zookeeper 进行集群协调，如 Broker 的状态管理、领导者选举等。例如，当一个 Broker 出现故障时，Zookeeper 能够协助重新选举领导者，以确保集群的正常运行。 NSQ 简单的分布式消息传递组件：NSQ 主要由生产者、消费者和 NSQ 守护进程（nsqd）组成。生产者将消息发送到 nsqd，nsqd 负责存储和转发消息给消费者。它没有像 Kafka 那样依赖额外的组件进行集群协调。 基于内存和磁盘的存储方式：nsqd 将消息先存储在内存队列中，然后定期将消息刷写到磁盘上进行持久化。这种方式相对 Kafka 分区存储的概念更为简单直接。 消息传递语义 Kafka 支持多种消息传递语义： 最多一次（At - Most - Once）：消息可能会丢失，适用于对数据准确性要求不高的场景，如日志收集的某些情况，因为即使部分日志消息丢失，对整体日志分析影响不大。 最少一次（At - Least - Once）：消息不会丢失，但可能会被重复处理。例如，在一些数据采集场景中，即使消息被重复处理，只要最终数据完整即可。 精确一次（Exactly - Once）：通过事务机制和幂等性消费等手段，确保消息既不丢失也不重复处理，在金融交易数据传输等对准确性要求极高的场景中有重要意义。 消息顺序保证：在每个分区内，消息是有序的。如果要保证消息在整个主题上的顺序，需要将主题设置为单分区，但这会影响可扩展性。 NSQ 以最少一次（At - Least - Once）为主：通过重传机制确保消息不会丢失，但可能会导致消息重复处理，在消息处理失败（如消费者崩溃）时会将消息重新放入队列等待重新处理。 消息顺序保证：在 NSQ 守护进程中的每个分区（Topic 中的分区）内消息是按顺序存储的，消费者通过有序消费和确认机制来保证消息顺序，但在分布式环境下整体顺序保证相对复杂。 性能和扩展性 Kafka 高吞吐量和低延迟：Kafka 设计用于处理大规模数据的高效传输。其分区机制和批量处理的特性使得它能够在高并发场景下实现高吞吐量，例如在大数据分析场景中，可以处理海量的日志数据传输。同时，它也能保持较低的延迟，满足实时性要求较高的应用场景。 水平扩展性强：通过增加 Broker 节点和分区数量，可以轻松扩展集群的处理能力。新的 Broker 可以加入集群分担负载，并且可以动态调整分区数量来适应数据增长。 NSQ 中等吞吐量和延迟特性：NSQ 的性能适用于一般规模的消息处理场景。它的内存队列和磁盘持久化机制在处理消息时相对简单，性能上不如 Kafka 在大规模数据传输时那么高效，但在中小规模场景下能够满足需求。 扩展性相对有限：虽然可以增加 nsqd 的数量来扩展，但在集群协调和整体架构的复杂性方面，不如 Kafka 那样易于大规模扩展。 数据持久化和可靠性 Kafka 可靠的持久化机制：消息被持久化到磁盘上的日志文件中，并且通过多副本（Replica）机制来确保数据的可靠性。每个分区可以有多个副本分布在不同的 Broker 上，当一个 Broker 故障时，其他副本可以继续提供服务，保证数据不丢失。 数据保留策略：可以根据时间或者消息大小等设置数据保留策略，例如可以设置只保留最近 7 天的消息或者当消息总量达到一定大小后开始删除旧消息。 NSQ 内存与磁盘结合的持久化：如前面所述，先将消息存储在内存队列中，再定期刷写到磁盘。这种方式在一定程度上确保了数据的持久性，但相对 Kafka 的多副本磁盘持久化，在可靠性方面可能稍逊一筹。 重传机制保障数据不丢失：通过重传机制确保消息在处理过程中不会因为消费者故障等原因丢失，但在磁盘故障等极端情况下，数据的恢复能力可能不如 Kafka。 应用场景 Kafka 大数据处理和日志系统：由于其高吞吐量、可扩展性和多种消息传递语义，非常适合大数据分析中的数据采集、日志收集与传输等场景。例如在大型互联网公司中收集服务器的日志数据，然后进行分布式处理和分析。 实时流处理：也适用于实时流处理场景，如实时监控数据的传输和分析，能够在保证低延迟的同时处理大量的实时数据。 NSQ 中小规模消息处理：适用于对吞吐量要求不是特别高的中小规模消息处理场景，如一些内部业务系统中的简单消息通知、任务队列等。例如在一个小型电商公司内部，用于订单状态更新通知等场景。 ","permalink":"https://gopherding.github.io/posts/tech/nsq%E5%92%8Ckafka%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/","summary":"架构设计 Kafka 分布式架构的分层结构：Kafka 具有高度分布式的架构，包含生产者（Producer）、消费者（Consumer）、Broker（服务器节点）和 Zookeeper（用于管理集群配置、选举等元数据）。生产者将消息发送到 Broker，消费者从 Broker 获取消息。其中，Broker 采用","title":"NSQ和kafka的技术选型"},{"content":"矛盾论 （一九三七年八月）\n这篇哲学论文，是毛泽东继《实践论》之后，为了同一的目的，即为了克服存在于中国共产党内的严重的教条主义思想而写的，曾在延安的抗日军事政治大学作过讲演。在收入本书第一版的时候，作者作了部分的补充、删节和修改。\n事物的矛盾法则，即对立统一的法则，是唯物辩证法的最根本的法则。列宁说：“就本来的意义讲，辩证法是研究对象的本质自身中的矛盾。”[1]列宁常称这个法则为辩证法的本质，又称之为辩证法的核心[2]。因此，我们在研究这个法则时，不得不涉及广泛的方面，不得不涉及许多的哲学问题。如果我们将这些问题都弄清楚了，我们就在根本上懂得了唯物辩证法。这些问题是：两种宇宙观；矛盾的普遍性；矛盾的特殊性；主要的矛盾和主要的矛盾方面；矛盾诸方面的同一性和斗争性；对抗在矛盾中的地位。 苏联哲学界在最近数年中批判了德波林学派[3]的唯心论，这件事引起了我们的极大的兴趣。德波林的唯心论在中国共产党内发生了极坏的影响，我们党内的教条主义思想不能说和这个学派的作风没有关系。因此，我们现在的哲学研究工作，应当以扫除教条主义思想为主要的目标。\n一　两种宇宙观 在人类的认识史中，从来就有关于宇宙发展法则的两种见解，一种是形而上学的见解，一种是辩证法的见解，形成了互相对立的两种宇宙观。列宁说：“对于发展（进化）所持的两种基本的（或两种可能的？或两种在历史上常见的？）观点是：（一）认为发展是减少和增加，是重复；（二）认为发展是对立的统一（统一物分成为两个互相排斥的对立，而两个对立又互相关联着）。”[4]列宁说的就是这两种不同的宇宙观。 形而上学，亦称玄学。这种思想，无论在中国，在欧洲，在一个很长的历史时间内，是属于唯心论的宇宙观，并在人们的思想中占了统治的地位。在欧洲，资产阶级初期的唯物论，也是形而上学的。由于欧洲许多国家的社会经济情况进到了资本主义高度发展的阶段，生产力、阶级斗争和科学均发展到了历史上未有过的水平，工业无产阶级成为历史发展的最伟大的动力，因而产生了马克思主义的唯物辩证法的宇宙观。于是，在资产阶级那里，除了公开的极端露骨的反动的唯心论之外，还出现了庸俗的进化论，出来对抗唯物辩证法。 所谓形而上学的或庸俗进化论的宇宙观，就是用孤立的、静止的和片面的观点去看世界。这种宇宙观把世界一切事物，一切事物的形态和种类，都看成是永远彼此孤立和永远不变化的。如果说有变化，也只是数量的增减和场所的变更。而这种增减和变更的原因，不在事物的内部而在事物的外部，即是由于外力的推动。形而上学家认为，世界上各种不同事物和事物的特性，从它们一开始存在的时候就是如此。后来的变化，不过是数量上的扩大或缩小。他们认为一种事物永远只能反复地产生为同样的事物，而不能变化为另一种不同的事物。在形而上学家看来，资本主义的剥削，资本主义的竞争，资本主义社会的个人主义思想等，就是在古代的奴隶社会里，甚至在原始社会里，都可以找得出来，而且会要永远不变地存在下去。说到社会发展的原因，他们就用社会外部的地理、气候等条件去说明。他们简单地从事物外部去找发展的原因，否认唯物辩证法所主张的事物因内部矛盾引起发展的学说。因此，他们不能解释事物的质的多样性，不能解释一种质变为他种质的现象。这种思想，在欧洲，在十七世纪和十八世纪是机械唯物论，在十九世纪末和二十世纪初则有庸俗进化论。在中国，则有所谓“天不变，道亦不变”[5]的形而上学的思想，曾经长期地为腐朽了的封建统治阶级所拥护。近百年来输入了欧洲的机械唯物论和庸俗进化论，则为资产阶级所拥护。 和形而上学的宇宙观相反，唯物辩证法的宇宙观主张从事物的内部、从一事物对他事物的关系去研究事物的发展，即把事物的发展看做是事物内部的必然的自己的运动，而每一事物的运动都和它的周围其它事物互相联系着和互相影响着。事物发展的根本原因，不是在事物的外部而是在事物的内部，在于事物内部的矛盾性。任何事物内部都有这种矛盾性，因此引起了事物的运动和发展。事物内部的这种矛盾性是事物发展的根本原因，一事物和他事物的互相联系和互相影响则是事物发展的第二位的原因。这样，唯物辩证法就有力地反对了形而上学的机械唯物论和庸俗进化论的外因论或被动论。这是清楚的，单纯的外部原因只能引起事物的机械的运动，即范围的大小，数量的增减，不能说明事物何以有性质上的千差万别及其互相变化。事实上，即使是外力推动的机械运动，也要通过事物内部的矛盾性。植物和动物的单纯的增长，数量的发展，主要地也是由于内部矛盾所引起的。同样，社会的发展，主要地不是由于外因而是由于内因。许多国家在差不多一样的地理和气候的条件下，它们发展的差异性和不平衡性，非常之大。同一个国家吧，在地理和气候并没有变化的情形下，社会的变化却是很大的。帝国主义的俄国变为社会主义的苏联，封建的闭关锁国的日本变为帝国主义的日本，这些国家的地理和气候并没有变化。长期地被封建制度统治的中国，近百年来发生了很大的变化，现在正在变化到一个自由解放的新中国的方向去，中国的地理和气候并没有变化。整个地球及地球各部分的地理和气候也是变化着的，但以它们的变化和社会的变化相比较，则显得很微小，前者是以若干万年为单位而显现其变化的，后者则在几千年、几百年、几十年、甚至几年或几个月（在革命时期）内就显现其变化了。按照唯物辩证法的观点，自然界的变化，主要地是由于自然界内部矛盾的发展。社会的变化，主要地是由于社会内部矛盾的发展，即生产力和生产关系的矛盾，阶级之间的矛盾，新旧之间的矛盾，由于这些矛盾的发展，推动了社会的前进，推动了新旧社会的代谢。唯物辩证法是否排除外部的原因呢？并不排除。唯物辩证法认为外因是变化的条件，内因是变化的根据，外因通过内因而起作用。鸡蛋因得适当的温度而变化为鸡子，但温度不能使石头变为鸡子，因为二者的根据是不同的。各国人民之间的互相影响是时常存在的。在资本主义时代，特别是在帝国主义和无产阶级革命的时代，各国在政治上、经济上和文化上的互相影响和互相激动，是极其巨大的。十月社会主义革命不只是开创了俄国历史的新纪元，而且开创了世界历史的新纪元，影响到世界各国内部的变化，同样地而且还特别深刻地影响到中国内部的变化，但是这种变化是通过了各国内部和中国内部自己的规律性而起的。两军相争，一胜一败，所以胜败，皆决于内因。胜者或因其强，或因其指挥无误，败者或因其弱，或因其指挥失宜，外因通过内因而引起作用。一九二七年中国大资产阶级战败了无产阶级，是通过中国无产阶级内部的（中国共产党内部的）机会主义而起作用的。当着我们清算了这种机会主义的时候，中国革命就重新发展了。后来，中国革命又受了敌人的严重的打击，是因为我们党内产生了冒险主义。当着我们清算了这种冒险主义的时候，我们的事业就又重新发展了。由此看来，一个政党要引导革命到胜利，必须依靠自己政治路线的正确和组织上的巩固。 辩证法的宇宙观，不论在中国，在欧洲，在古代就产生了。但是古代的辩证法带着自发的朴素的性质，根据当时的社会历史条件，还不可能有完备的理论，因而不能完全解释宇宙，后来就被形而上学所代替。生活在十八世纪末和十九世纪初期的德国著名哲学家黑格尔，对于辩证法曾经给了很重要的贡献，但是他的辩证法却是唯心的辩证法。直到无产阶级运动的伟大的活动家马克思和恩格斯综合了人类认识史的积极的成果，特别是批判地吸取了黑格尔的辩证法的合理的部分，创造了辩证唯物论和历史唯物论这个伟大的理论，才在人类认识史上起了一个空前的大革命。后来，经过列宁和斯大林，又发展了这个伟大的理论。这个理论一经传到中国来，就在中国思想界引起了极大的变化。 这个辩证法的宇宙观，主要地就是教导人们要善于去观察和分析各种事物的矛盾的运动，并根据这种分析，指出解决矛盾的方法。因此，具体地了解事物矛盾这一个法则，对于我们是非常重要的。\n二　矛盾的普遍性 为了叙述的便利起见，我在这里先说矛盾的普遍性，再说矛盾的特殊性。这是因为马克思主义的伟大的创造者和继承者马克思、恩格斯、列宁、斯大林他们发现了唯物辩证法的宇宙观，已经把唯物辩证法应用在人类历史的分析和自然历史的分析的许多方面，应用在社会的变革和自然的变革（例如在苏联）的许多方面，获得了极其伟大的成功，矛盾的普遍性已经被很多人所承认，因此，关于这个问题只需要很少的话就可以说明白；而关于矛盾的特殊性的问题，则还有很多的同志，特别是教条主义者，弄不清楚。他们不了解矛盾的普遍性即寓于矛盾的特殊性之中。他们也不了解研究当前具体事物的矛盾的特殊性，对于我们指导革命实践的发展有何等重要的意义。因此，关于矛盾的特殊性的问题应当着重地加以研究，并用足够的篇幅加以说明。为了这个缘故，当着我们分析事物矛盾的法则的时候，我们就先来分析矛盾的普遍性的问题，然后再着重地分析矛盾的特殊性的问题，最后仍归到矛盾的普遍性的问题。 矛盾的普遍性或绝对性这个问题有两方面的意义。其一是说，矛盾存在于一切事物的发展过程中；其二是说，每一事物的发展过程中存在着自始至终的矛盾运动。 恩格斯说：“运动本身就是矛盾。”[6]列宁对于对立统一法则所下的定义，说它就是“承认（发现）自然界（精神和社会两者也在内）的一切现象和过程都含有互相矛盾、互相排斥、互相对立的趋向”[7]。这些意见是对的吗？是对的。一切事物中包含的矛盾方面的相互依赖和相互斗争，决定一切事物的生命，推动一切事物的发展。没有什么事物是不包含矛盾的，没有矛盾就没有世界。 矛盾是简单的运动形式（例如机械性的运动）的基础，更是复杂的运动形式的基础。 恩格斯这样说明过矛盾的普遍性：“如果简单的机械的移动本身包含着矛盾，那末，物质的更高的运动形式，特别是有机生命及其发展，就更加包含着矛盾。……生命首先就在于：生物在每一个瞬间是它自身，但却又是别的什么。所以，生命也是存在于物体和过程本身中的不断地自行产生并自行解决的矛盾；这一矛盾一停止，生命亦即停止，于是死就来到。同样，我们看到了，在思维的范围以内我们也不能避免矛盾，并且我们看到了，例如，人的内部无限的认识能力与此种认识能力仅在外部被局限的而且认识上也被局限的个别人们身上的实际的实现二者之间的矛盾，是在人类世代的无穷的——至少对于我们，实际上是无穷的——连续系列之中，是在无穷的前进运动之中解决的。” “高等数学的主要基础之一，就是矛盾……” “就是初等数学，也充满着矛盾。……”[8] 列宁也这样说明过矛盾的普遍性：“在数学中，正和负，微分和积分。 在力学中，作用和反作用。 在物理学中，阳电和阴电。 在化学中，原子的化合和分解。 在社会科学中，阶级斗争。”[9] 战争中的攻守，进退，胜败，都是矛盾着的现象。失去一方，他方就不存在。双方斗争而又联结，组成了战争的总体，推动了战争的发展，解决了战争的问题。 人的概念的每一差异，都应把它看作是客观矛盾的反映。客观矛盾反映入主观的思想，组成了概念的矛盾运动，推动了思想的发展，不断地解决了人们的思想问题。 党内不同思想的对立和斗争是经常发生的，这是社会的阶级矛盾和新旧事物的矛盾在党内的反映。党内如果没有矛盾和解决矛盾的思想斗争，党的生命也就停止了。 由此看来，不论是简单的运动形式，或复杂的运动形式，不论是客观现象，或思想现象，矛盾是普遍地存在着，矛盾存在于一切过程中，这一点已经弄清楚了。但是每一过程的开始阶段，是否也有矛盾存在呢？是否每一事物的发展过程具有自始至终的矛盾运动呢？ 从苏联哲学界批判德波林学派的文章中看出，德波林学派有这样一种见解，他们认为矛盾不是一开始就在过程中出现，须待过程发展到一定的阶段才出现。那末，在那一时间以前，过程发展的原因不是由于内部的原因，而是由于外部的原因了。这样，德波林回到形而上学的外因论和机械论去了。拿这种见解去分析具体的问题，他们就看见在苏联条件下富农和一般农民之间只有差异，并无矛盾，完全同意了布哈林的意见。在分析法国革命时，他们就认为在革命前，工农资产阶级合组的第三等级中，也只有差异，并无矛盾。德波林学派这类见解是反马克思主义的。他们不知道世界上的每一差异中就已经包含着矛盾，差异就是矛盾。劳资之间，从两阶级发生的时候起，就是互相矛盾的，仅仅还没有激化而已。工农之间，即使在苏联的社会条件下，也有差异，它们的差异就是矛盾，仅仅不会激化成为对抗，不取阶级斗争的形态，不同于劳资间的矛盾；它们在社会主义建设中形成巩固的联盟，并在由社会主义走向共产主义的发展过程中逐渐地解决这个矛盾。这是矛盾的差别性的问题，不是矛盾的有无的问题。矛盾是普遍的、绝对的，存在于事物发展的一切过程中，又贯串于一切过程的始终。 新过程的发生是什么呢？这是旧的统一和组成此统一的对立成分让位于新的统一和组成此统一的对立成分，于是新过程就代替旧过程而发生。旧过程完结了，新过程发生了。新过程又包含着新矛盾，开始它自己的矛盾发展史。 事物发展过程的自始至终的矛盾运动，列宁指出马克思在《资本论》中模范地作了这样的分析。这是研究任何事物发展过程所必须应用的方法。列宁自己也正确地应用了它，贯彻于他的全部著作中。 “马克思在《资本论》中，首先分析的是资产阶级社会（商品社会）里最简单的、最普通的、最基本的、最常见的、最平常的、碰到亿万次的关系——商品交换。这一分析在这个最简单的现象之中（资产阶级社会的这个‘细胞’之中）暴露了现代社会的一切矛盾（以及一切矛盾的胚芽）。往后的叙述又向我们表明了这些矛盾和这个社会各个部分总和的自始至终的发展（增长与运动两者）。” 列宁说了上面的话之后，接着说道：“这应该是一般辩证法的……叙述（以及研究）方法。”[10] 中国共产党人必须学会这个方法，才能正确地分析中国革命的历史和现状，并推断革命的将来。\n三　矛盾的特殊性 矛盾存在于一切事物发展的过程中，矛盾贯串于每一事物发展过程的始终，这是矛盾的普遍性和绝对性，前面已经说过了。现在来说矛盾的特殊性和相对性。 这个问题，应从几种情形中去研究。 首先是各种物质运动形式中的矛盾，都带特殊性。人的认识物质，就是认识物质的运动形式，因为除了运动的物质以外，世界上什么也没有，而物质的运动则必取一定的形式。对于物质的每一种运动形式，必须注意它和其它各种运动形式的共同点。但是，尤其重要的，成为我们认识事物的基础的东西，则是必须注意它的特殊点，就是说，注意它和其它运动形式的质的区别。只有注意了这一点，才有可能区别事物。任何运动形式，其内部都包含着本身特殊的矛盾。这种特殊的矛盾，就构成一事物区别于他事物的特殊的本质。这就是世界上诸种事物所以有千差万别的内在的原因，或者叫做根据。自然界存在着许多的运动形式，机械运动、发声、发光、发热、电流、化分、化合等等都是。所有这些物质的运动形式，都是互相依存的，又是本质上互相区别的。每一物质的运动形式所具有的特殊的本质，为它自己的特殊的矛盾所规定。这种情形，不但在自然界中存在着，在社会现象和思想现象中也是同样地存在着。每一种社会形式和思想形式，都有它的特殊的矛盾和特殊的本质。 科学研究的区分，就是根据科学对象所具有的特殊的矛盾性。因此，对于某一现象的领域所特有的某一种矛盾的研究，就构成某一门科学的对象。例如，数学中的正数和负数，机械学中的作用和反作用，物理学中的阴电和阳电，化学中的化分和化合，社会科学中的生产力和生产关系、阶级和阶级的互相斗争，军事学中的攻击和防御，哲学中的唯心论和唯物论、形而上学观和辩证法观等等，都是因为具有特殊的矛盾和特殊的本质，才构成了不同的科学研究的对象。固然，如果不认识矛盾的普遍性，就无从发现事物运动发展的普遍的原因或普遍的根据；但是，如果不研究矛盾的特殊性，就无从确定一事物不同于他事物的特殊的本质，就无从发现事物运动发展的特殊的原因，或特殊的根据，也就无从辨别事物，无从区分科学研究的领域。 就人类认识运动的秩序说来，总是由认识个别的和特殊的事物，逐步地扩大到认识一般的事物。人们总是首先认识了许多不同事物的特殊的本质，然后才有可能更进一步地进行概括工作，认识诸种事物的共同的本质。当着人们已经认识了这种共同的本质以后，就以这种共同的认识为指导，继续地向着尚未研究过的或者尚未深入地研究过的各种具体的事物进行研究，找出其特殊的本质，这样才可以补充、丰富和发展这种共同的本质的认识，而使这种共同的本质的认识不致变成枯槁的和僵死的东西。这是两个认识的过程：一个是由特殊到一般，一个是由一般到特殊。人类的认识总是这样循环往复地进行的，而每一次的循环（只要是严格地按照科学的方法）都可能使人类的认识提高一步，使人类的认识不断地深化。我们的教条主义者在这个问题上的错误，就是，一方面，不懂得必须研究矛盾的特殊性，认识各别事物的特殊的本质，才有可能充分地认识矛盾的普遍性，充分地认识诸种事物的共同的本质；另一方面，不懂得在我们认识了事物的共同的本质以后，还必须继续研究那些尚未深入地研究过的或者新冒出来的具体的事物。我们的教条主义者是懒汉，他们拒绝对于具体事物做任何艰苦的研究工作，他们把一般真理看成是凭空出现的东西，把它变成为人们所不能够捉摸的纯粹抽象的公式，完全否认了并且颠倒了这个人类认识真理的正常秩序。他们也不懂得人类认识的两个过程的互相联结——由特殊到一般，又由一般到特殊，他们完全不懂得马克思主义的认识论。 不但要研究每一个大系统的物质运动形式的特殊的矛盾性及其所规定的本质，而且要研究每一个物质运动形式在其发展长途中的每一个过程的特殊的矛盾及其本质。一切运动形式的每一个实在的非臆造的发展过程内，都是不同质的。我们的研究工作必须着重这一点，而且必须从这一点开始。 不同质的矛盾，只有用不同质的方法才能解决。例如，无产阶级和资产阶级的矛盾，用社会主义革命的方法去解决；人民大众和封建制度的矛盾，用民主革命的方法去解决；殖民地和帝国主义的矛盾，用民族革命战争的方法去解决；在社会主义社会中工人阶级和农民阶级的矛盾，用农业集体化和农业机械化的方法去解决；共产党内的矛盾，用批评和自我批评的方法去解决；社会和自然的矛盾，用发展生产力的方法去解决。过程变化，旧过程和旧矛盾消灭，新过程和新矛盾发生，解决矛盾的方法也因之而不同。俄国的二月革命和十月革命所解决的矛盾及其所用以解决矛盾的方法是根本上不相同的。用不同的方法去解决不同的矛盾，这是马克思列宁主义者必须严格地遵守的一个原则。教条主义者不遵守这个原则，他们不了解诸种革命情况的区别，因而也不了解应当用不同的方法去解决不同的矛盾，而只是千篇一律地使用一种自以为不可改变的公式到处硬套，这就只能使革命遭受挫折，或者将本来做得好的事情弄得很坏。 为要暴露事物发展过程中的矛盾在其总体上、在其相互联结上的特殊性，就是说暴露事物发展过程的本质，就必须暴露过程中矛盾各方面的特殊性，否则暴露过程的本质成为不可能，这也是我们作研究工作时必须十分注意的。 一个大的事物，在其发展过程中，包含着许多的矛盾。例如，在中国资产阶级民主革命过程中，有中国社会各被压迫阶级和帝国主义的矛盾，有人民大众和封建制度的矛盾，有无产阶级和资产阶级的矛盾，有农民及城市小资产阶级和资产阶级的矛盾，有各个反动的统治集团之间的矛盾等等，情形是非常复杂的。这些矛盾，不但各各有其特殊性，不能一律看待，而且每一矛盾的两方面，又各各有其特点，也是不能一律看待的。我们从事中国革命的人，不但要在各个矛盾的总体上，即矛盾的相互联结上，了解其特殊性，而且只有从矛盾的各个方面着手研究，才有可能了解其总体。所谓了解矛盾的各个方面，就是了解它们每一方面各占何等特定的地位，各用何种具体形式和对方发生互相依存又互相矛盾的关系，在互相依存又互相矛盾中，以及依存破裂后，又各用何种具体的方法和对方作斗争。研究这些问题，是十分重要的事情。列宁说：马克思主义的最本质的东西，马克思主义的活的灵魂，就在于具体地分析具体的情况[11]。就是说的这个意思。我们的教条主义者违背列宁的指示，从来不用脑筋具体地分析任何事物，做起文章或演说来，总是空洞无物的八股调，在我们党内造成了一种极坏的作风。 研究问题，忌带主观性、片面性和表面性。所谓主观性，就是不知道客观地看问题，也就是不知道用唯物的观点去看问题。这一点，我在《实践论》一文中已经说过了。所谓片面性，就是不知道全面地看问题。例如：只了解中国一方、不了解日本一方，只了解共产党一方、不了解国民党一方，只了解无产阶级一方、不了解资产阶级一方，只了解农民一方、不了解地主一方，只了解顺利情形一方、不了解困难情形一方，只了解过去一方、不了解将来一方，只了解个体一方、不了解总体一方，只了解缺点一方、不了解成绩一方，只了解原告一方、不了解被告一方，只了解革命的秘密工作一方、不了解革命的公开工作一方，如此等等。一句话，不了解矛盾各方的特点。这就叫做片面地看问题。或者叫做只看见局部，不看见全体，只看见树木，不看见森林。这样，是不能找出解决矛盾的方法的，是不能完成革命任务的，是不能做好所任工作的，是不能正确地发展党内的思想斗争的。孙子论军事说：“知彼知己，百战不殆。”[12]他说的是作战的双方。唐朝人魏征说过：“兼听则明，偏信则暗。”[13]也懂得片面性不对。可是我们的同志看问题，往往带片面性，这样的人就往往碰钉子。《水浒传》上宋江三打祝家庄[14]，两次都因情况不明，方法不对，打了败仗。后来改变方法，从调查情形入手，于是熟悉了盘陀路，拆散了李家庄、扈家庄和祝家庄的联盟，并且布置了藏在敌人营盘里的伏兵，用了和外国故事中所说木马计[15]相像的方法，第三次就打了胜仗。《水浒传》上有很多唯物辩证法的事例，这个三打祝家庄，算是最好的一个。列宁说：“要真正地认识对象，就必须把握和研究它的一切方面、一切联系和‘媒介’。我们决不会完全地作到这一点，可是要求全面性，将使我们防止错误，防止僵化。”[16]我们应该记得他的话。表面性，是对矛盾总体和矛盾各方的特点都不去看，否认深入事物里面精细地研究矛盾特点的必要，仅仅站在那里远远地望一望，粗枝大叶地看到一点矛盾的形相，就想动手去解决矛盾（答复问题、解决纠纷、处理工作、指挥战争）。这样的做法，没有不出乱子的。中国的教条主义和经验主义的同志们所以犯错误，就是因为他们看事物的方法是主观的、片面的和表面的。片面性、表面性也是主观性，因为一切客观事物本来是互相联系的和具有内部规律的，人们不去如实地反映这些情况，而只是片面地或表面地去看它们，不认识事物的互相联系，不认识事物的内部规律，所以这种方法是主观主义的。 不但事物发展的全过程中的矛盾运动，在其相互联结上，在其各方情况上，我们必须注意其特点，而且在过程发展的各个阶段中，也有其特点，也必须注意。 事物发展过程的根本矛盾及为此根本矛盾所规定的过程的本质，非到过程完结之日，是不会消灭的；但是事物发展的长过程中的各个发展的阶段，情形又往往互相区别。这是因为事物发展过程的根本矛盾的性质和过程的本质虽然没有变化，但是根本矛盾在长过程中的各个发展阶段上采取了逐渐激化的形式。并且，被根本矛盾所规定或影响的许多大小矛盾中，有些是激化了，有些是暂时地或局部地解决了，或者缓和了，又有些是发生了，因此，过程就显出阶段性来。如果人们不去注意事物发展过程中的阶段性，人们就不能适当地处理事物的矛盾。 例如，自由竞争时代的资本主义发展为帝国主义，这时，无产阶级和资产阶级这两个根本矛盾着的阶级的性质和这个社会的资本主义的本质，并没有变化；但是，两阶级的矛盾激化了，独占资本和自由资本之间的矛盾发生了，宗主国和殖民地的矛盾激化了，各资本主义国家间的矛盾即由各国发展不平衡的状态而引起的矛盾特别尖锐地表现出来了，因此形成了资本主义的特殊阶段，形成了帝国主义阶段。列宁主义之所以成为帝国主义和无产阶级革命时代的马克思主义，就是因为列宁和斯大林正确地说明了这些矛盾，并正确地作出了解决这些矛盾的无产阶级革命的理论和策略。 拿从辛亥革命[17]开始的中国资产阶级民主革命过程的情形来看，也有了若干特殊阶段。特别是在资产阶级领导时期的革命和在无产阶级领导时期的革命，区别为两个很大不同的历史阶段。这就是：由于无产阶级的领导，根本地改变了革命的面貌，引出了阶级关系的新调度，农民革命的大发动，反帝国主义和反封建主义的革命彻底性，由民主革命转变到社会主义革命的可能性，等等。所有这些，都是在资产阶级领导革命时期不可能出现的。虽然整个过程中根本矛盾的性质，过程之反帝反封建的民主革命的性质（其反面是半殖民地半封建的性质），并没有变化，但是，在这长时间中，经过了辛亥革命失败和北洋军阀统治，第一次民族统一战线的建立和一九二四年至一九二七年的革命，统一战线破裂和资产阶级转入反革命，新的军阀战争，土地革命战争，第二次民族统一战线建立和抗日战争等等大事变，二十多年间经过了几个发展阶段。在这些阶段中，包含着有些矛盾激化了（例如土地革命战争和日本侵入东北四省[18]），有些矛盾部分地或暂时地解决了（例如北洋军阀的被消灭，我们没收了地主的土地），有些矛盾重新发生了（例如新军阀之间的斗争，南方各革命根据地丧失后地主又重新收回土地）等等特殊的情形。 研究事物发展过程中的各个发展阶段上的矛盾的特殊性，不但必须在其联结上、在其总体上去看，而且必须从各个阶段中矛盾的各个方面去看。 例如国共两党。国民党方面，在第一次统一战线时期，因为它实行了孙中山的联俄、联共、援助工农的三大政策，所以它是革命的、有朝气的，它是各阶级的民主革命的联盟。一九二七年以后，国民党变到了与此相反的方面，成了地主和大资产阶级的反动集团。一九三六年十二月西安事变[19]后又开始向停止内战、联合共产党共同反对日本帝国主义这个方面转变。这就是国民党在三个阶段上的特点。形成这些特点，当然有种种的原因。中国共产党方面，在第一次统一战线时期，它是幼年的党，它英勇地领导了一九二四年至一九二七年的革命；但在对于革命的性质、任务和方法的认识方面，却表现了它的幼年性，因此在这次革命的后期所发生的陈独秀主义[20]能够起作用，使这次革命遭受了失败。一九二七年以后，它又英勇地领导了土地革命战争，创立了革命的军队和革命的根据地，但是它也犯过冒险主义的错误，使军队和根据地都受了很大的损失。一九三五年以后，它又纠正了冒险主义的错误，领导了新的抗日的统一战线，这个伟大的斗争现在正在发展。在这个阶段上，共产党是一个经过了两次革命的考验、有了丰富的经验的党。这些就是中国共产党在三个阶段上的特点。形成这些特点也有种种的原因。不研究这些特点，就不能了解两党在各个发展阶段上的特殊的相互关系：统一战线的建立，统一战线的破裂，再一个统一战线的建立。而要研究两党的种种特点，更根本的就必须研究这两党的阶级基础以及因此在各个时期所形成的它们和其它方面的矛盾的对立。例如，国民党在它第一次联合共产党的时期，一方面有和国外帝国主义的矛盾，因而它反对帝国主义；另一方面有和国内人民大众的矛盾，它在口头上虽然允许给予劳动人民以许多的利益，但在实际上则只给予很少的利益，或者简直什么也不给。在它进行反共战争的时期，则和帝国主义、封建主义合作反对人民大众，一笔勾销了人民大众原来在革命中所争得的一切利益，激化了它和人民大众的矛盾。现在抗日时期，国民党和日本帝国主义有矛盾，它一面要联合共产党，同时它对共产党和国内人民并不放松其斗争和压迫。共产党则无论在哪一时期，均和人民大众站在一道，反对帝国主义和封建主义；但在现在的抗日时期，由于国民党表示抗日，它对国民党和国内封建势力，也就采取了缓和的政策。由于这些情况，所以或者造成了两党的联合，或者造成了两党的斗争，而且即使在两党联合的时期也有又联合又斗争的复杂的情况。如果我们不去研究这些矛盾方面的特点，我们就不但不能了解这两个党各各和其它方面的关系，也不能了解两党之间的相互关系。 由此看来，不论研究何种矛盾的特性——各个物质运动形式的矛盾，各个运动形式在各个发展过程中的矛盾，各个发展过程的矛盾的各方面，各个发展过程在其各个发展阶段上的矛盾以及各个发展阶段上的矛盾的各方面，研究所有这些矛盾的特性，都不能带主观随意性，必须对它们实行具体的分析。离开具体的分析，就不能认识任何矛盾的特性。我们必须时刻记得列宁的话：对于具体的事物作具体的分析。 这种具体的分析，马克思、恩格斯首先给了我们以很好的模范。 当马克思、恩格斯把这事物矛盾的法则应用到社会历史过程的研究的时候，他们看出生产力和生产关系之间的矛盾，看出剥削阶级和被剥削阶级之间的矛盾以及由于这些矛盾所产生的经济基础和政治及思想等上层建筑之间的矛盾，而这些矛盾如何不可避免地会在各种不同的阶级社会中，引出各种不同的社会革命。 马克思把这一法则应用到资本主义社会经济结构的研究的时候，他看出这一社会的基本矛盾在于生产的社会性和占有制的私人性之间的矛盾。这个矛盾表现于在各别企业中的生产的有组织性和在全社会中的生产的无组织性之间的矛盾。这个矛盾的阶级表现则是资产阶级和无产阶级之间的矛盾。 由于事物范围的极其广大，发展的无限性，所以，在一定场合为普遍性的东西，而在另一一定场合则变为特殊性。反之，在一定场合为特殊性的东西，而在另一一定场合则变为普遍性。资本主义制度所包含的生产社会化和生产资料私人占有制的矛盾，是所有有资本主义的存在和发展的各国所共有的东西，对于资本主义说来，这是矛盾的普遍性。但是资本主义的这种矛盾，乃是一般阶级社会发展在一定历史阶段上的东西，对于一般阶级社会中的生产力和生产关系的矛盾说来，这是矛盾的特殊性。然而，当着马克思把资本主义社会这一切矛盾的特殊性解剖出来之后，同时也就更进一步地、更充分地、更完全地把一般阶级社会中这个生产力和生产关系的矛盾的普遍性阐发出来了。 由于特殊的事物是和普遍的事物联结的，由于每一个事物内部不但包含了矛盾的特殊性，而且包含了矛盾的普遍性，普遍性即存在于特殊性之中，所以，当着我们研究一定事物的时候，就应当去发现这两方面及其互相联结，发现一事物内部的特殊性和普遍性的两方面及其互相联结，发现一事物和它以外的许多事物的互相联结。斯大林在他的名著《论列宁主义基础》一书中说明列宁主义的历史根源的时候，他分析了列宁主义所由产生的国际环境，分析了在帝国主义条件下已经发展到极点的资本主义的诸矛盾，以及这些矛盾使无产阶级革命成为直接实践的问题，并造成了直接冲击资本主义的良好的条件。不但如此，他又分析了为什么俄国成为列宁主义的策源地，分析了沙皇俄国当时是帝国主义一切矛盾的集合点以及俄国无产阶级所以能够成为国际的革命无产阶级的先锋队的原因。这样，斯大林分析了帝国主义的矛盾的普遍性，说明列宁主义是帝国主义和无产阶级革命时代的马克思主义；又分析了沙俄帝国主义在这一般矛盾中所具有的特殊性，说明俄国成了无产阶级革命理论和策略的故乡，而在这种特殊性中间就包含了矛盾的普遍性。斯大林的这种分析，给我们提供了认识矛盾的特殊性和普遍性及其互相联结的模范。 马克思和恩格斯，同样地列宁和斯大林，他们对于应用辩证法到客观现象的研究的时候，总是指导人们不要带上任何的主观随意性，而必须从客观的实际运动所包含的具体的条件，去看出这些现象中的具体的矛盾、矛盾各方面的具体的地位以及矛盾的具体的相互关系。我们的教条主义者因为没有这种研究态度，所以弄得一无是处。我们必须以教条主义的失败为鉴戒，学会这种研究态度，舍此没有第二种研究法。 矛盾的普遍性和矛盾的特殊性的关系，就是矛盾的共性和个性的关系。其共性是矛盾存在于一切过程中，并贯串于一切过程的始终，矛盾即是运动，即是事物，即是过程，也即是思想。否认事物的矛盾就是否认了一切。这是共通的道理，古今中外，概莫能外。所以它是共性，是绝对性。然而这种共性，即包含于一切个性之中，无个性即无共性。假如除去一切个性，还有什么共性呢？因为矛盾的各各特殊，所以造成了个性。一切个性都是有条件地暂时地存在的，所以是相对的。 这一共性个性、绝对相对的道理，是关于事物矛盾的问题的精髓，不懂得它，就等于抛弃了辩证法。\n四　主要的矛盾和主要的矛盾方面 在矛盾特殊性的问题中，还有两种情形必须特别地提出来加以分析，这就是主要的矛盾和主要的矛盾方面。 在复杂的事物的发展过程中，有许多的矛盾存在，其中必有一种是主要的矛盾，由于它的存在和发展规定或影响着其它矛盾的存在和发展。 例如在资本主义社会中，无产阶级和资产阶级这两个矛盾着的力量是主要的矛盾；其它的矛盾力量，例如，残存的封建阶级和资产阶级的矛盾，农民小资产者和资产阶级的矛盾，无产阶级和农民小资产者的矛盾，自由资产阶级和垄断资产阶级的矛盾，资产阶级的民主主义和资产阶级的法西斯主义的矛盾，资本主义国家相互间的矛盾，帝国主义和殖民地的矛盾，以及其它的矛盾，都为这个主要的矛盾力量所规定、所影响。 半殖民地的国家如中国，其主要矛盾和非主要矛盾的关系呈现着复杂的情况。 当着帝国主义向这种国家举行侵略战争的时候，这种国家的内部各阶级，除开一些叛国分子以外，能够暂时地团结起来举行民族战争去反对帝国主义。这时，帝国主义和这种国家之间的矛盾成为主要的矛盾，而这种国家内部各阶级的一切矛盾（包括封建制度和人民大众之间这个主要矛盾在内），便都暂时地降到次要和服从的地位。中国一八四○年的鸦片战争[21]，一八九四年的中日战争[22]，一九○○年的义和团战争[23]和目前的中日战争，都有这种情形。 然而在另一种情形之下，则矛盾的地位起了变化。当着帝国主义不是用战争压迫而是用政治、经济、文化等比较温和的形式进行压迫的时候，半殖民地国家的统治阶级就会向帝国主义投降，二者结成同盟，共同压迫人民大众。这种时候，人民大众往往采取国内战争的形式，去反对帝国主义和封建阶级的同盟，而帝国主义则往往采取间接的方式去援助半殖民地国家的反动派压迫人民，而不采取直接行动，显出了内部矛盾的特别尖锐性。中国的辛亥革命战争，一九二四年至一九二七年的革命战争，一九二七年以后的十年土地革命战争，都有这种情形。还有半殖民地国家各个反动的统治集团之间的内战，例如在中国的军阀战争，也属于这一类。 当着国内革命战争发展到从根本上威胁帝国主义及其走狗国内反动派的存在的时候，帝国主义就往往采取上述方法以外的方法，企图维持其统治：或者分化革命阵线的内部，或者直接出兵援助国内反动派。这时，外国帝国主义和国内反动派完全公开地站在一个极端，人民大众则站在另一极端，成为一个主要矛盾，而规定或影响其它矛盾的发展状态。十月革命后各资本主义国家援助俄国反动派，是武装干涉的例子。一九二七年的蒋介石的叛变，是分化革命阵线的例子。 然而不管怎样，过程发展的各个阶段中，只有一种主要的矛盾起着领导的作用，是完全没有疑义的。 由此可知，任何过程如果有多数矛盾存在的话，其中必定有一种是主要的，起着领导的、决定的作用，其它则处于次要和服从的地位。因此，研究任何过程，如果是存在着两个以上矛盾的复杂过程的话，就要用全力找出它的主要矛盾。捉住了这个主要矛盾，一切问题就迎刃而解了。这是马克思研究资本主义社会告诉我们的方法。列宁和斯大林研究帝国主义和资本主义总危机的时候，列宁和斯大林研究苏联经济的时候，也告诉了这种方法。万千的学问家和实行家，不懂得这种方法，结果如堕烟海，找不到中心，也就找不到解决矛盾的方法。 不能把过程中所有的矛盾平均看待，必须把它们区别为主要的和次要的两类，着重于捉住主要的矛盾，已如上述。但是在各种矛盾之中，不论是主要的或次要的，矛盾着的两个方面，又是否可以平均看待呢？也是不可以的。无论什么矛盾，矛盾的诸方面，其发展是不平衡的。有时候似乎势均力敌，然而这只是暂时的和相对的情形，基本的形态则是不平衡。矛盾着的两方面中，必有一方面是主要的，他方面是次要的。其主要的方面，即所谓矛盾起主导作用的方面。事物的性质，主要地是由取得支配地位的矛盾的主要方面所规定的。 然而这种情形不是固定的，矛盾的主要和非主要的方面互相转化着，事物的性质也就随着起变化。在矛盾发展的一定过程或一定阶段上，主要方面属于甲方，非主要方面属于乙方；到了另一发展阶段或另一发展过程时，就互易其位置，这是依靠事物发展中矛盾双方斗争的力量的增减程度来决定的。 我们常常说“新陈代谢”这句话。新陈代谢是宇宙间普遍的永远不可抵抗的规律。依事物本身的性质和条件，经过不同的飞跃形式，一事物转化为他事物，就是新陈代谢的过程。任何事物的内部都有其新旧两个方面的矛盾，形成为一系列的曲折的斗争。斗争的结果，新的方面由小变大，上升为支配的东西；旧的方面则由大变小，变成逐步归于灭亡的东西。而一当新的方面对于旧的方面取得支配地位的时候，旧事物的性质就变化为新事物的性质。由此可见，事物的性质主要地是由取得支配地位的矛盾的主要方面所规定的。取得支配地位的矛盾的主要方面起了变化，事物的性质也就随着起变化。 在资本主义社会中，资本主义已从旧的封建主义社会时代的附庸地位，转化成了取得支配地位的力量，社会的性质也就由封建主义的变为资本主义的。在新的资本主义社会时代，封建势力则由原来处在支配地位的力量转化为附庸的力量，随着也就逐步地归于消灭了，例如英法诸国就是如此。随着生产力的发展，资产阶级由新的起进步作用的阶级，转化为旧的起反动作用的阶级，以至于最后被无产阶级所推翻，而转化为私有的生产资料被剥夺和失去权力的阶级，这个阶级也就要逐步归于消灭了。人数比资产阶级多得多、并和资产阶级同时生长、但被资产阶级统治着的无产阶级，是一个新的力量，它由初期的附属于资产阶级的地位，逐步地壮大起来，成为独立的和在历史上起主导作用的阶级，以至最后夺取政权成为统治阶级。这时，社会的性质，就由旧的资本主义的社会转化成了新的社会主义的社会。这就是苏联已经走过和一切其它国家必然要走的道路。 就中国的情形来说，帝国主义处在形成半殖民地这种矛盾的主要地位，压迫中国人民，中国则由独立国变为半殖民地。然而事情必然会变化，在双方斗争的局势中，中国人民在无产阶级领导之下所生长起来的力量必然会把中国由半殖民地变为独立国，而帝国主义则将被打倒，旧中国必然要变为新中国。 旧中国变为新中国，还包含着国内旧的封建势力和新的人民势力之间的情况的变化。旧的封建地主阶级将被打倒，由统治者变为被统治者，这个阶级也就会要逐步归于消灭。人民则将在无产阶级领导之下，由被统治者变为统治者。这时，中国社会的性质就会起变化，由旧的半殖民地和半封建的社会变为新的民主的社会。 这种互相转化的事情，过去已有经验。统治中国将近三百年的清朝帝国，曾在辛亥革命时期被打倒；而孙中山领导的革命同盟会，则曾经一度取得了胜利。在一九二四年至一九二七年的革命战争中，共产党和国民党联合的南方革命势力，曾经由弱小的力量变得强大起来，取得了北伐的胜利；而称雄一时的北洋军阀则被打倒了。一九二七年，共产党领导的人民力量，受了国民党反动势力的打击，变得很小了；但因肃清了自己内部的机会主义，就又逐步地壮大起来。在共产党领导的革命根据地内，农民由被统治者转化为统治者，地主则作了相反的转化。世界上总是这样以新的代替旧的，总是这样新陈代谢、除旧布新或推陈出新的。 革命斗争中的某些时候，困难条件超过顺利条件，在这种时候，困难是矛盾的主要方面，顺利是其次要方面。然而由于革命党人的努力，能够逐步地克服困难，开展顺利的新局面，困难的局面让位于顺利的局面。一九二七年中国革命失败后的情形，中国红军在长征[24]中的情形，都是如此。现在的中日战争，中国又处在困难地位，但是我们能够改变这种情况，使中日双方的情况发生根本的变化。在相反的情形之下，顺利也能转化为困难，如果是革命党人犯了错误的话。一九二四年至一九二七年的革命的胜利，变为失败了。一九二七年以后在南方各省发展起来的革命根据地，至一九三四年都失败了。 研究学问的时候，由不知到知的矛盾也是如此。当着我们刚才开始研究马克思主义的时候，对于马克思主义的无知或知之不多的情况，和马克思主义的知识之间，互相矛盾着。然而由于努力学习，可以由无知转化为有知，由知之不多转化为知之甚多，由对于马克思主义的盲目性改变为能够自由运用马克思主义。 有人觉得有些矛盾并不是这样。例如，生产力和生产关系的矛盾，生产力是主要的；理论和实践的矛盾，实践是主要的；经济基础和上层建筑的矛盾，经济基础是主要的：它们的地位并不互相转化。这是机械唯物论的见解，不是辩证唯物论的见解。诚然，生产力、实践、经济基础，一般地表现为主要的决定的作用，谁不承认这一点，谁就不是唯物论者。然而，生产关系、理论、上层建筑这些方面，在一定条件之下，又转过来表现其为主要的决定的作用，这也是必须承认的。当着不变更生产关系，生产力就不能发展的时候，生产关系的变更就起了主要的决定的作用。当着如同列宁所说“没有革命的理论，就不会有革命的运动”[25]的时候，革命理论的创立和提倡就起了主要的决定的作用。当着某一件事情（任何事情都是一样）要做，但是还没有方针、方法、计划或政策的时候，确定方针、方法、计划或政策，也就是主要的决定的东西。当着政治文化等等上层建筑阻碍着经济基础的发展的时候，对于政治上和文化上的革新就成为主要的决定的东西了。我们这样说，是否违反了唯物论呢？没有。因为我们承认总的历史发展中是物质的东西决定精神的东西，是社会的存在决定社会的意识；但是同时又承认而且必须承认精神的东西的反作用，社会意识对于社会存在的反作用，上层建筑对于经济基础的反作用。这不是违反唯物论，正是避免了机械唯物论，坚持了辩证唯物论。 在研究矛盾特殊性的问题中，如果不研究过程中主要的矛盾和非主要的矛盾以及矛盾之主要的方面和非主要的方面这两种情形，也就是说不研究这两种矛盾情况的差别性，那就将陷入抽象的研究，不能具体地懂得矛盾的情况，因而也就不能找出解决矛盾的正确的方法。这两种矛盾情况的差别性或特殊性，都是矛盾力量的不平衡性。世界上没有绝对地平衡发展的东西，我们必须反对平衡论，或均衡论。同时，这种具体的矛盾状况，以及矛盾的主要方面和非主要方面在发展过程中的变化，正是表现出新事物代替旧事物的力量。对于矛盾的各种不平衡情况的研究，对于主要的矛盾和非主要的矛盾、主要的矛盾方面和非主要的矛盾方面的研究，成为革命政党正确地决定其政治上和军事上的战略战术方针的重要方法之一，是一切共产党人都应当注意的。\n五　矛盾诸方面的同一性和斗争性 在懂得了矛盾的普遍性和特殊性的问题之后，我们必须进而研究矛盾诸方面的同一性和斗争性的问题。 同一性、统一性、一致性、互相渗透、互相贯通、互相依赖（或依存）、互相联结或互相合作，这些不同的名词都是一个意思，说的是如下两种情形：第一、事物发展过程中的每一种矛盾的两个方面，各以和它对立着的方面为自己存在的前提，双方共处于一个统一体中；第二、矛盾着的双方，依据一定的条件，各向着其相反的方面转化。这些就是所谓同一性。 列宁说：“辩证法是这样的一种学说：它研究对立怎样能够是同一的，又怎样成为同一的（怎样变成同一的），——在怎样的条件之下它们互相转化，成为同一的，——为什么人的头脑不应当把这些对立看作死的、凝固的东西，而应当看作生动的、有条件的、可变动的、互相转化的东西。”[26] 列宁这段话是什么意思呢？ 一切过程中矛盾着的各方面，本来是互相排斥、互相斗争、互相对立的。世界上一切事物的过程里和人们的思想里，都包含着这样带矛盾性的方面，无一例外。单纯的过程只有一对矛盾，复杂的过程则有一对以上的矛盾。各对矛盾之间，又互相成为矛盾。这样地组成客观世界的一切事物和人们的思想，并推使它们发生运动。 如此说来，只是极不同一，极不统一，怎样又说是同一或统一呢？ 原来矛盾着的各方面，不能孤立地存在。假如没有和它作对的矛盾的一方，它自己这一方就失去了存在的条件。试想一切矛盾着的事物或人们心中矛盾着的概念，任何一方面能够独立地存在吗？没有生，死就不见；没有死，生也不见。没有上，无所谓下；没有下，也无所谓上。没有祸，无所谓福；没有福，也无所谓祸。没有顺利，无所谓困难；没有困难，也无所谓顺利。没有地主，就没有佃农；没有佃农，也就没有地主。没有资产阶级，就没有无产阶级；没有无产阶级，也就没有资产阶级。没有帝国主义的民族压迫，就没有殖民地和半殖民地；没有殖民地和半殖民地，也就没有帝国主义的民族压迫。一切对立的成分都是这样，因一定的条件，一面互相对立，一面又互相联结、互相贯通、互相渗透、互相依赖，这种性质，叫做同一性。一切矛盾着的方面都因一定条件具备着不同一性，所以称为矛盾。然而又具备着同一性，所以互相联结。列宁所谓辩证法研究“对立怎样能够是同一的”，就是说的这种情形。怎样能够呢？因为互为存在的条件。这是同一性的第一种意义。 然而单说了矛盾双方互为存在的条件，双方之间有同一性，因而能够共处于一个统一体中，这样就够了吗？还不够。事情不是矛盾双方互相依存就完了，更重要的，还在于矛盾着的事物的互相转化。这就是说，事物内部矛盾着的两方面，因为一定的条件而各向着和自己相反的方面转化了去，向着它的对立方面所处的地位转化了去。这就是矛盾的同一性的第二种意义。 为什么这里也有同一性呢？你们看，被统治的无产阶级经过革命转化为统治者，原来是统治者的资产阶级却转化为被统治者，转化到对方原来所占的地位。苏联已经是这样做了，全世界也将要这样做。试问其间没有在一定条件之下的联系和同一性，如何能够发生这样的变化呢？ 曾在中国近代历史的一定阶段上起过某种积极作用的国民党，因为它的固有的阶级性和帝国主义的引诱（这些就是条件），在一九二七年以后转化为反革命，又由于中日矛盾的尖锐化和共产党的统一战线政策（这些就是条件），而被迫着赞成抗日。矛盾着的东西这一个变到那一个，其间包含了一定的同一性。 我们实行过的土地革命，已经是并且还将是这样的过程，拥有土地的地主阶级转化为失掉土地的阶级，而曾经是失掉土地的农民却转化为取得土地的小私有者。有无、得失之间，因一定条件而互相联结，二者具有同一性。在社会主义条件之下，农民的私有制又将转化为社会主义农业的公有制，苏联已经这样做了，全世界将来也会这样做。私产和公产之间有一条由此达彼的桥梁，哲学上名之曰同一性，或互相转化、互相渗透。 巩固无产阶级的专政或人民的专政，正是准备着取消这种专政，走到消灭任何国家制度的更高阶段去的条件。建立和发展共产党，正是准备着消灭共产党和一切政党制度的条件。建立共产党领导的革命军，进行革命战争，正是准备着永远消灭战争的条件。这许多相反的东西，同时却是相成的东西。 大家知道，战争与和平是互相转化的。战争转化为和平，例如第一次世界大战转化为战后的和平，中国的内战现在也停止了，出现了国内的和平。和平转化为战争，例如一九二七年的国共合作转化为战争，现在的世界和平局面也可能转化为第二次世界大战。为什么是这样？因为在阶级社会中战争与和平这样矛盾着的事物，在一定条件下具备着同一性。 一切矛盾着的东西，互相联系着，不但在一定条件之下共处于一个统一体中，而且在一定条件之下互相转化，这就是矛盾的同一性的全部意义。列宁所谓“怎样成为同一的（怎样变成同一的），——在怎样的条件之下它们互相转化，成为同一的”，就是这个意思。 “为什么人的头脑不应当把这些对立看作死的、凝固的东西，而应当看作生动的、有条件的、可变动的、互相转化的东西”呢？因为客观事物本来是如此的。客观事物中矛盾着的诸方面的统一或同一性，本来不是死的、凝固的，而是生动的、有条件的、可变动的、暂时的、相对的东西，一切矛盾都依一定条件向它们的反面转化着。这种情况，反映在人们的思想里，就成了马克思主义的唯物辩证法的宇宙观。只有现在的和历史上的反动的统治阶级以及为他们服务的形而上学，不是把对立的事物当作生动的、有条件的、可变动的、互相转化的东西去看，而是当作死的、凝固的东西去看，并且把这种错误的看法到处宣传，迷惑人民群众，以达其继续统治的目的。共产党人的任务就在于揭露反动派和形而上学的错误思想，宣传事物的本来的辩证法，促成事物的转化，达到革命的目的。 所谓矛盾在一定条件下的同一性，就是说，我们所说的矛盾乃是现实的矛盾，具体的矛盾，而矛盾的互相转化也是现实的、具体的。神话中的许多变化，例如《山海经》中所说的“夸父追日”[27]，《淮南子》中所说的“羿射九日”[28]，《西游记》中所说的孙悟空七十二变[29]和《聊斋志异》[30]中的许多鬼狐变人的故事等等，这种神话中所说的矛盾的互相变化，乃是无数复杂的现实矛盾的互相变化对于人们所引起的一种幼稚的、想象的、主观幻想的变化，并不是具体的矛盾所表现出来的具体的变化。马克思说：“任何神话都是用想象和借助想象以征服自然力，支配自然力，把自然力加以形象化；因而，随着这些自然力之实际上被支配，神话也就消失了。”[31]这种神话中的（还有童话中的）千变万化的故事，虽然因为它们想象出人们征服自然力等等，而能够吸引人们的喜欢，并且最好的神话具有“永久的魅力”[32]（马克思），但神话并不是根据具体的矛盾之一定的条件而构成的，所以它们并不是现实之科学的反映。这就是说，神话或童话中矛盾构成的诸方面，并不是具体的同一性，只是幻想的同一性。科学地反映现实变化的同一性的，就是马克思主义的辩证法。 为什么鸡蛋能够转化为鸡子，而石头不能够转化为鸡子呢？为什么战争与和平有同一性，而战争与石头却没有同一性呢？为什么人能生人不能生出其它的东西呢？没有别的，就是因为矛盾的同一性要在一定的必要的条件之下。缺乏一定的必要的条件，就没有任何的同一性。 为什么俄国在一九一七年二月的资产阶级民主革命和同年十月的无产阶级社会主义革命直接地联系着，而法国资产阶级革命没有直接地联系于社会主义的革命，一八七一年的巴黎公社终于失败了呢？为什么蒙古和中亚细亚的游牧制度又直接地和社会主义联系了呢？为什么中国的革命可以避免资本主义的前途，可以和社会主义直接联系起来，不要再走西方国家的历史老路，不要经过一个资产阶级专政的时期呢？没有别的，都是由于当时的具体条件。一定的必要的条件具备了，事物发展的过程就发生一定的矛盾，而且这种或这些矛盾互相依存，又互相转化，否则，一切都不可能。 同一性的问题如此。那末，什么是斗争性呢？同一性和斗争性的关系是怎样的呢？ 列宁说：“对立的统一（一致、同一、合一），是有条件的、一时的、暂存的、相对的。互相排斥的对立的斗争则是绝对的，正如发展、运动是绝对的一样。”[33] 列宁这段话是什么意思呢？ 一切过程都有始有终，一切过程都转化为它们的对立物。一切过程的常住性是相对的，但是一种过程转化为他种过程的这种变动性则是绝对的。 无论什么事物的运动都采取两种状态，相对地静止的状态和显着地变动的状态。两种状态的运动都是由事物内部包含的两个矛盾着的因素互相斗争所引起的。当着事物的运动在第一种状态的时候，它只有数量的变化，没有性质的变化，所以显出好似静止的面貌。当着事物的运动在第二种状态的时候，它已由第一种状态中的数量的变化达到了某一个最高点，引起了统一物的分解，发生了性质的变化，所以显出显着地变化的面貌。我们在日常生活中所看见的统一、团结、联合、调和、均势、相持、僵局、静止、有常、平衡、凝聚、吸引等等，都是事物处在量变状态中所显现的面貌。而统一物的分解，团结、联合、调和、均势、相持、僵局、静止、有常、平衡、凝聚、吸引等等状态的破坏，变到相反的状态，便都是事物在质变状态中、在一种过程过渡到他种过程的变化中所显现的面貌。事物总是不断地由第一种状态转化为第二种状态，而矛盾的斗争则存在于两种状态中，并经过第二种状态而达到矛盾的解决。所以说，对立的统一是有条件的、暂时的、相对的，而对立的互相排除的斗争则是绝对的。 前面我们曾经说，两个相反的东西中间有同一性，所以二者能够共处于一个统一体中，又能够互相转化，这是说的条件性，即是说在一定条件之下，矛盾的东西能够统一起来，又能够互相转化；无此一定条件，就不能成为矛盾，不能共居，也不能转化。由于一定的条件才构成了矛盾的同一性，所以说同一性是有条件的、相对的。这里我们又说，矛盾的斗争贯串于过程的始终，并使一过程向着他过程转化，矛盾的斗争无所不在，所以说矛盾的斗争性是无条件的、绝对的。 有条件的相对的同一性和无条件的绝对的斗争性相结合，构成了一切事物的矛盾运动。 我们中国人常说：“相反相成。”[34]就是说相反的东西有同一性。这句话是辩证法的，是违反形而上学的。“相反”就是说两个矛盾方面的互相排斥，或互相斗争。“相成”就是说在一定条件之下两个矛盾方面互相联结起来，获得了同一性。而斗争性即寓于同一性之中，没有斗争性就没有同一性。 在同一性中存在着斗争性，在特殊性中存在着普遍性，在个性中存在着共性。拿列宁的话来说，叫做“在相对的东西里面有着绝对的东西”[35]。\n六　对抗在矛盾中的地位 在矛盾的斗争性的问题中，包含着对抗是什么的问题。我们回答道：对抗是矛盾斗争的一种形式，而不是矛盾斗争的一切形式。 在人类历史中，存在着阶级的对抗，这是矛盾斗争的一种特殊的表现。剥削阶级和被剥削阶级之间的矛盾，无论在奴隶社会也好，封建社会也好，资本主义社会也好，互相矛盾着的两阶级，长期地并存于一个社会中，它们互相斗争着，但要待两阶级的矛盾发展到了一定的阶段的时候，双方才取外部对抗的形式，发展为革命。阶级社会中，由和平向战争的转化，也是如此。 炸弹在未爆炸的时候，是矛盾物因一定条件共居于一个统一体中的时候。待至新的条件（发火）出现，才发生了爆炸。自然界中一切到了最后要采取外部冲突形式去解决旧矛盾产生新事物的现象，都有与此相仿佛的情形。 认识这种情形，极为重要。它使我们懂得，在阶级社会中，革命和革命战争是不可避免的，舍此不能完成社会发展的飞跃，不能推翻反动的统治阶级，而使人民获得政权。共产党人必须揭露反动派所谓社会革命是不必要的和不可能的等等欺骗的宣传，坚持马克思列宁主义的社会革命论，使人民懂得，这不但是完全必要的，而且是完全可能的，整个人类的历史和苏联的胜利，都证明了这个科学的真理。 但是我们必须具体地研究各种矛盾斗争的情况，不应当将上面所说的公式不适当地套在一切事物的身上。矛盾和斗争是普遍的、绝对的，但是解决矛盾的方法，即斗争的形式，则因矛盾的性质不同而不相同。有些矛盾具有公开的对抗性，有些矛盾则不是这样。根据事物的具体发展，有些矛盾是由原来还非对抗性的，而发展成为对抗性的；也有些矛盾则由原来是对抗性的，而发展成为非对抗性的。 共产党内正确思想和错误思想的矛盾，如前所说，在阶级存在的时候，这是阶级矛盾对于党内的反映。这种矛盾，在开始的时候，或在个别的问题上，并不一定马上表现为对抗性的。但随着阶级斗争的发展，这种矛盾也就可能发展为对抗性的。苏联共产党的历史告诉我们：列宁、斯大林的正确思想和托洛茨基、布哈林等人的错误思想的矛盾，在开始的时候还没有表现为对抗的形式，但随后就发展为对抗的了。中国共产党的历史也有过这样的情形。我们党内许多同志的正确思想和陈独秀、张国焘[36]等人的错误思想的矛盾，在开始的时候也没有表现为对抗的形式，但随后就发展为对抗的了。目前我们党内的正确思想和错误思想的矛盾，没有表现为对抗的形式，如果犯错误的同志能够改正自己的错误，那就不会发展为对抗性的东西。因此，党一方面必须对于错误思想进行严肃的斗争，另方面又必须充分地给犯错误的同志留有自己觉悟的机会。在这样的情况下，过火的斗争，显然是不适当的。但如果犯错误的人坚持错误，并扩大下去，这种矛盾也就存在着发展为对抗性的东西的可能性。 经济上城市和乡村的矛盾，在资本主义社会里面（那里资产阶级统治的城市残酷地掠夺乡村），在中国的国民党统治区域里面（那里外国帝国主义和本国买办大资产阶级所统治的城市极野蛮地掠夺乡村），那是极其对抗的矛盾。但在社会主义国家里面，在我们的革命根据地里面，这种对抗的矛盾就变为非对抗的矛盾，而当到达共产主义社会的时候，这种矛盾就会消灭。 列宁说：“对抗和矛盾断然不同。在社会主义下，对抗消灭了，矛盾存在着。”[37]这就是说，对抗只是矛盾斗争的一种形式，而不是它的一切形式，不能到处套用这个公式。\n七　结　论 说到这里，我们可以总起来说几句。事物矛盾的法则，即对立统一的法则，是自然和社会的根本法则，因而也是思维的根本法则。它是和形而上学的宇宙观相反的。它对于人类的认识史是一个大革命。按照辩证唯物论的观点看来，矛盾存在于一切客观事物和主观思维的过程中，矛盾贯串于一切过程的始终，这是矛盾的普遍性和绝对性。矛盾着的事物及其每一个侧面各有其特点，这是矛盾的特殊性和相对性。矛盾着的事物依一定的条件有同一性，因此能够共居于一个统一体中，又能够互相转化到相反的方面去，这又是矛盾的特殊性和相对性。然而矛盾的斗争则是不断的，不管在它们共居的时候，或者在它们互相转化的时候，都有斗争的存在，尤其是在它们互相转化的时候，斗争的表现更为显着，这又是矛盾的普遍性和绝对性。当着我们研究矛盾的特殊性和相对性的时候，要注意矛盾和矛盾方面的主要的和非主要的区别；当着我们研究矛盾的普遍性和斗争性的时候，要注意矛盾的各种不同的斗争形式的区别。否则就要犯错误。如果我们经过研究真正懂得了上述这些要点，我们就能够击破违反马克思列宁主义基本原则的不利于我们的革命事业的那些教条主义的思想；也能够使有经验的同志们整理自己的经验，使之带上原则性，而避免重复经验主义的错误。这些，就是我们研究矛盾法则的一些简单的结论。\n注释 [1] 见列宁《黑格尔〈哲学史讲演录〉一书摘要》（《列宁全集》第55卷，人民出版社1990年版，第213页）。\n[2] 参见列宁《谈谈辩证法问题》：“统一物之分为两个部分以及对它的矛盾着的部分的认识……，是辩证法的实质（是辩证法的‘本质’之一，是它的基本的特点或特征之一，甚至可说是它的最基本的特点或特征）。”并参见《黑格尔〈逻辑学〉一书摘要》中关于“辩证法的要素”部分：“可以把辩证法简要地规定为关于对立面的统一的学说。这样就会抓住辩证法的核心，可是这需要说明和发挥。”（《列宁全集》第55卷，人民出版社1990年版，第305、192页）\n[3] 德波林（一八八一——一九六三），苏联哲学家。一九二九年当选为苏联科学院院士。三十年代初，苏联哲学界发动对德波林学派的批判，认为他们犯了理论脱离实践、哲学脱离政治等唯心主义性质的错误。\n[4] 见列宁《谈谈辩证法问题》。新的译文是：“有两种基本的（或两种可能的？或两种在历史上常见的？）发展（进化）观点：认为发展是减少和增加，是重复；以及认为发展是对立面的统一（统一物之分为两个互相排斥的对立面以及它们之间的相互关系）。”（《列宁全集》第55卷，人民出版社1990年版，第306页）\n[5] 见《汉书•董仲舒传》。董仲舒（公元前一七九——前一○四）是孔子学派在西汉的主要代表，他曾经对汉武帝说：“道之大原出于天，天不变，道亦不变。”“道”是中国古代哲学家的通用语，它的意义是“道路”或“道理”，可作“法则”或“规律”解说。\n[6] 见恩格斯《反杜林论》第一编第十二节《辩证法。量和质》（《马克思恩格斯选集》第3卷，人民出版社1972年版，第160页）。\n[7] 见列宁《谈谈辩证法问题》。新的译文是：“承认（发现）自然界的（也包括精神的和社会的）一切现象和过程具有矛盾着的、相互排斥的、对立的倾向。”（《列宁全集》第55卷，人民出版社1990年版，第306页）\n[8] 以上所引恩格斯的三段话，均见恩格斯《反杜林论》第一编第十二节《辩证法。量和质》。其中第二段“高等数学的主要基础之一，就是矛盾……”，《反杜林论》中的原文是：“我们已经提到，高等数学的主要基础之一是这样一个矛盾：在一定条件下直线和曲线应当是一回事。高等数学还有另一个矛盾：在我们眼前相交的线，只要离开交点五六厘米，就应当认为是平行的、即使无限延长也不会相交的线。可是，高等数学利用这些和其它一些更加尖锐的矛盾获得了不仅是正确的、而且是初等数学所完全不能达到的成果。”（《马克思恩格斯选集》第3卷，人民出版社1972年版，第160—161页）\n[9] 见列宁《谈谈辩证法问题》（《列宁全集》第55卷，人民出版社1990年版，第305—306页）。\n[10] 见列宁《谈谈辩证法问题》（《列宁全集》第55卷，人民出版社1990年版，第307页）。\n[11] 参见本卷《中国革命战争的战略问题》注〔11〕。\n[12] 见《孙子•谋攻》。\n[13] 魏征（五八○——六四三），唐代初期的政治活动家和历史学家。本文引语见《资治通鉴》卷一百九十二。\n[14] 《水浒传》是中国描写农民战争的著名小说。宋江是这部小说中农民武装的主要领袖。祝家庄在农民武装根据地梁山泊的附近，这个庄的统治者祝朝奉，是一个大恶霸地主。\n[15] 木马计是希腊神话中的一个著名故事。据传说，古希腊人攻打特洛伊城，很久打不下来。后来，他们伪装撤退，在城下营房中留下了一匹腹内藏有一批勇士的大木马。特洛伊人不知道这是敌人的计策，把木马作为战利品拉进城去。深夜，勇士们走出木马，利用特洛伊人毫无戒备的时机，配合城外的军队，迅速地夺取了特洛伊城。\n[16] 见列宁《再论工会、目前局势及托洛茨基同志和布哈林同志的错误》。新的译文是：“要真正地认识事物，就必须把握住、研究清楚它的一切方面、一切联系和‘中介’。我们永远也不会完全做到这一点，但是，全面性这一要求可以使我们防止犯错误和防止僵化。”（《列宁全集》第40卷，人民出版社1986年版，第291页）\n[17] 见本卷《湖南农民运动考察报告》注〔3〕。\n[18] 见本卷《论反对日本帝国主义的策略》注〔5〕。\n[19] 参见本卷《关于蒋介石声明的声明》注〔1〕。\n[20] 见本卷《中国革命战争的战略问题》注〔4〕。\n[21] 见本卷《论反对日本帝国主义的策略》注〔35〕。\n[22] 一八九四年（甲午年）发生的中日战争，也称甲午战争。这次战争是日本军国主义者蓄意挑起的。日本军队先向朝鲜发动侵略并对中国的陆海军进行挑衅，继即大举侵入中国的东北。在战争中，中国军队曾经英勇作战，但是由于清朝政府的腐败以及缺乏坚决反对侵略的准备，中国方面遭到了失败。一八九五年，清朝政府和日本订立了可耻的马关条约，这个条约的主要内容是：中国割让台湾全岛及所有附属各岛屿、澎湖列岛和辽东半岛（后来在俄、德、法三国干涉下，日本同意由清政府偿付白银三千万两“赎还”该半岛），赔偿军费银二万万两，允许日本人在中国通商口岸开设工厂，开辟沙市、重庆、苏州、杭州等地为商埠。\n[23] 见本卷《论反对日本帝国主义的策略》注〔37〕。\n[24] 参见本卷《论反对日本帝国主义的策略》注〔22〕。\n[25] 见列宁《俄国社会民主党人的任务》（《列宁全集》第2卷，人民出版社1984年版，第443页）；并见列宁《怎么办？》第一章第四节（《列宁全集》第6卷，人民出版社1986年版，第23页）。\n[26] 见列宁《黑格尔〈逻辑学〉一书摘要》。新的译文是：“辩证法是一种学说，它研究对立面怎样才能够同一，是怎样（怎样成为）同一的——在什么条件下它们是相互转化而同一的，——为什么人的头脑不应该把这些对立面看作僵死的、凝固的东西，而应该看作活生生的、有条件的、活动的、彼此转化的东西。”（《列宁全集》第55卷，人民出版社1990年版，第90页）\n[27] 《山海经》是一部中国古代地理著作，其中记载了不少远古的神话传说。夸父是《山海经•海外北经》上记载的一个神人。据说：“夸父与日逐走。入日，渴欲得饮，饮于河渭。河渭不足，北饮大泽。未至，道渴而死。弃其杖，化为邓林。”\n[28] 羿是中国古代传说中的英雄，“射日”是关于他善射的著名故事。据西汉淮南王刘安（公元前二世纪人）及其门客所著《淮南子》一书说：“尧之时，十日并出，焦禾稼，杀草木，而民无所食。猰豸、凿齿、九婴、大风、封狶、修蛇，皆为民害。尧乃使羿……上射十日而下杀猰豸。……万民皆喜。”东汉著作家王逸（公元二世纪人）关于屈原诗篇《天问》的注释说：“淮南言，尧时十日并出，草木焦枯。尧命羿仰射十日，中其九日……留其一日。”\n[29] 《西游记》是明代作家吴承恩着的一部神话小说。孙悟空是书中的主角。他是一个神猴，有七十二变的法术，能够随意变成各式各样的鸟兽虫鱼草木器物或者人形。\n[30] 《聊斋志异》是清代文学家蒲松龄着的短篇小说集，大部分是叙述神仙狐鬼的故事。\n[31] 见马克思《〈政治经济学批判〉导言》（《马克思恩格斯选集》第2卷，人民出版社1972年版，第113页）。\n[32] 见马克思《〈政治经济学批判〉导言》（《马克思恩格斯选集》第2卷，人民出版社1972年版，第114页）。\n[33] 见列宁《谈谈辩证法问题》。新的译文是：“对立面的统一（一致、同一、均势）是有条件的、暂时的、易逝的、相对的。相互排斥的对立面的斗争是绝对的，正如发展、运动是绝对的一样。”（《列宁全集》第55卷，人民出版社1990年版，第306页）\n[34] 见东汉著名史学家班固（三二——九二）所著《汉书•艺文志》，原文是：“诸子十家，其可观者，九家而已。皆起于王道既微，诸侯力政，时君世主，好恶殊方。是以九家之术，蜂出并作，各引一端，崇其所善，以此驰说，取合诸侯。其言虽殊，辟犹水火，相灭亦相生也。仁之与义，敬之与和，相反而皆相成也。”\n[35] 见列宁《谈谈辩证法问题》。新的译文是：“相对中有绝对。”（《列宁全集》第55卷，人民出版社1990年版，第307页）\n[36] 见本卷《论反对日本帝国主义的策略》注〔24〕。\n[37] 见列宁《在尼•布哈林〈过渡时期经济学〉一书上作的批注和评论》（《列宁全集》第60卷，人民出版社1990年版，第282页）。\n","permalink":"https://gopherding.github.io/posts/read/%E7%9F%9B%E7%9B%BE%E8%AE%BA/","summary":"矛盾论 （一九三七年八月） 这篇哲学论文，是毛泽东继《实践论》之后，为了同一的目的，即为了克服存在于中国共产党内的严重的教条主义思想而写的，曾在延安的抗日军事政治大学作过讲演。在收入本书第一版的时候，作者作了部分的补充、删节和修改。 事物的矛盾法则，即对立统一的法则，是唯物辩证法的最根","title":"矛盾论"},{"content":"实践论 论认识和实践的关系——知和行的关系\n（一九三七年七月）\n在中国共产党内，曾经有一部分教条主义的同志长期拒绝中国革命的经验，否认“马克思主义不是教条而是行动的指南”这个真理，而只生吞活剥马克思主义书籍中的只言片语，去吓唬人们。还有另一部分经验主义的同志长期拘守于自身的片断经验，不了解理论对于革命实践的重要性，看不见革命的全局，虽然也是辛苦地——但却是盲目地在工作。这两类同志的错误思想，特别是教条主义思想，曾经在一九三一年至一九三四年使得中国革命受了极大的损失，而教条主义者却是披着马克思主义的外衣迷惑了广大的同志。毛泽东的《实践论》，是为着用马克思主义的认识论观点去揭露党内的教条主义和经验主义——特别是教条主义这些主观主义的错误而写的。因为重点是揭露看轻实践的教条主义这种主观主义，故题为《实践论》。毛泽东曾以这篇论文的观点在延安的抗日军事政治大学作过讲演。\n马克思以前的唯物论，离开人的社会性，离开人的历史发展，去观察认识问题，因此不能了解认识对社会实践的依赖关系，即认识对生产和阶级斗争的依赖关系。 首先，马克思主义者认为人类的生产活动是最基本的实践活动，是决定其它一切活动的东西。人的认识，主要地依赖于物质的生产活动，逐渐地了解自然的现象、自然的性质、自然的规律性、人和自然的关系；而且经过生产活动，也在各种不同程度上逐渐地认识了人和人的一定的相互关系。一切这些知识，离开生产活动是不能得到的。在没有阶级的社会中，每个人以社会一员的资格，同其它社会成员协力，结成一定的生产关系，从事生产活动，以解决人类物质生活问题。在各种阶级的社会中，各阶级的社会成员，则又以各种不同的方式，结成一定的生产关系，从事生产活动，以解决人类物质生活问题。这是人的认识发展的基本来源。 人的社会实践，不限于生产活动一种形式，还有多种其它的形式，阶级斗争，政治生活，科学和艺术的活动，总之社会实际生活的一切领域都是社会的人所参加的。因此，人的认识，在物质生活以外，还从政治生活文化生活中（与物质生活密切联系），在各种不同程度上，知道人和人的各种关系。其中，尤以各种形式的阶级斗争，给予人的认识发展以深刻的影响。在阶级社会中，每一个人都在一定的阶级地位中生活，各种思想无不打上阶级的烙印。 马克思主义者认为人类社会的生产活动，是一步又一步地由低级向高级发展，因此，人们的认识，不论对于自然界方面，对于社会方面，也都是一步又一步地由低级向高级发展，即由浅入深，由片面到更多的方面。在很长的历史时期内，大家对于社会的历史只能限于片面的了解，这一方面是由于剥削阶级的偏见经常歪曲社会的历史，另方面，则由于生产规模的狭小，限制了人们的眼界。人们能够对于社会历史的发展作全面的历史的了解，把对于社会的认识变成了科学，这只是到了伴随巨大生产力——大工业而出现近代无产阶级的时候，这就是马克思主义的科学。 马克思主义者认为，只有人们的社会实践，才是人们对于外界认识的真理性的标准。实际的情形是这样的，只有在社会实践过程中（物质生产过程中，阶级斗争过程中，科学实验过程中），人们达到了思想中所预想的结果时，人们的认识才被证实了。人们要想得到工作的胜利即得到预想的结果，一定要使自己的思想合于客观外界的规律性，如果不合，就会在实践中失败。人们经过失败之后，也就从失败取得教训，改正自己的思想使之适合于外界的规律性，人们就能变失败为胜利，所谓“失败者成功之母”，“吃一堑长一智”，就是这个道理。辩证唯物论的认识论把实践提到第一的地位，认为人的认识一点也不能离开实践，排斥一切否认实践重要性、使认识离开实践的错误理论。列宁这样说过：“实践高于（理论的）认识，因为它不但有普遍性的品格，而且还有直接现实性的品格。”[1]马克思主义的哲学辩证唯物论有两个最显着的特点：一个是它的阶级性，公然申明辩证唯物论是为无产阶级服务的；再一个是它的实践性，强调理论对于实践的依赖关系，理论的基础是实践，又转过来为实践服务。判定认识或理论之是否真理，不是依主观上觉得如何而定，而是依客观上社会实践的结果如何而定。真理的标准只能是社会的实践。实践的观点是辩证唯物论的认识论之第一的和基本的观点[2]。 然而人的认识究竟怎样从实践发生，而又服务于实践呢？这只要看一看认识的发展过程就会明了的。 原来人在实践过程中，开始只是看到过程中各个事物的现象方面，看到各个事物的片面，看到各个事物之间的外部联系。例如有些外面的人们到延安来考察，头一二天，他们看到了延安的地形、街道、屋宇，接触了许多的人，参加了宴会、晚会和群众大会，听到了各种说话，看到了各种文件，这些就是事物的现象，事物的各个片面以及这些事物的外部联系。这叫做认识的感性阶段，就是感觉和印象的阶段。也就是延安这些各别的事物作用于考察团先生们的感官，引起了他们的感觉，在他们的脑子中生起了许多的印象，以及这些印象间的大概的外部的联系，这是认识的第一个阶段。在这个阶段中，人们还不能造成深刻的概念，作出合乎论理（即合乎逻辑）的结论。 社会实践的继续，使人们在实践中引起感觉和印象的东西反复了多次，于是在人们的脑子里生起了一个认识过程中的突变（即飞跃），产生了概念。概念这种东西已经不是事物的现象，不是事物的各个片面，不是它们的外部联系，而是抓着了事物的本质，事物的全体，事物的内部联系了。概念同感觉，不但是数量上的差别，而且有了性质上的差别。循此继进，使用判断和推理的方法，就可产生出合乎论理的结论来。《三国演义》上所谓“眉头一皱计上心来”，我们普通说话所谓“让我想一想”，就是人在脑子中运用概念以作判断和推理的工夫。这是认识的第二个阶段。外来的考察团先生们在他们集合了各种材料，加上他们“想了一想”之后，他们就能够作出“共产党的抗日民族统一战线的政策是彻底的、诚恳的和真实的”这样一个判断了。在他们作出这个判断之后，如果他们对于团结救国也是真实的的话，那末他们就能够进一步作出这样的结论：“抗日民族统一战线是能够成功的。”这个概念、判断和推理的阶段，在人们对于一个事物的整个认识过程中是更重要的阶段，也就是理性认识的阶段。认识的真正任务在于经过感觉而到达于思维，到达于逐步了解客观事物的内部矛盾，了解它的规律性，了解这一过程和那一过程间的内部联系，即到达于论理的认识。重复地说，论理的认识所以和感性的认识不同，是因为感性的认识是属于事物之片面的、现象的、外部联系的东西，论理的认识则推进了一大步，到达了事物的全体的、本质的、内部联系的东西，到达了暴露周围世界的内在的矛盾，因而能在周围世界的总体上，在周围世界一切方面的内部联系上去把握周围世界的发展。 这种基于实践的由浅入深的辩证唯物论的关于认识发展过程的理论，在马克思主义以前，是没有一个人这样解决过的。马克思主义的唯物论，第一次正确地解决了这个问题，唯物地而且辩证地指出了认识的深化的运动，指出了社会的人在他们的生产和阶级斗争的复杂的、经常反复的实践中，由感性认识到论理认识的推移的运动。列宁说过：“物质的抽象，自然规律的抽象，价值的抽象以及其它等等，一句话，一切科学的（正确的、郑重的、非瞎说的）抽象，都更深刻、更正确、更完全地反映着自然。”[3]马克思列宁主义认为：认识过程中两个阶段的特性，在低级阶段，认识表现为感性的，在高级阶段，认识表现为论理的，但任何阶段，都是统一的认识过程中的阶段。感性和理性二者的性质不同，但又不是互相分离的，它们在实践的基础上统一起来了。我们的实践证明：感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻地感觉它。感觉只解决现象问题，理论才解决本质问题。这些问题的解决，一点也不能离开实践。无论何人要认识什么事物，除了同那个事物接触，即生活于（实践于）那个事物的环境中，是没有法子解决的。不能在封建社会就预先认识资本主义社会的规律，因为资本主义还未出现，还无这种实践。马克思主义只能是资本主义社会的产物。马克思不能在自由资本主义时代就预先具体地认识帝国主义时代的某些特异的规律，因为帝国主义这个资本主义最后阶段还未到来，还无这种实践，只有列宁和斯大林才能担当此项任务。马克思、恩格斯、列宁、斯大林之所以能够作出他们的理论，除了他们的天才条件之外，主要地是他们亲自参加了当时的阶级斗争和科学实验的实践，没有这后一个条件，任何天才也是不能成功的。“秀才不出门，全知天下事”，在技术不发达的古代只是一句空话，在技术发达的现代虽然可以实现这句话，然而真正亲知的是天下实践着的人，那些人在他们的实践中间取得了“知”，经过文字和技术的传达而到达于“秀才”之手，秀才乃能间接地“知天下事”。如果要直接地认识某种或某些事物，便只有亲身参加于变革现实、变革某种或某些事物的实践的斗争中，才能触到那种或那些事物的现象，也只有在亲身参加变革现实的实践的斗争中，才能暴露那种或那些事物的本质而理解它们。这是任何人实际上走着的认识路程，不过有些人故意歪曲地说些反对的话罢了。世上最可笑的是那些“知识里手”[4]，有了道听途说的一知半解，便自封为“天下第一”，适足见其不自量而已。知识的问题是一个科学问题，来不得半点的虚伪和骄傲，决定地需要的倒是其反面——诚实和谦逊的态度。你要有知识，你就得参加变革现实的实践。你要知道梨子的滋味，你就得变革梨子，亲口吃一吃。你要知道原子的组织同性质，你就得实行物理学和化学的实验，变革原子的情况。你要知道革命的理论和方法，你就得参加革命。一切真知都是从直接经验发源的。但人不能事事直接经验，事实上多数的知识都是间接经验的东西，这就是一切古代的和外域的知识。这些知识在古人在外人是直接经验的东西，如果在古人外人直接经验时是符合于列宁所说的条件“科学的抽象”，是科学地反映了客观的事物，那末这些知识是可靠的，否则就是不可靠的。所以，一个人的知识，不外直接经验的和间接经验的两部分。而且在我为间接经验者，在人则仍为直接经验。因此，就知识的总体说来，无论何种知识都是不能离开直接经验的。任何知识的来源，在于人的肉体感官对客观外界的感觉，否认了这个感觉，否认了直接经验，否认亲自参加变革现实的实践，他就不是唯物论者。“知识里手”之所以可笑，原因就是在这个地方。中国人有一句老话：“不入虎穴，焉得虎子。”这句话对于人们的实践是真理，对于认识论也是真理。离开实践的认识是不可能的。 为了明了基于变革现实的实践而产生的辩证唯物论的认识运动——认识的逐渐深化的运动，下面再举出几个具体的例子。 无产阶级对于资本主义社会的认识，在其实践的初期——破坏机器和自发斗争时期，他们还只在感性认识的阶段，只认识资本主义各个现象的片面及其外部的联系。这时，他们还是一个所谓“自在的阶级”。但是到了他们实践的第二个时期——有意识有组织的经济斗争和政治斗争的时期，由于实践，由于长期斗争的经验，经过马克思、恩格斯用科学的方法把这种种经验总结起来，产生了马克思主义的理论，用以教育无产阶级，这样就使无产阶级理解了资本主义社会的本质，理解了社会阶级的剥削关系，理解了无产阶级的历史任务，这时他们就变成了一个“自为的阶级”。 中国人民对于帝国主义的认识也是这样。第一阶段是表面的感性的认识阶段，表现在太平天国运动和义和团运动等笼统的排外主义的斗争上[5]。第二阶段才进到理性的认识阶段，看出了帝国主义内部和外部的各种矛盾，并看出了帝国主义联合中国买办阶级和封建阶级以压榨中国人民大众的实质，这种认识是从一九一九年五四运动[6]前后才开始的。 我们再来看战争。战争的领导者，如果他们是一些没有战争经验的人，对于一个具体的战争（例如我们过去十年的土地革命战争）的深刻的指导规律，在开始阶段是不了解的。他们在开始阶段只是身历了许多作战的经验，而且败仗是打得很多的。然而由于这些经验（胜仗，特别是败仗的经验），使他们能够理解贯串整个战争的内部的东西，即那个具体战争的规律性，懂得了战略和战术，因而能够有把握地去指导战争。此时，如果改换一个无经验的人去指导，又会要在吃了一些败仗之后（有了经验之后）才能理会战争的正确的规律。 常常听到一些同志在不能勇敢接受工作任务时说出来的一句话：没有把握。为什么没有把握呢？因为他对于这项工作的内容和环境没有规律性的了解，或者他从来就没有接触过这类工作，或者接触得不多，因而无从谈到这类工作的规律性。及至把工作的情况和环境给以详细分析之后，他就觉得比较地有了把握，愿意去做这项工作。如果这个人在这项工作中经过了一个时期，他有了这项工作的经验了，而他又是一个肯虚心体察情况的人，不是一个主观地、片面地、表面地看问题的人，他就能够自己做出应该怎样进行工作的结论，他的工作勇气也就可以大大地提高了。只有那些主观地、片面地和表面地看问题的人，跑到一个地方，不问环境的情况，不看事情的全体（事情的历史和全部现状），也不触到事情的本质（事情的性质及此一事情和其它事情的内部联系），就自以为是地发号施令起来，这样的人是没有不跌交子的。 由此看来，认识的过程，第一步，是开始接触外界事情，属于感觉的阶段。第二步，是综合感觉的材料加以整理和改造，属于概念、判断和推理的阶段。只有感觉的材料十分丰富（不是零碎不全）和合于实际（不是错觉），才能根据这样的材料造出正确的概念和论理来。 这里有两个要点必须着重指明。第一个，在前面已经说过的，这里再重复说一说，就是理性认识依赖于感性认识的问题。如果以为理性认识可以不从感性认识得来，他就是一个唯心论者。哲学史上有所谓“唯理论”一派，就是只承认理性的实在性，不承认经验的实在性，以为只有理性靠得住，而感觉的经验是靠不住的，这一派的错误在于颠倒了事实。理性的东西所以靠得住，正是由于它来源于感性，否则理性的东西就成了无源之水，无本之木，而只是主观自生的靠不住的东西了。从认识过程的秩序说来，感觉经验是第一的东西，我们强调社会实践在认识过程中的意义，就在于只有社会实践才能使人的认识开始发生，开始从客观外界得到感觉经验。一个闭目塞听、同客观外界根本绝缘的人，是无所谓认识的。认识开始于经验——这就是认识论的唯物论。 第二是认识有待于深化，认识的感性阶段有待于发展到理性阶段——这就是认识论的辩证法[7]。如果以为认识可以停顿在低级的感性阶段，以为只有感性认识可靠，而理性认识是靠不住的，这便是重复了历史上的“经验论”的错误。这种理论的错误，在于不知道感觉材料固然是客观外界某些真实性的反映（我这里不来说经验只是所谓内省体验的那种唯心的经验论），但它们仅是片面的和表面的东西，这种反映是不完全的，是没有反映事物本质的。要完全地反映整个的事物，反映事物的本质，反映事物的内部规律性，就必须经过思考作用，将丰富的感觉材料加以去粗取精、去伪存真、由此及彼、由表及里的改造制作工夫，造成概念和理论的系统，就必须从感性认识跃进到理性认识。这种改造过的认识，不是更空虚了更不可靠了的认识，相反，只要是在认识过程中根据于实践基础而科学地改造过的东西，正如列宁所说乃是更深刻、更正确、更完全地反映客观事物的东西。庸俗的事务主义家不是这样，他们尊重经验而看轻理论，因而不能通观客观过程的全体，缺乏明确的方针，没有远大的前途，沾沾自喜于一得之功和一孔之见。这种人如果指导革命，就会引导革命走上碰壁的地步。 理性认识依赖于感性认识，感性认识有待于发展到理性认识，这就是辩证唯物论的认识论。哲学上的“唯理论”和“经验论”都不懂得认识的历史性或辩证性，虽然各有片面的真理（对于唯物的唯理论和经验论而言，非指唯心的唯理论和经验论），但在认识论的全体上则都是错误的。由感性到理性之辩证唯物论的认识运动，对于一个小的认识过程（例如对于一个事物或一件工作的认识）是如此，对于一个大的认识过程（例如对于一个社会或一个革命的认识）也是如此。 然而认识运动至此还没有完结。辩证唯物论的认识运动，如果只到理性认识为止，那末还只说到问题的一半。而且对于马克思主义的哲学说来，还只说到非十分重要的那一半。马克思主义的哲学认为十分重要的问题，不在于懂得了客观世界的规律性，因而能够解释世界，而在于拿了这种对于客观规律性的认识去能动地改造世界。在马克思主义看来，理论是重要的，它的重要性充分地表现在列宁说过的一句话：“没有革命的理论，就不会有革命的运动。”[8]然而马克思主义看重理论，正是，也仅仅是，因为它能够指导行动。如果有了正确的理论，只是把它空谈一阵，束之高阁，并不实行，那末，这种理论再好也是没有意义的。认识从实践始，经过实践得到了理论的认识，还须再回到实践去。认识的能动作用，不但表现于从感性的认识到理性的认识之能动的飞跃，更重要的还须表现于从理性的认识到革命的实践这一个飞跃。抓着了世界的规律性的认识，必须把它再回到改造世界的实践中去，再用到生产的实践、革命的阶级斗争和民族斗争的实践以及科学实验的实践中去。这就是检验理论和发展理论的过程，是整个认识过程的继续。理论的东西之是否符合于客观真理性这个问题，在前面说的由感性到理性之认识运动中是没有完全解决的，也不能完全解决的。要完全地解决这个问题，只有把理性的认识再回到社会实践中去，应用理论于实践，看它是否能够达到预想的目的。许多自然科学理论之所以被称为真理，不但在于自然科学家们创立这些学说的时候，而且在于为尔后的科学实践所证实的时候。马克思列宁主义之所以被称为真理，也不但在于马克思、恩格斯、列宁、斯大林等人科学地构成这些学说的时候，而且在于为尔后革命的阶级斗争和民族斗争的实践所证实的时候。辩证唯物论之所以为普遍真理，在于经过无论什么人的实践都不能逃出它的范围。人类认识的历史告诉我们，许多理论的真理性是不完全的，经过实践的检验而纠正了它们的不完全性。许多理论是错误的，经过实践的检验而纠正其错误。所谓实践是真理的标准，所谓“生活、实践底观点，应该是认识论底首先的和基本的观点”[9]，理由就在这个地方。斯大林说得好：“理论若不和革命实践联系起来，就会变成无对象的理论，同样，实践若不以革命理论为指南，就会变成盲目的实践。”[10] 说到这里，认识运动就算完成了吗？我们的答复是完成了，又没有完成。社会的人们投身于变革在某一发展阶段内的某一客观过程的实践中（不论是关于变革某一自然过程的实践，或变革某一社会过程的实践），由于客观过程的反映和主观能动性的作用，使得人们的认识由感性的推移到了理性的，造成了大体上相应于该客观过程的法则性的思想、理论、计划或方案，然后再应用这种思想、理论、计划或方案于该同一客观过程的实践，如果能够实现预想的目的，即将预定的思想、理论、计划、方案在该同一过程的实践中变为事实，或者大体上变为事实，那末，对于这一具体过程的认识运动算是完成了。例如，在变革自然的过程中，某一工程计划的实现，某一科学假想的证实，某一器物的制成，某一农产的收获，在变革社会过程中某一罢工的胜利，某一战争的胜利，某一教育计划的实现，都算实现了预想的目的。然而一般地说来，不论在变革自然或变革社会的实践中，人们原定的思想、理论、计划、方案，毫无改变地实现出来的事，是很少的。这是因为从事变革现实的人们，常常受着许多的限制，不但常常受着科学条件和技术条件的限制，而且也受着客观过程的发展及其表现程度的限制（客观过程的方面及本质尚未充分暴露）。在这种情形之下，由于实践中发现前所未料的情况，因而部分地改变思想、理论、计划、方案的事是常有的，全部地改变的事也是有的。即是说，原定的思想、理论、计划、方案，部分地或全部地不合于实际，部分错了或全部错了的事，都是有的。许多时候须反复失败过多次，才能纠正错误的认识，才能到达于和客观过程的规律性相符合，因而才能够变主观的东西为客观的东西，即在实践中得到预想的结果。但是不管怎样，到了这种时候，人们对于在某一发展阶段内的某一客观过程的认识运动，算是完成了。 然而对于过程的推移而言，人们的认识运动是没有完成的。任何过程，不论是属于自然界的和属于社会的，由于内部的矛盾和斗争，都是向前推移向前发展的，人们的认识运动也应跟着推移和发展。依社会运动来说，真正的革命的指导者，不但在于当自己的思想、理论、计划、方案有错误时须得善于改正，如同上面已经说到的，而且在于当某一客观过程已经从某一发展阶段向另一发展阶段推移转变的时候，须得善于使自己和参加革命的一切人员在主观认识上也跟着推移转变，即是要使新的革命任务和新的工作方案的提出，适合于新的情况的变化。革命时期情况的变化是很急速的，如果革命党人的认识不能随之而急速变化，就不能引导革命走向胜利。 然而思想落后于实际的事是常有的，这是因为人的认识受了许多社会条件的限制的缘故。我们反对革命队伍中的顽固派，他们的思想不能随变化了的客观情况而前进，在历史上表现为右倾机会主义。这些人看不出矛盾的斗争已将客观过程推向前进了，而他们的认识仍然停止在旧阶段。一切顽固党的思想都有这样的特征。他们的思想离开了社会的实践，他们不能站在社会车轮的前头充任向导的工作，他们只知跟在车子后面怨恨车子走得太快了，企图把它向后拉，开倒车。 我们也反对“左”翼空谈主义。他们的思想超过客观过程的一定发展阶段，有些把幻想看作真理，有些则把仅在将来有现实可能性的理想，勉强地放在现时来做，离开了当前大多数人的实践，离开了当前的现实性，在行动上表现为冒险主义。 唯心论和机械唯物论，机会主义和冒险主义，都是以主观和客观相分裂，以认识和实践相脱离为特征的。以科学的社会实践为特征的马克思列宁主义的认识论，不能不坚决反对这些错误思想。马克思主义者承认，在绝对的总的宇宙发展过程中，各个具体过程的发展都是相对的，因而在绝对真理的长河中，人们对于在各个一定发展阶段上的具体过程的认识只具有相对的真理性。无数相对的真理之总和，就是绝对的真理[11]。客观过程的发展是充满着矛盾和斗争的发展，人的认识运动的发展也是充满着矛盾和斗争的发展。一切客观世界的辩证法的运动，都或先或后地能够反映到人的认识中来。社会实践中的发生、发展和消灭的过程是无穷的，人的认识的发生、发展和消灭的过程也是无穷的。根据于一定的思想、理论、计划、方案以从事于变革客观现实的实践，一次又一次地向前，人们对于客观现实的认识也就一次又一次地深化。客观现实世界的变化运动永远没有完结，人们在实践中对于真理的认识也就永远没有完结。马克思列宁主义并没有结束真理，而是在实践中不断地开辟认识真理的道路。我们的结论是主观和客观、理论和实践、知和行的具体的历史的统一，反对一切离开具体历史的“左”的或右的错误思想。 社会的发展到了今天的时代，正确地认识世界和改造世界的责任，已经历史地落在无产阶级及其政党的肩上。这种根据科学认识而定下来的改造世界的实践过程，在世界、在中国均已到达了一个历史的时节——自有历史以来未曾有过的重大时节，这就是整个儿地推翻世界和中国的黑暗面，把它们转变过来成为前所未有的光明世界。无产阶级和革命人民改造世界的斗争，包括实现下述的任务：改造客观世界，也改造自己的主观世界——改造自己的认识能力，改造主观世界同客观世界的关系。地球上已经有一部分实行了这种改造，这就是苏联。他们还正在促进这种改造过程。中国人民和世界人民也都正在或将要通过这样的改造过程。所谓被改造的客观世界，其中包括了一切反对改造的人们，他们的被改造，须要通过强迫的阶段，然后才能进入自觉的阶段。世界到了全人类都自觉地改造自己和改造世界的时候，那就是世界的共产主义时代。 通过实践而发现真理，又通过实践而证实真理和发展真理。从感性认识而能动地发展到理性认识，又从理性认识而能动地指导革命实践，改造主观世界和客观世界。实践、认识、再实践、再认识，这种形式，循环往复以至无穷，而实践和认识之每一循环的内容，都比较地进到了高一级的程度。这就是辩证唯物论的全部认识论，这就是辩证唯物论的知行统一观。\n注释\n[1] 见列宁《黑格尔〈逻辑学〉一书摘要》。新的译文是：“实践高于（理论的）认识，因为它不仅具有普遍性的品格，而且还具有直接现实性的品格。”（《列宁全集》第55卷，人民出版社1990年版，第183页）\n[2] 参见马克思《关于费尔巴哈的提纲》（《马克思恩格斯选集》第1卷，人民出版社1972年版，第16—19页）和列宁《唯物主义和经验批判主义》第二章第六节（《列宁全集》第18卷，人民出版社1988年版，第144页）。\n[3] 见列宁《黑格尔〈逻辑学〉一书摘要》（《列宁全集》第55卷，人民出版社1990年版，第142页）。\n[4] 里手，湖南方言，内行的意思。\n[5] 一九五一年三月二十七日，毛泽东在致李达的信中说：“《实践论》中将太平天国放在排外主义一起说不妥，出选集时拟加修改，此处暂仍照原。”\n[6] 五四运动是一九一九年五月四日发生的反帝反封建的爱国运动。当时，第一次世界大战刚刚结束，英、美、法、日、意等战胜国在巴黎召开对德和会，决定由日本继承德国在中国山东的特权。中国是参加对德宣战的战胜国之一，但北洋军阀政府却准备接受这个决定。五月四日，北京学生游行示威，反对帝国主义的这一无理决定和北洋军阀政府的妥协。这次运动迅速地获得了全国人民的响应，到六月三日以后，发展成为有工人阶级、城市小资产阶级和民族资产阶级参加的广大群众性的反帝反封建的爱国运动。五四运动也是反对封建文化的新文化运动。以一九一五年《青年杂志》（后改名《新青年》）创刊为起点的新文化运动，竖起“民主”和“科学”的旗帜，反对旧道德，提倡新道德，反对旧文学，提倡新文学。五四运动中的先进分子接受了马克思主义，使新文化运动发展成为马克思主义思想运动，他们致力于马克思主义同中国工人运动相结合，在思想上和干部上准备了中国共产党的成立。\n[7] 参见列宁《黑格尔〈逻辑学〉一书摘要》：“要理解，就必须从经验开始理解、研究，从经验上升到一般。”（《列宁全集》第55卷，人民出版社1990年版，第175页）\n[8] 见列宁《俄国社会民主党人的任务》（《列宁全集》第2卷，人民出版社1984年版，第443页）；并见列宁《怎么办？》第一章第四节（《列宁全集》第6卷，人民出版社1986年版，第23页）。\n[9] 见列宁《唯物主义和经验批判主义》第二章第六节（《列宁全集》第18卷，人民出版社1988年版，第144页）。\n[10] 见斯大林《论列宁主义基础》第三部分《理论》。新的译文是：“离开革命实践的理论是空洞的理论，而不以革命理论为指南的实践是盲目的实践。”（《斯大林选集》上卷，人民出版社1979年版，第199—200页）\n[11] 参见列宁《唯物主义和经验批判主义》第二章第五节。原文是：“人类思维按其本性是能够给我们提供并且正在提供由相对真理的总和所构成的绝对真理的。”（《列宁全集》第18卷，人民出版社1988年版，第135页）\n","permalink":"https://gopherding.github.io/posts/read/%E5%AE%9E%E8%B7%B5%E8%AE%BA/","summary":"实践论 论认识和实践的关系——知和行的关系 （一九三七年七月） 在中国共产党内，曾经有一部分教条主义的同志长期拒绝中国革命的经验，否认“马克思主义不是教条而是行动的指南”这个真理，而只生吞活剥马克思主义书籍中的只言片语，去吓唬人们。还有另一部分经验主义的同志长期拘守于自身的片断经验，不","title":"实践论"},{"content":"对于指针接收器和值接收器方法的一些拙见 本文主要解决了下文代码中\nm := inputType.Method(i) 在使用指针接收器（pointer receiver）\nfunc (this *User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } 定义方法时Method()无预期输出的问题😫😫😫，详见代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this *User) Call() { //改成func (this User) Call()即可被下文inputType.Method(i)实现 fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() //可寻址值变量（左值） 上调用指针接收器方法，Golang 会自动隐式的为变量取地址后调用方法，Golang 的语法糖让我们不用再啰嗦的显式取地址。同理，当指针类型调用值接收器方法时，Golang 也会通过指针找到值类型，在值类型上调用方法。此处如果写成 User{1, \u0026#34;Aceld\u0026#34;, 18}.Call() 会报错，因为 User{1, \u0026#34;Aceld\u0026#34;, 18} 不是左值。 DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) fmt.Println(\u0026#34;inputType is :\u0026#34;, inputType.Name()) //获取input的value inputValue := reflect.ValueOf(input) fmt.Println(\u0026#34;inputValue is:\u0026#34;, inputValue) //通过type 获取里面的字段 //1. 获取interface的reflect.Type，通过Type得到NumField ,进行遍历 //2. 得到每个field，数据类型 //3. 通过filed有一个Interface()方法等到 对应的value for i := 0; i \u0026lt; inputType.NumField(); i++ { field := inputType.Field(i) value := inputValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, field.Name, field.Type, value) } //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, m.Name, m.Type) } } 在Go语言中，方法是否可以被反射（通过reflect包）获取取决于它们是如何定义的。当使用指针接收器（pointer receiver）定义一个方法时，该方法仅在指针类型上存在，而不是在值类型上。相反，当使用值接收器（value receiver）定义方法时，该方法将在值类型和指针类型上均可用。\n让我们分析提供的两种情况：\n使用指针接收器的方法： func (this *User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } 在这种情况下，Call方法是一个指针方法。这意味着它只能被*User类型的变量调用，而不能被User类型的变量调用。当使用指针接收器定义方法时，Go语言会在运行时为该方法创建一个新的函数，该函数接受一个指向接收者类型的指针作为第一个参数。因此，当尝试通过值类型的变量调用这个方法时，它不会出现在方法的列表中。\n使用值接收器的方法： func (this User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } 在这种情况下，Call方法是一个值方法。它可以被User类型的变量直接调用。当使用值接收器定义方法时，Go语言会为该方法创建一个新的函数，该函数接受接收者类型的值作为第一个参数。因此，当通过值类型的变量调用方法时，这个方法会出现在方法的列表中。\n在DoFiledAndMethod函数中，是通过一个interface{}类型的变量来获取方法的。如果interface{}变量包含的是一个User类型的值，那么使用值接收器定义的方法或者指针接收器定义的方法都会被反射包检测到。如果interface{}变量包含的是一个*User类型的指针，那么只有使用指针接收器定义的方法才会被检测到。😋😋😋　为了通过反射获取所有定义在User类型上的方法（无论它们是使用值接收器还是指针接收器定义的），需要在DoFiledAndMethod函数中处理这两种情况。可以通过检查inputType的Kind来确定它是否是一个指针，并相应地获取方法。下面是一个修改后的DoFiledAndMethod函数，它可以处理这两种情况：\nfunc DoFiledAndMethod(input interface{}) { // 获取input的type inputType := reflect.TypeOf(input) fmt.Println(\u0026#34;inputType is :\u0026#34;, inputType.Name()) // 获取input的value inputValue := reflect.ValueOf(input) fmt.Println(\u0026#34;inputValue is:\u0026#34;, inputValue) // 获取字段 for i := 0; i \u0026lt; inputType.NumField(); i++ { field := inputType.Field(i) value := inputValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, field.Name, field.Type, value) } // 获取方法 var userType reflect.Type if inputType.Kind() == reflect.Ptr { // 如果input是一个指针，获取它指向的实际类型 userType = inputType.Elem() } else { // 否则，直接使用input的类型 userType = inputType } for i := 0; i \u0026lt; userType.NumMethod(); i++ { m := userType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, m.Name, m.Type) } } 在这个修改后的函数中，我们检查了inputType的Kind是否为reflect.Ptr，如果是，则使用inputType.Elem()来获取指针指向的实际类型。然后，我们在这个实际类型上调用NumMethod和Method来获取和打印方法。这样，无论input是一个User类型的值还是一个*User类型的指针，函数都会正确地打印出定义在User类型上的所有方法。ヾ(≧▽≦*)o\n那究竟怎么选择是指针接收器还是值接收器呢？\n何时使用值类型 （1）如果接收器是一个 map，func 或者 chan，使用值类型（因为它们本身就是引用类型）。 （2）如果接收器是一个 slice，并且方法不执行 reslice 操作，也不重新分配内存给 slice，使用值类型。 （3）如果接收器是一个小的数组或者原生的值类型结构体类型(比如 time.Time 类型)，而且没有可修改的字段和指针，又或者接收器是一个简单地基本类型像是 int 和 string，使用值类型就好了。\n值类型的接收器可以减少一定数量的内存垃圾生成，值类型接收器一般会在栈上分配到内存（但也不一定），在没搞明白代码想干什么之前，别为这个原因而选择值类型接收器。\n何时使用指针类型 （1）如果方法需要修改接收器里的数据，则接收器必须是指针类型。 （2）如果接收器是一个包含了 sync.Mutex 或者类似同步字段的结构体，接收器必须是指针，这样可以避免拷贝。 （3）如果接收器是一个大的结构体或者数组，那么指针类型接收器更有效率。 （4）如果接收器是一个结构体，数组或者 slice，它们中任意一个元素是指针类型而且可能被修改，建议使用指针类型接收器，这样会增加程序的可读性。\n无论你声明方法的接收器是指针接收器还是值接收器，Go都可以帮你隐式转换为正确的方法使用。\n只需要记住，值类型不能调用指针接收器方法\n**也即：值接收器方法（value methods）可以通过指针和值调用，但是指针接收器方法（pointer methods）只能通过指针来调用。**但有一个例外，如果某个值是可寻址的（addressable，或者说左值），那么编译器会在值调用指针方法时自动插入取地址符，使得在此情形下看起来像指针方法也可以通过值来调用（语法糖）。\n从逻辑上理解为什么 “值类型不能调用指针接收器方法” 指针接收器方法，很可能在方法中会对调用者的属性进行更改操作，从而影响接收器；而对于值接收器方法，在方法中不会对接收器本身产生影响。\n指针接收器方法，很可能在方法中会对调用者的属性进行更改操作，从而影响接收器；而对于值接收器方法，在方法中不会对接收器本身产生影响。所以，当实现了一个值接收器方法，就可以自动生成一个指针接收器方法，因为两者都不会影响接收器。但是，当实现了一个指针接收器方法，如果此时自动生成一个值接收器方法，原本期望对接收器的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响接收器。\n如果实现了值接收器方法，会隐含地也实现了指针接收器方法。\n最后如果实在还是不知道该使用哪种接收器，那么记住使用指针接收器是最靠谱的。\ne.g.\n1.值接收器\u0026amp;\u0026amp;值调用，ok\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%v %s: %v\\n\u0026#34;, i, m.Name, m.Type) } } 2.值接收器\u0026amp;\u0026amp;指针调用，ok（如果实现了值接收器方法，会隐含地也实现了指针接收器方法。）\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := \u0026amp;User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%v %s: %v\\n\u0026#34;, i, m.Name, m.Type) } } 3.指针接收器\u0026amp;\u0026amp;值调用，no！！！\n/**当你使用 `reflect.TypeOf(user)` 来获取 `user` 变量的类型时，你得到的是 `User` 类型，而不是 `*User` 类型。由于 `Call` 方法现在是一个指针接收器方法，它只存在于 `*User` 类型上，而不是 `User` 类型上。 这就是为什么在 `DoFiledAndMethod` 函数中找不到 `Call` 方法的原因。`DoFiledAndMethod` 函数正在查看 `User` 类型的方法，而不是 `*User` 类型的方法。 **/ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this *User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%v %s: %v\\n\u0026#34;, i, m.Name, m.Type) } } 4.指针接收器\u0026amp;\u0026amp;指针调用，ok\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%v %s: %v\\n\u0026#34;, i, m.Name, m.Type) } } ","permalink":"https://gopherding.github.io/posts/tech/%E5%AF%B9%E4%BA%8E%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E5%99%A8%E5%92%8C%E5%80%BC%E6%8E%A5%E6%94%B6%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8B%99%E8%A7%81/","summary":"对于指针接收器和值接收器方法的一些拙见 本文主要解决了下文代码中 m := inputType.Method(i) 在使用指针接收器（pointer receiver） func (this *User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } 定义方法时Method()无预期输出的问题😫😫😫，详见代码如下： package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this *User) Call() { //改成func (this User) Call","title":"对于指针接收器和值接收器方法的一些拙见"},{"content":" CAS 实际代码文件在 Go / src / runtime / internal / atomic / asm_amd.s 文件中\nfunc (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // Slow path (outlined so that the fast path can be inlined) m.lockSlow() } 如果可以获得锁资源，则修改Mutex.state中的locked位，并成功获取，如果获取不到，则执行lowSlow()方法。\n比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。\nCAS缺点：\n1.CAS在共享资源竞争比较激烈的时候，每个goroutine会容易处于自旋状态，影响效率，在竞争激烈的时候推荐使用锁。\n2.无法解决ABA问题，ABA问题是无锁结构实现中常见的一种问题，可基本表述为： 进程P1读取了一个数值A P1被挂起(时间片耗尽、中断等)，进程P2开始执行 P2修改数值A为数值B，然后又修改回A P1被唤醒，比较后发现数值A没有变化，程序继续执行。\nGo如何保证并发安全 Mutex、Channel、Atomic\nMutex\n加锁应该是最常见的并发控制方法，一般分成两种，乐观锁和悲观锁。\n悲观锁是一种悲观思想，它总认为最坏的情况可能会出现。不管意料之外的结果是否会发生，只要存在发生的可能，就在操作这个资源之前先上锁。例如互斥锁、读写锁都是悲观锁。\n乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过。乐观锁适用于多读的场景，可以提高吞吐量。乐观锁的实现方案主要包含CAS和版本号机制。\nChannel\n详见：[goroutine\u0026amp;channel专题.md](C:\\Users\\GEORGE DING\\Desktop!\\BLOG\\Golang\\goroutine\u0026amp;channel专题.md)\nAtomic\n1.总线加锁\n所谓总线锁就是使用处理器提供的一个lock#信号，当一个处理器在总线上输出此信号时，其他处理器的请求会被阻塞住，那么该处理器可以独占共享内存。\n但总线锁定把cpu和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以开销比较大。\n2.缓存加锁\n第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。\n去 Go SDK/sync/atomic下找罢，或者点击这里\nCSP CSP 是通信顺序进程（Communicating Sequential Process）的简称，是一种并发编程模型。简单来说，CSP模型由并发的实体所组成，实体之间通过发送消息进行通信，而发送消息使用的就是通道，即channel。GO实现了CSP部分理论，goroutine对应CSP中的并发执行的实体，channel对应CSP中的channel。\n不要通过共享内存来通信，而应该通过通信来共享内存 一份有用的说明文档通常比额外的长名字更有价值 ","permalink":"https://gopherding.github.io/posts/tech/%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84go%E6%80%9D%E6%83%B3/","summary":"CAS 实际代码文件在 Go / src / runtime / internal / atomic / asm_amd.s 文件中 func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // Slow path (outlined so that the fast path can be inlined) m.lockSlow() } 如果可以获得锁资源，则修改Mutex.state中的locked位，并成功获取，如果获取不到，则执行lowSlow()方法。 比较并交换(compare and swap, CAS)","title":"眼前一亮的go思想"},{"content":"Nginx 实现负载均衡主要有以下几种方法：\n轮询（Round - Robin） 原理 轮询是 Nginx 默认的负载均衡算法。它按照顺序依次将客户端的请求分配到后端的服务器组中。例如，有服务器 A、B、C，当第一个请求来时分配到 A，第二个请求分配到 B，第三个请求分配到 C，第四个请求又回到 A，如此循环。 配置示例 在nginx.conf的http块中定义一个upstream服务器组： upstream backend { server server1.example.com; server server2.example.com; server server3.example.com; } 然后在server块中，使用proxy_pass指令将请求转发到这个upstream组： server { listen 80; server_name example.com; location / { proxy_pass http://backend; } } 加权轮询（Weighted Round - Robin） 原理 加权轮询考虑到后端服务器的性能差异。为不同的服务器分配不同的权重值，权重越高的服务器被分配到请求的概率就越大。例如，服务器 A 的权重为 3，服务器 B 的权重为 2，服务器 C 的权重为 1，那么在总共 6 次请求中，服务器 A 可能会被分配到 3 次，服务器 B 被分配到 2 次，服务器 C 被分配到 1 次。 配置示例 在upstream组中为服务器指定权重： upstream backend { server server1.example.com weight = 3; server server2.example.com weight = 2; server server3.example.com weight = 1; } IP 哈希（IP Hash） 原理 IP 哈希算法根据客户端的 IP 地址计算一个哈希值，然后根据这个哈希值将请求固定分配到后端的某一台服务器上。这样可以保证来自同一个客户端的请求总是被发送到同一台服务器，适用于有状态的服务，如某些需要保持会话状态的 Web 应用。 配置示例 在upstream组中使用ip_hash指令： upstream backend { ip_hash; server server1.example.com; server server2.example.com; server server3.example.com; } 最少连接（Least Connections） 原理 最少连接算法会将新的请求分配到当前连接数最少的服务器上。这有助于更均衡地分配负载，特别是在后端服务器的处理能力相近但请求处理时间差异较大的情况下。例如，服务器 A 当前有 10 个连接，服务器 B 有 5 个连接，服务器 C 有 3 个连接，那么新的请求就会被分配到服务器 C。 配置示例 在upstream组中使用least_conn指令： upstream backend { least_conn; server server1.example.com; server server2.example.com; server server3.example.com; } 基于 URL 的哈希（URL Hash） 原理 根据请求的 URL 计算哈希值，然后根据这个哈希值将请求分配到后端服务器。这样相同的 URL 请求总是被发送到同一台服务器，适用于对缓存有特殊要求的场景，如缓存服务器组，相同的 URL 内容可以在同一台服务器上缓存和处理。 配置示例 在upstream组中使用hash指令，并指定$uri（表示请求的 URL）作为哈希计算的依据： upstream backend { hash $uri; server server1.example.com; server server2.example.com; server server3.example.com; } ","permalink":"https://gopherding.github.io/posts/tech/nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","summary":"Nginx 实现负载均衡主要有以下几种方法： 轮询（Round - Robin） 原理 轮询是 Nginx 默认的负载均衡算法。它按照顺序依次将客户端的请求分配到后端的服务器组中。例如，有服务器 A、B、C，当第一个请求来时分配到 A，第二个请求分配到 B，第三个请求分配到 C，第四个请求又回到 A，如此循环。 配置示例 在","title":"Nginx实现负载均衡的几种方法"},{"content":"nginx.conf`是 Nginx 服务器的配置文件，用于配置服务器的各种行为和功能。以下是一些常见配置项及其在静态文件服务、反向代理负载均衡、改写请求响应方面的相关用法：\n1. 基本配置块 user：指定运行 Nginx 工作进程的用户和用户组。例如：user nobody nobody;。这在控制 Nginx 进程的权限方面非常重要，确保它只能访问必要的资源。 error_log：设置错误日志的路径和级别。例如：error_log /var/log/nginx/error.log error;，其中error是日志级别，可以是debug、info、notice、warn、error、crit等，用于记录不同严重程度的错误和事件，方便排查问题。 pid：指定 Nginx 进程 ID 文件的路径。例如：pid /var/run/nginx.pid;，这个文件用于存储 Nginx 主进程的进程 ID，在一些管理操作（如重新加载配置、停止 Nginx 等）中会用到。 2. 事件配置块 worker_connections：设置每个工作进程可以同时处理的最大连接数。例如：worker_connections 1024;，这对于调整 Nginx 的并发处理能力很关键，需要根据服务器硬件资源和预期的并发请求量来合理设置。 3. HTTP 配置块（包含静态文件服务、反向代理负载均衡、改写请求响应相关配置） 静态文件服务 server：定义一个虚拟服务器，在其中可以配置多location块来处理不同的请求路径。 server_name：指定服务器的域名或 IP 地址，用于匹配客户端请求的主机头。例如：server_name example.com www.example.com;，这样 Nginx 就知道哪些请求应该由这个虚拟服务器来处理。 location：配置请求的路径匹配规则。 对于静态文件服务，例如将/static/路径下的请求映射到服务器上的/var/www/static/目录下的静态文件，可以这样配置： location /static/ { root /var/www; autoindex on; # 开启目录浏览（可选） } root指令指定了静态文件的根目录，Nginx 会在这个目录下查找与请求路径相对应的文件。如果启用了autoindex，当客户端访问该目录时，会显示目录中的文件列表（在某些情况下可能需要谨慎使用，避免暴露敏感信息）。\n反向代理负载均衡 upstream：定义后端服务器集群，给集群一个名称，以便在server块中引用。例如 upstream backend_cluster { server backend1.example.com weight=3; # 分配权重为3 server backend2.example.com; server backend3.example.com down; # 标记为不可用（临时下线） } 这里配置了一个名为backend_cluster的后端服务器集群，包含三个后端服务器。可以通过weight参数设置每个服务器的权重，权重越高，分配到的请求比例就越大；down参数用于标记服务器暂时不可用，Nginx 将不会把请求转发到该服务器。\nserver：在server块中使用location和proxy_pass指令将请求反向代理到后端服务器集群。例如： server { listen 80; server_name example.com; location / { proxy_pass http://backend_cluster; proxy_set_header Host $host; # 设置转发请求的Host头 proxy_set_header X-Real-IP $remote_addr; # 设置真实客户端IP头（可选，用于后端获取真实客户端IP） } } 当客户端访问example.com时，请求会被反向代理到backend_cluster定义的后端服务器集群中的某个服务器上，根据负载均衡算法（默认是轮询，可以通过ip_hash等指令修改算法）进行分配。proxy_set_header指令用于设置转发到后端服务器的请求头信息，确保后端服务器能够正确处理请求并获取必要的信息。\n改写请求响应 rewrite：用于改写请求的 URL。例如，将所有以.html结尾的请求重定向到不带.html的路径： location / { rewrite ^(.*)\\.html$ $1 permanent; } 这里的rewrite规则使用正则表达式^(.*)\\.html$匹配以.html结尾的请求路径，并将其重写为去掉.html的路径。permanent表示返回 301 永久重定向状态码给客户端，告诉客户端更新书签等。\nproxy_redirect：用于改写后端服务器返回的响应头中的Location和Refresh字段。例如，如果后端服务器返回的重定向地址是相对路径，而希望在返回给客户端时将其转换为绝对路径，可以这样配置： location / { proxy_pass http://backend; proxy_redirect off; # 关闭默认的重定向处理（如果需要自定义） proxy_redirect http://backend/ /; # 将后端返回的以http://backend/开头的重定向地址转换为以/开头的绝对路径 } 这样可以确保客户端接收到正确的重定向地址，提高用户体验并避免一些潜在的问题。\n4. 其他常见配置项 access_log：设置访问日志的路径和格式。例如：access_log /var/log/nginx/access.log combined;，combined是一种常用的日志格式，记录了客户端 IP、请求时间、请求方法、请求 URL、协议、响应状态码、发送字节数、引用页面等信息，方便分析服务器的访问情况和用户行为。 sendfile：用于开启或关闭高效文件传输模式（sendfile系统调用）。例如：sendfile on;，在提供静态文件服务时，开启sendfile可以提高文件传输效率，减少数据在内核空间和用户空间之间的拷贝次数。 keepalive_timeout：设置长连接的超时时间。例如：keepalive_timeout 65;，当客户端与服务器建立长连接后，如果在这个时间内没有新的请求，连接将被关闭。合理设置这个值可以在一定程度上提高性能，减少连接建立和关闭的开销，但也需要根据实际情况平衡服务器资源和客户端连接的管理。 ","permalink":"https://gopherding.github.io/posts/tech/nginx.conf%E7%9A%84%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E9%A1%B9/","summary":"nginx.conf`是 Nginx 服务器的配置文件，用于配置服务器的各种行为和功能。以下是一些常见配置项及其在静态文件服务、反向代理负载均衡、改写请求响应方面的相关用法： 1. 基本配置块 user：指定运行 Nginx 工作进程的用户和用户组。例如：user nobody nobody;。这在控制 Nginx 进程的权限方面非常重","title":"Nginx.conf的常见配置项"},{"content":"细说\nmerge 会对提交历史进行保留，很显然更适合多人协作开发的场景，因为如果出现问题也可以追溯到历史的每一次提交。\n而 rebase 则是会让提交历史更加简洁易读，保持提交历史的线性结构，所以更适合个人开发和整理分支的情况。\n如果我想要把某个特性分支 feature_xxx 合并到 main 分支中的时候，最好的方式就是 merge，而当我一个人需要开发某个 feature_xxx 分支的时候，最好的方式就是 rebase。\ngit rebase 的黄金法则是：永远不要在公共分支上使用它！\n一句话概括就是：merge 适合团队协作，而 rebase 适合一个人开发的分支。\n","permalink":"https://gopherding.github.io/posts/tech/git-merge%E5%92%8Crebase/","summary":"细说 merge 会对提交历史进行保留，很显然更适合多人协作开发的场景，因为如果出现问题也可以追溯到历史的每一次提交。 而 rebase 则是会让提交历史更加简洁易读，保持提交历史的线性结构，所以更适合个人开发和整理分支的情况。 如果我想要把某个特性分支 feature_xxx 合并到 main 分支中的时候，最好的方式就是 merge，而当我","title":"Git:merge or rebase?"},{"content":" \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 命令分类 命令 描述 初始化 git init 在当前目录创建一个新的 Git 仓库。 克隆仓库 git clone [url] 从远程仓库克隆到本地。 添加文件 git add [file directory] 添加文件，将文件或目录添加到暂存区。 提交更改 git commit -m \u0026quot;message\u0026quot; 将暂存区的内容提交到本地仓库，同时附上提交信息。 查看状态 git status 显示工作区和暂存区的状态。 查看日志 git log 查看提交历史记录。 分支操作 git branch 列出本地分支。 git branch [branch-name] 创建一个新分支。 git checkout [branch-name] 切换到指定分支。 git merge [branch-name] 将指定分支合并到当前分支。 远程仓库 git remote add [name] [url] 添加一个远程仓库。 git push [remote-name] [branch-name] 将本地指定分支推送到远程仓库对应的分支。如果远程分支不存在，会自动创建。例如，git push origin master 将本地的 master 分支推送到名为 origin 的远程仓库的 master 分支。 git push --set-upstream [remote-name] [branch-name] 首次推送一个新分支到远程仓库并建立跟踪关系。 git push -f [remote-name] [branch-name] 强制推送，覆盖远程分支的内容。一般不建议常规使用，除非确定了解其后果。 拉取操作 git pull [remote-name] [branch-name] 从远程仓库拉取最新的更改并合并到当前分支。 比较差异 git diff 显示工作区和暂存区的差异。 git diff --staged 显示暂存区和上一次提交的差异。 git diff [branch1] [branch2] 比较两个分支的差异。 撤销操作 git reset git revert [commit] 创建一个新的提交来撤销指定的提交。 标签操作 git tag [tag-name] 给当前提交打标签。 git tag -a [tag-name] -m \u0026quot;message\u0026quot; 创建带注释的标签。 git push [remote-name] [tag-name] 将标签推送到远程仓库。 配置信息 git config --global user.name \u0026quot;your name\u0026quot; 设置全局用户名。 git config --global user.email \u0026quot;your email\u0026quot; 设置全局用户邮箱。 git config --list 查看所有配置信息。 ","permalink":"https://gopherding.github.io/posts/tech/git%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/","summary":"\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 命令分类 命令 描述 初始化 git init 在当前目录创建一个新的 Git 仓库。 克隆仓库 git clone [url] 从远程仓库克隆到本地。 添加文件 git add [file directory] 添加文件，将文件或目录添加到暂存区。 提交更改 git commit -m \u0026quot;message\u0026quot; 将暂存区的内容提交到本地仓库，同时附上提交信息。 查看状态 git status 显示工作区和暂存区的状态。 查看日志 git log 查看提交历史记录","title":"Git命令速查表"},{"content":"实现细节： 看看大佬：\n![image-20240812182747227](C:\\Users\\GEORGE DING\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240812182747227.png)\nmheap：全局的内存起源，访问要加全局锁 mcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内 mcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁 附：分点阐述 mspan 的特质： mspan 是 Golang 内存管理的最小单元 mspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样） 每个 mspan 根据空间大小以及面向分配对象的大小，会被划分为不同的等级（2.2小节展开） 同等级的 mspan 会从属同一个 mcentral，最终会被组织成链表，因此带有前后指针（prev、next） 由于同等级的 mspan 内聚于同一个 mcentral，所以会基于同一把互斥锁管理 mspan 会基于 bitMap 辅助快速找到空闲内存块（块大小为对应等级下的 object 大小），此时需要使用到 Ctz64 算法. 宏观描述： 另一个大佬：\n（一）Page 和TCMalloc中page相同，上图中最下方浅蓝色长方形代表一个page。\n（二）Span 与TCMalloc中的Span相同，Span是go内存管理的基本单位，代码中为mspan，一组连续的Page组成1个Span，所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span，另外，1个淡紫色长方形为1个Span。\n（三）mcache mcache与TCMalloc中的ThreadCache类似，mcache保存的是各种大小的Span，并按Span class分类，小对象直接从mcache分配内存，它起到了缓存的作用，并且可以无锁访问。\n（四）mcentral mcentral与TCMalloc中的CentralCache类似，是所有线程共享的缓存，需要加锁访问，它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。但mcentral与CentralCache也有不同点，CentralCache是每个级别的Span有1个链表，mcache是每个级别的Span有2个链表。\n（五）mheap mheap与TCMalloc中的PageHeap类似，它是堆内存的抽象，把从OS（系统）申请出的内存页组织成Span，并保存起来。当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。但mheap与PageHeap也有不同点：mheap把Span组织成了树结构，而不是链表，并且还是2棵树，然后把Span分配到heapArena进行管理，它包含地址映射和span是否包含指针等位图，这样做的主要原因是为了更高效的利用内存：分配、回收和再利用。\nGo的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。\n大体上的分配流程：\n32KB 的对象，直接从mheap上分配；\n\u0026lt;=16B 的对象使用mcache的tiny分配器分配； (16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配； 如果mcache没有相应规格大小的mspan，则向mcentral申请 如果mcentral没有相应规格大小的mspan，则向mheap申请 如果mheap中也没有合适大小的mspan，则向操作系统申请\n总结 Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。 Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。 mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。 极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。\n","permalink":"https://gopherding.github.io/posts/tech/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/","summary":"实现细节： 看看大佬： ![image-20240812182747227](C:\\Users\\GEORGE DING\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240812182747227.png) mheap：全局的内存起源，访问要加全局锁 mcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内 mcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁 附：分点阐述 mspan 的特质： mspan 是 Golang 内存管理的最小单元 mspan 大小","title":"Golang内存模型与分配机制"},{"content":" := 不支持声明全局变量，作用域为局部变量。\niota，默认值为0，每行的iota都会累加1。\nGolang的自增自减\u0026rsquo;++\u0026rsquo; \u0026lsquo;\u0026ndash;\u0026lsquo;是语句而非表达式\na := 1 a ++ // 注意：不能写成 ++ a 或 -- a 必须放在右边使用 // b := a++ // 此处为错误的用法，不能写在一行，要单独作为语句使用 对外函数的函数名应该首字母大写，否则外部包无法调用该函数（类、属性亦然）。\n在包中，任何顶级声明前面的注释都将作为该声明的文档注释。在程序中，每个可导出（首字母大写）的名称都应该有文档注释。\n包应当以小写的单个单词来命名，不能使用下划线或驼峰。\nimport _ \u0026ldquo;fmt\u0026rdquo; : 给包起匿名别名，无法调用该包的方法但是可以执行当前包内部的init()方法，此即为副作用而导入。\nimport . \u0026ldquo;fmt\u0026rdquo; ：将当前包的全部方法导入到当前包的作用中，fmt包中的全部方法可以直接使用API调用，不需要使用fmt.API来调用。\ndefer执行顺序：先写的defer先入栈（代码行在上部的先入栈），然后先进后出，后出栈。\ndefer和return的先后顺序：return语句先执行，当该函数体执行完毕后（当前作用域内），defer语句执行。这是由于在Go语言中，return 语句不是原子操作，分为赋值，和返回值两步操作，最先是所有结果值在进入函数时都会初始化为其类型的零值（姑且称为ret赋值），然后执行defer命令,最后才是return操作。如果是有名返回值，返回值变量其实可视为是引用赋值，可以能被defer修改。而在匿名返回值时，给ret的值相当于拷贝赋值，defer命令时不能直接修改。return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。\ndefer延迟调用与闭包：defer 调用会在当前函数执行结束前才被执行，这些调用被称为延迟调用。defer 中使用的匿名函数也是一个闭包。重要的是：当defer被声明时，其参数就会被实时解析。\nfunc func1() { a := 1 defer func(r int) { fmt.Println(r) }(a) a = a + 100 fmt.Println(a) } func func2() { a := 1 defer func() { fmt.Println(a) }() a = a + 100 fmt.Println(a) } func1输出结果：\n$go run main.go 101 1 func2输出结果\n$go run main.go 101 101 两个函数的差异在于，func1中的defer定义时就将a=1赋值给了defer，在执行defer函数时执行时用的a是在定义时对a的拷贝并非当前环境变量中的a值，即defer执行的是:\nfunc (r int) { fmt.Println(r) }(1) 而在func2中,在defer定义时并没有完成任何赋值动作，只是注册了在执行完成后调用的函数，使用的a变量是当前环境的变量。\n函数调用时，引用类型（slice, map, interface, channel）都默认使用传递指针的值传递——只是功能类似于引用传递罢了。详见Go语言引用传递与值传递\n在Go中，结构体是一种聚合的数据类型，它包含零个或多个任意类型的值作为成员。由于结构体是值类型，当将一个结构体变量赋值给另一个变量时，会创建一个新的结构体实例，并将原始结构体的值拷贝给新实例。这意味着两个结构体变量将拥有独立的副本，对其中一个变量的修改不会影响另一个变量。\n匿名函数的快速执行：\nfunc(){ fmt.println(\u0026#34;Hello\u0026#34;) }() //这里加上()是定义并执行函数 闭包：简单来说，闭包 = 函数 + 引用环境\nslice动态数组对其传递可以修改原slice数据是因为使用了slice这个引用类型的指针进行的传递，是值传递（传递指针）而不是引用传递——GO只存在值传递——map类型亦是如此。slice能够通过函数传参后，修改对应的数组值，是因为 slice 内部保存了引用数组的指针，并不是因为引用传递。\n固定长度的数组在传参的时候是严格匹配数据类型的，e.g:[10]int的参数无法传到[5]int中，反之亦然，因为数组的大小是其类型的一部分。\nvar slice []int : 声明slice是一个切片，但是没有给其分配空间，修改其内部元素会报错index out；\n可以通过\nslice = make ([]int, 3) 来分配空间—— 一般通过\nslice := make([]int, 3) 来声明一个切片并开辟内存空间。\n切片保存了对底层数组的引用，若你将切片赋予另一个切片，它们会引用同一个数组。\nvar slice = make([]int, len, cap) ：长度为len，容量为cap;\nslice := arr[startIndex : endIndex] : 初始化切片slice为数组arr的引用。\nslice中的len表示数组空间内存在有效值的数组长度，cap表示这个底层数组空间的大小，当len达到cap时，cap自动扩容一倍；在修改切片中的元素时，需要确保索引不超出切片的长度len范围。\n如果期望容量大于当前容量的两倍就会使用期望容量； 如果当前切片的长度小于阈值（默认 256）就会将容量翻倍； 如果当前切片的长度大于等于阈值（默认 256），就会每次增加 25% 的容量，基准是 newcap + 3*threshold，直到新容量大于期望容量；\n切片截取：slice[x : y] : 截取从索引x（包含）到索引y（不包含）。\n使用 copy 函数要注意对于 copy(dst, src)，要初始化 dst 的 len，否则无法复制。\n切片就像数组的引用 切片并不存储任何数据，它只是描述了底层数组中的一段，更改切片的元素会修改其底层数组中对应的元素，和它共享底层数组的切片都会观测到这些修改。\nvar myMap map[int] string : 声明myMap是一种map类型，key是int型，value是string型，但是没有分配内存空间；\n可以通过myMap = make(map[int]string, 10)来分配空间——一般通过\nmyMap := make(map[int]string) myMap2[1] = \u0026#34;java\u0026#34; myMap2[2] = \u0026#34;c++\u0026#34; myMap2[3] = \u0026#34;python\u0026#34; //或者 myMap := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;c++\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;python\u0026#34;, } 来进行声明+初始化。\n哪些数据结构可以作为map的key？\n具有可比较性：键的类型必须支持相等性比较；\n可哈希性:键的类型必须支持哈希计算；\n通常使用整数、字符串、浮点数、指针等基本类型作为 map 的键；\n切片和函数不支持比较，不能用作map的键。\n结构体指针：结构体调用成员变量可以使用 变量名.成员名、指针名.成员名 都可以，直接用指针名.成员名的方式，修改原地址的值。\nGo 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口——鸭子类型。\n只包含一个方法的接口应当以该方法的名称加上 -er 后缀来命名。\nGo没有显式的继承，而是通过组合实现继承，内嵌一个（或多个）包含想要的行为（字段和方法）的结构体；多重继承可以通过内嵌多个结构体实现。\n所有的类型包括自定义类型都实现了空接口interface{}，所以空接口interface{}可以被当做任意类型的数值/万能数据类型。\n类型断言用于将接口类型转换为指定类型，其语法为：\nvalue.(type) 或者 value.(T) str, ok := value.(string) 其中 value 是接口类型的变量，type 或 T 是要转换成的类型。\n如果类型断言成功，它将返回转换后的值和一个布尔值，表示转换是否成功；如果断言失败，str将继续存在且为字符串类型，但将拥有零值——即空字符串。\n断言成功的两种情况：两种动态类型是相同的；断言接口值实现了目标接口的所有方法（结构体类型的断言）。\n[对于指针接收器和值接收器方法的一些拙见.md](C:\\Users\\GEORGE DING\\Desktop!\\BLOG\\Golang\\对于指针接收器和值接收器方法的一些拙见.md)\nnew 和 make 均是用于分配内存：new用于值类型的内存分配，并且置为零值。make只用于slice、map以及channel这三种引用数据类型的内存分配和初始化。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。make(T) 它返回类型T的值（不是* T）。\npanic可以在任何地方引发，但是recover只能在defer的函数中有效。recover只能捕获同一goroutine内发生的panic，对于其他goroutine引发的panic无能为力。\n","permalink":"https://gopherding.github.io/posts/tech/golang%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/","summary":":= 不支持声明全局变量，作用域为局部变量。 iota，默认值为0，每行的iota都会累加1。 Golang的自增自减\u0026rsquo;++\u0026rsquo; \u0026lsquo;\u0026ndash;\u0026lsquo;是语句而非表达式 a := 1 a ++ // 注意：不能写成 ++ a 或 -- a 必须放在右边使用 // b := a++ // 此处为错误的用法，","title":"Golang学习中遇到的那些坑"},{"content":"Goroutine 单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。 Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过runtime.GOMAXPROCS函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。） Channel 未初始化的通道类型变量其默认零值是nil。\n关闭后的通道有以下特点：\n对一个关闭的通道再发送值就会导致 panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。(此时若不对 value, ok := \u0026lt;- ch 的ok值进行判定，则该通道转化为一个关闭的并且没有值的通道，继续接收则会输出无限0——规则同下) 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致 panic。 使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为同步通道。\n发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。\n单向通道：\n\u0026lt;- chan int // 只接收通道，只能接收不能发送 chan \u0026lt;- int // 只发送通道，只能发送不能接收 //在函数传参及任何赋值操作中全向通道（正常通道）可以转换为单向通道，但是无法反向转换。 如图：![image-20240318204746723](C:\\Users\\GEORGE DING\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240318204746723.png)\n不要在数据接收方或者在有多个发送者的情况下关闭通道\nDon’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.\n如何优雅地关闭channel？\n一个接收者和N个发送者：增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止发送数据。\nM个接收者和N个发送者：引入一个中间调解者角色并让其关闭额外的信号通道来通知所有的接收者和发送者结束工作。\ntype hchan struct { qcount uint // 环形队列中的（缓冲区中的）总元素个数 dataqsiz uint // 环形队列（缓冲区的）容量大小，即可存放元素的个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 //每个元素的大小 closed uint32 //标识关闭状态 elemtype *_type // 元素类型 sendx uint // 发送索引，元素写入时存放到队列中的位置 recvx uint // 接收索引，元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列 sendq waitq // 等待写消息的goroutine队列 lock mutex //互斥锁，chan不允许并发读写 } 我理解的不好，找到个大佬——Golang Channel 的底层原理\n大佬二号：Golang Channel 的底层原理\n大佬三号：深入 Go 并发原语 — Channel 底层实现\n","permalink":"https://gopherding.github.io/posts/tech/goroutinechannel%E4%B8%93%E9%A2%98/","summary":"Goroutine 单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc","title":"Goroutine\u0026Channel专题"},{"content":"Go的编译执行流程主要包括编译和执行两个阶段。 编译阶段：╰(艹皿艹 ) 前端编译：这个阶段的主要任务是将Go源代码转换成抽象语法树（AST, Abstract syntax tree）。首先，词法分析器将源代码转换成token序列，即将代码按关键字、标识符、运算符等分割成单个单元。然后，语法分析器将这些token序列转换成AST，即将代码按照语法规则进行解析，构建出语法树。在构建AST的过程中，还会进行语义分析，检查语法是否合法，例如变量是否被定义等。 后端编译：这个阶段的主要任务是将AST转换成机器码。编译器会将AST转换成中间代码，然后优化这些中间代码，最后生成目标机器能够运行的二进制机器码。\n执行阶段：o(￣┰￣*)ゞ 执行阶段则直接运行编译阶段生成的机器码。当程序被加载到内存中并执行时，CPU会按照机器码中的指令执行相应的操作，从而完成程序的功能。\n总的来说，Go的编译执行流程是一个典型的编译型语言的流程，先通过编译器将源代码转换成机器码，然后再由执行器执行这些机器码。在这个过程中，编译器会进行一系列的优化操作，以提高程序的运行效率。\ngo build之后发生了甚么事？😁 创建临时目录，mkdir -p $WORK/b001/ 查找依赖信息，cat \u0026gt;$WORK/b001/importcfg \u0026laquo; \u0026hellip; 执行源代码编译，/usr/local/go/pkg/tool/darwin_amd64/compile \u0026hellip; 收集链接库文件，cat \u0026gt;$WORK/b001/importcfg.link \u0026laquo; \u0026hellip; 生成可执行文件，/usr/local/go/pkg/tool/darwin_amd64/link -o \u0026hellip; 移动可执行文件，mv $WORK/b001/exe/a.out hello go run后又发生了甚么事？😀 与build不同的是，在link生成hello文件后，并没有把它移动到当前目录，而是通过$WORK/b001/exe/hello执行了程序。\n","permalink":"https://gopherding.github.io/posts/tech/go%E7%9A%84%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","summary":"Go的编译执行流程主要包括编译和执行两个阶段。 编译阶段：╰(艹皿艹 ) 前端编译：这个阶段的主要任务是将Go源代码转换成抽象语法树（AST, Abstract syntax tree）。首先，词法分析器将源代码转换成token序列，即将代码按关键字、标识符、运算符等分割成单个单元。然后，语法分析器将这些token","title":"Go的编译执行流程"},{"content":" klenkiven | 凛冬将至 klenkiven的博客 uublog | 博识笔记 一只youdama的博客 👉友链格式 名称： uublog 网址： https://uublog.xyz/ 图标： https://uublog.xyz/avatar.jpg 描述： 一只youdama的博客 👉友链申请要求 来E-Mail我就好啦，欢迎骚扰 : -）\n","permalink":"https://gopherding.github.io/links/","summary":"klenkiven | 凛冬将至 klenkiven的博客 uublog | 博识笔记 一只youdama的博客 👉友链格式 名称： uublog 网址： https://uublog.xyz/ 图标： https://uublog.xyz/avatar.jpg 描述： 一只youdama的博客 👉友链申请要求 来E-Mail我就好啦，欢迎骚扰 : -）","title":"🤝友链"},{"content":"索引下推： ​ 索引下推（Index Condition Pushdown）是数据库查询优化的一种技术，通常用于处理包含过滤条件的查询语句。它的原理是在使用索引进行查询时，将查询的过滤条件也应用到索引查找过程中，以减少需要读取和处理的数据量，从而提高查询性能。\n索引下推是MySQL5.6推出来的一个查询优化方案，主要的目的是减少数据库中不必要的数据读取和计算。\n索引下推的原理是尽可能把查寻条件推到索引层面进行过滤，减少从磁盘读取的数据量。\n索引覆盖： ​ 索引覆盖（Index Covering）是指一个查询可以完全通过索引来执行，而无需访问实际的数据行。在数据库中，通常查询语句包含了一系列的条件，这些条件用于筛选出符合特定条件的数据行。如果这些条件能够通过索引直接定位到符合条件的数据行，而无需访问实际的数据页，那么就称为索引覆盖。\n比如我们有这样一条SQL语句：\nselect name,age,level from user where name = \u0026#34;AAA\u0026#34; and age 17 那么我们就可以把目标查询内容设置成为索引\nkey idx_nal (name,age,level) using btree 那么这样的话，我们在搜索的时候，只需要通过索引就能够拿到我们需要的全部数据了。这样就避免了回表。\n索引覆盖注意事项：\n1.如果一个索引包含了需要查询的所有字段，那么这个索引就是覆盖索引。\n2.MySQL 只能使用B+Tree索引做覆盖索引，因为只有B+树能存储索引列值。\n","permalink":"https://gopherding.github.io/posts/tech/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E5%92%8C%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/","summary":"索引下推： ​ 索引下推（Index Condition Pushdown）是数据库查询优化的一种技术，通常用于处理包含过滤条件的查询语句。它的原理是在使用索引进行查询时，将查询的过滤条件也应用到索引查找过程中，以减少需要读取和处理的数据量，从而提高查询性能。 索引下推是MySQL5.6推出来的一个查询优","title":"索引下推和覆盖索引"},{"content":"病梅馆记 清· 龚自珍\n江宁之龙蟠，苏州之邓尉，杭州之西溪，皆产梅。或曰：“梅以曲为美，直则无姿；以欹为美，正则无景；以疏为美，密则无态。”固也。此文人画士，心知其意，未可明诏大号以绳天下之梅也；又不可以使天下之民斫直，删密，锄正，以夭梅病梅为业以求钱也。梅之欹之疏之曲，又非蠢蠢求钱之民能以其智力为也。有以文人画士孤癖之隐明告鬻梅者，斫其正，养其旁条，删其密，夭其稚枝，锄其直，遏其生气，以求重价，而江浙之梅皆病。文人画士之祸之烈至此哉！ 予购三百盆，皆病者，无一完者。既泣之三日，乃誓疗之：纵之顺之，毁其盆，悉埋于地，解其棕缚；以五年为期，必复之全之。予本非文人画士，甘受诟厉，辟病梅之馆以贮之。 呜呼！安得使予多暇日，又多闲田，以广贮江宁、杭州、苏州之病梅，穷予生之光阴以疗梅也哉！\n译文 ​\t江宁的龙蟠里，苏州的邓尉山，杭州的西溪，都出产梅。有人说：\u0026ldquo;梅凭着弯曲的姿态被认为是美丽的，笔直了就没有风姿；凭着枝干倾斜被认为是美丽的，端正了就没有景致；凭着枝叶稀疏被认为是美丽的，茂密了就没有姿态。”本来就如此。（对于）这，文人画家在心里明白它的意思，却不便公开宣告，大声疾呼，用（这种标准）来约束天下的梅。又不能够来让天下种梅人砍掉笔直的枝干、除去繁密的枝条、锄掉端正的枝条，把枝干摧折、使梅花呈病态作为职业来谋求钱财。梅的枝干的倾斜、枝叶的疏朗、枝干的弯曲，又不是那些忙于赚钱的人能够凭借他们的智慧、力量做得到的。有的人把文人画士这隐藏在心中的特别嗜好明白地告诉卖梅的人，（使他们）砍掉端正的（枝干），培养倾斜的侧枝，除去繁密的（枝干），摧折它的嫩枝，锄掉笔直的（枝干），阻碍它的生机，用这样的方法来谋求大价钱，于是江苏、浙江的梅都成病态了。文人画家造成的祸害严重到这个地步啊！　我买了三百盆梅，都是病梅，没有一盆完好的。我已经为它们流了好几天泪之后，于是发誓要治疗它们：我放开它们，使它们顺其自然生长，毁掉那些盆子，把梅全部种在地里，解开捆绑它们棕绳的束缚；把五年作为期限，一定使它们恢复和使它们完好。我本来不是文人画士，心甘情愿受到辱骂，开设一个病梅馆来贮存它们。 唉！怎么能让我有多一些空闲时间，又有多一些空闲的田地，来广泛贮存南京、杭州、苏州的病态的梅树，竭尽我毕生的时间来治疗病梅呢！\n","permalink":"https://gopherding.github.io/posts/read/%E7%97%85%E6%A2%85%E9%A6%86%E8%AE%B0/","summary":"病梅馆记 清· 龚自珍 江宁之龙蟠，苏州之邓尉，杭州之西溪，皆产梅。或曰：“梅以曲为美，直则无姿；以欹为美，正则无景；以疏为美，密则无态。”固也。此文人画士，心知其意，未可明诏大号以绳天下之梅也；又不可以使天下之民斫直，删密，锄正，以夭梅病梅为业以求钱也。梅之欹之疏之曲，又非蠢蠢求钱之","title":"病梅馆记"},{"content":"答韦中立论师道书 唐·柳宗元\n二十一日，宗元白：\n辱书云，欲相师。仆道不笃，业甚浅近，环顾其中，未见可师者。虽常好言论，为文章，甚不自是也。不意吾子自京师来蛮夷间，乃幸见取。仆自卜固无取，假令有取，亦不敢为人师。为众人师且不敢，况敢为吾子师乎？\n孟子称“人之患在好为人师”。由魏、晋氏以下，人益不事师。今之世，不闻有师，有辄哗笑之，以为狂人。独韩愈奋不顾流俗，犯笑侮，收召后学，作《师说》，因抗颜而为师。世果群怪聚骂，指目牵引，而增与为言辞。愈以是得狂名，居长安，炊不暇熟，又挈挈而东，如是者数矣。\n屈子赋曰：“邑犬群吠，吠所怪也。”仆往闻庸、蜀之南，恒雨少日，日出则犬吠，余以为过言。前六七年，仆来南，二年冬，幸大雪逾岭，被南越中数州。数州之犬，皆苍黄吠噬，狂走者累日，至无雪乃已，然后始信前所闻者。今韩愈既自以为蜀之日，而吾子又欲使吾为越之雪，不以病乎？非独见病，亦以病吾子。然雪与日岂有过哉？顾吠者犬耳！度今天下不吠者几人，而谁敢炫怪于群目，以召闹取怒乎？\n仆自谪过以来，益少志虑。居南中九年，增脚气病，渐不喜闹。岂可使呶呶者，早暮咈吾耳，骚吾心？则固僵仆烦愦，愈不可过矣。平居，望外遭齿舌不少，独欠为人师耳。\n抑又闻之，古者重冠礼，将以责成人之道，是圣人所尤用心者也。数百年来，人不复行。近有孙昌胤者，独发愤行之。既成礼，明日造朝，至外庭，荐笏，言于卿士曰：“某子冠毕。”应之者咸怃然。京兆尹郑叔则怫然，曳笏却立，曰：“何预我耶？”廷中皆大笑。天下不以非郑尹而快孙子，何哉独为所不为也。今之命师者大类此。\n吾子行厚而辞深，凡所作皆恢恢然有古人形貌；虽仆敢为师，亦何所增加也假而以仆年先吾子，闻道著书之日不後，诚欲往来言所闻，则仆固愿悉陈中所得者。吾子苟自择之，取某事，去某事，则可矣；若定是非以敎吾子，仆才不足，而又畏前所陈者，其为不敢也决矣。吾子前所欲见吾文，既悉以陈之，非以耀明於子，聊欲以观子气色，诚好恶如何也。今书来言者皆大过。吾子诚非佞誉诬谀之徒，直见爱甚故然耳!\n始吾幼且少，为文章，以辞为工。及长，乃知文者以明道，是固不苟为炳炳烺烺，务釆色，夸声音而以为能也。凡吾所陈，皆自谓近道，而不知道之果近乎？远乎？吾子好道而可吾文，或者其於道不远矣。故吾每为文章，未尝敢以轻心掉之，惧其剽而不留也；未尝敢以怠心易之，惧其弛而不严也；未尝敢以昏气出之，惧其昧没而杂也；未尝敢以矜气作之，惧其偃蹇而骄也。抑之欲其奥，扬之欲其明，疏之欲其通，廉之欲其节；激而发之欲其清，固而存之欲其重，此吾所以羽翼夫道也。本之《书》以求其质，本之《诗》以求其恒，本之《礼》以求其宜，本之《春秋》以求其断，本之《易》以求其动：此吾所以取道之原也。参之《谷梁氏》以厉其气，参之《孟》，《荀》以畅其支，参之《庄》，《老》以肆其端，参之《国语》以博其趣，参之《离骚》以致其幽，参之《太史公》以著其洁：此吾所以旁推交通，而以为之文也。凡若此者，果是耶，非耶？有取乎，抑其无取乎？吾子幸观焉，择焉，有余以告焉。苟亟来以广是道，子不有得焉，则我得矣，又何以师云尔哉？取其实而去其名，无招越、蜀吠，而为外廷所笑，则幸矣。宗元复白。\n译文 ​\t二十一日，宗元写：\n​\t承蒙您来信说，想要认我做老师。我的道德修养不深，学识非常浅薄，从各方面审察自己，看不出有值得学习的东西。虽然经常喜欢发些议论，写点文章，但我自己很不以为都是正确的。没有想到您从京城来到偏远的永州，竟幸运地被您取法。我自估量本来就没有什么可取的东西；即使有可取的，也不敢做别人的老师。做一般人的老师尚且不敢，更何况敢做您的老师呢？\n​\t孟子说，“人们的毛病，在于喜欢充当别人的老师。”从魏、晋以来，人们更加不尊奉老师。在当今的时代，没听说还有老师；如果有，人们就会哗然讥笑他，把他看作狂人。只有韩愈奋然不顾时俗，冒着人们的嘲笑侮辱，招收后辈学生，写作《师说》，就严正不屈地当起老师来。世人果然都感到惊怪，相聚咒骂，对他指指点点使眼色，相互拉拉扯扯示意，而且大肆渲染地编造谣言来攻击他。韩愈因此得到了狂人的名声，他住在长安，煮饭都来不及煮熟，又被外放而匆匆忙忙地向东奔去，像这样的情况有好几次了。\n​\t屈原的赋里说：“城镇中的狗成群地乱叫，叫的是它们感到奇怪的东西。”我过去听说庸、蜀的南边，经常下雨，很少出太阳，太阳一出来就会引起狗叫。我以为这是过分夸大的话。六七年前，我来到南方。元和二年的冬天，遇到下大雪，越过了五岭，覆盖了南越的几个州；这几个州的狗，都惊慌地叫着咬着，疯狂奔跑了好几天，直到没有雪了才静止下来，这以后我才相信过去所听说的话。如今韩愈已经把自己当作蜀地的太阳，而您又想使我成为越地的雪，我岂不要因此受到辱骂吗？不仅我会被辱骂，人们也会因此辱骂您。然而雪和太阳难道有罪过吗？只不过感到惊怪而狂叫的是狗罢了。试想当今天下见到奇异的事情不像狗那样乱叫的能有几个人，因而谁又敢在众人眼前显出自己与众不同，来招惹人们的喧闹和恼怒呢？\n​\t我自从被贬官以来，更加意志薄弱，很少思虑。居住南方九年，增添了脚气病（风瘫之类的），渐渐不喜欢喧闹，怎能让那些喧嚣不休的人从早到晚来刺激我的耳朵，扰乱我的心绪？那么必将使我卧病不起，心烦意乱，更不能生活下去了。平时意外地遭受到不少是非口舌，唯独还没有喜欢充当别人老师的罪名罢了。\n​\t我还听说，古代重视冠礼，是借以用成年人做人的道理来要求大家。这是圣人所以特别重视的原因。几百年以来，人们不再举行这种冠礼。近来有个叫孙昌胤的人，独自下决心举行冠礼。冠礼举行过后，第二天去上朝，来到外廷，把笏板插进衣带对大臣们说：“我已经行过冠礼了。”听见这话的人都感到莫名其妙。京兆尹郑叔则却满脸怒气，垂手拖着笏板，退后一步站着，说：“这与我有什么相干呀！”廷中的人都大笑起来。天下的人不因此去责难京兆尹郑叔则，反而嘲笑孙昌胤，这是为什么呢？只是因为孙昌胤做了别人所不做的事。现在被称作老师的人，非常像这种情况。\n​\t您的品行敦厚，文辞高深，凡是您作的文章，都气魄宏大，有古人的风貌；即使我敢做您的老师，对您又有什么帮助呢？假如因为我比您年长，学道、写文章的时间比您早，您确实愿同我往来，交谈彼此所学的东西，那么，我当然愿意向您毫无保留地陈述自己全部的心得，您自己随便加以选择，吸取哪些，扬弃哪些，就可以了。如果要我判定是非来教您，我的才能不够，而且又顾忌前面所说的那些情况，我不敢做您的老师是肯定的。您以前想要看看我的文章，我已经全部陈列给您了，这并不是以此向您炫耀自己，只是姑且想要看看，从您的神情态度上反映出我的文章的确是好是坏。现在您的来信，说的话都对我过奖了。您的确不是那种巧言谄媚假意奉承的人，只不过是特别喜欢我的文章，所以才这样说罢了。\n​\t当初我年轻又不懂事，写文章时把文辞漂亮当作工巧。到了年纪大一些，才知道文章是用来阐明道的，因此不再轻率地讲究形式的美观、追求辞采的华美、炫耀声韵的铿锵、把这些当做自己的才能了。凡是我所呈给您看的文章，都自认为接近于道，但不晓得果真离道近呢，还是远呢？您喜爱道而又赞许我的文章，也许它离道不远了。所以，我每当写文章的时候，从来不敢漫不经心地随便写作，恐怕文章浮滑而不深刻，从来不敢偷懒取巧地写作，恐怕文章松散而不严谨；从来不翦用糊涂不清的态度去写作，恐怕文章晦涩而又杂乱；从来不敢用骄傲的心理去写作，恐怕文章盛气凌人而又狂妄。加以抑制是希望文章含蓄，进行发挥是希望文章明快；加以疏导是希望文气流畅，进行精简是希望文辞凝炼；剔除污浊是希望语言清雅不俗，凝聚保存文气是希望风格庄重不浮。这就是我用文章来辅佐道的方法。学习写作以《尚书》为本原，以求文章质朴无华，以《诗经》为本原，以求文章具有永恒的情理，以《三礼》为本原，以求文章内容合理，以《春秋》为本原，以求文章是非明确、褒贬分明，以《易经》为本原，以求文章能够反映出事物的发展变化。这就是我吸取“道”的源泉的办法。参考《谷梁传》，以加强文章的气势，参考《孟子》、《荀子》，以使文章条理通达，参考《庄子》、《老子》，以使文章汪洋恣肆，参考《国语》，以使文章增强情趣，参考《离骚》，以使文章能够情思幽微，参考《史记》，以使文章显得语言简洁。这就是我用来广泛学习，使它们融会贯通，并运用来写文章的办法。凡是上面所说的这些，到底是对，还是不对呢？有可取的地方呢，还是没有可取的地方呢？希望您看看，进行选择，有空就来信告诉我。如果我们经常往来交谈，以扩充发挥作文之道，即使您不因我的帮助有什么收获，我却因为您的帮助而有所收获，又何必以老师来称呼这种关系呢？采取老师的实质，去掉老师的义，不要招致越地和蜀地的狗的惊怪狂叫，或者象孙昌胤举行冠礼那样遭到人们的嘲笑，那就万幸了。宗元再告。\n","permalink":"https://gopherding.github.io/posts/read/%E7%AD%94%E9%9F%A6%E4%B8%AD%E7%AB%8B%E8%AE%BA%E5%B8%88%E9%81%93%E4%B9%A6/","summary":"答韦中立论师道书 唐·柳宗元 二十一日，宗元白： 辱书云，欲相师。仆道不笃，业甚浅近，环顾其中，未见可师者。虽常好言论，为文章，甚不自是也。不意吾子自京师来蛮夷间，乃幸见取。仆自卜固无取，假令有取，亦不敢为人师。为众人师且不敢，况敢为吾子师乎？ 孟子称“人之患在好为人师”。由魏、晋氏以下","title":"答韦中立论师道书"},{"content":"好了歌( 第一回) 世人都晓神仙好, 惟有功名忘不了!\n古今将相在何方? 荒冢一堆草没了。\n世人都晓神仙好, 只有金银忘不了!\n终朝只恨聚无多, 及到多时眼闭了。\n世人都晓神仙好, 只有娇妻忘不了!\n君生日日说恩情, 君死又随人去了。\n世人都晓神仙好, 只有儿孙忘不了!\n痴心父母古来多, 孝顺子孙谁见了?\n好了歌注 陋室空堂，当年笏满床。\n衰草枯杨，曾为歌舞场。\n蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。\n说什么脂正浓，粉正香，如何两鬓又成霜？\n昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。\n金满箱，银满箱，展眼乞丐人皆谤。\n正叹他人命不长，那知自己归来丧！\n训有方，保不定日后作强梁。\n择膏粱，谁承望流落在烟花巷！\n因嫌纱帽小，致使锁枷杠。\n昨怜破袄寒，今嫌紫蟒长： 乱烘烘你方唱罢我登场，反认他乡是故乡。\n甚荒唐，到头来都是为他人作嫁衣裳！\n护官符( 第四回) 贾不假, 白玉为堂金作马。\n阿房宫, 三百里, 住不下金陵一个史。\n东海缺少白玉床, 龙王来请金陵王。\n丰年好大雪, 珍珠如土金如铁。\n警幻仙子赋( 第五回) 方离柳坞, 乍出花房。\n但行处, 鸟惊庭树; 将到时, 影度回廊。\n仙袂乍飘兮, 闻麝兰之馥郁; 荷衣欲动兮, 听环佩之铿锵。\n靥笑春桃兮, 云堆翠髻; 唇绽樱颗兮, 榴齿含香。\n纤腰之楚楚兮, 回风舞雪; 珠翠之辉辉兮, 满额鹅黄。\n金陵十二钗正册判词·可叹停机德( 第五回) 可叹停机德, 堪怜咏絮才。\n玉带林中挂, 金簪雪里埋。\n红楼梦曲·枉凝眉( 第五回) 一个是阆苑仙葩, 一个是美玉无瑕。\n若说没奇缘, 今生偏又遇着他;\n若说有奇缘, 如何心事终虚化?\n一个枉自嗟呀, 一个空劳牵挂;\n一个是水中月, 一个是镜中花。\n想眼中能有多少泪珠儿?\n怎经得秋流到冬尽, 春流到夏。\n红楼梦曲·分骨肉( 第五回) 一帆风雨路三千, 把骨肉家园齐来抛闪。\n恐哭损残年, 告爹娘: 休把儿悬念。\n自古穷通皆有定, 离合岂无缘!\n从今分两地, 各自保平安。\n奴去也, 莫牵连。\n红楼梦曲·收尾·飞鸟各投林( 第五回) 为官的, 家业凋零; 富贵的, 金银散尽;\n有恩的, 死里逃生; 无情的, 分明报应;\n欠命的, 命已还; 欠泪的, 泪已尽。\n冤冤相报实非轻, 分离聚合皆前定。\n欲知命短问前生, 老来富贵也真侥幸。\n看破的, 遁入空门; 痴迷的, 枉送了性命。\n好一似食尽鸟投林, 落了片白茫茫大地真干净!\n通灵宝玉与金锁铭文 ( 第八回) 通灵宝玉铭文:\n莫失莫忘, 仙寿恒昌 。\n金锁铭文:\n不离不弃, 芳龄永继 。\n赞会芳园 ( 第十一回) 黄花满地 , 白柳横坡。\n小桥通若耶之溪 , 曲径接天台之路 。\n石中清流激湍, 篱落飘香; 树头红叶翩翻 , 疏林如画。西风乍紧, 初罢莺啼; 暖日当暄 , 又添蛩语 。\n遥望东南, 建几处依山之榭 ; 纵观西北, 结三间临水之轩 。笙簧盈耳, 别有幽情; 罗绮穿林, 倍添韵致。\n蘅芷清芬 ( 贾宝玉) 蘅芜满净苑, 萝薜助芬芳。\n软衬三春草, 柔拖一缕香。\n轻烟迷曲径, 冷翠滴回廊。\n谁谓池塘曲, 谢家幽梦长。\n杏帘在望 ( 贾宝玉) 杏帘招客饮, 在望有山庄。\n菱荇鹅儿水, 桑榆燕子梁。\n一畦春韭绿, 十里稻花香。\n盛世无饥馁, 何须耕织忙?\n参禅偈·寄生草·解偈 ( 第二十二回) 参禅偈 你证我证, 心证意证。是无有证, 斯可云证。无可云证, 是立足境。\n无立足境, 是方干净。 (黛玉续)\n寄生草·解偈 无我原非你, 从他不解伊。肆行无碍凭来去。\n茫茫着甚悲愁喜, 纷纷说甚亲疏密。\n从前碌碌却因何, 到如今回头试想真无趣!\n葬花吟( 第二十七回) 花谢花飞花满天，红消香断有谁怜？ 游丝软系飘春榭，落絮轻沾扑绣帘。 闺中女儿惜春暮，愁绪满怀无释处。 手把花锄出绣闺，忍踏落花来复去。 柳丝榆荚自芳菲，不管桃飘与李飞； 桃李明年能再发，明年闺中知有谁？ 三月香巢已垒成，梁间燕子太无情！ 明年花发虽可啄，却不道人去梁空巢也倾。 一年三百六十日，风刀霜剑严相逼； 明媚鲜妍能几时，一朝漂泊难寻觅。 花开易见落难寻，阶前愁杀葬花人， 独倚花锄泪暗洒，洒上空枝见血痕。 杜鹃无语正黄昏，荷锄归去掩重门； 青灯照壁人初睡，冷雨敲窗被未温。 怪奴底事倍伤神？半为怜春半恼春。 怜春忽至恼忽去，至又无言去未闻。 昨宵庭外悲歌发，知是花魂与鸟魂？ 花魂鸟魂总难留，鸟自无言花自羞； 愿侬此日生双翼，随花飞到天尽头。 天尽头，何处有香丘？ 未若锦囊收艳骨，一抔净土掩风流。 质本洁来还洁去，强于污淖陷渠沟。 尔今死去侬收葬，未卜侬身何日丧？ 侬今葬花人笑痴，他年葬侬知是谁？ 试看春残花渐落，便是红颜老死时； 一朝春尽红颜老，花落人亡两不知！\n题帕三绝句 ( 第三十四回) 其一 眼空蓄泪泪空垂, 暗洒闲拋更向谁?\n尺幅鲛绡劳惠赠, 叫人焉得不伤悲!\n其二 拋珠滚玉只偷潸, 镇日无心镇日闲。\n枕上袖边难拂拭, 任他点点与斑斑。\n其三 彩线难收面上珠, 湘江旧迹已模糊。\n窗前亦有千竿竹, 不识香痕渍也无?\n林黛玉咏白海棠 ( 第三十七回) 半卷湘帘半掩门, 碾冰为土玉为盆。\n偷来梨蕊三分白, 借得梅花一缕魂。\n月窟仙人缝缟袂, 秋闺怨女拭啼痕。\n娇羞默默同谁诉? 倦倚西风夜已昏。\n蘅芜君宝钗·忆菊 ( 第三十八回) 怅望西风抱闷思, 蓼红苇白断肠时。\n空篱旧圃秋无迹, 冷月清霜梦有知。\n念念心随归雁远, 寥寥坐听晚砧迟。\n谁怜我为黄花瘦, 慰语重阳会有期。\n潇湘妃子黛玉·咏菊 ( 第三十八回) 无赖诗魔昏晓侵, 绕篱欹石自沉音。\n毫端蕴秀临霜写, 口角噙香对月吟。\n满纸自怜题素怨, 片言谁解诉秋心?\n一从陶令评章后, 千古高风说到今。\n潇湘妃子黛玉·问菊 ( 第三十八回) 欲讯秋情众莫知, 喃喃负手扣东篱。\n孤标傲世偕谁隐? 一样花开为底迟?\n圃露庭霜何寂寞? 雁归蛩病可相思?\n莫言举世无谈者, 解语何妨话片时?\n代别离·秋窗风雨夕 ( 第四十五回) 秋花惨淡秋草黄, 耿耿秋灯秋夜长。\n已觉秋窗秋不尽, 那堪风雨助凄凉!\n助秋风雨来何速? 惊破秋窗秋梦绿。\n抱得秋情不忍眠, 自向秋屏移泪烛。\n泪烛摇摇爇短檠, 牵愁照恨动离情。\n谁家秋院无风入? 何处秋窗无雨声?\n罗衾不奈秋风力, 残漏声催秋雨急。\n连宵脉脉复飕飕, 灯前似伴离人泣。\n寒烟小院转萧条, 疏竹虚窗时滴沥。\n不知风雨几时休, 已教泪洒窗纱湿。\n真真国女儿诗 ( 第五十二回) 昨夜朱楼梦, 今宵水国吟。\n岛云蒸大海, 岚气接丛林。\n月本无今古, 情缘自浅深。\n汉南春历历, 焉得不关心?\n林黛玉柳絮词·唐多令 ( 第七十回) 粉堕百花洲, 香残燕子楼。 一团团逐对成球。漂泊亦如人命薄, 空缱绻, 说风流!\n草木也知愁, 韶华竟白头。 叹今生, 谁拾谁收!嫁与东风春不管, 凭尔去, 忍淹留!\n","permalink":"https://gopherding.github.io/posts/read/%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%AF%97%E8%AF%8D%E6%9B%B2/","summary":"好了歌( 第一回) 世人都晓神仙好, 惟有功名忘不了! 古今将相在何方? 荒冢一堆草没了。 世人都晓神仙好, 只有金银忘不了! 终朝只恨聚无多, 及到多时眼闭了。 世人都晓神仙好, 只有娇妻忘不了! 君生日日说恩情, 君死又随人去了。 世人都晓神仙好, 只有儿孙忘不了! 痴心父母古来多, 孝顺子孙谁见了? 好了歌注","title":"红楼梦诗词（曲）\u003cTo Be Continue\u003e"},{"content":" 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法。 冒泡排序、插入排序、归并排序、基数排序是稳定的排序算法。\n选快希堆不稳，冒插归基稳定。\n","permalink":"https://gopherding.github.io/posts/tech/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","summary":"选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法。 冒泡排序、插入排序、归并排序、基数排序是稳定的排序算法。 选快希堆不稳，冒插归基稳定。","title":"排序算法"}]