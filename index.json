[{"content":"匆匆 盼望着，盼望着，东风来了，春天的脚步近了。\n一切都像刚睡醒的样子，欣欣然张开了眼。山朗润起来了，水长起来了，太阳的脸红起来了。\n小草偷偷地从土里钻出来，嫩嫩的，绿绿的。园子里，田野里，瞧去，一大片一大片满是的。坐着，躺着，打两个滚，踢几脚球，赛几趟跑，捉几回迷藏。风轻悄悄的，草绵软软的。\n桃树、杏树、梨树，你不让我，我不让你，都开满了花赶趟儿。红的像火，粉的像霞，白的像雪。花里带着甜味；闭了眼，树上仿佛已经满是桃儿、杏儿、梨儿。花下成千成百的蜜蜂嗡嗡地闹着，大小的蝴蝶飞来飞去。野花遍地是：杂样儿，有名字的，没名字的，散在花丛里，像眼睛，像星星，还眨呀眨的。\n“吹面不寒杨柳风”，不错的，像母亲的手抚摸着你。风里带来些新翻的泥土的气息，混着青草味，还有各种花的香，都在微微润湿的空气里酝酿。鸟儿将窠巢安在繁花嫩叶当中，高兴起来了，呼朋引伴地卖弄清脆的喉咙，唱出宛转的曲子，与轻风流水应和着。牛背上牧童的短笛，这时候也成天在嘹亮地响着。\n雨是最寻常的，一下就是三两天。可别恼。看，像牛毛，像花针，像细丝，密密地斜织着，人家屋顶上全笼着一层薄烟。树叶子却绿得发亮，小草也青得逼你的眼。傍晚时候，上灯了，一点点黄晕的光，烘托出一片安静而和平的夜。乡下去，小路上，石桥边，撑起伞慢慢走着的人；还有地里工作的农夫，披着蓑，戴着笠的。他们的草屋，稀稀疏疏的在雨里静默着。\n天上风筝渐渐多了，地上孩子也多了。城里乡下，家家户户，老老小小，他们也赶趟儿似的，一个个都出来了。舒活舒活筋骨，抖擞抖擞精神，各做各的一份事去。“一年之计在于春”；刚起头儿，有的是工夫，有的是希望。\n春天像刚落地的娃娃，从头到脚都是新的，他生长着。\n春天像小姑娘，花枝招展的，笑着，走着。\n春天像健壮的青年，有铁一般的胳膊和腰脚，他领着我们上前去。\n1933年7月\n","permalink":"https://gopherding.github.io/posts/read/%E6%98%A5/","summary":"\u003ch3 id=\"匆匆\"\u003e匆匆\u003c/h3\u003e\n\u003cp\u003e盼望着，盼望着，东风来了，春天的脚步近了。\u003c/p\u003e\n\u003cp\u003e一切都像刚睡醒的样子，欣欣然张开了眼。山朗润起来了，水长起来了，太阳的脸红起来了。\u003c/p\u003e\n\u003cp\u003e小草偷偷地从土里钻出来，嫩嫩的，绿绿的。园子里，田野里，瞧去，一大片一大片满是的。坐着，躺着，打两个滚，踢几脚球，赛几趟跑，捉几回迷藏。风轻悄悄的，草绵软软的。\u003c/p\u003e","title":"春"},{"content":"CS5494 Week 1: Introduction to Generative AI \u0026amp; Perception Models 第一周：生成式人工智能与感知模型导论 1. 核心概念：生成模型与判别模型 Core Concept: Generative vs. Discriminative Models 这是本节课最重要的理论基础，理解它们的区别是入门的关键。\n1. 判别模型 (Discriminative Models)\n功能 (Function): 学习如何区分或预测。就像给作业打分的老师，看到一个输入（试卷），给出一个输出（分数）。 Analogy: Like a teacher grading an exam. Given an input (exam paper), it produces an output (score). 数学表达 (Mathematical Form): 建模条件概率 $P(y|x)$。即给定输入 $x$（如一张照片），预测标签 $y$（如“猫”或“狗”）的概率。 Math: Models the conditional probability $P(y|x)$. Given input $x$, predict the probability of label $y$. 局限 (Limitation): 它们无法创造新数据，只能对现有数据进行分类或回归。 2. 生成模型 (Generative Models)\n功能 (Function): 学习数据的底层分布 (Underlying Distribution)，从而能够创造出与训练数据相似但全新的数据。就像一个画家，看过很多猫之后，在一张白纸上画出一只从未存在过的猫。 Analogy: Like an artist who, after seeing many cats, draws a new cat that never existed before on a blank piece of paper. 数学表达 (Mathematical Form): 建模联合概率分布 $P(x,y)$ 或数据本身的分布 $P(x)$。 Math: Models the joint probability distribution $P(x,y)$ or the data distribution $P(x)$ itself. 核心目标 (Core Goal): 能够从学习到的分布中采样 (Sample)，生成逼真的新样本（图像、文本、音频）。 2. 感知模型与表示学习 Perception Models \u0026amp; Representation Learning 课件中强调，为了做好生成（Generation），首先要解决感知（Perception）的问题。感知模型的核心就是表示学习。\n什么是表示学习？ (What is Representation Learning?)\n定义: 将原始数据（Raw Data）转化为机器更容易理解和处理的形式（Feature/Embedding）。 Definition: Converting raw data into a form (features/embeddings) that is easier for machines to understand and process. 过程: 从原始像素（Pixels）$\\rightarrow$ 抽象特征（Abstraction）$\\rightarrow$ 概念（Concepts）。 Process: From raw pixels $\\rightarrow$ Abstract features $\\rightarrow$ High-level concepts. 重要性: 好的表示（Representation）能让模型“理解”数据的本质，而不仅仅是死记硬背。AlphaGo 的成功就归功于它能比人类更好地表示棋盘局势。 3. 深度神经网络的演进 (Deep Neural Networks Evolution) From LeNet to Transformers 这部分回顾了深度学习过去十年的关键突破，正是这些技术让现在的 GenAI 成为可能。\nA. 卷积神经网络 (CNNs) 的崛起 LeNet (1989/1998): 引入了卷积 (Convolution) 和 池化 (Pooling) 的概念。利用权值共享（Weight Sharing）大大减少了参数量，适合处理图像。 AlexNet (2012): 深度学习的爆发点。引入了 ReLU 激活函数（解决了梯度消失问题）和 Dropout，并使用了 GPU 加速训练。 VGG (2014): 证明了**“越深越好” (Deeper is better)**。它用连续的 3x3 小卷积核代替了大卷积核，加深了网络结构。 B. 突破瓶颈：初始化与归一化 (Initialization \u0026amp; Normalization) 随着网络变深，训练变得极其困难（梯度爆炸或消失）。\n初始化 (Initialization): Xavier 和 Kaiming Initialization 提供了科学的参数初始值设定方法，让信号能更稳定地在网络中传播。 批归一化 (Batch Normalization, BN): 强制将每一层的输入拉回到标准的分布。这被认为是训练深层网络的“神技”，大大加速了收敛。 C. 残差网络 (ResNet, 2015) 问题: 当网络非常深时（如 100 层），简单堆叠层数反而会导致性能下降（Degradation problem）。 解决方案: 引入 Shortcut Connection (跳跃连接)，让数据可以直接跨层传递。 Mechanism: The network learns the residual (difference) $F(x)$ instead of the original mapping. Mathematically: $y = F(x) + x$. 意义: 使得训练成百上千层的网络成为可能，是现代大模型（包括 GPT 系列）的基石结构。 D. Transformer (2017) \u0026amp; ViT (2020) Transformer: 抛弃了循环（RNN）和卷积（CNN），完全依赖 Attention Mechanism (注意力机制)。每一个 token 都能看到所有其他 token，拥有全局上下文 (Global Context)。 Vision Transformer (ViT): 将图像切成小块（Patches），像处理文字一样处理图像。这统一了视觉和语言的模型架构。 4. 生成模型的框架 Framework of Generative Models 课件最后总结了构建一个生成模型的五个关键要素：\n形式化 (Formulation): 将问题定义为概率建模问题（如何描述 $P(x)$？）。 表示 (Representation): 使用深度神经网络（如 ResNet, Transformer）来拟合复杂的数据分布。 目标函数 (Objective Function): 定义“生成得好不好”的标准（Loss Function），衡量预测分布与真实分布的差异。 优化 (Optimization): 调整网络参数以最小化目标函数（通常使用反向传播）。 推断 (Inference): 训练好后，如何采样（Sampler）生成新数据？ 5. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 生成模型 Generative Model 学习数据分布 $P(x)$ 以生成新样本的模型。如 GPT, Stable Diffusion。 判别模型 Discriminative Model 学习条件概率 $P(y|x)$ 以分类或预测标签的模型。如垃圾邮件分类器。 表示学习 Representation Learning 自动从原始数据中提取有效特征的过程，将高维数据映射到低维、抽象的特征空间。 卷积神经网络 CNN (Convolutional Neural Network) 专门处理网格数据（如图像）的神经网络，利用卷积层提取局部特征。 残差学习 Residual Learning ResNet 的核心。通过引入“跳跃连接”，让网络学习残差（差异）而不是完整的映射，解决了深层网络的退化问题。 批归一化 Batch Normalization (BN) 在每一层网络的激活前对数据进行归一化处理，防止分布偏移，加速训练。 注意力机制 Attention Mechanism Transformer 的核心。允许模型在处理一个元素时，动态关注序列中的其他相关元素（无论距离多远）。 反向传播 Backpropagation 训练神经网络的核心算法。根据输出误差，反向计算梯度并更新网络参数。 概率分布 Probability Distribution 描述随机变量取值可能性的数学函数。生成模型本质上就是在拟合这个复杂的函数。 推断 Inference 模型训练完成后，利用模型进行预测或生成新数据的过程。 总结 (Summary) 这份课件的核心逻辑是：Generative AI 的本质是概率分布的建模，而为了通过机器学习好这个分布，我们需要强大的 Deep Learning 模型（如 ResNet, Transformer）作为支撑。 所以第一周花了很多时间复习深度学习的基础架构。\nCS5494 Week 2: Basics of Probability Distributions 第二周：概率分布基础 1. 生成模型 vs. 判别模型 (进阶版) Generative vs. Discriminative Models (Revisited) 上周讲了概念，这周从数学角度深入对比。\n判别模型 (Discriminative Models):\n目标 (Goal): 直接区分 $y$（标签）。建立 $x$ 到 $y$ 的映射。 数学 (Math): 建模条件概率 $P(y|x)$。 决策边界 (Decision Boundary): 它只关心怎么把两类数据分开，不关心数据长什么样。 Analogy: Like learning a rule to distinguish cats from dogs without knowing how to draw them. 生成模型 (Generative Models):\n目标 (Goal): 描述数据 $x$ 是如何生成的。 数学 (Math): 建模联合概率 $P(x, y)$ 或边缘概率 $P(x)$。 贝叶斯公式 (Bayes\u0026rsquo; Rule): 生成模型可以通过贝叶斯公式转化为判别模型： $$P(y|x) = \\frac{P(x|y)P(y)}{P(x)}$$ 优势 (Advantage): 课件特别提到，生成模型在缺失数据 (Missing Data) 的情况下依然有效。因为它可以对未观察到的变量进行边缘化 (Marginalize)，而判别模型必须依赖完整的 $x$。 2. 核心挑战：维数灾难 The Core Challenge: Curse of Dimensionality 这是本节课提出的最根本问题：为什么生成模型这么难做？\n问题描述 (Problem): 假设我们要为一个简单的 $28 \\times 28$ 黑白像素图像（如 MNIST 数字）建模联合分布。 每个像素有 2 种状态（0 或 1）。 总共有 $784$ 个像素。 那么这幅图可能的状态总数是 $2^{784}$。 Concept: The number of possible configurations grows exponentially with the number of variables (pixels). 结论 (Conclusion): 我们不可能列出一张表来记录每一个可能图像的概率。所需的参数量远远超过了宇宙中原子的数量。 解决方案 (Solution): 我们必须引入假设 (Assumptions) 和 结构 (Structure) 来减少参数量。 3. 结构化模型：贝叶斯网络 Structured Models: Bayesian Networks 为了解决维数灾难，我们引入了“条件独立性”假设。\nA. 链式法则 (The Chain Rule) 任何复杂的联合分布都可以分解为条件概率的乘积： $$P(x_1, x_2, x_3, x_4) = P(x_1) P(x_2|x_1) P(x_3|x_1, x_2) P(x_4|x_1, x_2, x_3)$$\n解释: 就像讲故事，后面的情节取决于前面的铺垫。 问题: 即使分解了，参数量并没有减少。最后几项依然非常复杂。 B. 条件独立性假设 (Conditional Independence Assumption) 这是贝叶斯网络的核心。我们假设：每个变量只依赖于它的少数几个“父节点”，而不是之前的所有变量。\nKey Idea: Variable $x_i$ is independent of its non-descendants given its parents. C. 贝叶斯网络 (Bayesian Networks) 定义: 一个有向无环图 (DAG)，其中节点代表变量，边代表依赖关系。 公式: $P(x_1, \u0026hellip;, x_n) = \\prod_{i=1}^{n} P(x_i | \\text{Parents}(x_i))$ 效果: 极大地减少了参数量。 全连接 (Fully Connected): 每个变量都依赖所有前序变量 $\\rightarrow$ 参数爆炸。 稀疏连接 (Sparse): 每个变量只依赖 1-2 个父节点 $\\rightarrow$ 参数可控。 D. 经典案例：朴素贝叶斯 (Naive Bayes) 这是贝叶斯网络的一个极端特例。 假设: 给定类别 $y$ 后，所有的特征 $x_i$ 都是相互独立的。 Assumption: All features are independent given the class label. 局限: 这个假设太强了（现实中像素之间肯定有关联），所以它生成的图片通常全是噪点，效果不好。但它作为分类器效果还不错。 4. 神经模型：引入深度学习 Neural Models: Merging Probability with Deep Learning 传统的图模型（如贝叶斯网络）需要专家手工设计依赖关系图，这很难。现在的趋势是结合神经网络。\n参数化 (Parameterization): 在贝叶斯网络中，我们需要用表格或简单函数来表示 $P(x_i | \\text{Parents}(x_i))$。 在神经模型中，我们用一个神经网络来拟合这个条件概率函数。 Mechanism: Use a neural network to output the probability distribution parameters. 非线性依赖 (Non-linear Dependence): 线性模型（如逻辑回归）假设变量间是线性关系。而神经网络通过激活函数（如 Sigmoid, ReLU）引入了非线性，能够捕捉更复杂的数据关系。 $$y = \\sigma(Wx + b)$$ 从图到网 (From Graphs to Nets): 我们可以重复堆叠神经层，构建深层网络。这实际上是在学习更复杂的、隐含的依赖结构，而不需要人工显式地画出每一条边。 5. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 联合分布 Joint Distribution $P(x, y)$ 或 $P(x_1, \u0026hellip;, x_n)$。描述所有变量同时取特定值的概率。这是生成模型的核心。 条件概率 Conditional Probability $P(A|B)$。在事件 B 发生的条件下，事件 A 发生的概率。 边缘化 Marginalization 通过对某些变量求和（或积分），从联合分布中得到子集变量分布的过程。常用于处理缺失数据。 维数灾难 Curse of Dimensionality 随着数据维度（特征数量）增加，数据空间呈指数级爆炸，导致数据变得极其稀疏，难以建模。 链式法则 Chain Rule (Probability) 概率论基本定理，允许将联合概率分解为一系列条件概率的乘积。 贝叶斯网络 Bayesian Network 一种概率图模型，使用有向无环图 (DAG) 来表示变量间的条件依赖关系。 条件独立 Conditional Independence 如果已知变量 Z，变量 X 和 Y 互不影响，则称 X 和 Y 关于 Z 条件独立。这是简化模型的关键。 朴素贝叶斯 Naive Bayes 一种简单的生成模型，假设特征之间相互独立。常作为基准模型 (Baseline)。 有向无环图 DAG (Directed Acyclic Graph) 贝叶斯网络的结构基础，图中的边是有方向的，且不存在闭环。 逻辑函数 Logistic Function (Sigmoid) $\\sigma(z) = \\frac{1}{1+e^{-z}}$。常用于神经网络中将输出压缩到 (0,1) 之间，表示概率。 总结 (Summary) Week 2 告诉你：因为世界太复杂（维数灾难），我们不能蛮力记录所有可能性。 我们必须偷懒——要么假设变量之间没那么多关系（贝叶斯网络），要么用一个强大的黑盒（神经网络）去拟合这些关系。现代 GenAI 正是选择了后者。\nCS5494 Week 3: Autoregressive Models 第三周：自回归模型 1. 核心定义：什么是自回归模型？ Core Definition: What are Autoregressive Models? 自回归模型是生成式 AI 中最主流的一派（GPT 中的 \u0026ldquo;G\u0026rdquo; 就是 Generative，实际上是 Autoregressive 的）。\n基本思想 (Basic Idea): 将生成高维数据（如一张图或一段话）的任务，拆解为序列生成 (Sequential Generation) 任务。即：根据前面所有的内容，预测下一个内容。\nConcept: Decompose the task of generating high-dimensional data into a sequential generation task. Predict the next token based on all previous tokens. 数学基础：链式法则 (Mathematical Foundation: Chain Rule) 我们利用概率链式法则，将联合分布分解为条件概率的乘积，不引入任何独立性假设： $$P(x_1, \u0026hellip;, x_n) = \\prod_{i=1}^{n} P(x_i | x_1, \u0026hellip;, x_{i-1})$$\nExplanation: $x_i$ depends on all previous variables $x_{\u0026lt;i}$. This is different from Naive Bayes (which assumes independence). 2. 全可见信念网络 (FVBN) Fully Visible Belief Networks (FVBN) 这是一个理论模型，用来解释自回归过程的图结构。\n结构 (Structure): 这是一个有向无环图 (DAG)。每一个节点 $x_i$ 都连接到它之前的所有节点 ($x_1$ 到 $x_{i-1}$)。 Structure: Every node $x_i$ is connected to all its predecessors. 参数化 (Parameterization): 既然 $x_i$ 依赖于前面所有 $x$，我们需要一个函数来拟合这个关系： $$P(x_i | x_{\u0026lt;i}) = f(x_{\u0026lt;i}; \\theta)$$ 线性方法: 使用逻辑回归 (Logistic Regression)。能力有限，处理不了复杂图片。 非线性方法: 使用神经网络 (Neural Networks)，如 NADE (Neural Autoregressive Distribution Estimation)。NADE 通过共享权重的方法，用神经网络来预测像素的条件概率。 3. 循环神经网络 (RNN) Recurrent Neural Networks (RNN) 当我们要处理序列数据 (Sequential Data)（如文本、音频），而不是固定大小的图片时，FVBN 这种固定结构的图就不够用了。我们需要 RNN。\n核心机制：隐状态 (Core Mechanism: Hidden State) RNN 引入了一个“记忆单元”——隐状态 $h_t$。 $$h_t = \\sigma(W x_t + U h_{t-1})$$\n$x_t$: 当前的输入（这个字）。 $h_{t-1}$: 上一步的记忆（上文的意思）。 $h_t$: 更新后的记忆（包含当前字和上文的意思）。 Function: The hidden state acts as a summary of the entire history up to time $t$. RNN 的致命弱点 (Issues with RNNs):\n信息瓶颈 (Information Bottleneck): 所有的历史信息（哪怕是一本书）都必须被压缩进一个固定大小的向量 $h_t$ 中，导致信息丢失。 梯度消失 (Vanishing Gradients): 也就是“长时记忆遗忘”。模型很难记住很久以前出现的词。 无法并行 (Sequential Computation): 必须算完 $t-1$ 才能算 $t$，训练速度非常慢。 4. 革命性突破：Attention 与 Transformer The Revolution: Attention \u0026amp; Transformer 这是本周课件的重中之重，也是现代 LLM 的基石。\nA. 注意力机制 (Attention Mechanism) 为了解决 RNN “记不住”的问题，我们引入了 Attention。\n原理 (Principle): 在预测下一个词时，模型不再只依赖那个被压缩的 $h_t$，而是可以直接“回头看” 原始输入序列中的每一个词，并根据相关性给予不同的权重。 Analogy: Instead of reading the whole book and trying to summarize it in one sentence (RNN), you can flip back to any previous page to find the relevant information when needed. B. Transformer 架构 Transformer 彻底抛弃了 RNN 的循环结构，完全基于 Attention。\n自注意力 (Self-Attention): 序列中的每个词都会去“关注”序列中的其他所有词，计算它们之间的关联。 Query (Q), Key (K), Value (V): 这是 Attention 的核心计算公式。 $$Attention(Q, K, V) = \\text{softmax}(\\frac{QK^T}{\\sqrt{d_k}})V$$ 掩码自注意力 (Masked Self-Attention): 关键点: 在训练生成模型时，我们不能让模型“偷看”到后面的答案。 Explanation: We apply a mask (setting future positions to $-\\infty$) so that when predicting position $t$, the model can only attend to positions $1$ to $t-1$. This preserves the autoregressive property. 优势 (Advantages): 并行计算 (Parallelization): 不用像 RNN 那样排队算，可以一次性输入整个句子，利用 GPU 疯狂加速。 全局视野 (Global Context):无论两个词距离多远，它们之间的交互距离都是 1（直接相连）。 5. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 自回归模型 Autoregressive Model 根据之前的序列值来预测当前值的模型。比如根据前文预测下一个字。 链式法则 Chain Rule 概率论定理，允许将 $P(A, B, C)$ 分解为 $P(A)P(B|A)P(C|A,B)$。是自回归模型的数学基础。 全可见信念网络 FVBN (Fully Visible Belief Network) 一种概率图模型，每个变量都依赖于它之前的所有变量。 循环神经网络 RNN (Recurrent Neural Network) 专门处理序列数据的神经网络，具有“记忆”功能（隐状态），能捕捉时间依赖性。 梯度消失 Vanishing Gradient 深度网络（尤其是 RNN）训练中的常见问题，指反向传播时梯度变得极小，导致模型无法学习长距离依赖。 注意力机制 Attention Mechanism 允许模型在处理当前任务时，动态地关注输入序列中不同部分的技术。 自注意力 Self-Attention Attention 的一种变体，指一个序列内部的元素之间互相进行 Attention 计算，以捕捉序列内部的关联。 掩码 Masking 在 Transformer 训练中，通过遮挡未来的 Token，防止模型“作弊”（看到未来），从而强制模型学习预测下一个词。 Transformer Transformer 由 Google 提出的基于 Attention 机制的深度学习模型架构，是 BERT、GPT 等现代大模型的基础。 总结 (Summary) Week 3 的逻辑链条是： 我们要生成序列 $\\rightarrow$ 最初用简单的统计方法 (N-gram) $\\rightarrow$ 后来用 RNN (但有记忆瓶颈且慢) $\\rightarrow$ 现在用 Transformer (通过 Attention 机制解决了记忆和速度问题)。\n理解了 Masked Self-Attention，你就理解了 GPT (Generative Pre-trained Transformer) 为什么能像接龙一样一个个字地生成文本。\nCS5494 Week 4: Large Language Models (Decoder-only Architecture) 第四周：大语言模型（仅解码器架构） 1. 宏观架构：Decoder-only 模型 Macro Architecture: Decoder-only Models 这是本周最重要的概念。原始的 Transformer (2017) 是 Encoder-Decoder 架构（用于翻译）。但后来的 GPT 系列（包括 Llama, DeepSeek）发现，做生成任务只需要Decoder。\nDecoder-only 的逻辑: 我们不需要把输入压缩成一个向量再解压（Encoder-Decoder），而是直接进行“接龙”。每一个 token 既是输入也是输出的一部分。 Concept: Instead of encoding text into a vector and then decoding it, we treat the task as a continuous sequence generation. 结构 (Structure): 它是多个 Decoder Block 的堆叠（Stack）。每个 Block 包含两个核心组件： Masked Self-Attention (带掩码的自注意力) Feed Forward Neural Network (FFN/MLP) (前馈神经网络) 2. 预处理第一步：分词器 (Tokenizer) Preprocessing Step 1: Tokenizer 模型看不懂单词，只能看懂数字。Tokenizer 的作用就是把文本切块并转化为数字 ID。\n为什么不是按字符（Character）切？ “apple”按字符切是 5 个 ID。序列太长，且单个字母没有语义。 为什么不是按单词（Word）切？ 英语单词太多了（几十万个），词表（Vocabulary）会爆炸，且无法处理生僻词（OOV - Out of Vocabulary）。 最佳方案：子词分词 (Sub-word Tokenization) BPE (Byte Pair Encoding): 这是目前最主流的方法。它会统计语料中出现频率最高的“字符对”，把它们合并成一个新的 token。 Mechanism: Frequently occurring character pairs are merged into a single token. e.g., \u0026ldquo;learning\u0026rdquo; might be split into \u0026ldquo;learn\u0026rdquo; + \u0026ldquo;ing\u0026rdquo;. 优势: 既控制了词表大小（通常 3万-10万），又能通过组合来表示任何词。 3. 预处理第二步：嵌入层 (Embedding) Preprocessing Step 2: Embedding 把 Tokenizer 给出的数字 ID（例如 \u0026ldquo;cat\u0026rdquo; -\u0026gt; 4521）变成一个高维向量。\n语义空间 (Semantic Space): Embedding 将离散的 ID 映射到一个连续的向量空间。在这个空间里，语义相近的词距离更近。 Example: Vector(\u0026ldquo;King\u0026rdquo;) - Vector(\u0026ldquo;Man\u0026rdquo;) + Vector(\u0026ldquo;Woman\u0026rdquo;) $\\approx$ Vector(\u0026ldquo;Queen\u0026rdquo;). 查表 (Lookup Table): 本质上是一个巨大的矩阵，模型通过 ID 去在这个矩阵里查找对应的行。 4. 关键技术：位置编码 (Positional Embedding/Encoding) Key Technique: Positional Embedding 这是 Transformer 架构中最天才但也最难理解的设计之一。\n问题 (The Problem): Attention 机制本质上是“词袋模型”（Bag of Words）。它计算的是两两之间的关联，如果不加干预，“我爱你”和“你爱我”在 Attention 看来是一样的。模型不知道词的顺序。\nConcept: Attention is permutation invariant. It has no inherent notion of sequence order. 解决方案 (The Solution): 我们需要给每个 token 的向量里“加”一点信息，告诉模型它在第几个位置。 $$Input = TokenEmbedding + PositionalEmbedding$$\n正弦/余弦位置编码 (Sinusoidal/Cosinusoidal PE): 课件中特别提到了这个经典方法（原始 Transformer 使用）。\n原理: 使用不同频率的正弦和余弦波来表示位置。 Reasoning: 就像时钟的指针，秒针转得快，分针转得慢。通过不同频率的波组合，可以唯一地标识每一个绝对位置。 公式: $PE_{(pos, 2i)} = \\sin(pos / 10000^{2i/d_{model}})$ 5. 核心机制：因果注意力 (Causal Attention) Core Mechanism: Causal Attention (Masked Attention) 这是 GPT (Decoder-only) 和 BERT (Encoder-only) 的根本区别。\n不能偷看未来 (No Peeking at the Future): 在做文本生成（自回归）时，当我们预测第 $t$ 个词，我们只能看到 $1$ 到 $t-1$ 个词。如果让模型看到了第 $t+1$ 个词，那就是作弊，训练出来的模型毫无用处。\n掩码矩阵 (Mask Matrix): 我们在计算 Attention Score 时，人为地把“未来”位置的分数设为负无穷（$-\\infty$）。这样经过 Softmax 后，未来的权重就变成了 0。\nVisual: 这通常表现为一个下三角矩阵 (Lower Triangular Matrix)。 Result: Token 3 can attend to Token 1, 2, 3, but NOT Token 4, 5. 6. 训练与推理 (Training vs. Inference) Training Phase vs. Generation Phase 这两个阶段在操作上有显著区别，课件最后专门做了对比。\n训练阶段 (Training): 并行 (Parallel)\n我们已经拥有完整的句子（Ground Truth）。虽然我们要模拟“不能看未来”，但我们可以一次性把整句话输入进去，通过 Mask 矩阵并行计算所有位置的 Loss。这叫 Teacher Forcing。 Advantage: Very fast, utilizes GPU parallelism. 生成/推理阶段 (Generation/Inference): 串行 (Sequential)\n我们真的不知道下一个词是什么。只能生成一个词，把它加到输入里，再生成下一个。 KV Cache: 为了加速，我们会把之前算过的 Key 和 Value 存起来，不用每次都重算以前的词。 7. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 仅解码器架构 Decoder-only Architecture 像 GPT 这样的架构，去掉了 Transformer 的编码器，专注于自回归生成的结构。 分词器 Tokenizer 将文本分割成 Token（数字 ID）的组件。常见算法有 BPE (Byte Pair Encoding)。 嵌入 Embedding 将离散的 Token ID 转化为连续的高维向量，捕捉词义。 位置编码 Positional Embedding (PE) 注入到 Embedding 中的位置信息，使 Attention 机制能够识别词序。常见有 Sinusoidal PE。 因果注意力 Causal Attention 也叫 Masked Attention。通过掩码确保模型在预测当前词时，只能关注到之前的词，不能关注未来的词。 掩码 Mask 在 Attention 矩阵中将特定区域（如上三角区域）设为负无穷，以屏蔽信息。 Teacher Forcing Teacher Force 训练时的一种策略，不管模型上一步预测得对不对，下一步输入都强制使用真实的正确答案。这允许并行训练。 自回归 Autoregressive 每一个输出都依赖于之前的输出。即 $P(x_t 前馈神经网络 FFN / MLP Transformer Block 中的全连接层部分，负责处理和整合 Attention 提取的信息。 总结 (Summary) Week 4 告诉你如何把之前的理论拼装成一个 ChatGPT：\n用 Tokenizer 切碎文字。 用 Embedding 变成向量。 用 Positional Encoding 标记顺序。 进入 Decoder Block，利用 Causal Attention 确保只看历史不看未来。 层层堆叠，最后算出下一个词的概率。 CS5494 Week 5: Generative Adversarial Networks (GAN) 第五周：生成对抗网络 1. 核心直觉：对抗博弈 Core Intuition: The Adversarial Game GAN (Goodfellow et al., 2014) 的核心思想不同于显式地去计算概率密度 $P(x)$（像 PixelRNN 或 GPT 那样），而是通过两个神经网络的对抗来隐式地学习分布。\n比喻 (Analogy):\n生成器 (Generator, G): 就像一个伪钞制造者 (Counterfeiter)。它的目标是制造出连警察都分不清真假的假钞。 判别器 (Discriminator, D): 就像警察 (Police)。它的目标是准确地鉴别出哪张是真钞，哪张是假钞。 过程: 随着博弈的进行，警察的眼力越来越好，造假者的技术也必须越来越高超。最终，造出来的假钞逼真到警察无法分辨（概率为 0.5）。 隐式密度估计 (Implicit Density Estimation): GAN 不会直接告诉你这张图出现的概率是多少，它只会给你生成这张图。\nConcept: GANs learn a mechanism to sample from the distribution without explicitly defining the probability density function. 2. 数学架构：极小极大博弈 Mathematical Architecture: Minimax Game 理解 GAN 的关键在于它的目标函数（Loss Function）。这是一个极小极大 (Minimax) 问题。\n$$\\min_G \\max_D V(D, G) = \\mathbb{E}{x \\sim p{data}}[\\log D(x)] + \\mathbb{E}{z \\sim p{z}}[\\log(1 - D(G(z)))]$$\n判别器 D 的视角 (Max D):\n它想让 $\\log D(x)$ 变大（把真图 $x$ 判为 1）。 它想让 $\\log(1 - D(G(z)))$ 变大（把假图 $G(z)$ 判为 0）。 Goal: Maximize the probability of correctly assigning labels to both real and fake examples. 生成器 G 的视角 (Min G):\n它想让 $D(G(z))$ 接近 1，从而使 $\\log(1 - D(G(z)))$ 变得极小（负无穷）。 即：骗过判别器。 Goal: Minimize the probability that the discriminator is correct. 3. 理论痛点：为什么原始 GAN 很难训练？ Theoretical Pain Point: Why is Vanilla GAN Hard to Train? 课件花了很大篇幅讨论距离度量（Metric）的问题。这是理解 WGAN 的前置知识。\nA. 传统的距离度量：KL 散度与 JS 散度 KL 散度 (KL Divergence): 衡量两个分布 $P$ 和 $Q$ 的差异。它是不对称的。 JS 散度 (Jensen-Shannon Divergence): KL 散度的对称版本。原始 GAN 的优化目标本质上是在最小化生成分布与真实分布之间的 JS 散度。 B. 梯度消失问题 (Vanishing Gradient Problem) 现象: 当生成器生成的图像很差，或者真实分布与生成分布没有重叠 (No Overlap) 时（在高维空间中这很常见），JS 散度是一个常数（$\\log 2$）。 后果: 常数的梯度是 0。这意味着生成器得不到任何反馈，不知道往哪个方向改才能变好。 Explanation: If the real and fake distributions are disjoint, the JS divergence is constant. This causes vanishing gradients, meaning the generator learns nothing. 4. 解决方案：Wasserstein GAN (WGAN) The Solution: Wasserstein GAN 为了解决梯度消失，我们引入了一种新的距离度量——推土机距离 (Earth-Mover Distance)，即 Wasserstein Distance。\n直观理解 (Intuition): 想象把“生成分布”看作一堆土，把“真实分布”看作一个坑。Wasserstein 距离就是把这堆土搬到那个坑里所需的最小工作量（距离 $\\times$ 土量）。\nAnalogy: The minimum cost to transport mass from one distribution to transform it into the other. 优势 (Advantages): 即使两个分布完全不重叠，Wasserstein 距离依然是一个平滑的数值（代表距离多远），而不是常数。这能提供持续的、有意义的梯度，指导生成器慢慢靠近真实分布。\nBenefit: Provides meaningful gradients even when distributions are disjoint, stabilizing training. 实现细节 (Implementation Detail): 为了计算 Wasserstein 距离，我们需要限制判别器（此时改叫 Critic）的能力，要求它满足 1-Lipschitz 连续性。在代码中通常通过权重剪裁 (Weight Clipping) 或 梯度惩罚 (Gradient Penalty, WGAN-GP) 来实现。\n5. 进阶应用：CycleGAN Advanced Application: CycleGAN 课件最后提到了 CycleGAN，这是解决无配对图像翻译 (Unpaired Image-to-Image Translation) 的神器。\n场景: 你想把“马”变成“斑马”，但你没有同一匹马变成斑马前后的对比照。你只有一堆马的照片和一堆斑马的照片。 循环一致性损失 (Cycle Consistency Loss): 思路：如果我把马变成斑马，再把斑马变回马，它应该长得和原来一模一样。 公式：$F(G(x)) \\approx x$ Mechanism: Translating an image to the other domain and back should yield the original image. This constraint prevents mode collapse and ensures the content is preserved. 6. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 生成对抗网络 GAN (Generative Adversarial Network) 由生成器和判别器组成的对抗式生成模型框架。 极小极大博弈 Minimax Game 博弈论术语。在 GAN 中指生成器试图最小化判别器的准确率，而判别器试图最大化自己的准确率。 KL 散度 KL Divergence 衡量两个概率分布差异的非对称指标。 JS 散度 JS Divergence (Jensen-Shannon) KL 散度的对称平滑版本。原始 GAN 实际上是在优化这个指标。 模式崩溃 Mode Collapse GAN 训练中的常见失败模式。生成器发现只能生成某一种特定的样本（如只生成同一张脸）就能骗过判别器，从而失去了多样性。 Wasserstein 距离 Wasserstein Distance (Earth-Mover) 一种衡量分布距离的方法。相比 JS 散度，它在分布不重叠时也能提供有效的梯度，极大稳定了 GAN 的训练。 1-Lipschitz 连续 1-Lipschitz Continuity 数学约束，要求函数的变化率不能超过某个常数（斜率不超过 1）。这是 WGAN 成立的必要条件。 循环一致性 Cycle Consistency CycleGAN 的核心概念。要求 $X \\rightarrow Y \\rightarrow X$ 的变换结果应还原为 $X$，保证了翻译过程中内容的保留。 隐式密度 Implicit Density 与显式定义 $P(x)$ 不同，模型不直接计算概率值，而是通过采样机制间接反映数据分布。 总结 (Summary) Week 5 的核心教训是：虽然 GAN 生成的图片很逼真，但训练它非常困难（不稳定）。 为了让 GAN 听话，我们需要更高级的数学工具（Wasserstein 距离）来替代传统的概率度量（JS 散度），从而保证生成器在任何时候都能收到“改进方向”的信号。\nCS5494 Week 6: Variational Autoencoder (VAE) 第六周：变分自编码器 1. 前置概念：自编码器 (Autoencoder, AE) Precursor: Autoencoder 在讲 VAE 之前，课件先回顾了普通的自编码器。\n结构 (Structure): Encoder (编码器): 把高维输入 $x$（如一张图）压缩成低维向量 $z$（Latent Code）。 Decoder (解码器): 把 $z$ 还原回 $x$。 Analogy: 就像把文件压缩成 zip (Encoder)，再解压出来 (Decoder)。 瓶颈层 (Bottleneck): 中间的 $z$ 维度远小于 $x$（例如 784维 $\\rightarrow$ 20维）。这迫使模型学会提取“精华”特征，而不是死记硬背。 局限性 (Limitation): 它不是生成模型。AE 学习到的潜在空间（Latent Space）是不连续的。如果你在两个训练过的 $z$ 之间随机取一个点，解码出来的可能是一堆乱码。它只能“复读”，不能“创造”。 2. 核心理论：潜变量模型与难解性 Latent Variable Models \u0026amp; Intractability 为了让模型能“创造”，我们需要引入概率。我们假设图片 $x$ 是由某个看不见的隐变量 $z$ 生成的。\n生成过程 (Generation Process): 先从标准正态分布中采样一个 $z \\sim \\mathcal{N}(0, I)$。 通过神经网络生成 $x = g(z)$。 数学难题 (The Math Problem): 为了训练这个模型，我们需要最大化数据的对数似然 $\\log P(x)$。 根据概率公式：$P(x) = \\int P(x|z)P(z) dz$。 难点 (Hard Point): 这个积分极其难算 (Intractable)。因为 $z$ 的可能性无穷无尽，我们不可能遍历所有的 $z$ 来算出 $P(x)$。 Concept: We cannot calculate the marginal likelihood because integrating over all possible latent variables is computationally impossible. 3. 解决方案：变分推断与 ELBO (重点/难点) Solution: Variational Inference \u0026amp; ELBO 既然算不出真实的 $P(x)$，我们退而求其次，去寻找一个下界 (Lower Bound)，只要把这个下界推得越高，真实的概率也就越高。\nA. 变分推断 (Variational Inference) 我们无法知道真实的后验概率 $P(z|x)$（即：给定这张图，它对应的 $z$ 到底是多少？）。 所以，我们引入一个新的分布 $Q(z|x)$（由神经网络 Encoder 拟合）来近似真实的 $P(z|x)$。\nB. ELBO (证据下界) 这是本周最核心的公式。通过数学推导（Jensen不等式），我们可以得出：\n$$\\log P(x) \\ge \\text{ELBO}$$\nELBO 的组成 (The Decomposition of ELBO): $$\\text{ELBO} = \\mathbb{E}{z \\sim Q}[\\log P(x|z)] - D{KL}(Q(z|x) || P(z))$$\n这行公式对应了 VAE 的两个 Loss 部分，非常关键，请仔细看下面的深度解释。\n4. VAE 的模型架构与损失函数 VAE Architecture \u0026amp; Loss Function VAE 把上面的数学公式变成了具体的神经网络架构。\n第一部分：重建损失 (Reconstruction Loss)\n对应公式：$\\mathbb{E}_{z \\sim Q}[\\log P(x|z)]$ 含义: 就像普通的 Autoencoder 一样，要求解码出来的图 $\\hat{x}$ 和原图 $x$ 越像越好。 Intuition: Make sure the output looks like the input. 第二部分：正则化项 (KL Divergence Regularization) [⚠️难点]\n对应公式：$D_{KL}(Q(z|x) || P(z))$ 含义: 强迫 Encoder 输出的分布 $Q(z|x)$ 尽可能接近标准正态分布 $P(z) = \\mathcal{N}(0, 1)$。 为什么要这么做？ (Why?): 如果不加这一项，模型会“作弊”，它会把每个数据的 $z$ 记得离得远远的（互不重叠），退化成普通的 Autoencoder。 加上这一项，所有图片的 $z$ 都被迫挤在一个标准圆里。这样，$z$ 空间就变得连续了。你在这个圆里随便插值采样，都能生成一张像模像样的新图。 5. 实现细节：重参数化技巧 (Reparameterization Trick) Implementation: The Reparameterization Trick 这是课件中提到“Variational parameters”时隐含的一个关键工程技巧，也是考试常考点。\n问题: VAE 中需要进行采样 ($z \\sim \\mathcal{N}(\\mu, \\sigma^2)$)。由于“采样”这个操作是随机的，不可导，导致无法进行反向传播（Backpropagation）。 技巧: 我们把随机性转移到一个独立的变量 $\\epsilon$ 上。 $$z = \\mu + \\sigma \\odot \\epsilon, \\quad \\text{where } \\epsilon \\sim \\mathcal{N}(0, 1)$$ 效果: 现在 $\\mu$ 和 $\\sigma$ 变成了确定性的参数，梯度可以直接传导给 Encoder，而随机性只在常数 $\\epsilon$ 里。 6. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 自编码器 Autoencoder (AE) 一种神经网络，旨在学习将输入压缩为低维编码，再将其重建回原始输入。 变分自编码器 VAE (Variational Autoencoder) 在 AE 基础上引入概率生成模型的概念，通过学习数据的潜在分布来生成新数据。 潜变量模型 Latent Variable Model 假设观测数据 $x$ 是由不可见的潜变量 $z$ 生成的概率模型。 变分推断 Variational Inference 用一个简单的分布 $Q$ 去近似难以计算的复杂后验分布 $P$ 的方法。 证据下界 ELBO (Evidence Lower Bound) 对数似然函数的一个下界。训练 VAE 的本质就是最大化 ELBO。 KL 散度 KL Divergence 衡量两个概率分布之间差异的指标。在 VAE 中用于拉近 $Q(z|x)$ 和 $P(z)$ 的距离。 难解性 Intractability 指计算量过大（通常是指数级或无穷积分），无法在有限时间内精确算出结果。 重参数化技巧 Reparameterization Trick 将随机变量分解为确定性部分和随机噪声部分（$z=\\mu+\\sigma\\epsilon$），使采样过程变得可导。 后验分布 Posterior Distribution $P(z|x)$。即“看到这张图后，推断它的潜在特征是什么”。 先验分布 Prior Distribution $P(z)$。我们预先假设的潜变量分布，VAE 中通常假设为标准正态分布 $\\mathcal{N}(0, 1)$。 总结 (Summary) Week 6 告诉你：为了让神经网络具备创造力，我们不能让它死记硬背坐标（固定数值），而要让它学习范围（概率分布）。 VAE 通过 ELBO 将“生成难题”转化为了“优化难题”，并通过 KL 散度 保证了学习到的空间是平滑、连续的，从而能生成新的图片。\nCS5494 Week 7: Diffusion Models (DDPM) 第七周：扩散模型 (DDPM) 1. 核心直觉：毁掉它，再复原它 Core Intuition: Destroy and Restore 扩散模型的灵感来源于非平衡热力学。想象一滴墨水滴入清水中，随着时间推移，墨水分子会扩散，直到整杯水变成均匀的浑浊颜色。\n前向过程 (Forward Process / Diffusion):\n就像墨水扩散。我们往一张清晰的图片上一步步加噪点。 最后（比如加了 1000 步后），图片变成了一张纯粹的、没有任何信息的高斯噪声 (Gaussian Noise)。 Analogy: Slowly adding static to a TV screen until the image is gone. 反向过程 (Reverse Process / Denoising):\n这是模型的任务。如果我们能学会**“时间倒流”**，从这一张纯噪声中，一步步把噪点拿掉，就能变回一张清晰的图。 因为是从纯噪声（随机数）开始“去噪”，每次生成的图都不一样，这就是生成的过程。 2. 前向过程：加噪 (The Forward Process) Adding Noise systematically 这是一个固定的过程，不需要任何神经网络训练。我们规定好每一步加多少噪声（这叫 Noise Schedule，$\\beta_t$）。\n单步加噪: $$q(x_t | x_{t-1}) = \\mathcal{N}(x_t; \\sqrt{1-\\beta_t}x_{t-1}, \\beta_t I)$$\n意思就是：现在的图 $x_t$ = 稍微暗一点的上一张图 $x_{t-1}$ + 一点点新的噪声。 任意步加噪 (The \u0026ldquo;Jump\u0026rdquo; Property): [重要考点] 我们不需要一步步算。数学上可以证明，我们可以直接算出第 $t$ 步的图 $x_t$ 长什么样（基于原图 $x_0$）： $$x_t = \\sqrt{\\bar{\\alpha}_t} x_0 + \\sqrt{1 - \\bar{\\alpha}_t} \\epsilon$$\n$\\epsilon \\sim \\mathcal{N}(0, I)$ 是这一步的总噪声。 $\\bar{\\alpha}_t$ 是一个随时间 $t$ 变小的系数（信号保留比例）。 直觉: $x_t$ 就是“原图”和“噪声”的加权混合。$t$ 越大，原图成分越少，噪声成分越多。 3. 反向过程：去噪 (The Reverse Process) Denoising with Neural Networks 这是我们需要训练的部分。我们想求 $q(x_{t-1} | x_t)$，即：给定现在的脏图，它上一时刻长什么样？ 但这个分布太复杂了，算不出来。\n解决方案: 用神经网络 $p_\\theta(x_{t-1} | x_t)$ 去拟合它。 假设: 当每一步加的噪声极小时，反向过程也可以近似为一个高斯分布： $$p_\\theta(x_{t-1} | x_t) = \\mathcal{N}(x_{t-1}; \\mu_\\theta(x_t, t), \\Sigma_\\theta(x_t, t))$$ 任务: 神经网络只需要输入一张脏图 $x_t$ 和时间 $t$，然后预测出这个高斯分布的均值 $\\mu_\\theta$ 即可（方差通常设为固定值）。 4. 核心难点：训练目标是什么？ The Hard Part: What is the Loss Function? 这部分是课件中公式最多的地方，也是理解 DDPM (Denoising Diffusion Probabilistic Models) 的关键。\nA. 为什么不能直接由 $x_t$ 推 $x_{t-1}$？ 因为从 $x_t$ 回到 $x_{t-1}$ 有无数种可能，直接训很难收敛。 但是，如果我们知道原图 $x_0$，那么从 $x_t$ 推导 $x_{t-1}$ 就变得确定且简单了。 这就引出了扩散模型最天才的数学推导——后验分布 $q(x_{t-1} | x_t, x_0)$。\nB. 简化的训练目标 (Simplified Loss) [⭐最重要结论] 虽然数学推导（ELBO）很复杂，但 Ho et al. (2020) 发现，训练扩散模型其实只需要做一件事： 预测噪声 (Predict the Noise)。\n随机抽一张原图 $x_0$。 随机生成一个噪声 $\\epsilon$。 把噪声加到图上得到 $x_t$（利用第2节的公式）。 把 $x_t$ 丢给神经网络，让它猜：“刚才加在这个图里的噪声 $\\epsilon$ 长什么样？” Loss Function: $$L_{simple} = || \\epsilon - \\epsilon_\\theta(\\underbrace{\\sqrt{\\bar{\\alpha}_t} x_0 + \\sqrt{1 - \\bar{\\alpha}t} \\epsilon}{输入 x_t}, t) ||^2$$ 即：真实噪声 $\\epsilon$ 与预测噪声 $\\epsilon_\\theta$ 的均方误差 (MSE)。 总结: 扩散模型本质上就是一个**“猜噪声”的去噪自编码器 (Denoising Autoencoder)**。\n5. 推理算法：怎么生成图片？ Inference: Sampling Algorithm 训练好模型（会猜噪声）后，我们怎么生成新图？\n从纯噪声开始: $x_T \\sim \\mathcal{N}(0, I)$。 循环 $T$ 步 (例如 1000 步): 从 $T$ 倒数到 $1$。 计算当前步预测的噪声 $\\epsilon_\\theta(x_t, t)$。 去噪公式 (核心): $$x_{t-1} = \\frac{1}{\\sqrt{\\alpha_t}} (x_t - \\frac{1 - \\alpha_t}{\\sqrt{1 - \\bar{\\alpha}t}} \\epsilon\\theta(x_t, t)) + \\sigma_t z$$ 解释: 把预测出来的噪声从图里减掉一部分，然后再加回一点点随机噪声 $z$ (Langevin Dynamics)。 Why add noise back? 为了保持生成的随机性和多样性，防止模型坍缩到单一结果。 结束: 得到 $x_0$，就是生成的精美图片。 6. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 扩散模型 Diffusion Model 一类通过反转噪声扩散过程来生成数据的生成模型。 DDPM Denoising Diffusion Probabilistic Models 2020年提出的经典扩散模型算法，证明了预测噪声等价于优化 ELBO。 前向过程 Forward Process 逐步向数据添加高斯噪声直到其变为纯噪声的过程。$q(x_t|x_{t-1})$。 反向过程 Reverse Process 逐步去除噪声以恢复数据的过程。$p_\\theta(x_{t-1}|x_t)$。 噪声调度 Noise Schedule ($\\beta_t$) 控制每一步添加多少噪声的超参数。 ELBO Evidence Lower Bound 变分推断中的证据下界。扩散模型的 Loss 本质上是在最大化 ELBO。 重参数化技巧 Reparameterization Trick 在扩散模型中指 $x_t = \\sqrt{\\bar{\\alpha}_t}x_0 + \\sqrt{1-\\bar{\\alpha}_t}\\epsilon$，它允许我们将随机性剥离，直接对噪声进行求导。 马尔可夫链 Markov Chain 一个随机过程，其中未来的状态仅取决于当前状态（与过去无关）。扩散过程是一个马尔可夫链。 U-Net U-Net 扩散模型中最常用的神经网络架构，形状像个 U，擅长处理图像的细节和整体特征。 Langevin 动力学 Langevin Dynamics 一种物理过程，扩散模型的采样过程（去噪+加随机扰动）在数学上类似于 Langevin 动力学采样。 总结 (Summary) Week 7 的核心逻辑是： 生成 = 去噪。 我们不需要像 GAN 那样用判别器去“逼”模型生成，也不需要像 VAE 那样把分布压缩到潜空间。 我们只需要教会神经网络一件事：看到一张全是噪点的图，请告诉我，刚才加进去的噪点长什么样？ 只要它能把噪点预测出来，我们把它减掉，图就变清晰了。\nCS5494 Week 8: AI Agent 第八周：人工智能智能体 1. 核心定义：什么是 AI Agent？ Core Definition: What is an AI Agent? 传统的 LLM (如 ChatGPT) 就像一个“大脑在缸中”，它什么都知道，但什么都做不了（除了说话）。AI Agent 就是给这个大脑装上了手脚（工具）和长期记忆。\n公式 (The Formula): $$Agent = LLM + Planning + Memory + Tools$$ [cite_start][cite: 3]\n区别 (Difference):\nGenerative AI (Chatbot): 模式: 输入 Prompt $\\rightarrow$ 输出文字/图片。 特点: Reactive (被动反应)。你不问，它不说。 Analogy: Like a library. [cite_start]It contains knowledge but sits still until you open a book. [cite: 53] AI Agent: 模式: 设定目标 Goal $\\rightarrow$ 自主规划 $\\rightarrow$ 使用工具 $\\rightarrow$ 完成任务。 特点: Proactive (主动)。它可以为了一个目标进行多步操作。 Analogy: Like a personal assistant. [cite_start]You say \u0026ldquo;plan a trip,\u0026rdquo; and it books flights, hotels, and restaurants on its own. [cite: 54] 2. 核心能力一：规划与思考 (Planning \u0026amp; Reasoning) Core Capability 1: How AI Thinks? 这是本课的难点。模型通过什么方式来“思考”下一步该做什么？\nA. 观察-思考-行动循环 (Obs-Think-Act Loop) Agent 不会直接跳到结论，而是经历一个循环：\n观察 (Observation): 现在的状态是什么？（比如：棋盘现在长什么样？） 思考 (Thought): 基于观察，我该怎么做？ [cite_start]行动 (Action): 执行操作（比如：下棋，或者搜索谷歌）。[cite: 3] B. ReAct 框架 (Reasoning + Acting) [重点] 课件中隐含的 ReAct 概念是 Agent 的核心工作流。\n原理: 要求 LLM 在执行动作之前，先显式地把思考过程 (Chain of Thought) 写出来。 例子: 用户: \u0026ldquo;马斯克现在的身价是多少？\u0026rdquo; Agent 思考: \u0026ldquo;我需要查最新的数据，因为我的训练数据可能过时了。\u0026rdquo; (Reasoning) Agent 行动: Search(\u0026quot;Elon Musk net worth today\u0026quot;) (Acting) Agent 观察: \u0026ldquo;搜索结果显示 2500亿美元。\u0026rdquo; (Observation) Agent 回答: \u0026ldquo;马斯克目前身价约2500亿美元。\u0026rdquo; 3. 核心能力二：工具使用 (Tool Use) Core Capability 2: How AI Uses Tools? LLM 本身无法联网，也不擅长精确数学运算。我们需要教它使用外部工具。\n函数调用 (Function Calling):\n原理: 我们不直接把工具给 LLM，而是给它一本说明书 (System Prompt)。 [cite_start]Prompt 示例: \u0026ldquo;如果你遇到不懂的问题，你可以输出 \u0026lt;tool\u0026gt;Search(query)\u0026lt;/tool\u0026gt; 来使用搜索引擎。\u0026rdquo; [cite: 27] 流程: LLM 输出一段特定的文本（如 XML 标签）。 系统拦截这段文本，去运行真正的 Python 代码或 API。 系统把运行结果（比如天气是 30度）塞回给 LLM。 [cite_start]LLM 根据结果生成最终回答。 [cite: 29, 33, 34] 自我判断 (Judgment):\n难点: 工具不总是对的。Agent 需要具备批判性思维。 Case: 如果天气 API 返回 \u0026ldquo;500°C\u0026rdquo;，LLM 不应直接复述，而应该判断 \u0026ldquo;这数据不合理，可能是工具出错了\u0026rdquo;。 [cite_start]Concept: Internal Knowledge (自身常识) vs. External Knowledge (工具结果)。Agent 需要权衡这两者。 [cite: 49, 50, 52] 4. 核心能力三：记忆与经验 (Memory \u0026amp; Experience) Core Capability 3: Adjusting Behavior via Experience 如果 Agent 每次任务结束就重置，它永远不会进步。它需要记忆。\n短期记忆 (Short-term Memory): 上下文窗口 (Context Window)，记录当前的对话历史。 长期记忆 (Long-term Memory): [cite_start]RAG (检索增强生成): 将过往的经验存入向量数据库 (Vector DB)。当遇到类似任务时，检索出相关的经验供 LLM 参考。 [cite: 15, 19] [cite_start]反思 (Reflection): Agent 在行动后，会生成一段“反思总结”，存入记忆。比如 \u0026ldquo;上次我直接搜索失败了，下次应该先拆解问题\u0026rdquo;。 [cite: 21] 5. 进阶概念：Agentic AI 与多智能体 Advanced Concept: Agentic AI Systems 这是从“单个员工”到“公司团队”的跨越。\nAgentic AI System: 不是单打独斗，而是多个 Agent 协作。 [cite_start]工作流示例 (Youtube -\u0026gt; Rednote): [cite: 55] Agent 1 (听录员): 把视频转成文字。 Agent 2 (标题党): 根据文字起一个吸引人的标题。 Agent 3 (写手): 撰写正文。 Agent 4 (编辑): 润色和排版。 优势: 术业有专攻，每个 Agent 只需要专注于一个小任务，整体效果更好。 6. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 人工智能智能体 AI Agent 一个拥有感知、规划能力的系统，能使用工具自主完成目标。公式：LLM + 规划 + 记忆 + 工具。 被动反应 Reactive 传统的 GenAI 模式，只有收到指令才会有输出，不会主动发起行动。 函数调用 Function Calling 允许 LLM 输出特定格式的指令来触发外部代码（如查天气、搜网页）的技术。 检索增强生成 RAG (Retrieval-Augmented Generation) 结合了搜索（检索）和生成的技术。让 LLM 在回答前先去“翻书”（数据库），从而减少胡说八道。 思维链 Chain of Thought (CoT) 提示工程技术，引导模型一步步把逻辑写出来，能显著提升复杂推理任务的准确率。 ReAct 框架 ReAct (Reason+Act) 一种通过交替进行“推理”和“行动”来解决任务的模式。是 Agent 的核心思考方式。 多智能体系统 Multi-Agent System 由多个扮演不同角色的 Agent 组成的系统，它们像人类团队一样协作完成复杂任务。 幻觉 Hallucination LLM 一本正经地胡说八道。通过使用工具（如搜索、计算器）可以有效减少幻觉。 总结 (Summary) Week 8 的核心在于**“Action”**。 如果说前几周是教你造一个“全知全能的哲学家”（GenAI），这周就是教你把这个哲学家变成一个“能干活的打工人”（Agent）。 关键在于：\n给它工具（Function Call）。 教它流程（ReAct Loop: 观察-\u0026gt;思考-\u0026gt;行动）。 给它记忆（RAG/Database），让它能从经验中学习。 CS5494 Week 9: 3D Vision \u0026amp; Generation 第九周：三维视觉与生成 1. 核心痛点：3D 表示的多样性 Core Pain Point: Diversity of 3D Representations 在 2D 中，我们只有一种标准格式：像素网格 (Pixel Grid)。但在 3D 中，没有统一的标准，我们需要根据任务选择不同的数据结构。\nA. 显式表示 (Explicit Representations) 直接定义物体的几何形状。\n体素 (Voxels):\n定义: 3D 版的像素 (Volume Pixel)。就像《我的世界》(Minecraft) 里的方块。 优点: 规则结构，可以直接用 3D 卷积神经网络 (3D CNN) 处理。 缺点: 内存爆炸。分辨率每增加 1 倍，内存消耗增加 8 倍 ($O(N^3)$)。这就叫“维数灾难”。 点云 (Point Clouds):\n定义: 一堆 $(x, y, z)$ 坐标点的集合。通常由激光雷达 (LiDAR) 采集。 特点: 无序性 (Unordered)。点的顺序不影响形状，这对神经网络是个挑战（后面会讲 PointNet）。 缺点: 没有表面信息，放大看全是洞。 网格 (Meshes):\n定义: 由顶点 (Vertices)、边 (Edges) 和面 (Faces) 组成的集合。是游戏和电影工业的标准。 缺点: 拓扑结构复杂，神经网络很难直接生成（很难处理“这就多了一个洞”这种拓扑变化）。 B. 隐式表示 (Implicit Representations) [重点] 不直接存储点，而是存储一个数学函数。\n思想: 定义一个函数 $f(x, y, z)$。 SDF (Signed Distance Function): 函数返回该点距离物体表面的距离。负数在内部，正数在外部，0 就是表面。 优点: 分辨率无限，可以表示极其复杂的拓扑结构。 2. 核心架构：PointNet (处理点云) Core Architecture: PointNet (Processing Point Clouds) 这是深度学习处理 3D 点云的开山之作。\n难点: 点云是无序的。输入 $(Point A, Point B)$ 和 $(Point B, Point A)$ 应该代表同一个物体。普通的 CNN 或 RNN 对顺序敏感，无法处理。 PointNet 的解决方案: 共享 MLP (Shared MLP): 对每一个点单独进行特征提取（映射到高维空间），每个点用的权重是一样的。 对称函数 (Symmetric Function): 使用 Max Pooling。不管输入的点顺序怎么变，取“最大值”这个操作得到的结果永远是一样的。 Mechanism: Map each point individually to a higher dimension, then aggregate them using a symmetric operation (max pooling) to get a global feature vector. 3. 革命性技术：NeRF (神经辐射场) Revolutionary Tech: NeRF (Neural Radiance Fields) 这是本周课件最硬核、也是现代 3D 生成的基石。它不仅是一种表示，更是一种渲染技术。\n核心定义: NeRF 不是存网格，而是训练一个全连接神经网络 (MLP) 来隐式地存储场景。 $$F_\\theta(x, y, z, \\theta, \\phi) \\rightarrow (r, g, b, \\sigma)$$\n输入: 空间坐标 $(x, y, z)$ + 观看角度 $(\\theta, \\phi)$。 输出: 该点的颜色 $(r, g, b)$ + 密度 (Density $\\sigma$)。 体渲染 (Volumetric Rendering): 怎么把这个神经网络变成一张图片？\n光线投射 (Ray Marching): 从相机位置向屏幕的每个像素发射一条射线。 采样 (Sampling): 在这条射线上取很多采样点。 查询 (Query): 把每个采样点的坐标丢给 MLP，问它：“这里有什么颜色？密度多少？” 积分 (Integration): 根据密度把颜色累加起来。密度大的地方会遮挡后面的点。 Analogy: 就像在雾中看东西。视线穿过雾气（累加颜色），直到被厚实的东西挡住。 优势: 生成的视图具有照片级真实感 (Photorealistic)，且视点连续变化。\n劣势: 渲染极慢（生成一张图要查询几百万次网络）。\n4. 3D 生成：DreamFusion 与 SDS 3D Generation: DreamFusion \u0026amp; SDS 我们有很强的 2D 生成模型（如 Stable Diffusion），但没有很多 3D 数据来训练 3D 模型。怎么办？ DreamFusion (2023) 提出了一种“借鸡生蛋”的方法。\n核心逻辑: 用 2D 模型当“老师”，指导 3D 模型“画画”。 流程 (Process): 初始化一个随机的 NeRF（看起来像一团雾）。 渲染 (Render): 从某个角度拍一张这团雾的照片。 打分 (Critic): 把照片丢给 2D Diffusion Model (比如 Stable Diffusion)，再加上文字提示（如 \u0026ldquo;一只红色的青蛙\u0026rdquo;）。 SDS Loss (Score Distillation Sampling): 2D 模型会告诉 3D 模型：“这看起来不像青蛙，你应该把这里的像素变红一点”。（计算梯度） 更新 (Update): 根据建议修改 NeRF 的参数。 重复几千次，直到 3D 模型从各个角度看都像一只青蛙。 5. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 体素 Voxel (Volumetric Pixel) 3D 空间中的规则网格单位，相当于 2D 图片中的像素。常用于医疗影像或简单的 3D 模型。 点云 Point Cloud 3D 空间中一组数据点 $(x,y,z)$ 的集合。由激光雷达扫描生成，数据稀疏且无序。 网格 Mesh 由多边形（通常是三角形）组成的 3D 物体表面表示法。由顶点、边和面构成。 SDF Signed Distance Function 符号距离函数。一种隐式表示，记录空间中任意一点到最近物体表面的距离（内部为负，外部为正）。 NeRF NeRF (Neural Radiance Fields) 神经辐射场。用神经网络来表示 3D 场景，通过输入坐标和视角输出颜色和密度，能渲染出极高保真的新视角图像。 体渲染 Volumetric Rendering 一种基于光线穿过介质（如烟雾、云层）的物理特性的图像生成技术。NeRF 使用它将 3D 密度场转化为 2D 图像。 光线投射 Ray Casting / Marching 图形学技术。从相机向屏幕像素发射光线，检测光线与物体的交互。 PointNet PointNet 专门处理点云数据的神经网络架构，解决了点云无序性的问题。 DreamFusion DreamFusion Google 提出的文本生成 3D 模型。它不需要 3D 训练数据，而是利用预训练的 2D 扩散模型来优化 3D 结构。 SDS Score Distillation Sampling 分数蒸馏采样。DreamFusion 的核心算法，用于从 2D 扩散模型中提取梯度信息来更新 3D 参数。 总结 (Summary) Week 9 的核心在于**“升维”**。\n存数据: 既然存不下所有像素（体素太贵），我们就存点（点云），或者存皮（网格），或者最现代的方法——存函数 (NeRF)。 生成数据: 既然没有 3D 数据集，我们就用 2D 的 AI 去“监考” 3D 的 AI，让它凭空捏出一个 3D 模型 (DreamFusion)。 CS5494 Week 10: Large Foundation Models (VLM \u0026amp; VLA) 第十周：多模态基础模型与具身智能 1. 范式转变：从专用模型到基础模型 Paradigm Shift: From Specialized to Foundation Models 课件开篇首先强调了 AI 开发模式的根本性变化。\n过去 (The Past): 为每个任务训练一个专用模型。 做分类训练一个 ResNet，做分割训练一个 U-Net，做翻译训练一个 LSTM。 Analogy: 就像家里买了打蛋器、榨汁机、绞肉机，每个机器只能干一件事。 现在 (The Present): 基础模型 (Foundation Models)。 在大规模数据上预训练一个通用的模型（如 GPT-4, Gemini），然后通过微调 (Fine-tuning) 或提示 (Prompting) 适应各种下游任务。 Analogy: 就像一个全能的大厨，你给他什么指令，他就能做什么菜。 2. 视觉-语言模型 (VLM): CLIP Vision-Language Models (VLM): CLIP CLIP (Contrastive Language-Image Pre-training) 是连接文字和图片最重要的桥梁。\n核心思想 (Core Idea): CLIP 不再像传统分类模型那样预测固定的 1000 个类别（ImageNet），而是学习图片和文字描述之间的匹配关系。 训练方法：对比学习 (Contrastive Learning): [重点] 输入：一对对图片和对应的文字说明 (Image-Text Pairs)。 模型包含一个 Image Encoder 和一个 Text Encoder。 拉近 (Pull): 只有正确的图文对，它们生成的向量在空间中应该靠得很近。 推远 (Push): 错误的图文组合（比如“狗的图”配“猫的字”），向量应该互相排斥。 Concept: Maximizing the cosine similarity for $N$ real pairs, while minimizing it for $N^2 - N$ incorrect pairings. 能力: Zero-shot Classification (零样本分类)。CLIP 不需要重新训练就能识别从未见过的物体，只要你告诉它那个物体的名字（文字）。 3. 让 LLM 看懂图: LLaVA Making LLM See: LLaVA (Large Language-and-Vision Assistant) CLIP 只能做匹配，不能像 ChatGPT 那样聊天。LLaVA 是通过视觉指令微调 (Visual Instruction Tuning) 把视觉能力嫁接到 LLM 上。\n架构 (Architecture): $$LLaVA = VisionEncoder + Projection + LLM$$ Vision Encoder: 用 CLIP 把图片变成向量特征。 Projection Layer (投影层): [难点] LLM 只能看懂文本向量空间，看不懂图片向量空间。 投影层就是一个“翻译官”（通常是个简单的 MLP），把图片特征映射到 LLM 的文本特征空间中。 LLM: 也就是 Llama 或 Vicuna。对它来说，投影后的图片特征就像是一堆“外语单词”。 训练: 通过问答对（例如：“这张图里有什么？”-“有一只猫”）来训练，让 LLM 学会理解这些“视觉单词”的含义。 4. 视觉分割基座: SAM Vision Foundation Model: SAM (Segment Anything Model) SAM 是 Meta 发布的图像分割领域的“GPT”。\n痛点: 以前做分割（把物体抠出来）需要针对特定物体训练，且标注数据极难。 Promptable Segmentation (可提示分割): SAM 不需要你告诉它具体的类别，你只需要给它一个提示 (Prompt)： 点一下 (Point) 画个框 (Box) 写行字 (Text) 它就能把对应的物体抠出来。 意义: 解决了视觉任务中最繁琐的分割问题，成为各种高级视觉任务的预处理工具。 5. 具身智能: VLA 模型 (Robotic Foundation Models) Embodied AI: Vision-Language-Action Models (VLA) 这是本节课最高阶的内容。我们不仅要 AI 看图说话 (VLM)，还要它看图干活。\nA. RT-1 (Robotic Transformer 1) 核心创新: 动作 Token 化 (Tokenizing Actions)。 Transformer 本质上是预测下一个单词 (Token)。 RT-1 把机器人的动作（手臂移动 x, y, z，夹爪开合）离散化成一个个数字 Token。 这样，控制机器人就变成了“文本生成”问题：输入是图片，输出是“动作单词”。 Concept: Treating physical motor control as a sequence modeling problem, just like language. B. RT-2: 互联网知识迁移 (Internet Knowledge Transfer) 问题: 机器人数据很少（很难让机器人实际抓 100 万次杯子），但互联网图片/文字数据很多。 Co-training (联合训练): RT-2 把互联网上的 VQA 数据（看图问答）和机器人操作数据混在一起训练。 涌现能力 (Emergent Capabilities): [难点] 如果你教机器人“抓苹果”，它会抓苹果。 但如果你让它“抓那个灭绝的动物”（桌上有恐龙玩具和苹果），RT-1 会傻掉。 RT-2 知道“恐龙是灭绝动物”（来自互联网知识），也知道“怎么抓东西”（来自机器人数据），所以它能推断出要去抓恐龙玩具。 Takeaway: Semantic knowledge from the web is transferred to physical control. C. RT-X / OpenVLA 跨形态 (Cross-Embodiment): 不同的机器人（有的单臂，有的双臂，有的长有的短）如何共用一个模型？ 通过标准化动作空间，汇集全世界不同机器人的数据训练出一个通用的 VLA 模型。 6. 专有名词表 (Glossary) 中文术语 English Term 详细解释 / Detailed Explanation 基础模型 Foundation Model 在海量数据上预训练的大规模模型，具有强大的泛化能力，可适应多种下游任务（如 GPT-4, Llama）。 多模态 Multimodal 指模型能同时处理多种媒体数据，如文本、图像、音频、视频等。 对比学习 Contrastive Learning CLIP 的核心训练方法。通过拉近正样本对（匹配的图文）、推远负样本对来学习特征表示。 零样本分类 Zero-shot Classification 模型无需针对特定类别进行微调，仅凭类别的语义描述就能识别样本的能力。 视觉指令微调 Visual Instruction Tuning LLaVA 的训练方法。将图像特征映射到语言空间，并通过指令-回复对来微调 LLM，使其具备多模态对话能力。 具身智能 Embodied AI 拥有物理实体（如机器人）的 AI，不仅能进行数字计算，还能与物理世界进行交互（感知+行动）。 VLA 模型 VLA (Vision-Language-Action) 视觉-语言-动作模型。VLM 的进阶版，输出不仅是文本，还可以是机器人的控制指令。 动作 Token 化 Action Tokenization 将连续的机器人动作（如电压、角度、坐标）转化为离散的数字 Token，以便 Transformer 处理。 联合训练 Co-training 在 RT-2 中使用的方法，同时使用互联网图文数据和机器人操作数据进行训练，以实现知识迁移。 跨形态 Cross-Embodiment 指一个模型能够控制身体结构完全不同的多种机器人（如不同品牌、不同自由度的机械臂）。 总结 (Summary) Week 10 告诉你 AI 的终极形态：\nCLIP 让电脑学会了把“图”和“字”对上号。 LLaVA 让 LLM 长了眼睛，能看图说话。 SAM 提供了像素级的精确视觉能力。 RT-2 / VLA 把这一切装进了机器人的身体里，利用大模型学到的世界知识（语义），去指导物理世界的行动（操作）。 从“读万卷书”（LLM）到“行万里路”（VLA），这就是 AI 的未来。 ","permalink":"https://gopherding.github.io/posts/tech/introduction-to-generative-ai/","summary":"\u003ch1 id=\"cs5494-week-1-introduction-to-generative-ai--perception-models\"\u003eCS5494 Week 1: Introduction to Generative AI \u0026amp; Perception Models\u003c/h1\u003e\n\u003ch1 id=\"第一周生成式人工智能与感知模型导论\"\u003e第一周：生成式人工智能与感知模型导论\u003c/h1\u003e\n\u003ch2 id=\"1-核心概念生成模型与判别模型\"\u003e1. 核心概念：生成模型与判别模型\u003c/h2\u003e\n\u003ch3 id=\"core-concept-generative-vs-discriminative-models\"\u003eCore Concept: Generative vs. Discriminative Models\u003c/h3\u003e\n\u003cp\u003e这是本节课最重要的理论基础，理解它们的区别是入门的关键。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. 判别模型 (Discriminative Models)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e功能 (Function)\u003c/strong\u003e: 学习如何区分或预测。就像给作业打分的老师，看到一个输入（试卷），给出一个输出（分数）。\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eAnalogy\u003c/em\u003e: Like a teacher grading an exam. Given an input (exam paper), it produces an output (score).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数学表达 (Mathematical Form)\u003c/strong\u003e: 建模条件概率 $P(y|x)$。即给定输入 $x$（如一张照片），预测标签 $y$（如“猫”或“狗”）的概率。\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eMath\u003c/em\u003e: Models the conditional probability $P(y|x)$. Given input $x$, predict the probability of label $y$.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e局限 (Limitation)\u003c/strong\u003e: 它们无法创造新数据，只能对现有数据进行分类或回归。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e2. 生成模型 (Generative Models)\u003c/strong\u003e\u003c/p\u003e","title":"Introduction to Generative AI"},{"content":"I placed a red beacon in the canyon’s throat,\nIt stood unshaken, against the dimming light,\nIt bade the wandering vine tendrils pause\nAnd arrest their climb, mid-air unspun.\nShadows pooled around its stark steel frame,\nLearned a sharp radius, no more formless,\nThe beacon glowed upon the stone\nAnd cast a deliberate, electric order.\nIt claimed the night’s wild unrest,\nThe beacon: glass, cold steel, pure red,\nIt bore no leaf, no dew, no wing’s soft tremor,\nLike nothing else in the canyon’s dream.\n","permalink":"https://gopherding.github.io/posts/life/red-beacon/","summary":"\u003cp\u003eI placed a red beacon in the canyon’s throat,\u003c/p\u003e\n\u003cp\u003eIt stood unshaken, against the dimming light,\u003c/p\u003e\n\u003cp\u003eIt bade the wandering vine tendrils pause\u003c/p\u003e\n\u003cp\u003eAnd arrest their climb, mid-air unspun.\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eShadows pooled around its stark steel frame,\u003c/p\u003e\n\u003cp\u003eLearned a sharp radius, no more formless,\u003c/p\u003e\n\u003cp\u003eThe beacon glowed upon the stone\u003c/p\u003e\n\u003cp\u003eAnd cast a deliberate, electric order.\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eIt claimed the night’s wild unrest,\u003c/p\u003e\n\u003cp\u003eThe beacon: glass, cold steel, pure red,\u003c/p\u003e\n\u003cp\u003eIt bore no leaf, no dew, no wing’s soft tremor,\u003c/p\u003e\n\u003cp\u003eLike nothing else in the canyon’s dream.\u003c/p\u003e","title":"Red Beacon"},{"content":"獅子山下 作詞：黃霑 作曲：顧嘉煇\n人生中有歡喜 難免亦常有淚\n我哋大家 在獅子山下相遇上\n總算是歡笑多於唏噓\n人生不免崎嶇 難以絕無掛慮\n既是同舟 在獅子山下且共濟\n拋棄區分求共對\n放開彼此心中矛盾 理想一起去追\n同舟人 誓相隨 無畏更無懼\n同處海角天邊 攜手踏平崎嶇\n我哋大家 用艱辛努力寫下那\n不朽香江名句\n放開彼此心中矛盾 理想一起去追\n同舟人 誓相隨 無畏更無懼\n同處海角天邊 攜手踏平崎嶇\n我哋大家 用艱辛努力寫下那\n不朽香江名句\n","permalink":"https://gopherding.github.io/posts/read/%E7%8B%AE%E5%AD%90%E5%B1%B1%E4%B8%8B/","summary":"\u003ch3 id=\"獅子山下\"\u003e獅子山下\u003c/h3\u003e\n\u003cp\u003e作詞：黃霑   作曲：顧嘉煇\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e人生中有歡喜 難免亦常有淚\u003c/p\u003e\n\u003cp\u003e我哋大家 在獅子山下相遇上\u003c/p\u003e\n\u003cp\u003e總算是歡笑多於唏噓\u003c/p\u003e\n\u003cp\u003e人生不免崎嶇 難以絕無掛慮\u003c/p\u003e\n\u003cp\u003e既是同舟 在獅子山下且共濟\u003c/p\u003e\n\u003cp\u003e拋棄區分求共對\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e放開彼此心中矛盾 理想一起去追\u003c/p\u003e\n\u003cp\u003e同舟人 誓相隨 無畏更無懼\u003c/p\u003e\n\u003cp\u003e同處海角天邊 攜手踏平崎嶇\u003c/p\u003e\n\u003cp\u003e我哋大家 用艱辛努力寫下那\u003c/p\u003e\n\u003cp\u003e不朽香江名句\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e放開彼此心中矛盾 理想一起去追\u003c/p\u003e\n\u003cp\u003e同舟人 誓相隨 無畏更無懼\u003c/p\u003e","title":"獅子山下"},{"content":"北方的冬天是冬天 徐志摩\n北方的冬天是冬天，\n满眼黄沙漠漠的地与天：\n赤膊的树枝，硬搅着北风先——\n一队队敢死的健儿，傲立在战阵前！\n不留半片残青，没有一丝粘恋，\n只拼着精光的筋骨；凝敛着生命的精液，\n耐，耐三冬的霜鞭与雪拳与风剑，\n直耐到春阳征服了消杀与枯寂与凶惨，\n直耐到春阳打开了生命的牢监，放出一瓣的树头鲜！\n直耐到忍耐的奋斗功效见，健儿克敌回家酣笑颜！\n北方的冬天是冬天！\n满眼黄沙茫茫的地与天；\n田里一只困顿的黄牛，\n西天边画出几线的悲鸣雁。\n","permalink":"https://gopherding.github.io/posts/read/%E5%8C%97%E6%96%B9%E7%9A%84%E5%86%AC%E5%A4%A9%E6%98%AF%E5%86%AC%E5%A4%A9/","summary":"\u003ch3 id=\"北方的冬天是冬天\"\u003e北方的冬天是冬天\u003c/h3\u003e\n\u003cp\u003e徐志摩\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e北方的冬天是冬天，\u003c/p\u003e\n\u003cp\u003e满眼黄沙漠漠的地与天：\u003c/p\u003e\n\u003cp\u003e赤膊的树枝，硬搅着北风先——\u003c/p\u003e\n\u003cp\u003e一队队敢死的健儿，傲立在战阵前！\u003c/p\u003e\n\u003cp\u003e不留半片残青，没有一丝粘恋，\u003c/p\u003e\n\u003cp\u003e只拼着精光的筋骨；凝敛着生命的精液，\u003c/p\u003e\n\u003cp\u003e耐，耐三冬的霜鞭与雪拳与风剑，\u003c/p\u003e\n\u003cp\u003e直耐到春阳征服了消杀与枯寂与凶惨，\u003c/p\u003e\n\u003cp\u003e直耐到春阳打开了生命的牢监，放出一瓣的树头鲜！\u003c/p\u003e\n\u003cp\u003e直耐到忍耐的奋斗功效见，健儿克敌回家酣笑颜！\u003c/p\u003e","title":"北方的冬天是冬天"},{"content":"这个与那个 一　读经与读史 一个阔人说要读经，嗡的一阵一群狭人也说要读经。岂但“读”而已矣哉，据说还可以“救国”哩。“学而时习之，不亦说乎？”那也许是确凿的罢，然而甲午战败了，——为什么独独要说“甲午”呢，是因为其时还在开学校，废读经以前。\n我以为伏案还未功深的朋友，现在正不必埋头来哼线装书。倘其咿唔日久，对于旧书有些上瘾了，那么，倒不如去读史，尤其是宋朝、明朝史，而且尤须是野史；或者看杂说。\n现在中西的学者们，几乎一听到“钦定四库全书”这名目就魂不附体，膝弯总要软下来似的。其实呢，书的原式是改变了，错字是加添了，甚至于连文章都删改了，最便当的是《琳琅秘室丛书》中的两种《茅亭客话》，一是宋本，一是四库本，一比较就知道。“官修”而加以“钦定”的正史也一样，不但本纪咧，列传咧，要摆“史架子”；里面也不敢说什么。据说，字里行间是也含着什么褒贬的，但谁有这么多的心眼儿来猜闷壶卢。至今还道“将平生事迹宣付国史馆立传”，还是算了罢。\n野史和杂说自然也免不了有讹传，挟恩怨，但看往事却可以较分明，因为它究竟不像正史那样地装腔作势。看宋事，《三朝北盟汇编》已经变成古董，太贵了，新排印的《宋人说部丛书》却还便宜。明事呢，《野获编》原也好，但也化为古董了，每部数十元；易于入手的是《明季南北略》、《明季稗史汇编》，以及新近集印的《痛史》。\n史书本来是过去的陈帐簿，和急进的猛士不相干。但先前说过，倘若还不能忘情于咿唔，倒也可以翻翻，知道我们现在的情形，和那时的何其神似，而现在的昏妄举动，胡涂思想，那时也早已有过，并且都闹糟了。\n试到中央公园去，大概总可以遇见祖母带着她孙女儿在玩的。这位祖母的模样，就预示着那娃儿的将来。所以倘有谁要预知令夫人后日的丰姿，也只要看丈母。不同是当然要有些不同的，但总归相去不远。我们查帐的用处就在此。\n但我并不说古来如此，现在遂无可为，劝人们对于“过去”生敬畏心，以为它已经铸定了我们的运命。Le Bon先生说，死人之力比生人大，诚然也有一理的，然而人类究竟进化着。又据章士钊总长说，则美国的什么地方已在禁讲进化论了，这实在是吓死我也，然而禁只管禁，进却总要进的。\n总之：读史，就愈可以觉悟中国改革之不可缓了。虽是国民性，要改革也得改革，否则，杂史杂说上所写的就是前车。一改革，就无须怕孙女儿总要像点祖母那些事，譬如祖母的脚是三角形，步履维艰的，小姑娘的却是天足，能飞跑；丈母老太太出过天花，脸上有些缺点的，令夫人却种的是牛痘，所以细皮白肉：这也就大差其远了。\n（十二月八日。）\n二　捧与挖 中国的人们，遇见带有会使自己不安的朕兆的人物，向来就用两样法：将他压下去，或者将他捧起来。\n压下去就用旧习惯和旧道德，或者凭官力，所以孤独的精神的战士，虽然为民众战斗，却往往反为这“所为”而灭亡。到这样，他们这才安心了。压不下时，则于是乎捧，以为抬之使高，餍之使足，便可以于己稍稍无害，得以安心。\n伶俐的人们，自然也有谋利而捧的，如捧阔老，捧戏子，捧总长之类；但在一般粗人，——就是未尝“读经”的，则凡有捧的行为的“动机”，大概是不过想免害。即以所奉祀的神道而论，也大抵是凶恶的，火神瘟神不待言，连财神也是蛇呀刺猬呀似的骇人的畜类；观音菩萨倒还可爱，然而那是从印度输入的，并非我们的“国粹”。要而言之：凡有被捧者，十之九不是好东西。\n既然十之九不是好东西，则被捧而后，那结果便自然和捧者的希望适得其反了。不但能使不安，还能使他们很不安，因为人心本来不易餍足。然而，人们终于至今没有悟，还以捧为苟安之一道。\n记得有一部讲笑话的书，名目忘记了，也许是《笑林广记》罢，说，当一个知县的寿辰，因为他是子年生，属鼠的，属员们便集资铸了一个金老鼠去作贺礼。知县收受之后，另寻了机会对大众说道：明年又恰巧是贱内的整寿；她比我小一岁，是属牛的。其实，如果大家先不送金老鼠，他决不敢想金牛。一送开手，可就难于收拾了，无论金牛无力致送，即使送了，怕他的姨太太也会属象。象不在十二生肖之内，似乎不近情理罢，但这是我替他设想的法子罢了，知县当然别有我们所莫测高深的妙法在。\n民元革命时候，我在Ｓ城，来了一个都督。他虽然也出身绿林大学，未尝“读经”（？），但倒是还算顾大局，听舆论的，可是自绅士以至于庶民，又用了祖传的捧法群起而捧之了。这个拜会，那个恭维，今天送衣料，明天送翅席，捧得他连自己也忘其所以，结果是渐渐变成老官僚一样，动手刮地皮。\n最奇怪的是北几省的河道，竟捧得河身比屋顶高得多了。当初自然是防其溃决，所以壅上一点土；殊不料愈壅愈高，一旦溃决，那祸害就更大。于是就“抢堤”咧，“护堤”咧，“严防决堤”咧，花色繁多，大家吃苦。如果当初见河水泛滥，不去增堤，却去挖底，我以为决不至于这样。\n有贪图金牛者，不但金老鼠，便是死老鼠也不给。那么，此辈也就连生日都未必做了。单是省却拜寿，已经是一件大快事。\n中国人的自讨苦吃的根苗在于捧，“自求多福”之道却在于挖。其实，劳力之量是差不多的，但从惰性太多的人们看来，却以为还是捧省力。\n（十二月十日。）\n三　最先与最后 《韩非子》说赛马的妙法，在于“不为最先，不耻最后”。这虽是从我们这样外行的人看起来，也觉得很有理。因为假若一开首便拼命奔驰，则马力易竭。但那第一句是只适用于赛马的，不幸中国人却奉为人的处世金了。\n中国人不但“不为戎首”，“不为祸始”，甚至于“不为福先”。所以凡事都不容易有改革；前驱和闯将，大抵是谁也怕得做。然而人性岂真能如道家所说的那样恬淡；欲得的却多。既然不敢径取，就只好用阴谋和手段。以此，人们也就日见其卑怯了，既是“不为最先”，自然也不敢“不耻最后”，所以虽是一大堆群众，略见危机，便“纷纷作鸟兽散”了。如果偶有几个不肯退转，因而受害的，公论家便异口同声，称之曰傻子。对于“锲而不舍”的人们也一样。\n我有时也偶尔去看看学校的运动会。这种竞争，本来不像两敌国的开战，挟有仇隙的，然而也会因了竞争而骂，或者竟打起来。但这些事又作别论。竞走的时候，大抵是最快的三四个人一到决胜点，其余的便松懈了，有几个还至于失了跑完豫定的圈数的勇气，中途挤入看客的群集中；或者佯为跌倒，使红十字队用担架将他抬走。假若偶有虽然落后，却尽跑，尽跑的人，大家就嗤笑他。大概是因为他太不聪明，“不耻最后”的缘故罢。\n所以中国一向就少有失败的英雄，少有韧性的反抗，少有敢单身鏖战的武人，少有敢抚哭叛徒的吊客；见胜兆则纷纷聚集，见败兆则纷纷逃亡。战具比我们精利的欧、美人，战具未必比我们精利的匈奴、蒙古、满洲人，都如入无人之境。“土崩瓦解”这四个字，真是形容得有自知之明。\n多有“不耻最后”的人的民族，无论什么事，怕总不会一下子就“土崩瓦解”的，我每看运动会时，常常这样想：优胜者固然可敬，但那虽然落后而仍非跑至终点不止的竞技者，和见了这样竞技者而肃然不笑的看客，乃正是中国将来的脊梁。\n四　流产与断种 近来对于青年的创作，忽然降下一个“流产”的恶，哄然应和的就有一大群。我现在相信，发明这话的是没有什么恶意的，不过偶尔说一说；应和的也是情有可原的，因为世事本来大概就这样。\n我独不解中国人何以于旧状况那么心平气和，于较新的机运就这么疾首蹙额；于已成之局那么委曲求全，于初兴之事就这么求全责备？\n智识高超而眼光远大的先生们开导我们：生下来的倘不是圣贤、豪杰、天才，就不要生；写出来的倘不是不朽之作，就不要写；改革的事倘不是一下子就变成极乐世界，或者，至少能给我（！）有更多的好处，就万万不要动！……\n那么，他是保守派么？据说：并不然的。他正是革命家。惟独他有公平，正当，稳健，圆满，平和，毫无流弊的改革法；现下正在研究室里研究着哩，——只是还没有研究好。\n什么时候研究好呢？答曰：没有准儿。\n孩子初学步的第一步，在成人看来，的确是幼稚，危险，不成样子，或者简直是可笑的。但无论怎样的愚妇人，却总以恳切的希望的心，看他跨出这第一步去，决不会因为他的走法幼稚，怕要阻碍阔人的路线而“逼死”他；也决不至于将他禁在床上，使他躺着研究到能够飞跑时再下地。因为她知道：假如这么办，即使长到一百岁也还是不会走路的。\n古来就这样，所谓读书人，对于后起者却反而专用彰明较著的或改头换面的禁锢。近来自然客气些，有谁出来，大抵会遇见学士文人们挡驾：且住，请坐。接着是谈道理了：调查，研究，推敲，修养，……结果是老死在原地方。否则，便得到“捣乱”的称号。我也曾有如现在的青年一样，向已死和未死的导师们问过应走的路。他们都说：不可向东，或西，或南，或北。但不说应该向东，或西，或南，或北。我终于发见他们心底里的蕴蓄了：不过是一个“不走”而已。\n坐着而等待平安，等待前进，倘能，那自然是很好的，但可虑的是老死而所等待的却终于不至；不生育，不流产而等待一个英伟的宁馨儿，那自然也很可喜的，但可虑的是终于什么也没有。\n倘以为与其所得的不是出类拔萃的婴儿，不如断种，那就无话可说。但如果我们永远要听见人类的足音，则我以为流产究竟比不生产还有望，因为这已经明明白白地证明着能够生产的了。\n（十二月二十日。）\n","permalink":"https://gopherding.github.io/posts/read/%E8%BF%99%E4%B8%AA%E4%B8%8E%E9%82%A3%E4%B8%AA/","summary":"\u003ch3 id=\"这个与那个\"\u003e这个与那个\u003c/h3\u003e\n\u003ch4 id=\"一读经与读史\"\u003e一　读经与读史\u003c/h4\u003e\n\u003cp\u003e一个阔人说要读经，嗡的一阵一群狭人也说要读经。岂但“读”而已矣哉，据说还可以“救国”哩。“学而时习之，不亦说乎？”那也许是确凿的罢，然而甲午战败了，——为什么独独要说“甲午”呢，是因为其时还在开学校，废读经以前。\u003c/p\u003e\n\u003cp\u003e我以为伏案还未功深的朋友，现在正不必埋头来哼线装书。倘其咿唔日久，对于旧书有些上瘾了，那么，倒不如去读史，尤其是宋朝、明朝史，而且尤须是野史；或者看杂说。\u003c/p\u003e","title":"这个与那个"},{"content":"问题 部署到GitHub Pages后加载速度慢，主要原因是依赖多个外部CDN资源。\n解决方案 将所有外部CDN资源本地化，从GitHub Pages直接加载。\n本地化的资源 JavaScript 文件 (static/js/) jquery-3.7.1.min.js (85.5 KB) - jQuery核心库 busuanzi.pure.mini.js (1.9 KB) - 不蒜子访问统计 mermaid.min.js (818 KB) - Mermaid图表渲染 CSS 文件 (static/css/) font-awesome.min.css (72.1 KB) - Font Awesome图标库 字体文件 (static/webfonts/) fa-solid-900.woff2 (154.5 KB) - Font Awesome实心图标字体 fa-regular-400.woff2 (24.9 KB) - Font Awesome常规图标字体 fa-brands-400.woff2 (115.9 KB) - Font Awesome品牌图标字体 修改的文件 layouts/partials/extend_head.html - 将CDN链接改为本地路径 优化效果 ✅ 加载速度显著提升（无需等待多个外部CDN）\n✅ 稳定性增强（不受CDN服务状态影响）\n✅ 离线开发可用\n✅ 版本完全可控\n总资源大小 约 1.4 MB（已压缩）\n","permalink":"https://gopherding.github.io/posts/blog/%E5%A4%96%E9%83%A8cdn%E4%BE%9D%E8%B5%96%E6%9C%AC%E5%9C%B0%E5%8C%96/","summary":"\u003ch3 id=\"问题\"\u003e问题\u003c/h3\u003e\n\u003cp\u003e部署到GitHub Pages后加载速度慢，主要原因是依赖多个外部CDN资源。\u003c/p\u003e\n\u003ch3 id=\"解决方案\"\u003e解决方案\u003c/h3\u003e\n\u003cp\u003e将所有外部CDN资源本地化，从GitHub Pages直接加载。\u003c/p\u003e\n\u003ch3 id=\"本地化的资源\"\u003e本地化的资源\u003c/h3\u003e\n\u003ch4 id=\"javascript-文件-staticjs\"\u003eJavaScript 文件 (\u003ccode\u003estatic/js/\u003c/code\u003e)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ejquery-3.7.1.min.js\u003c/code\u003e (85.5 KB) - jQuery核心库\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebusuanzi.pure.mini.js\u003c/code\u003e (1.9 KB) - 不蒜子访问统计\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emermaid.min.js\u003c/code\u003e (818 KB) - Mermaid图表渲染\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"css-文件-staticcss\"\u003eCSS 文件 (\u003ccode\u003estatic/css/\u003c/code\u003e)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efont-awesome.min.css\u003c/code\u003e (72.1 KB) - Font Awesome图标库\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"字体文件-staticwebfonts\"\u003e字体文件 (\u003ccode\u003estatic/webfonts/\u003c/code\u003e)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efa-solid-900.woff2\u003c/code\u003e (154.5 KB) - Font Awesome实心图标字体\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efa-regular-400.woff2\u003c/code\u003e (24.9 KB) - Font Awesome常规图标字体\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efa-brands-400.woff2\u003c/code\u003e (115.9 KB) - Font Awesome品牌图标字体\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"修改的文件\"\u003e修改的文件\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elayouts/partials/extend_head.html\u003c/code\u003e - 将CDN链接改为本地路径\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"优化效果\"\u003e优化效果\u003c/h3\u003e\n\u003cp\u003e✅ 加载速度显著提升（无需等待多个外部CDN）\u003cbr\u003e\n✅ 稳定性增强（不受CDN服务状态影响）\u003cbr\u003e\n✅ 离线开发可用\u003cbr\u003e\n✅ 版本完全可控\u003c/p\u003e","title":"外部CDN依赖本地化"},{"content":"实践是检验真理的唯一标准 光明日报特约评论员\n检验真理的标准是什么？这是早被无产阶级的革命导师解决了的问题。但是这些年来，由于“四人帮”的破坏和他们控制下的舆论工具大量的歪曲宣传，把这个问题搞得混乱不堪。为了深入批判“四人帮”，肃清其流毒和影响，在这个问题上拨乱反正，十分必要。\n检验真理的标准只能是社会实践 怎样区别真理与谬误呢？1845年，马克思就提出了检验真理的标准问题：“人的思维是否具有客观的真理性，这并不是一个理论的问题，而是一个实践的问题。人应该在实践中证明自己思维的真理性，即自己思维的现实性和力量，亦即自己思维的此岸性。关于离开实践的思维是否具有现实性的争论，是一个纯粹经院哲学的问题。”（《马克思恩格斯选集》第1卷第16页）这就非常清楚地告诉我们，一个理论，是否正确反映了客观实际，是不是真理，只能靠社会实践来检验。这是马克思主义认识论的一个基本原理。\n实践不仅是检验真理的标准，而且是唯一的标准。毛主席说：“真理只有一个，而究竟谁发现了真理，不依靠主观的夸张，而依靠客观的实践。只有千百万人民的革命实践，才是检验真理的尺度。”（《新民主主义论》）“真理的标准只能是社会的实践。”（《实践论》）这里说：“只能”“才是”，就是说，标准只有一个，没有第二个。这是因为，辩证唯物主义所说的真理是客观真理，是人的思想对于客观世界及其规律的正确反映。因此，作为检验真理的标准，就不能到主观领域内去寻找，不能到理论领域内去寻找，思想、理论自身不能成为检验自身是否符合客观实际的标准，正如在法律上原告是否属实，不能依他自己的起诉为标准一样。作为检验真理的标准，必须具有把人的思想和客观世界联系起来的特性，否则就无法检验。人的社会实践是改造客观世界的活动，是主观见之于客观的东西。实践具有把思想和客观实际联系起来的特性。因此，正是实践，也只有实践，才能够完成检验真理的任务。科学史上的无数事实，充分地说明了这个问题。\n门捷列夫根据原子量的变化，制定了元素周期表，有人赞同，有人怀疑，争论不休。尔后，根据元素周期表发现了几种元素，它们的化学特性刚好符合元素周期表的预测。这样，元素周期表就被证实了是真理。哥白尼的太阳系学说在300年里一直是一种假说，而当勒维烈从这个太阳系学说所提供的数据，不仅推算出一定还存在一个尚未知道的行星，而且还推算出这个行星在太空中的位置的时候，当加勒于1846年确实发现了海王星这颗行星的时候，哥白尼的太阳系学说才被证实了，成了公认的真理。\n马克思主义之所以被承认为真理，正是千百万群众长期实践证实的结果。毛主席说：“马克思列宁主义之所以被称为真理，也不但在于马克思、恩格斯、列宁、斯大林等人科学地构成这些学说的时候，而且在于为尔后革命的阶级斗争和民族斗争的实践所证实的时候。”（《实践论》）马克思主义原是工人运动中的一个派别，开始并不出名，反动派围攻它，资产阶级学者反对它，其他的社会主义流派攻击它，但是，长期的革命实践证明了马克思主义是真理，终于成为国际共产主义运动的指导思想。\n检验路线之正确与否，情形也是这样。马克思主义政党在制订自己的路线时，当然要从现实的阶级关系和阶级斗争的情况出发，依据革命理论的指导并且加以论证。但是，国际共产主义运动和各个革命政党的路线是否正确，同样必须由社会实践来检验。20世纪初，国际共产主义运动和俄国工人运动中，都发生了列宁的马克思主义路线与第二国际修正主义路线的激烈斗争，那时第二国际的头面人物是考茨基，列宁主义者是少数，斗争持续了很长一个时间。俄国十月革命和各国无产阶级革命的实践证明列宁主义是真理，宣告了第二国际修正主义路线的破产。\n毛泽东思想是马克思列宁主义普遍真理与革命具体实践相结合的产物。毛主席的革命路线与“左”、右倾机会主义路线进行了长期的斗争。在一个时期内，毛主席的革命路线没有占主导地位。长期的革命斗争，成功的经验和失败的教训，从正反两个方面证明毛主席的革命路线是正确的，而“左”、右倾机会主义路线是错误的。标准是什么呢？只有一个：就是千百万人民的社会实践。\n理论与实践的统一，是马克思主义的一个最基本的原则 有的同志担心，坚持实践是检验真理的唯一标准，会削弱理论的意义。这种担心是多余的。凡是科学的理论，都不会害怕实践的检验。相反，只有坚持实践是检验真理的唯一标准，才能够使伪科学、伪理论现出原形，从而捍卫真正的科学与理论。这一点，对于澄清被“四人帮”搞得非常混乱的理论问题，具有特别重要的意义。\n“四人帮”出于篡党夺权的反革命需要，鼓吹种种唯心论的先验论，反对实践是检验真理的标准。例如，他们炮制“天才论”，捏造文艺、教育等各条战线的“黑线专政”论，伪造老干部是民主派、民主派必然变成走资派的“规律”，胡诌社会主义生产关系“是产生新的资产阶级分子的经济基础”的谬论，虚构儒法斗争继续到现在的无稽之谈，等等。所有这些，都曾经被奉为神圣不可侵犯的所谓“理论”，谁反对，就会被扣上反对马列主义、反对毛泽东思想的大帽子。但是，这些五花八门的谬论，根本经不起革命实践的检验，它们连同“四人帮”另立的“真理标准”，一个个都像肥皂泡那样很快破灭了。这个事实雄辩地说明，他们自吹自擂证明不了真理，大规模的宣传证明不了真理，强权证明不了真理。他们以马列主义、毛泽东思想的“权威”自居，实践证明他们是反马列主义，反毛泽东思想的政治骗子。\n马列主义、毛泽东思想之所以有力量，正是由于它是经过实践检验了的客观真理，正是由于它高度概括了实践经验，使之上升为理论，并用来指导实践。正因为这样，我们要非常重视革命理论。列宁指出：“没有革命的理论，就不会有革命的运动。”（《列宁选集》第一卷第241页）理论所以重要，就是在于它来源于实践，又能正确指导实践，而理论到底是不是正确地指导了实践以及怎样才能正确地指导实践，一点也离不开实践的检验。不掌握这个精神实质，那是不可能真正发挥理论的作用的。\n有的同志说，我们批判修正主义，难道不是用马列主义、毛泽东思想去衡量，从而证明修正主义是错误的吗？我们说，是的，马列主义、毛泽东思想是我们批判修正主义的锐利武器，也是我们论证的根据。我们用马列主义、毛泽东思想的基本原理去批判修正主义，这些基本原理是马、恩、列、斯和毛主席从革命斗争的实践经验概括起来的，它们被长期的实践证明为不易之真理；但同时我们用这些原理去批判修正主义，仍然一点也不能离开当前的（和过去的）实践，只有从实践经验出发，才能使这些原理显示出巨大的生命力；我们的批判只有结合大量的事实分析，才有说服力。不研究实践经验，不从实践经验出发，是不能最终驳倒修正主义的。\n客观世界是不断发展的，实践是不断发展的。新事物新问题层出不穷，这就需要在马克思主义一般原理指导下研究新事物、新问题，不断作出新的概括，把理论推向前进。这些新的理论概括是否正确由什么来检验呢？只能用实践来检验。例如，列宁关于帝国主义时代个别国家或少数国家可以取得社会主义革命胜利的学说，是一个新的结论，这个结论正确不正确，不能用马克思主义关于资本主义的一般理论去检验，只有帝国主义时代的实践，第一次世界大战和十月革命的实践，才能证明列宁这个学说是真理。\n毛主席说：“理论与实践的统一，是马克思主义的一个最基本的原则。”（《毛泽东选集》第5卷第297页）坚持实践是检验真理的唯一标准，就是坚持马克思主义，坚持辩证唯物主义。\n革命导师是坚持用实践检验真理的榜样 革命导师们不仅提出了实践是检验真理的唯一标准，而且亲自作出了用实践去检验一切理论包括自己所提出的理论的光辉榜样。马克思和恩格斯对待他们所共同创造的著名的马克思主义科学文献《共产党宣言》的态度，就是许多事例当中的一个生动的例子。1848年《宣言》发表后，在45年中马克思和恩格斯一直在用实践来检验它。《宣言》的七篇序言，详细地记载了这个事实。首先，马克思恩格斯指出：“不管最近25年来的情况发生了多大的变化，这个《宣言》中所发挥的一般基本原理整个说来到现在还是完全正确的。”同时，他们又指出，“这些基本原理的实际运用，正如《宣言》中所说的，随时随地都要以当时的历史条件为转移。”（《马克思恩格斯选集》第1卷第228页）马克思和恩格斯根据新实践的不断检验，包括新的历史事实的发现，曾对《宣言》的个别论点作了修改。例如，《宣言》第一章的第一句是：“到目前为止的一切社会的历史都是阶级斗争的历史。”恩格斯在1888年的《宣言》英文版上加了一条注释：“确切地说，这是指有文字记载的历史。”（《马克思恩格斯选集》第1卷第251页）这是因为，《宣言》发表以后人们对于社会的史前史有了进一步的认识，特别是摩尔根的调查研究证明：在阶级社会以前，有一个很长的无阶级社会；阶级是社会发展到一定历史阶段的产物，并非从来就有的。可见，说“一切社会的历史都是阶级斗争的历史”，并不确切。恩格斯根据新发现的历史事实，作了这个说明，修改了《宣言》的旧提法。《宣言》还有一个说法，说到无产阶级要用暴力革命夺取政权，以推翻资产阶级。1872年，两位革命导师在他们共同签名的最后一篇序言中，明确指出：“由于最近25年来大工业已有很大发展而工人阶级的政党组织也跟着发展起来，由于首先有了二月革命的实际经验而后来尤其是有了无产阶级第一次掌握政权达两月之久的巴黎公社的实际经验，所以这个纲领现在有些地方已经过时了。特别是公社已经证明：‘工人阶级不能简单地掌握现成的国家机器，并运用它来达到自己的目的。’”（《马克思恩格斯选集》第1卷第229页）列宁对马克思和恩格斯的这个说明十分重视，他认为这是对《共产党宣言》的一个“重要的修改”。（《列宁选集》第3卷第201页）\n正如华主席所指出的：“毛主席从来对思想理论问题采取极其严肃和慎重的态度，他总是要让他的著作经过一段时间的实践的考验以后再来编定他的选集”。毛主席一贯严格要求不断用革命实践来检验自己提出的理论和路线。1955年毛主席在编辑《中国农村的社会主义高潮》一书的时候，写了104篇按语。当时没有预料到1956年以后国际国内所发生的阶级斗争的新情况。因此，1958年在重印一部分按语的时候，毛主席特别写了一个说明，指出这些按语“其中有一些现在还没有丧失它们的意义。其中说：1955年是社会主义与资本主义决战取得基本胜利的一年，这样说不妥当。应当说：1955年是在生产关系的所有制方面取得基本胜利的一年，在生产关系的其他方面以及上层建筑的某些方面即思想战线方面和政治战线方面，则或者还没有基本胜利，或者还没有完全胜利，还有待于尔后努力。”（《毛泽东选集》第5卷第225页）\n革命导师这种尊重实践的严肃的科学态度，给我们极大的教育。他们并不认为自己提出的理论是已经完成了的绝对真理或“顶峰”，可以不受实践检验的；并不认为只要是他们作出的结论不管实际情况如何都不能改变；更不要说那些根据个别情况作出的个别论断了。他们处处时时用实践来检验自己的理论、论断、指示，坚持真理，修正错误，尊重实践，尊重群众，毫无偏见。他们从不容许别人把他们的言论当作“圣经”来崇拜。毫无疑义，马克思主义的基本原理，马克思主义的立场、观点和方法，必须坚持，决不能动摇；但是，马克思主义的理论宝库并不是一堆僵死不变的教条，它要在实践中不断增加新的观点、新的结论，抛弃那些不再适合新情况的个别旧观点、旧结论。关于哲学，毛主席曾经说过：现在，我们已经进入社会主义时代，出现了一系列新的问题，如果只有几篇原有的哲学著作，不适应新的需要，写出新的著作，形成新的理论，那是不行的。实践、生活的观点是认识论的首要的和基本的观点。实践、生活之树是常青的。正是革命导师的这种坚持实践是检验真理的唯一标准的辩证唯物主义立场，才保证了马克思主义的不断发展，而永葆其青春。\n任何理论都要不断接受实践的检验 我们不仅承认实践是真理的标准，而且要从发展的观点看待实践标准。实践是不断发展的，因此作为检验真理的标准，它既具有绝对的意义，又具有相对的意义。就一切思想和理论都必须由实践来检验这一点讲，它是绝对的、无条件的；就实践在它发展的一定阶段上都有其局限性，不能无条件地完全证实或完全驳倒一切思想和理论这一点来讲，它又是相对的、有条件的；但是，今天的实践回答不了的问题，以后的实践终究会回答它，就这点来讲，它又是绝对的。列宁说：“当然，在这里不要忘记：实践标准实质上决不能完全地证实或驳倒人类的任何表象。这个标准也是这样的‘不确定’，以便不至于使人的知识变成‘绝对’，同时它又是这样的确定，以便同唯心主义和不可知论的一切变种进行无情的斗争。”（《列宁选集》第2卷第142页）\n辩证唯物主义认识论关于实践标准的绝对性和相对性辩证统一的观点，就是任何思想、任何理论必须无例外地、永远地、不断地接受实践的检验的观点，也就是真理发展的观点。任何思想、理论，即使是已经在一定的实践阶段上证明为真理，在其发展过程中仍然要接受新的实践的检验而得到补充、丰富或者纠正。毛主席指出：“人类认识的历史告诉我们，许多理论的真理性是不完全的，经过实践的检验而纠正了它们的不完全性。许多理论是错误的，经过实践的检验而纠正其错误。”又指出：“客观现实世界的变化运动永远没有完结，人们在实践中对于真理的认识也就永远没有完结。马克思列宁主义并没有结束真理，而是在实践中不断地开辟认识真理的道路。”（《实践论》）马克思主义强调实践是检验真理的标准，强调在实践中对于真理的认识永远没有完结，就是承认我们的认识不可能一次完成或最终完成。就是承认由于历史的和阶级的局限性，我们的认识可能犯错误，需要由实践来检验，凡经实践证明是错误的或者不符合实际的东西，就应当改变，不应再坚持。事实上这种改变是常有的。毛主席说：“真正的革命的指导者，不但在于当自己的思想、理论、计划、方案有错误时须得善于改正”，“而且在于当某一客观过程已经从某一发展阶段向另一发展阶段推移转变的时候，须得善于使自己和参加革命的一切人员在主观认识上也跟着推移转变，即是要使新的革命任务和新的工作方案的提出，适合于新的情况的变化。”（《实践论》）林彪、“四人帮”为了篡党夺权，胡诌什么“一句顶一万句”“句句是真理”。实践证明，他们所说的绝不是毛泽东思想的真理，而是他们冒充毛泽东思想的谬论。\n现在，“四人帮”及其资产阶级帮派体系已被摧毁，但是，“四人帮”加在人们身上的精神枷锁，还远没有完全粉碎。毛主席在第二次国内革命战争时期曾经批评过的“圣经上载了的才是对的”（《论反对日本帝国主义的策略》）这种倾向依然存在。无论在理论上或实际工作中，“四人帮”都设置了不少禁锢人们思想的“禁区”，对于这些“禁区”我们要敢于去触及，敢于去弄清是非。科学无禁区。凡有超越于实践并自奉为绝对的“禁区”的地方，就没有科学，就没有真正的马列主义、毛泽东思想，而只有蒙昧主义、唯心主义、文化专制主义。\n党的十一大和五届人大，确定了全党和全国人民在社会主义革命和社会主义建设新的发展时期的总任务。社会主义对于我们来说，有许多地方还是未被认识的必然王国。我们要完成这个伟大的任务，面临着许多新的问题，需要我们去认识，去研究，躺在马列主义毛泽东思想的现成条文上，甚至拿现成的公式去限制、宰割、裁剪无限丰富的飞速发展的革命实践，这种态度是错误的。我们要有共产党人的责任心和胆略，勇于研究生动的实际生活，研究现实的确切事实，研究新的实践中提出的新问题。只有这样，才是对待马克思主义的正确态度，才能够逐步地由必然王国向自由王国前进，顺利地进行新的伟大的长征。\n（《光明日报》1978年5月11日）\n","permalink":"https://gopherding.github.io/posts/read/%E5%AE%9E%E8%B7%B5%E6%98%AF%E6%A3%80%E9%AA%8C%E7%9C%9F%E7%90%86%E7%9A%84%E5%94%AF%E4%B8%80%E6%A0%87%E5%87%86/","summary":"\u003ch3 id=\"实践是检验真理的唯一标准\"\u003e实践是检验真理的唯一标准\u003c/h3\u003e\n\u003cp\u003e光明日报特约评论员\u003c/p\u003e\n\u003cp\u003e检验真理的标准是什么？这是早被无产阶级的革命导师解决了的问题。但是这些年来，由于“四人帮”的破坏和他们控制下的舆论工具大量的歪曲宣传，把这个问题搞得混乱不堪。为了深入批判“四人帮”，肃清其流毒和影响，在这个问题上拨乱反正，十分必要。\u003c/p\u003e\n\u003ch4 id=\"检验真理的标准只能是社会实践\"\u003e\u003cstrong\u003e检验真理的标准只能是社会实践\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e　　怎样区别真理与谬误呢？1845年，马克思就提出了检验真理的标准问题：“人的思维是否具有客观的真理性，这并不是一个理论的问题，而是一个实践的问题。人应该在实践中证明自己思维的真理性，即自己思维的现实性和力量，亦即自己思维的此岸性。关于离开实践的思维是否具有现实性的争论，是一个纯粹经院哲学的问题。”（《马克思恩格斯选集》第1卷第16页）这就非常清楚地告诉我们，一个理论，是否正确反映了客观实际，是不是真理，只能靠社会实践来检验。这是马克思主义认识论的一个基本原理。\u003c/p\u003e","title":"实践是检验真理的唯一标准"},{"content":"答李端叔书 宋·苏轼\n轼顿首再拜。闻足下名久矣，又于相识处，往往见所作诗文，虽不多，亦足以髣髴其为人矣。\n寻常不通书问，怠慢之罪，独可阔略，及足下斩然在疚，亦不能以一字奉慰。舍弟子由至，先蒙惠书，又复懒不即答，顽钝废礼，一至于此，而足下终不弃绝，递中再辱手书，待遇益隆，览之面热汗下也。\n足下才高识明，不应轻许与人，得非用黄鲁直、秦太虚辈语，真以为然耶？不肖为人所憎，而二子独喜见誉，如人嗜昌歜、羊枣，未易诘其所以然者。以二子为妄则不可，遂欲以移之众口，又大不可也。\n轼少年时，读书作文，专为应举而已。既及进士第，贪得不已，又举制策，其实何所有。而其科号为直言极谏，故每纷然诵说古今，考论是非，以应其名耳，人苦不自知，既以此得，因以为实能之，故譊譊至今，坐此得罪几死，所谓齐虏以口舌得官，直可笑也。然世人遂以轼为欲立异同，则过矣。妄论利害，搀说得失，此正制科人习气。譬之候虫时鸟，自鸣自己，何足为损益。轼每怪时人待轼过重，而足下又复称说如此，愈非其实。\n得罪以来，深自闭塞，扁舟草履，放浪山水间，与樵渔杂处，往往为醉人所推骂。辄自喜渐不为人识，平生亲友，无一字见及，有书与之亦不答，自幸庶几免矣。足下又复创相推与，甚非所望。\n木有瘿，石有晕，犀有通，以取妍于人；皆物之病也。谪居无事，默自观省，回视三十年以来所为，多其病者。足下所见，皆故我，非今我也。无乃闻其声不考其情，取其华而遗其实乎？抑将又有取于此也？此事非相见不能尽。\n自得罪后，不敢作文字。此书虽非文，然信笔书意，不觉累幅，亦不须示人。必喻此意。\n岁行尽，寒苦。惟万万节哀强食。不次。\n","permalink":"https://gopherding.github.io/posts/read/%E7%AD%94%E6%9D%8E%E7%AB%AF%E5%8F%94%E4%B9%A6/","summary":"\u003ch3 id=\"答李端叔书\"\u003e答李端叔书\u003c/h3\u003e\n\u003cp\u003e宋·苏轼\u003c/p\u003e\n\u003cp\u003e　　轼顿首再拜。闻足下名久矣，又于相识处，往往见所作诗文，虽不多，亦足以髣髴其为人矣。\u003c/p\u003e\n\u003cp\u003e　　寻常不通书问，怠慢之罪，独可阔略，及足下斩然在疚，亦不能以一字奉慰。舍弟子由至，先蒙惠书，又复懒不即答，顽钝废礼，一至于此，而足下终不弃绝，递中再辱手书，待遇益隆，览之面热汗下也。\u003c/p\u003e\n\u003cp\u003e　　足下才高识明，不应轻许与人，得非用黄鲁直、秦太虚辈语，真以为然耶？不肖为人所憎，而二子独喜见誉，如人嗜昌歜、羊枣，未易诘其所以然者。以二子为妄则不可，遂欲以移之众口，又大不可也。\u003c/p\u003e","title":"答李端叔书"},{"content":"外企面试注意事项——时区划分 记录一下今日大失败： 由于本人的愚蠢和对ChatGPT的信任，致使我或许将要失去一次相当宝贵（从薪酬和前景来看）的外企面试机会（虽然我大概率面不进去），故惩罚我今天多刷三道LeetCode，以及下次Tutorial不准使用AI.\n那末，也适时提醒一下正在准备外企面试的同志们，如果一位HR邀请你/妳在某某时刻的CST时间参加面试，务必和对方确认清楚这个CST是指 China Standard Time 还是 Central Standard Time，特别是这家公司总部还在美国中部的情况下——如果对方比较善解人意，专门为你/妳选择了前者；然而你/妳也很善解人意，专门为他/她选择了后者——那末，这样的双向奔赴会隔着足足13/14小时的时差！\n同时，你/妳也会发现——Zoom之中万籁俱寂，而邮件里面幽幽地传来一行：Is now still a good time to talk?（4 hours ago）\n荣耀此时并不会向我俯首，但是沉默此刻确是震耳欲聋。\n我真傻，真的。\n","permalink":"https://gopherding.github.io/posts/life/%E5%A4%96%E4%BC%81%E9%9D%A2%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%97%B6%E5%8C%BA%E5%88%92%E5%88%86/","summary":"\u003ch3 id=\"外企面试注意事项时区划分\"\u003e外企面试注意事项——时区划分\u003c/h3\u003e\n\u003cp\u003e记录一下今日大失败：\n由于本人的愚蠢和对ChatGPT的信任，致使我或许将要失去一次相当宝贵（从薪酬和前景来看）的外企面试机会（虽然我大概率面不进去），故惩罚我今天多刷三道LeetCode，以及下次Tutorial不准使用AI.\u003c/p\u003e\n\u003cp\u003e那末，也适时提醒一下正在准备外企面试的同志们，如果一位HR邀请你/妳在某某时刻的CST时间参加面试，务必和对方确认清楚这个CST是指 China Standard Time 还是 Central Standard Time，特别是这家公司总部还在美国中部的情况下——如果对方比较善解人意，专门为你/妳选择了前者；然而你/妳也很善解人意，专门为他/她选择了后者——那末，这样的双向奔赴会隔着足足13/14小时的时差！\u003c/p\u003e","title":"外企面试注意事项——时区划分"},{"content":"愿你做一条马氏链 在2017北京大学国际关系学院毕业典礼上的致辞\n老师们、同学们、来宾们，上午好！\n很荣幸作为校友代表参加这次毕业典礼。我从北大国关毕业过两次，那时候还没有国关楼，我也没有参加过院里的典礼。今天我来到这里，祝贺学弟学妹们毕业，也弥补一下心中这个小小的遗憾。\n记忆中的毕业季，充满了豪言壮语、哲思妙想、山盟海誓。但事后看，极少有能够算数的，都是狄奥尼索斯式的壮丽和快慰。但，青春的横绝本该如此。\n这该是你们激情表达而非静心聆听的季节，但倚门目送你们远去的师与长，却也非得要做执手叮咛的亲眷、赠人以言的君子，一表浓情雅意。\n于是，我就以大师姐的身份，站在了这里。\n我在国关念书的时候，心里有一个信念，就是天底下没有比这里更好的地方，能赖多久我就要赖多久。结果如愿以偿，我的人在国关晃了8年，而我的档案在北大存了15年。作为学生，谁又舍得离开这个“钟鸣鼎食之家、诗书礼仪之邦”呢？我那时候贪恋着她的近乎宠溺的宽容，纵容着我的天生不羁爱自由，旁观着我那些与国际关系专业毫不相干的尝试与追逐，在这母校的怀抱中肆意地做着浪子，在这温柔乡里关山飞渡、涉江来去。今天我成为一名国际关系学者，当年的老师和同学，何曾会想到玩世不恭地走着文艺女青年路线的我，最终会属意于严谨的学术？最要命的是，我爱的竟然是那些抽象的理论、艰深的模型和烧脑的算法！我自己成为一名教育工作者后才明白，那些年我在这里享受到的正是弥足珍贵的博雅教育。给你一片宁静，你才能听到内心的召唤，给你无限可能，你才能拥有非他莫属的一份事业。在北大国关，没有人逼迫你急功近利，没有人看低你徘徊低迷，没有人用世俗的刻度丈量你的高低贵贱，没有人蛮横地打磨你的锋芒棱角。正是这种教育，让追求知识、向往纯粹的心，才能在洗净铅华后显现在眼前，带着我负笈远游、上下求索。正是这种教育，让我们有机会怀疑自身、拷问心灵，去旁观、去尝试、去选择、去放弃、去否定、去珍惜。接受过这种教育的人，才会取舍有道、进退有度，才能有“竹杖芒鞋、吟啸徐行”的从容，才能做“有终身之忧，无一朝之患”的君子。这正是我最为要恭喜同学们的，这是你们将要从北大国关带走的终身财富，也是你们将来要屡屡被世人或赞美或诟病的所谓“北大气质”，请你们翼翼珍重、持定坚守。\n好喜欢看今天的你们意气风发的样子，银鞍照白马，飒沓如流星，爱国关天下，何处不风流。但，我不知道你们会不会有一天也会像我这样，时常被自身的渺小与无助所击中，莫名的挫败感和虚无感会在无眠的深夜袭来，这无关世俗的得失、无关外界的荣辱。一个人越有为天地而立的心，越是倍感现实的羁绊和压迫；一个人越有为生民而立的命，越是痛感一己的无力与无用。出了北大这个门，便是茫茫天涯、便要安身立命，情非得已的人云亦云，无可奈何的亦步亦趋，似乎与理想在南辕北辙，似乎与人格在背道而驰。我们再不能活得如曾经那般清奇，但我们宁可承受人潮人海中的孤独和冠盖如云里的憔悴，也不能用平庸麻木、帮闲媚俗、屈从逢迎，获取廉价肤浅的惬怀自喜与自欺欺人的志得意满。\n在我的研究中，经常要处理随机过程，就是一种由统计分布决定的数学过程。不了解它们的人，以为这很无趣很枯燥，但其实随机过程特别玄妙，它们甚至是各种深刻的人生隐喻。有一种过程叫随机行走。它的每一步变化完全来自外在的冲击，随波逐流、顺风转舵，它没有定力和主线，也无挣扎与痛苦，很是顺应潮流、很会投机上位，但这个过程很快就构成了一个失控的轨迹，无法收敛、不知所终。而另外一种随机过程叫马氏链，在我看来，它隐喻着一种理想人生。马氏链有一个前定的目标空间，虽不知具体是什么、不知究竟在何处，但它的整个过程朝向那个遥远而有力的内心召唤。它并非直线行进，每走一步都忍受着巨大的不确定性，看似后退、看似放弃、看似溜达，就这样，它通俗而不媚俗、变通而不世故、妥协而不屈服，在诡谲无垠的高维空间中，最终能够找到心向往之的地方，实现一条马氏链存在的使命与价值。马氏链还经常被羁绊在洼地中脱身不出，也会兜兜转转、起起伏伏，一时不知身居何处，但它从不忘记内心的召唤，也从不停息摆脱桎梏的挣扎。只要心坚若磐石，又何惧身漂若浮萍。马氏链只有短暂的记忆，荣光终将被稀释、错误终将被原谅，一切终将与我们从何处而来没了关系。\n我希望你们的将来不要做随机行走，而要做一条奥德赛式的马氏链。\n今天，你们注定要远行，但好在有博雅塔静穆地守望着你们的精神家园；将来，你们注定要老去，但好在有未名湖小心地收纳着你们的烈焰青春。你们是幸福的、也是幸运的，愿这幸福与幸运与你们永远同在。你们的生活或将因沾湿和黏附渐渐变沉，愿你们干燥的北大灵魂一直持守自身、飘逸轻盈。\n恭喜你们！谢谢大家！\n","permalink":"https://gopherding.github.io/posts/read/%E6%84%BF%E4%BD%A0%E5%81%9A%E4%B8%80%E6%9D%A1%E9%A9%AC%E6%B0%8F%E9%93%BE-%E5%9C%A82017%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E5%9B%BD%E9%99%85%E5%85%B3%E7%B3%BB%E5%AD%A6%E9%99%A2%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC%E4%B8%8A%E7%9A%84%E8%87%B4%E8%BE%9E/","summary":"\u003ch3 id=\"愿你做一条马氏链\"\u003e\u003ca href=\"https://www.sis.pku.edu.cn/docs/%E9%99%84%E4%BB%B6%EF%BC%9A3%E3%80%81%E9%99%A2%E5%8F%8B%E4%BB%A3%E8%A1%A8%E3%80%81%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%9B%BD%E9%99%85%E5%85%B3%E7%B3%BB%E7%A0%94%E7%A9%B6%E9%99%A2%E5%BA%9E%E7%8F%A3%E6%95%99%E6%8E%88%E7%9A%84%E8%87%B4%E8%BE%9E.pdf\"\u003e愿你做一条马氏链\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e在2017北京大学国际关系学院毕业典礼上的致辞\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e老师们、同学们、来宾们，上午好！\u003c/p\u003e\n\u003cp\u003e很荣幸作为校友代表参加这次毕业典礼。我从北大国关毕业过两次，那时候还没有国关楼，我也没有参加过院里的典礼。今天我来到这里，祝贺学弟学妹们毕业，也弥补一下心中这个小小的遗憾。\u003c/p\u003e\n\u003cp\u003e记忆中的毕业季，充满了豪言壮语、哲思妙想、山盟海誓。但事后看，极少有能够算数的，都是狄奥尼索斯式的壮丽和快慰。但，青春的横绝本该如此。\u003c/p\u003e","title":"愿你做一条马氏链"},{"content":"CHANGELOG-v1.1.0-移动端优化 发布日期：2025年10月5日\n更新类型：用户体验优化与界面美化\n影响范围：全站页面布局与交互体验\n🎯 本次更新概述 本次更新专注于提升博客的视觉效果和用户体验，特别针对移动端显示效果和目录导航功能进行了全面优化。通过精心设计的CSS样式和响应式布局，为读者提供更加现代化、美观且易用的阅读体验。\n✨ 主要更新内容 📱 移动端体验优化 完全重写移动端适配逻辑：针对不同屏幕尺寸（480px、768px、360px）提供精确的布局优化 文字选择体验改善：优化了移动设备上的文本选择效果，提升可读性 触摸交互优化：改善移动端的点击和滑动体验 🎨 视觉效果全面升级 现代化设计语言：引入玻璃拟态效果和渐变背景，提升视觉层次 导航栏美化：添加毛玻璃效果和动态阴影，增强现代感 头像与个人资料优化：改善个人主页的视觉呈现效果 代码块样式重设计：采用macOS风格的红黄绿装饰点，提升代码阅读体验 🧭 目录导航系统优化 解决目录遮挡问题：彻底修复了滚动时导航栏遮挡目录的问题 响应式目录布局：在不同设备上提供最佳的目录显示效果 智能定位系统：优化目录链接点击后的页面定位准确性 🔧 性能与兼容性改进 CSS优化：简化样式代码，提升页面加载速度 跨设备兼容：确保在各种设备和浏览器上的一致性表现 减少动画负载：为偏好减少动效的用户提供性能优化选项 📂 技术文件更新清单 新增文件 assets/css/extended/ ├── mobile-optimization.css # 移动端优化样式 ├── visual-enhancement.css # 视觉美化效果 ├── profile-enhancement.css # 个人资料页优化 ├── post-enhancement.css # 文章页面美化 ├── scroll-to-top-enhancement.css # 返回顶部按钮优化 ├── toc-simple-fix.css # 目录导航修复 └── disable-code-decorations.css # 代码块样式优化 assets/js/ ├── typewriter.js # 打字动画效果 └── mobile-nav-optimization.js # 移动端导航优化 content/ └── 模板.md # 文章模板更新 修改文件 layouts/partials/ ├── footer.html # 底部布局优化 └── toc.html # 目录组件改进 assets/css/extended/ ├── toc.css # 目录样式调整 └── blank.css # 基础样式更新 config.yml # 配置文件优化 🌟 用户体验改进 桌面端体验 左侧目录导航：完美避开顶部导航栏，提供清晰的文章结构导览 现代化界面：采用渐变背景和玻璃拟态效果，提升视觉质感 代码展示优化：macOS风格的代码块装饰，增强代码可读性 移动端体验 响应式布局：针对手机和平板设备的专门优化 触摸友好：优化按钮大小和点击区域，提升操作便利性 性能优化：减少不必要的动画，确保流畅的浏览体验 通用改进 智能滚动：点击目录链接时自动计算导航栏高度，精确定位 一致性体验：在所有页面类型（首页、文章页、关于页面等）保持统一的设计语言 可访问性提升：改善文字对比度和选择效果，提升阅读体验 🔄 兼容性说明 浏览器支持：兼容所有现代浏览器（Chrome、Firefox、Safari、Edge） 设备适配：支持从320px到4K显示器的全范围屏幕尺寸 向后兼容：保持原有功能完整性，不影响现有内容展示 📈 后续计划 持续监控用户反馈，进一步优化交互体验 计划添加更多个性化主题选项 考虑引入暗色模式的进一步优化 技术支持：如遇到任何问题或有改进建议，欢迎通过Issues反馈\n更新方式：本次更新采用渐进式发布，确保稳定性和用户体验的平滑过渡\n","permalink":"https://gopherding.github.io/posts/blog/changelog-v1.2.0-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96/","summary":"\u003ch2 id=\"changelog-v110-移动端优化\"\u003e\u003cstrong\u003eCHANGELOG-v1.1.0-移动端优化\u003c/strong\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e发布日期：2025年10月5日\u003cbr\u003e\n更新类型：用户体验优化与界面美化\u003cbr\u003e\n影响范围：全站页面布局与交互体验\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"-本次更新概述\"\u003e🎯 本次更新概述\u003c/h2\u003e\n\u003cp\u003e本次更新专注于提升博客的视觉效果和用户体验，特别针对移动端显示效果和目录导航功能进行了全面优化。通过精心设计的CSS样式和响应式布局，为读者提供更加现代化、美观且易用的阅读体验。\u003c/p\u003e","title":"CHANGELOG-v1.1.0-移动端优化"},{"content":"如何对博客进行版本更新并推送 在日常维护 Hugo 博客的过程中，我们不仅会不断写新文章，还会对主题、样式和功能进行改进。为了更好地管理这些变化，给博客打上 版本号 是一个好习惯。这样可以清晰地记录每个阶段的更新内容，也方便回溯。\n为什么要进行版本管理？ 清晰记录：知道每个版本新增了哪些功能或修复了哪些问题 方便回滚：如果新版本出现问题，可以快速回退到旧版本 发布节奏：通过版本号来标记“里程碑”更新，而不是每次小改动都算一个版本 版本号规范（SemVer） 我们采用语义化版本号（Semantic Versioning），格式为：\n主版本号.次版本号.修订号\n主版本号 (MAJOR)：有不兼容的重大变更时 +1 次版本号 (MINOR)：新增功能且向下兼容时 +1 修订号 (PATCH)：修复 bug 或小改动时 +1 例如：\n1.0.0 → 初始版本 1.1.0 → 新增移动端支持 1.1.1 → 修复移动端样式 bug 操作步骤 1.提交代码 git add . git commit -m \u0026#34;feat: 增加移动端支持\u0026#34; 2. 打标签（Tag） git tag -a v1.1.0 -m \u0026#34;Release v1.1.0: 增加移动端支持\u0026#34; 3. 推送到 GitHub git push origin main git push origin v1.1.0 4. 发布 Release（可选） 在 GitHub 仓库 → Releases → Draft a new release\n选择 v1.1.0 标签，填写更新说明并发布。\n日常更新 vs 版本更新 日常更新（写文章、改配置）： 直接 git push origin main，GitHub Actions 会自动部署到 Pages。 版本更新（新增功能、主题改版）： 除了 git push，还要打上版本号标签并发布 Release。 覆盖更新标签（特殊情况） 如果打错了版本号（比如误打成 v1.2.0），可以这样修正：\ngit tag -d v1.2.0 git push origin --delete v1.2.0 git tag -a v1.1.0 -m \u0026#34;Release v1.1.0: 修正版本\u0026#34; git push origin v1.1.0 总结 日常写文章：直接 git push 重要更新：打版本号 + 发布 Release 版本号规则：主.次.修订，根据更新内容递增 通过这种方式，你的 Hugo 博客就有了清晰的版本演进记录，也方便未来维护和回溯。\n","permalink":"https://gopherding.github.io/posts/blog/%E5%A6%82%E4%BD%95%E5%AF%B9%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E5%B9%B6%E6%8E%A8%E9%80%81/","summary":"\u003ch3 id=\"如何对博客进行版本更新并推送\"\u003e如何对博客进行版本更新并推送\u003c/h3\u003e\n\u003cp\u003e在日常维护 Hugo 博客的过程中，我们不仅会不断写新文章，还会对主题、样式和功能进行改进。为了更好地管理这些变化，给博客打上 \u003cstrong\u003e版本号\u003c/strong\u003e 是一个好习惯。这样可以清晰地记录每个阶段的更新内容，也方便回溯。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"为什么要进行版本管理\"\u003e为什么要进行版本管理？\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e清晰记录\u003c/strong\u003e：知道每个版本新增了哪些功能或修复了哪些问题\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e方便回滚\u003c/strong\u003e：如果新版本出现问题，可以快速回退到旧版本\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e发布节奏\u003c/strong\u003e：通过版本号来标记“里程碑”更新，而不是每次小改动都算一个版本\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"版本号规范semver\"\u003e版本号规范（SemVer）\u003c/h2\u003e\n\u003cp\u003e我们采用语义化版本号（Semantic Versioning），格式为：\u003c/p\u003e","title":"如何对博客进行版本更新并推送"},{"content":"作为一个喜欢折腾博客细节的人，我一直觉得 Hugo PaperMod 主题的首页副标题太 “安静” 了 —— 静态文字放在那里，少了点互动感。于是今天给自己定了个小目标：给副标题加个「打字轮询动画」：文字逐字敲出、带闪烁光标，还能自动切换不同的句子。本以为是 “复制粘贴代码” 的小事，结果踩了好几个坑，好在最后完美实现。这篇就记录下整个过程，希望能帮到同样想折腾的朋友。\n一、先看最终效果：我想要的是什么？ 在动手前先明确需求，避免后续跑偏：\n打字效果：文字不是一次性出来，而是像键盘敲击一样逐字显示； 闪烁光标：文字右侧跟着一个竖线光标，模仿真实打字体验； 自动轮询：打完一句后，逐字删除，再随机切换下一句（不重复）； 不破坏主题：尽量不改主题核心文件，后续升级 PaperMod 不丢配置。 最终实现的效果是：首页 profile 区域，光标先闪，然后逐字 “敲” 出句子，停顿 2 秒后删光，再切换下一句，循环往复 —— 看起来像是博客在 “自言自语”，多了点灵动的感觉。\n二、从零开始：分 5 步实现动画 整个过程围绕「配置→模板→逻辑→样式→加载」展开，每个步骤都有需要注意的细节，尤其是 Hugo 的模板语法和资源处理逻辑，踩坑也多在这上面。\n第一步：配置文件埋 “伏笔”—— 集中管理要轮询的句子 首先要把想轮询的句子存在配置里，方便后续修改（不用改代码）。打开项目根目录的 config.yml，在 params 下加两个关键配置：\nparams: # 1. 启用首页 profile 模式（必须开，否则副标题不显示） profileMode: enabled: true # 核心开关，关了整个 profile 都没了 title: \u0026#34;我的博客\u0026#34; # 主标题不变 subtitle: \u0026#34;\u0026#34; # 副标题留空！后面让 JS 填内容 imageUrl: \u0026#34;img/avatar.jpg\u0026#34; # 头像路径（放 static/img 里） imageWidth: 275 imageHeight: 275 # 2. 要轮询的句子列表（和 profileMode 平级！别嵌套进去） quotes: - \u0026#34;生命不是要超越别人，而是要超越自己。\u0026#34; - \u0026#34;人生伟业的建立，不在能知，乃在能行。\u0026#34; - \u0026#34;任何的限制，都是从自己内心开始的。\u0026#34; - \u0026#34;含泪播种的人一定能含笑收获。\u0026#34; 这里踩了第一个坑：一开始把 quotes 嵌套进 profileMode 里（比如 params → profileMode → quotes），结果后续 JS 根本读不到句子 ——Hugo 对 YAML 层级极敏感，必须确保 quotes 和 profileMode 是 “兄弟” 关系，都在 params 下面。\n第二步：改模板 —— 给副标题 “挂标识” PaperMod 渲染首页 profile 的模板是 index_profile.html，需要给副标题加两个东西：\nclass=\u0026quot;profile-subtitle\u0026quot;：让 JS/CSS 能定位到这个元素； data-quotes：把 config.yml 里的句子列表以 JSON 格式 “注入” 到元素里，供 JS 读取。 操作时要注意：不要直接改主题文件夹的模板（升级会覆盖），先复制到项目目录：\n把 themes/PaperMod/layouts/partials/index_profile.html 复制到 项目根目录/layouts/partials/index_profile.html（没有 partials 文件夹就手动建）； 打开复制后的文件，找到原副标题代码（通常是 \u0026lt;span\u0026gt;{{ .subtitle | markdownify }}\u0026lt;/span\u0026gt;），替换成： \u0026lt;!-- 副标题：加 class 供定位，加 data-quotes 传句子列表 --\u0026gt; \u0026lt;span class=\u0026#34;profile-subtitle\u0026#34; data-quotes=\u0026#39;{{ site.Params.quotes | jsonify | safeHTMLAttr }}\u0026#39;\u0026gt; \u0026lt;/span\u0026gt; 解释下这行代码：\nsite.Params.quotes：读取配置里的句子列表； jsonify：把列表转成 JSON 格式（JS 能解析）； safeHTMLAttr：防止 Hugo 转义引号（比如把 \u0026quot; 变成 \u0026quot;），确保 JSON 格式正确。 第三步：写 JS 逻辑 —— 实现打字 + 轮询 这是核心步骤，要让 JS 完成 “读句子→打字→删除→切换” 的循环。在 项目根目录/assets/js/ 下新建 typewriter.js（assets 是 Hugo 处理资源的目录，比 static 更灵活）：\n// 等 DOM 加载完再执行，避免找不到元素 document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { // 1. 找到副标题元素 const subtitle = document.querySelector(\u0026#34;.profile-subtitle\u0026#34;); if (!subtitle) return; // 没找到元素就退出，避免报错 // 2. 读取 data-quotes 里的句子列表 const quotes = JSON.parse(subtitle.dataset.quotes || \u0026#34;[]\u0026#34;); if (quotes.length === 0) return; // 没句子也退出 // 3. 动画参数（可自己调速度） const typingSpeed = 100; // 打字速度（毫秒/字） const deletingSpeed = 50; // 删除速度 const pauseAfterTyping = 2000; // 打完停顿2秒 const pauseAfterDeleting = 500;// 删除完停顿0.5秒 // 4. 状态变量 let currentQuoteIndex = Math.floor(Math.random() * quotes.length); // 随机开始第一句 let currentText = \u0026#34;\u0026#34;; // 当前显示的文字 let charIndex = 0; // 当前处理的字符索引 let isDeleting = false; // 是否在删除状态 // 5. 核心打字函数 function typeWriter() { const currentQuote = quotes[currentQuoteIndex]; if (isDeleting) { // 删除阶段：逐字减少 currentText = currentQuote.substring(0, charIndex - 1); charIndex--; } else { // 打字阶段：逐字增加 currentText = currentQuote.substring(0, charIndex + 1); charIndex++; } // 更新副标题内容 subtitle.textContent = currentText; // 切换状态/句子 if (!isDeleting \u0026amp;\u0026amp; charIndex === currentQuote.length) { // 打完一句，准备删除 isDeleting = true; setTimeout(typeWriter, pauseAfterTyping); } else if (isDeleting \u0026amp;\u0026amp; charIndex === 0) { // 删除完，切换下一句（避免重复） isDeleting = false; let newIndex; do { newIndex = Math.floor(Math.random() * quotes.length); } while (newIndex === currentQuoteIndex); currentQuoteIndex = newIndex; setTimeout(typeWriter, pauseAfterDeleting); } else { // 继续打字/删除 setTimeout(typeWriter, isDeleting ? deletingSpeed : typingSpeed); } } // 6. 启动动画 typeWriter(); }); 这段代码的逻辑很直观：先读句子，然后循环 “打字→停顿→删除→换句子”，还加了随机开始和避免重复的逻辑，体验更自然。\n第四步：写 CSS 样式 —— 让光标闪起来 光有文字打字还不够，得加个闪烁的光标。在 项目根目录/assets/css/extended/ 下新建 custom.css：\n/* 副标题基础样式：确保文字可见 */ .profile-subtitle { position: relative; /* 给光标定位用 */ display: inline-block; /* 避免光标换行 */ color: inherit !important; /* 继承父元素颜色，防止和背景同色 */ white-space: nowrap; /* 文字不换行 */ } /* 光标样式：用伪元素生成竖线 */ .profile-subtitle::after { content: \u0026#34;|\u0026#34;; /* 光标符号 */ position: absolute; /* 绝对定位，跟着文字走 */ right: -6px; /* 光标在文字右侧的距离 */ animation: blink 1s step-end infinite; /* 1秒闪烁一次 */ color: inherit; /* 光标颜色和文字一致 */ } /* 光标闪烁动画 */ @keyframes blink { from, to { opacity: 1; } /* 开始和结束显示 */ 50% { opacity: 0; } /* 中间隐藏 */ } 这里用 ::after 伪元素生成光标，比直接写在 JS 里更灵活，样式也更容易调整 —— 想换光标颜色或速度，改 CSS 就行，不用动 JS。\n第五步：加载资源 —— 让 JS 和 CSS 生效 Hugo 不会自动加载 assets 里的文件，必须手动配置。一开始我想改 baseof.html（所有页面的根模板），但后来觉得不够 “优雅”，最终选择更规范的方式：\n1. CSS 加载：放在 head.html 里 CSS 适合在头部加载，避免页面闪烁。把主题的 themes/PaperMod/layouts/partials/head.html 复制到 项目根目录/layouts/partials/head.html，在 \u0026lt;head\u0026gt; 标签内的 “样式加载区”（比如最后一个 \u0026lt;link\u0026gt; 后面）加：\n\u0026lt;!-- 加载光标样式 CSS --\u0026gt; {{ $customCss := resources.Get \u0026#34;css/extended/custom.css\u0026#34; }} {{ if $customCss }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ $customCss.RelPermalink }}\u0026#34;\u0026gt; {{ end }} 2. JS 加载：放在 footer.html 里 JS 放在页脚加载，避免阻塞页面渲染。把主题的 themes/PaperMod/layouts/partials/footer.html 复制到 项目根目录/layouts/partials/footer.html，在 \u0026lt;/footer\u0026gt; 标签后面加：\n\u0026lt;!-- 加载打字动画 JS --\u0026gt; {{ $typewriter := resources.Get \u0026#34;js/typewriter.js\u0026#34; }} {{ if $typewriter }} \u0026lt;script src=\u0026#34;{{ $typewriter.RelPermalink }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 这里又踩了个坑：一开始我把 JS 放在 static/js/ 目录，还用 custom/js.html 加载，结果页面源代码里根本找不到脚本标签 —— 后来才知道 PaperMod 旧版本不默认加载 custom 目录的 partial，直接改 footer.html 才是 “万能方案”。\n三、那些让人头大的坑：解决了才敢分享 折腾过程中遇到几个问题，差点放弃，最后靠调试工具和查文档解决了，记录下来帮大家避坑：\n坑 1：只有光标，没有文字 现象：光标闪得很欢，但看不到打字的文字。\n原因：文字颜色和背景色一致（我的博客是深色模式，文字默认白色，背景也是白色）。\n解决：在 custom.css 里加 color: inherit !important，让文字继承父元素颜色，确保可见。\n坑 2：删了 CSS 引用，样式还生效 现象：我在 head.html 里删了 custom.css 的加载代码，结果光标样式还在。\n原因：看了 head.html 源码才发现，主题用 resources.Match \u0026quot;css/extended/*.css\u0026quot; 批量合并了 css/extended 目录下的所有 CSS，custom.css 正好在这个目录里，被自动打包进总样式文件了。\n解决：如果想彻底移除，要么把 custom.css 移到其他目录（比如 css/my-custom），要么在合并逻辑里排除它（用 where \u0026quot;Name\u0026quot; \u0026quot;not in\u0026quot; \u0026quot;css/extended/custom.css\u0026quot;）。\n四、总结：折腾一天的收获 Hugo 读配置全靠层级，quotes 和 profileMode 必须平级，差一层就报错； 改主题模板时，先复制到项目目录再改，避免升级主题时被覆盖； F12 控制台查 JS 错误，Elements 看元素是否存在，Network 看资源是否加载，遇到问题先看这三个地方； CSS 放头部，JS 放页脚，符合网页性能规范，体验更好。 现在打开博客，看着副标题逐字敲出，光标跟着闪烁，再自动切换句子，感觉之前的折腾都值了。如果你也想给 Hugo 博客加这个小动画，跟着上面的步骤来，应该能少踩很多坑～\n","permalink":"https://gopherding.github.io/posts/blog/%E6%8A%98%E8%85%BE%E4%B8%80%E5%A4%A9%E7%BB%88%E4%BA%8E%E7%BB%99%E5%89%AF%E6%A0%87%E9%A2%98%E5%8A%A0%E4%B8%8A%E4%BA%86%E6%89%93%E5%AD%97%E8%BD%AE%E8%AF%A2%E5%8A%A8%E7%94%BB/","summary":"\u003cp\u003e作为一个喜欢折腾博客细节的人，我一直觉得 Hugo PaperMod 主题的首页副标题太 “安静” 了 —— 静态文字放在那里，少了点互动感。于是今天给自己定了个小目标：给副标题加个「打字轮询动画」：文字逐字敲出、带闪烁光标，还能自动切换不同的句子。本以为是 “复制粘贴代码” 的小事，结果踩了好几个坑，好在最后完美实现。这篇就记录下整个过程，希望能帮到同样想折腾的朋友。\u003c/p\u003e","title":"折腾一天：终于给副标题加上了打字轮询动画"},{"content":"\u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e We choose to go to the Moon President Pitzer, Mr. Vice President, Governor, Congressman Thomas, Senator Wiley, and Congressman Miller, Mr. Webb, Mr. Bell, scientists, distinguished guests, and ladies and gentlemen:\nI appreciate your president having made me an honorary visiting professor, and I will assure you that my first lecture will be very brief.\nI am delighted to be here, and I\u0026rsquo;m particularly delighted to be here on this occasion.\nWe meet at a college noted for knowledge, in a city noted for progress, in a State noted for strength, and we stand in need of all three, for we meet in an hour of change and challenge, in a decade of hope and fear, in an age of both knowledge and ignorance. The greater our knowledge increases, the greater our ignorance unfolds.\nDespite the striking fact that most of the scientists that the world has ever known are alive and working today, despite the fact that this Nation¹s own scientific manpower is doubling every 12 years in a rate of growth more than three times that of our population as a whole, despite that, the vast stretches of the unknown and the unanswered and the unfinished still far outstrip our collective comprehension.\nNo man can fully grasp how far and how fast we have come, but condense, if you will, the 50,000 years of man¹s recorded history in a time span of but a half-century. Stated in these terms, we know very little about the first 40 years, except at the end of them advanced man had learned to use the skins of animals to cover them. Then about 10 years ago, under this standard, man emerged from his caves to construct other kinds of shelter. Only five years ago man learned to write and use a cart with wheels. Christianity began less than two years ago. The printing press came this year, and then less than two months ago, during this whole 50-year span of human history, the steam engine provided a new source of power.\nNewton explored the meaning of gravity. Last month electric lights and telephones and automobiles and airplanes became available. Only last week did we develop penicillin and television and nuclear power, and now if America\u0026rsquo;s new spacecraft succeeds in reaching Venus, we will have literally reached the stars before midnight tonight.\nThis is a breathtaking pace, and such a pace cannot help but create new ills as it dispels old, new ignorance, new problems, new dangers. Surely the opening vistas of space promise high costs and hardships, as well as high reward.\nSo it is not surprising that some would have us stay where we are a little longer to rest, to wait. But this city of Houston, this State of Texas, this country of the United States was not built by those who waited and rested and wished to look behind them. This country was conquered by those who moved forward\u0026ndash;and so will space.\nWilliam Bradford, speaking in 1630 of the founding of the Plymouth Bay Colony, said that all great and honorable actions are accompanied with great difficulties, and both must be enterprised and overcome with answerable courage.\nIf this capsule history of our progress teaches us anything, it is that man, in his quest for knowledge and progress, is determined and cannot be deterred. The exploration of space will go ahead, whether we join in it or not, and it is one of the great adventures of all time, and no nation which expects to be the leader of other nations can expect to stay behind in the race for space.\nThose who came before us made certain that this country rode the first waves of the industrial revolutions, the first waves of modern invention, and the first wave of nuclear power, and this generation does not intend to founder in the backwash of the coming age of space. We mean to be a part of it\u0026ndash;we mean to lead it. For the eyes of the world now look into space, to the moon and to the planets beyond, and we have vowed that we shall not see it governed by a hostile flag of conquest, but by a banner of freedom and peace. We have vowed that we shall not see space filled with weapons of mass destruction, but with instruments of knowledge and understanding.\nYet the vows of this Nation can only be fulfilled if we in this Nation are first, and, therefore, we intend to be first. In short, our leadership in science and in industry, our hopes for peace and security, our obligations to ourselves as well as others, all require us to make this effort, to solve these mysteries, to solve them for the good of all men, and to become the world\u0026rsquo;s leading space-faring nation.\nWe set sail on this new sea because there is new knowledge to be gained, and new rights to be won, and they must be won and used for the progress of all people. For space science, like nuclear science and all technology, has no conscience of its own. Whether it will become a force for good or ill depends on man, and only if the United States occupies a position of pre-eminence can we help decide whether this new ocean will be a sea of peace or a new terrifying theater of war. I do not say the we should or will go unprotected against the hostile misuse of space any more than we go unprotected against the hostile use of land or sea, but I do say that space can be explored and mastered without feeding the fires of war, without repeating the mistakes that man has made in extending his writ around this globe of ours.\nThere is no strife, no prejudice, no national conflict in outer space as yet. Its hazards are hostile to us all. Its conquest deserves the best of all mankind, and its opportunity for peaceful cooperation many never come again. But why, some say, the moon? Why choose this as our goal? And they may well ask why climb the highest mountain? Why, 35 years ago, fly the Atlantic? Why does Rice play Texas?\nWe choose to go to the moon. We choose to go to the moon in this decade and do the other things, not because they are easy, but because they are hard, because that goal will serve to organize and measure the best of our energies and skills, because that challenge is one that we are willing to accept, one we are unwilling to postpone, and one which we intend to win, and the others, too.\nIt is for these reasons that I regard the decision last year to shift our efforts in space from low to high gear as among the most important decisions that will be made during my incumbency in the office of the Presidency.\nIn the last 24 hours we have seen facilities now being created for the greatest and most complex exploration in man\u0026rsquo;s history. We have felt the ground shake and the air shattered by the testing of a Saturn C-1 booster rocket, many times as powerful as the Atlas which launched John Glenn, generating power equivalent to 10,000 automobiles with their accelerators on the floor. We have seen the site where the F-1 rocket engines, each one as powerful as all eight engines of the Saturn combined, will be clustered together to make the advanced Saturn missile, assembled in a new building to be built at Cape Canaveral as tall as a 48 story structure, as wide as a city block, and as long as two lengths of this field.\nWithin these last 19 months at least 45 satellites have circled the earth. Some 40 of them were \u0026ldquo;made in the United States of America\u0026rdquo; and they were far more sophisticated and supplied far more knowledge to the people of the world than those of the Soviet Union.\nThe Mariner spacecraft now on its way to Venus is the most intricate instrument in the history of space science. The accuracy of that shot is comparable to firing a missile from Cape Canaveral and dropping it in this stadium between the the 40-yard lines.\nTransit satellites are helping our ships at sea to steer a safer course. Tiros satellites have given us unprecedented warnings of hurricanes and storms, and will do the same for forest fires and icebergs.\nWe have had our failures, but so have others, even if they do not admit them. And they may be less public.\nTo be sure, we are behind, and will be behind for some time in manned flight. But we do not intend to stay behind, and in this decade, we shall make up and move ahead.\nThe growth of our science and education will be enriched by new knowledge of our universe and environment, by new techniques of learning and mapping and observation, by new tools and computers for industry, medicine, the home as well as the school. Technical institutions, such as Rice, will reap the harvest of these gains.\nAnd finally, the space effort itself, while still in its infancy, has already created a great number of new companies, and tens of thousands of new jobs. Space and related industries are generating new demands in investment and skilled personnel, and this city and this State, and this region, will share greatly in this growth. What was once the furthest outpost on the old frontier of the West will be the furthest outpost on the new frontier of science and space. Houston, your City of Houston, with its Manned Spacecraft Center, will become the heart of a large scientific and engineering community. During the next 5 years the National Aeronautics and Space Administration expects to double the number of scientists and engineers in this area, to increase its outlays for salaries and expenses to $60 million a year; to invest some $200 million in plant and laboratory facilities; and to direct or contract for new space efforts over $1 billion from this Center in this City.\nTo be sure, all this costs us all a good deal of money. This year¹s space budget is three times what it was in January 1961, and it is greater than the space budget of the previous eight years combined. That budget now stands at $5,400 million a year\u0026ndash;a staggering sum, though somewhat less than we pay for cigarettes and cigars every year. Space expenditures will soon rise some more, from 40 cents per person per week to more than 50 cents a week for every man, woman and child in the United Stated, for we have given this program a high national priority\u0026ndash;even though I realize that this is in some measure an act of faith and vision, for we do not now know what benefits await us.\nBut if I were to say, my fellow citizens, that we shall send to the moon, 240,000 miles away from the control station in Houston, a giant rocket more than 300 feet tall, the length of this football field, made of new metal alloys, some of which have not yet been invented, capable of standing heat and stresses several times more than have ever been experienced, fitted together with a precision better than the finest watch, carrying all the equipment needed for propulsion, guidance, control, communications, food and survival, on an untried mission, to an unknown celestial body, and then return it safely to earth, re-entering the atmosphere at speeds of over 25,000 miles per hour, causing heat about half that of the temperature of the sun\u0026ndash;almost as hot as it is here today\u0026ndash;and do all this, and do it right, and do it first before this decade is out\u0026ndash;then we must be bold.\nI\u0026rsquo;m the one who is doing all the work, so we just want you to stay cool for a minute. [laughter]\nHowever, I think we\u0026rsquo;re going to do it, and I think that we must pay what needs to be paid. I don\u0026rsquo;t think we ought to waste any money, but I think we ought to do the job. And this will be done in the decade of the sixties. It may be done while some of you are still here at school at this college and university. It will be done during the term of office of some of the people who sit here on this platform. But it will be done. And it will be done before the end of this decade.\nI am delighted that this university is playing a part in putting a man on the moon as part of a great national effort of the United States of America.\nMany years ago the great British explorer George Mallory, who was to die on Mount Everest, was asked why did he want to climb it. He said, \u0026ldquo;Because it is there.\u0026rdquo;\nWell, space is there, and we\u0026rsquo;re going to climb it, and the moon and the planets are there, and new hopes for knowledge and peace are there. And, therefore, as we set sail we ask God\u0026rsquo;s blessing on the most hazardous and dangerous and greatest adventure on which man has ever embarked.\nThank you.\n","permalink":"https://gopherding.github.io/posts/read/we-choose-to-go-to-the-moon/","summary":"\u003c!DOCTYPE HTML\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cstyle type=\"text/css\"\u003e\n        .youtube_shortcodes {\n            position: relative;\n            width: 100%;\n            height: 0;\n            padding-bottom: 66%;\n            margin: auto;\n            overflow: hidden;\n            text-align: center;\n             \n        }\n\n        .youtube_shortcodes iframe {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            left: 0;\n            top: 0;\n        }\n    \u003c/style\u003e\n    \u003ctitle\u003e\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cdiv class=\"youtube_shortcodes\"\u003e\n    \u003ciframe\n            class=\"youtube-player\"\n            type=\"text/html\"\n            width=\"640\"\n            height=\"385\"\n            src=\"https://www.youtube.com/embed/ouRbkBAOGEw?autoplay=0\"\n            style=\"\n                 position: absolute;\n                 top: 0;\n                 left: 0;\n                 width: 100%;\n                 height: 100%;\n                 border:0;\"\n            allowfullscreen frameborder=\"0\"\u003e\n    \u003c/iframe\u003e\n\u003c/div\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\u003chr\u003e\n\u003c!DOCTYPE HTML\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cstyle type=\"text/css\"\u003e\n        .bilibili_shortcodes {\n            position: relative;\n            width: 100%;\n            height: 0;\n            padding-bottom: 66%;\n            margin: auto;\n            overflow: hidden;\n            text-align: center;\n             \n        }\n\n        .bilibili_shortcodes iframe {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            left: 0;\n            top: 0;\n        }\n    \u003c/style\u003e\n    \u003ctitle\u003e\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cdiv class=\"bilibili_shortcodes\"\u003e\n    \u003ciframe\n            src=\"https://player.bilibili.com/player.html?bvid=BV1r4pGepEYA\u0026page=1\u0026high_quality=1\u0026danmaku=0\u0026as_wide=0\"\n            scrolling=\"no\"\n            border=\"0\"\n            frameborder=\"no\"\n            framespacing=\"0\"\n            allowfullscreen=\"true\"\n    \u003e\n    \u003c/iframe\u003e\n    \n    \n    \n\n    \n\n\u003c/div\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\u003ch3 id=\"we-choose-to-go-to-the-moon\"\u003e\u003ca href=\"https://www.rice.edu/jfk-speech\"\u003eWe choose to go to the Moon\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003ePresident Pitzer, Mr. Vice President, Governor, Congressman Thomas, Senator Wiley, and Congressman Miller, Mr. Webb, Mr. Bell, scientists, distinguished guests, and ladies and gentlemen:\u003c/p\u003e\n\u003cp\u003eI appreciate your president having made me an honorary visiting professor, and I will assure you that my first lecture will be very brief.\u003c/p\u003e\n\u003cp\u003eI am delighted to be here, and I\u0026rsquo;m particularly delighted to be here on this occasion.\u003c/p\u003e","title":"We choose to go to the Moon"},{"content":"2022 Baccalaureate Remarks\nWelcome, members of the Class of 2022—and soon-to-be-graduates of Harvard College.\nExactly 1,359 days ago, we met at Convocation, and we began our first year together—you as undergraduates, me as president. I spoke about the merits of academic regalia, and I challenged you to use your waking hours as undergraduates—some 21,000 of them—to explore all that the University had to offer.\nLittle did we know then that we would all confront a global pandemic that would test us in ways that we could not have imagined. I find it fitting that we are gathered here in these billowing robes, a symbol not only of our membership in a community of learning but also of our experience these past four years, our experience of a Harvard—of a world—blown about by winds that never existed before. And all of us carried along with them—and into the unknown.\nIt has been a wilder ride than any of us could have expected. Candidly, when I made the difficult decision to send you all home on such short notice in March of 2020, I never imagined that two years later—and after one million people had succumbed to this virus in the US alone—we would still be dealing with this public health crisis. Your class has been tested as few others have been. You have demonstrated extraordinary resilience and patience, both skills that will serve you well as you prepare for life after Harvard. Based on what I have seen of you and how you have met this moment, I have great faith that you, like those who came before you, will find your way, and will make your mark on the world. Let me take this moment to thank you for your perseverance, for your flexibility and your understanding. I don’t think I have ever been prouder of any graduating class at any university than I am of the Harvard College Class of 2022.\nOne day, there will be enough distance for us to contemplate the enormity of what we have been through as a community, but that day is not today—and that is okay. For now, we can share a quiet moment to say goodbye to whatever we imagined these last 1,359 days might have held for us. For now, we can be grateful that we are here—together—on the verge of your commencement and all that awaits you in the years ahead.\nIt is quite common for students at this precise moment in time—a day before your College graduation—to feel a combination of excitement and anxiety. Excitement for all that awaits you as you begin the next chapter in the journey called life, and anxiety over where that journey is likely to take you. Some of you entered Harvard convinced of exactly where you wanted to go—law school, medical school, a career in public service, for example. Some of you found your passion on this campus and are now going to pursue academic careers or opportunities in journalism, the arts, or entertainment. And some of you are still searching. You may have a job lined up that will pay you well, but, if you are honest with yourself, you are still worried if it is the right path for you or if you will succeed.\nOne of the problems in trying to plan your career is that a career is only knowable in retrospect. On the day you retire you can look back and it all makes sense. You can identify the inflection points, the decisions, that brought you to where you ultimately wound up. But when confronting these decisions in real time, you will struggle. You will make lists of pros and cons. You will consult with friends and family. And you will agonize over these choices long into the night.\nI know what I am talking about because I have been there.\nAs I was completing my PhD here at Harvard, Adele and I thought we were headed to Washington, DC. It was the start of the Carter administration, and we were excited by the prospect of getting in on the ground floor. But then an unexpected opportunity came up:\nWould I like to return to my alma mater, MIT, to fill in for someone going on leave for two years? The salary was a fraction of what I would have made in DC and there was no guarantee of a job two years hence.\nA number of years later, I was still at MIT—now on the tenure track but disheartened because my fabulously talented co-author didn’t get tenure. I had concluded that if he did not get it, I wouldn’t either, and I had just made up my mind to leave MIT and academia altogether when my department chair came calling:\nWould I consider taking on major administrative responsibility to launch a new academic program?\nFlash forward 35 years. I was a member of a presidential search committee, trying to find a leader for a university I care a lot about. I had been comfortably semi-retired—more or less—for almost seven years when the chair of the search committee approached me on behalf of the group:\nWould I consider becoming a candidate for the job?\nIf I had said “no” to any one of those questions, I would not be standing here today. This is not to say that I am prescient or wise, or brave—just that I was open to seeing where roads I hadn’t considered might lead me. That way of moving through the world has taken me to some pretty interesting places—being here, behind this podium, is one of them.\nYou, too, will have chances to consider other paths for yourself, paths that will appear to you unexpectedly—even inconveniently. Be willing to take those chances. Believe in yourself. And don’t be too concerned about failure. My late mother, Ruth, was a very wise woman. Whenever I worried about a decision, she would always say, “What’s the worst that can happen? Can you live with that? If you can, go for it.” I hope you are as liberated by this advice as I have been throughout my life.\nOther discrete moments will influence you so profoundly that denying them would be a tragedy.\nJorie Graham, Boylston Professor of Oratory and Rhetoric, was once an undergraduate at NYU with her heart set on filmmaking. One day, walking past an open door of a poetry class, she heard lines from The Love Song of J. Alfred Prufrock: “I have heard the mermaids singing, each to each. / I do not think they will sing to me.” But sing they did—and, because of that moment, Jorie went on to become one of America’s most distinguished poets, a Pulitzer Prize winner, and one of Harvard’s most beloved faculty members.\nRubén Blades, a musical giant and this year’s Harvard Arts medalist, was once a law student in Panama. One weekend, the dean of the school he attended saw him performing with his band. The dean took him aside and told him that if he wanted to be a lawyer—to reflect the dignity of that profession—he would have to quit singing. Rubén ended up in Miami with a demo album—a wild talent and ambition—and, eventually, seventeen Grammys.\nRay Hammond, a graduate of Harvard College and Harvard Medical School, was a very successful surgeon. Then he heard another voice calling him. Today he is Reverend Ray Hammond, one of Boston’s most influential spiritual leaders.\nI chose these examples because they demonstrate the randomness with which new roads will appear to you. Neither Jorie nor Rubén nor Ray could dream of where a single voice would take them, but they listened nonetheless, paying close attention to the world around them as they imagined how and where they wanted to focus their attention and time.\nNow, I will say something that you may shrug off as nostalgia. But I hope you will remember it: Random events of profound influence don’t happen on a screen. Think of a person stopping in her tracks to listen to lines of unfamiliar poetry. Think of a person recognizing his desire in an unexpected and unwelcome ultimatum. Think of a person tuning into something greater than himself. Think of where and how those things happen—and where and how they can’t or won’t. Engage and embrace the world personally with passion and enthusiasm and, if you are lucky, you too will someday be inspired by the unexpected.\nMembers of the Class of 2022: May you consider fully the paths that reveal themselves to you in the years ahead. May you experience the sweetness of both poetry and song, and marvel at the refrains that emerge as you make your way through life. May you be spared anxiety, dread, and uncertainty—and may you always be surrounded by people who love you.\nBest of luck to each of you—and Godspeed.\nPublished on May 24, 2022\n","permalink":"https://gopherding.github.io/posts/read/2022-baccalaureate-remarks-harvard/","summary":"\u003cp\u003e\u003ca href=\"https://www.harvard.edu/president/speeches-by-president-bacow/2022/2022-baccalaureate-remarks/\"\u003e2022 Baccalaureate Remarks\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eWelcome, members of the Class of 2022—and soon-to-be-graduates of Harvard College.\u003c/p\u003e\n\u003cp\u003eExactly 1,359 days ago, we met at Convocation, and we began our first year together—you as undergraduates, me as president. I spoke about the merits of academic regalia, and I challenged you to use your waking hours as undergraduates—some 21,000 of them—to explore all that the University had to offer.\u003c/p\u003e\n\u003cp\u003eLittle did we know then that we would all confront a global pandemic that would test us in ways that we could not have imagined. I find it fitting that we are gathered here in these billowing robes, a symbol not only of our membership in a community of learning but also of our experience these past four years, our experience of a Harvard—of a world—blown about by winds that never existed before. And all of us carried along with them—and into the unknown.\u003c/p\u003e","title":"2022 Baccalaureate Remarks, Harvard"},{"content":"Commencement Remarks to the Class of 2022\nTo everyone who is assembled here today to celebrate the Class of 2022, welcome!\nCongratulations, moms and dads, spouses and children, family and friends—cheerleaders and champions all.\nAnd a special congratulations to all of you who are joining us online. I met with four seniors last week—all international students—and we talked about travel restrictions that kept some of their families from attending in person today. So, to all of you watching this around the world, a special welcome. In fact, let’s all wave to them.\nThe motto of this University is Veritas. So let me begin by telling you something true.\nThe view from up here is amazing. I can’t believe it has been three years since we have been able to gather like this.\nBeing here—being together again at long last—is moving beyond words. But, to our graduates, you did not get here alone. No one accomplishes anything on their own. Please rise, face your family and friends and all those who have helped you reach this special moment, and give them your thanks.\nExcellent work. Now that you are settled in your seats, I can share another truth with you.\nSomething very inconvenient happens when you combine a nation’s worth of graduations with a global supply chain shortage.\nThere are not enough folding chairs to go around.\nI am not kidding—half of you almost had to sit on blankets today.\nI won’t tell you which half.\nFortunately, the people who make Harvard run—our amazing staff—are creative, resilient, and resourceful. So now you know about the Great Seat Scramble of 2022.\nI am telling you this because it is likely the last time you almost didn’t get a seat. Soon you will have a degree in hand from an institution whose name is known no matter where you go in the world, whose name is synonymous with excellence, ambition, and achievement—and maybe some other modifiers on which we needn’t dwell today.\nWith your degree in hand, you may often find yourself invited to sit and stay awhile, invited to share your thoughts and ideas, invited to participate, to contribute, to lead. You may end up sitting on a board or occupying a seat of power. Who knows? You may even be standing up here someday, welcoming another class of Harvard graduates to their Commencement.\nAnd what are you to make of that—of the fact that people will make room for you, find a seat for you?\nYou could take it for granted. You could assume that you deserved it all along.\nBut what a waste that would be.\nToday, I want to challenge you—members of the Harvard Class of 2022—to save a seat for others, to make room for others, to ensure that the opportunities afforded by your education do not enrich your life alone. You will have more chances than most to make a difference in the world, more opportunities to give others a chance at a better life. Take advantage of these opportunities when they arise. Whatever you do with your Harvard education, please be known at least as much for your humility, kindness, and concern for others as for your professional accomplishments. Recognize the role that good fortune and circumstance have played in your life, and please work to extend opportunity to others just as it has been extended to you.\nThat is how you will sustain the pride and joy you feel today. And that’s the truth.\nCongratulations, members of the Class of 2022. You have accomplished great things; you’re going to accomplish even more. Good luck to each and every one of you—and Godspeed.\nNow, we will hear from three students selected to deliver this year’s orations.\nPublished on May 26, 2022\n","permalink":"https://gopherding.github.io/posts/read/commencement-remarks-to-the-class-of-2022-harvard/","summary":"\u003cp\u003e\u003ca href=\"https://www.harvard.edu/president/speeches-by-president-bacow/2022/commencement-remarks-to-the-class-of-2022/\"\u003eCommencement Remarks to the Class of 2022\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eTo everyone who is assembled here today to celebrate the Class of 2022, welcome!\u003c/p\u003e\n\u003cp\u003eCongratulations, moms and dads, spouses and children, family and friends—cheerleaders and champions all.\u003c/p\u003e\n\u003cp\u003eAnd a special congratulations to all of you who are joining us online. I met with four seniors last week—all international students—and we talked about travel restrictions that kept some of their families from attending in person today. So, to all of you watching this around the world, a special welcome. In fact, let’s all wave to them.\u003c/p\u003e\n\u003cp\u003eThe motto of this University is Veritas. So let me begin by telling you something true.\u003c/p\u003e","title":"Commencement Remarks to the Class of 2022, Harvard"},{"content":"2019学年度东京大学开学典礼 祝辞\n首先恭喜各位同学考入东京大学。你们从激烈的竞争中脱颖而出，才来到了这里。\n女学生所处的现状 我想大家应该都不会质疑这场选拔考试的公平性。倘若缺乏公正的话，你们肯定会非常愤怒吧。 但是，就在去年，东京医科大学被爆出歧视女生和复读学生等“入学不公”丑闻。依据日本文科省对全国81所医科大学、医学部进行的全面调查显示，女生普遍很难考入医科大学。换句话说，相对于女生的医科大学入学合格率，男生的平均合格率要高出1.2倍。此次，被爆出丑闻的东医大高达1.29倍，最高的顺天堂大学为1.67倍。排名靠前的大学还有昭和大学、日本大学、庆应大学等私立学校。而女生入学困难度低于1.0，即相对而言女生更容易考入的大学有鸟取大学、岛根大学、德岛大学、弘前大学等地方国立大学医学部。顺便说一下，东京大学理科3类为1.03，虽然低于1.2的平均值，但仍超出正常值1.0。那么，我们究竟该如何解读这个数字呢？统计非常重要，因为研究都是基于统计才成立的。\n女生比男生更难合格，这是因为男生的考试成绩更优异吗？ 公布了全国医学部调查结果的文科省负责人表示：“当前没有发现其它优先考虑男生的院系，无论是理工科还是文科，大多数情况下还是女生更有优势”。如此说来，除医学部外，其他学部女生的入学难度均低于1，而医学部则高于1。针对这一现状，势必需要讨个说法。\n事实上，各种数据都表明，女性考生的偏差值普遍高于男性考生。首先，为了避免复读，女生通常会做足准备后，再慎重决定报考院校。第二，长期以来，东京大学入学者的女性比例一直无法突破“2成的壁垒”。 今年考入东大的女生仅为18.1%，比前年还要低。由于在统计数据中，偏差值的正态分布没有男女差异，因此可以断定报考东大的女性学生往往比男性学生更优秀。第三，4年制大学的入学率本身就存在性别差异。根据2016年度的学校基本调查，就4年制大学的入学率而言，男生为55.6%，女生为48.2%，有7个百分点的差距。这个差距并非是成绩上的差距，而是由于父母的 “儿子上大学，女儿上短大就可以”的重男轻女观念造成的差距。\n近期，获得诺贝尔和平奖的马拉拉·优素福·扎伊女士在访问日本时，强烈呼吁“女性教育”的必要性。女性教育对巴基斯坦而言至关重要，那么对日本而言就是无关紧要了吗？ “反正是女孩子”“毕竟是女孩子”这种给女孩泼冷水、拖后腿、浇灭女性求学热情的现象叫做aspiration的cooling down，即热情冷却效应。马拉拉的父亲在被问及“是如何养育女儿的”时候，回答道“不能折断女儿的翅膀”。的确，每个孩子都拥有自己的翅膀，可是许多女儿的翅膀都被折断了。\n通过努力奋斗而考上东大的各位男女同学们，等待你们的又是怎样的环境呢？在和其他大学联谊时，东大的男生会很受欢迎。 但我从东大的女生口中听到了这样的话。当被别人问道“你是哪所大学的学生？”时，她会犹豫地回答说：“东京的……一所大学。”因为一听说是东大的学生，对方就会退避三舍。为什么男生可以身为东大学生而无比自豪，女生却不敢轻易向别人吐露自己是东大学生呢？因为男性的价值和优异的成绩是对等的，而女性的价值和优异的成绩之间却不能轻易画等号。女生从小就被期待“可爱”。话说回来，“可爱”究竟是什么样的价值呢？被爱、被选择、被守护，这样的价值中隐藏着一种保证“绝对不能威胁到对方”。因此，女生通常倾向于隐瞒自己成绩优异和自己是东大学生的事实。\n东大曾经发生过一起5名东大工学部和研究生院的男生，集体性侵私立大学女学生的事件。 加害者中的3人被退学，2人遭受停学处分。以该事件为原型，日本作家姬野考可写了一部名为《因为她脑子笨》的小说。2018年，东大还以此为主题在校内举办了研讨会。为什么小说取名叫《因为她脑子笨》呢？据说这是在审讯过程中，一名施暴男生实际说出的话。只要读下这部作品，大家就能迅速明白日本社会是如何看待东大男生的。\n我听说，东大至今仍然存在着一些不允许东大女生实质参与，只允许其他大学的女生参加的男生社团。在半个世纪以前，我的学生时代也曾有过类似的社团。万万没想到，在半个世纪后的今天仍然存在着这样的社团。今年3月，我以东京大学男女共同参画负责理事·副校长的名义，向这些社团发出了“排斥女生违背了《东大宪章》所倡导的平等理念”的警告。\n迄今为止，你们生活的学校是一个表面平等的社会。看似在偏差值竞争上，并没有男女差别。但是，当你们真正进入大学的那一刻起，隐性的性别歧视便开始萌芽。当你们走出校园踏上社会后，性别歧视将会更加肆无忌惮。很遗憾，东京大学也是其中的一例。\n东大内，本科生中女生占比20%左右，而研究生院中，读硕士课程的女生占比25%，读博士课程的女生占比30.7%。然而，在研究职位上，女性助教的比例会下降到18.2%，女性副教授为11.6%，女性教授的比例仅为7.8%。 这个数字比女性国会议员的比例还低。而系主任和研究科长职位中，每15人中仅有1人为女性，历任校长中都没有女性。\n作为女性学的第一人 早在40年前，就已经诞生了研究这一问题的学问——女性学，后来我们称之为性别研究。 在我的学生时代，世界上还不存在什么女性学、性别研究。但正因为没有，才决定创建这门新学问。女性学诞生于大学之外，却最终回归大学校园。 25年前，我到东京大学任职时，是文学部的第三位女教员。于是，我决定将女性学带入课堂。在开始研究女性学之后，我发现世界上尽是未解的谜团。为什么大家一致认为工作是男人的事，家务是女人的事？男人一定是工作，女人是家务？ 家庭主妇是什么，她应该做些什么？在没有卫生巾和卫生棉条的时代，女性会用什么月经用品呢？ 日本历史上是否有过同性恋？ 因为没有人研究过，自然也不会有什么先行研究。因此，无论当时我做了什么，我都能成为那个领域的先驱者和第一人。如今在东京大学，无论是从事家庭主妇研究，少女漫画研究，还是性行为研究，都能获得相应的学位。但是，这样的优越条件是我们前人不断开辟新领域，不断斗争为你们换取来的。而一直激励我不断前进和斗争的正是永不满足的好奇心和对社会不公正的愤怒。\n学问也有风险。既有不断衰败的学问，也有许多新兴学问。女性学也是一门充满风险的学问。不仅是女性学，当今社会还兴起了环境学、情报学、障碍学等各种新学问。这是因为时代的变化需要这些学问。\n包容变化和多样性的东京大学 我想先声明一下，东京大学是一所包容变化和多样性的大学。东大能够录用我，并让我今天能够站在大家面前，这就是最好的证明。次外，东京大学还有国立大学第一位在日韩国人教授姜尚中先生，也有国立大学第一位高中毕业的教授安藤忠雄先生，还有具有盲聋哑三重残疾的教授福岛智先生。\n而你们也成功通过选拔来到这里。据说，国家每年会支付给每个东大学生月500万日元的经费。在接下来的4年间，等待你们的将是绝佳的教育学习环境。针对这一点，常年在这里授课的我可以向大家保证。\n你们应该都是抱着“只要努力就会有回报”的信念来到这里的。 但是，正如我一开始就谈到的“入学不公”现象一样，今后等待着你们的将是“即便努力也不一定会有公平回报”的社会。而且，请你们不要忘记，那些你们自以为“努力换来的回报”，并不单单是你们拼命努力的成果，而是你们身处的环境所赋予你们的。你们今天之所以能觉得“努力就会有回报”，是因为在过去的岁月里，你们周围的环境激励你们、督促你们、支持你们，并且称赞你们所获得的成就。你们是足够幸运的，因为世界上存在着即便努力也无法得到回报的人，存在着即便想努力却无法努力的人，也存在着由于过度努力而身心受挫的人，还存在着努力之前，因被别人嘲讽“就凭你不可能做到”，或陷入自我怀疑“反正我也做不到”，而丧失前进的动力的人。\n请不要只为了一己输赢而努力。请不要将你们所获得的优越环境和能力，用来贬低那些没有你们那么幸运的人，而是用来帮助这群人。最后，请你们不要逞强，勇敢承认自己的弱点，互相支撑着活下去。孕育女性学的正是女权主义这种女性运动，但女权主义绝不是让女性像男性一样行动，也不是让让弱者变身为强者的思想。女权主义追求的是一种身为弱者也能受到应有尊重的思想。\n在东京大学学习的价值 今后，等待你们的将是一个现有学说完全无法适用的不可预测的未知世界。迄今为止，你们一直都在追求有正确答案的知识。今后等待你们的将是一个充满未知、充满没有正确答案的问题的世界。为什么学校里需要多样性呢？因为新的价值在体系和体系之间、在不同文化的摩擦碰撞之间产生的。这不仅局限于校内，东大将为大家提供海外留学和国际交流项目，同时也支持大家参与各类解决国内地域课题的相关活动。 请你们追求未知，勇敢地走向世界。 不必害怕异域文化。只要是有人类存活的地方，你们到哪里都能生存下去。我希望你们能掌握生存下去的智慧，只有这样，今后当你们跳出东大这块金字招牌，走向其它环境时，即便你们变成难民，也能够顺利生存下去。我深信，在大学学习的价值，不再是单纯掌握已有知识，而是掌握一种探索发现未知知识的能力。能够诞生新知识的知识叫做元知识。而让学生掌握元知识才是大学的真正使命。\n欢迎你们来到东京大学。\n平成31年4月12日\nNPO法人Women’s Action Network理事长\n上野 千鹤子\n","permalink":"https://gopherding.github.io/posts/read/2019%E5%AD%A6%E5%B9%B4%E5%BA%A6%E4%B8%9C%E4%BA%AC%E5%A4%A7%E5%AD%A6%E5%BC%80%E5%AD%A6%E5%85%B8%E7%A4%BC%E7%A5%9D%E8%BE%9E/","summary":"\u003cp\u003e\u003ca href=\"https://www.u-tokyo.ac.jp/ja/about/president/b_message31_03.html\"\u003e2019学年度东京大学开学典礼 祝辞\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e首先恭喜各位同学考入东京大学。你们从激烈的竞争中脱颖而出，才来到了这里。\u003c/p\u003e\n\u003ch3 id=\"女学生所处的现状\"\u003e女学生所处的现状\u003c/h3\u003e\n\u003chr\u003e\n\u003cp\u003e我想大家应该都不会质疑这场选拔考试的公平性。倘若缺乏公正的话，你们肯定会非常愤怒吧。 但是，就在去年，东京医科大学被爆出歧视女生和复读学生等“入学不公”丑闻。依据日本文科省对全国81所医科大学、医学部进行的全面调查显示，女生普遍很难考入医科大学。换句话说，相对于女生的医科大学入学合格率，男生的平均合格率要高出1.2倍。此次，被爆出丑闻的东医大高达1.29倍，最高的顺天堂大学为1.67倍。排名靠前的大学还有昭和大学、日本大学、庆应大学等私立学校。而女生入学困难度低于1.0，即相对而言女生更容易考入的大学有鸟取大学、岛根大学、德岛大学、弘前大学等地方国立大学医学部。顺便说一下，东京大学理科3类为1.03，虽然低于1.2的平均值，但仍超出正常值1.0。那么，我们究竟该如何解读这个数字呢？统计非常重要，因为研究都是基于统计才成立的。\u003c/p\u003e","title":"2019学年度东京大学开学典礼 祝辞"},{"content":"雨巷 戴望舒\n撑着油纸伞，独自\n彷徨在悠长、悠长\n又寂寥的雨巷，\n我希望逢着\n一个丁香一样地\n结着愁怨的姑娘。\n她是有\n丁香一样的颜色，\n丁香一样的芬芳，\n丁香一样的忧愁，\n在雨中哀怨，\n哀怨又彷徨；\n她彷徨在这寂寥的雨巷，\n撑着油纸伞\n像我一样，\n像我一样地\n默默彳亍着，\n冷漠，凄清，又惆怅。\n她静默地走近\n走近，又投出\n太息一般的眼光，\n她飘过\n像梦一般地，\n像梦一般地凄婉迷茫。\n像梦中飘过\n一枝丁香地，\n我身旁飘过这女郎；\n她静默地远了，远了，\n到了颓圮的篱墙，\n走尽这雨巷。\n在雨的哀曲里，\n消了她的颜色，\n散了她的芬芳，\n消散了，甚至她的\n太息般的眼光，\n丁香般的惆怅。\n撑着油纸伞，独自\n彷徨在悠长、悠长\n又寂寥的雨巷，\n我希望飘过\n一个丁香一样地\n结着愁怨的姑娘。\n","permalink":"https://gopherding.github.io/posts/read/%E9%9B%A8%E5%B7%B7/","summary":"\u003ch3 id=\"雨巷\"\u003e雨巷\u003c/h3\u003e\n\u003cp\u003e戴望舒\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e撑着油纸伞，独自\u003c/p\u003e\n\u003cp\u003e彷徨在悠长、悠长\u003c/p\u003e\n\u003cp\u003e又寂寥的雨巷，\u003c/p\u003e\n\u003cp\u003e我希望逢着\u003c/p\u003e\n\u003cp\u003e一个丁香一样地\u003c/p\u003e\n\u003cp\u003e结着愁怨的姑娘。\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e她是有\u003c/p\u003e\n\u003cp\u003e丁香一样的颜色，\u003c/p\u003e\n\u003cp\u003e丁香一样的芬芳，\u003c/p\u003e\n\u003cp\u003e丁香一样的忧愁，\u003c/p\u003e\n\u003cp\u003e在雨中哀怨，\u003c/p\u003e\n\u003cp\u003e哀怨又彷徨；\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e她彷徨在这寂寥的雨巷，\u003c/p\u003e\n\u003cp\u003e撑着油纸伞\u003c/p\u003e\n\u003cp\u003e像我一样，\u003c/p\u003e\n\u003cp\u003e像我一样地\u003c/p\u003e\n\u003cp\u003e默默彳亍着，\u003c/p\u003e\n\u003cp\u003e冷漠，凄清，又惆怅。\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e她静默地走近\u003c/p\u003e\n\u003cp\u003e走近，又投出\u003c/p\u003e\n\u003cp\u003e太息一般的眼光，\u003c/p\u003e\n\u003cp\u003e她飘过\u003c/p\u003e\n\u003cp\u003e像梦一般地，\u003c/p\u003e\n\u003cp\u003e像梦一般地凄婉迷茫。\u003c/p\u003e","title":"雨巷"},{"content":"我的塔巴\n我的所囤在市街，\n便利店中挑桶面。\n付账转身归家去，\n叉子忘在货架前。\n吃个锤子：手抓面。\n方知塔巴不爱我，\n否则何故兮使我饿扁。\n我的所忙在窗沿，\n要粘胶带防雨溅。\n翻遍抽屉没找着，\n只剩一段黏成团。\n贴个毛线：不贴了淦。\n方知塔巴不爱我，\n否则何故兮使我难眠。\n我的所急在站边，\n听闻广播“路将淹”。\n吓得哥们抽出伞，\n出站立马往家返。\n急个半天：没下雨。\n方知塔巴不爱我，\n否则何故兮使我心惊胆颤。\n我的所晾在栏边，\n雨渐紧时兮没有晾干。\n刚抓两件棉T恤，\n衣架跌地滚阶前。\n气个半死：白洗了。\n方知塔巴不爱我，\n否则何故兮——天可怜见。\n","permalink":"https://gopherding.github.io/posts/life/%E6%88%91%E7%9A%84%E5%A1%94%E5%B7%B4/","summary":"\u003cp\u003e我的塔巴\u003c/p\u003e\n \u003cbr\u003e\n\u003cp\u003e我的所囤在市街，\u003c/p\u003e\n\u003cp\u003e便利店中挑桶面。\u003c/p\u003e\n\u003cp\u003e付账转身归家去，\u003c/p\u003e\n\u003cp\u003e叉子忘在货架前。\u003c/p\u003e\n\u003cp\u003e吃个锤子：手抓面。\u003c/p\u003e\n\u003cp\u003e方知塔巴不爱我，\u003c/p\u003e\n\u003cp\u003e否则何故兮使我饿扁。\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e我的所忙在窗沿，\u003c/p\u003e\n\u003cp\u003e要粘胶带防雨溅。\u003c/p\u003e\n\u003cp\u003e翻遍抽屉没找着，\u003c/p\u003e\n\u003cp\u003e只剩一段黏成团。\u003c/p\u003e\n\u003cp\u003e贴个毛线：不贴了淦。\u003c/p\u003e\n\u003cp\u003e方知塔巴不爱我，\u003c/p\u003e\n\u003cp\u003e否则何故兮使我难眠。\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e我的所急在站边，\u003c/p\u003e\n\u003cp\u003e听闻广播“路将淹”。\u003c/p\u003e\n\u003cp\u003e吓得哥们抽出伞，\u003c/p\u003e\n\u003cp\u003e出站立马往家返。\u003c/p\u003e\n\u003cp\u003e急个半天：没下雨。\u003c/p\u003e","title":"我的塔巴"},{"content":"The Road Not Taken By Robert Frost\nWhose woods these are I think I know.\nHis house is in the village though;\nHe will not see me stopping here\nTo watch his woods fill up with snow.\nMy little horse must think it queer\nTo stop without a farmhouse near\nBetween the woods and frozen lake\nThe darkest evening of the year.\nHe gives his harness bells a shake\nTo ask if there is some mistake.\nThe only other sound’s the sweep\nOf easy wind and downy flake.\nThe woods are lovely, dark and deep,\nBut I have promises to keep,\nAnd miles to go before I sleep,\nAnd miles to go before I sleep.\n","permalink":"https://gopherding.github.io/posts/read/stopping-by-woods-on-a-snowy-evening/","summary":"\u003ch3 id=\"the-road-not-taken\"\u003eThe Road Not Taken\u003c/h3\u003e\n\u003cp\u003eBy Robert Frost\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eWhose woods these are I think I know.\u003c/p\u003e\n\u003cp\u003eHis house is in the village though;\u003c/p\u003e\n\u003cp\u003eHe will not see me stopping here\u003c/p\u003e\n\u003cp\u003eTo watch his woods fill up with snow.\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eMy little horse must think it queer\u003c/p\u003e\n\u003cp\u003eTo stop without a farmhouse near\u003c/p\u003e\n\u003cp\u003eBetween the woods and frozen lake\u003c/p\u003e\n\u003cp\u003eThe darkest evening of the year.\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eHe gives his harness bells a shake\u003c/p\u003e\n\u003cp\u003eTo ask if there is some mistake.\u003c/p\u003e\n\u003cp\u003eThe only other sound’s the sweep\u003c/p\u003e\n\u003cp\u003eOf easy wind and downy flake.\u003c/p\u003e\n\u003cp\u003eThe woods are lovely, dark and deep,\u003c/p\u003e\n\u003cp\u003eBut I have promises to keep,\u003c/p\u003e\n\u003cp\u003eAnd miles to go before I sleep,\u003c/p\u003e\n\u003cp\u003eAnd miles to go before I sleep.\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/winter.jpg\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"Stopping by Woods on a Snowy Evening"},{"content":"The Road Not Taken By Robert Frost\nTwo roads diverged in a yellow wood,\nAnd sorry I could not travel both\nAnd be one traveler, long I stood\nAnd looked down one as far as I could\nTo where it bent in the undergrowth;\nThen took the other, as just as fair,\nAnd having perhaps the better claim,\nBecause it was grassy and wanted wear;\nThough as for that the passing there\nHad worn them really about the same,\nAnd both that morning equally lay\nIn leaves no step had trodden black.\nOh, I kept the first for another day!\nYet knowing how way leads on to way,\nI doubted if I should ever come back.\nI shall be telling this with a sigh\nSomewhere ages and ages hence:\nTwo roads diverged in a wood, and I—\nI took the one less traveled by,\nAnd that has made all the difference.\n","permalink":"https://gopherding.github.io/posts/read/the-road-not-taken/","summary":"\u003ch3 id=\"the-road-not-taken\"\u003eThe Road Not Taken\u003c/h3\u003e\n\u003cp\u003eBy Robert Frost\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eTwo roads diverged in a yellow wood,\u003c/p\u003e\n\u003cp\u003eAnd sorry I could not travel both\u003c/p\u003e\n\u003cp\u003eAnd be one traveler, long I stood\u003c/p\u003e\n\u003cp\u003eAnd looked down one as far as I could\u003c/p\u003e\n\u003cp\u003eTo where it bent in the undergrowth;\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eThen took the other, as just as fair,\u003c/p\u003e\n\u003cp\u003eAnd having perhaps the better claim,\u003c/p\u003e\n\u003cp\u003eBecause it was grassy and wanted wear;\u003c/p\u003e\n\u003cp\u003eThough as for that the passing there\u003c/p\u003e\n\u003cp\u003eHad worn them really about the same,\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eAnd both that morning equally lay\u003c/p\u003e\n\u003cp\u003eIn leaves no step had trodden black.\u003c/p\u003e\n\u003cp\u003eOh, I kept the first for another day!\u003c/p\u003e\n\u003cp\u003eYet knowing how way leads on to way,\u003c/p\u003e\n\u003cp\u003eI doubted if I should ever come back.\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eI shall be telling this with a sigh\u003c/p\u003e\n\u003cp\u003eSomewhere ages and ages hence:\u003c/p\u003e\n\u003cp\u003eTwo roads diverged in a wood, and I—\u003c/p\u003e\n\u003cp\u003eI took the one less traveled by,\u003c/p\u003e","title":"The Road Not Taken"},{"content":"Sonnet 73 By William Shakespeare\nThat time of year thou mayst in me behold\n妳也许会于我身上看到那样的时节——\nWhen yellow leaves, or none, or few, do hang\n如黄叶，稀疏，落罢，又孤悬\nUpon those boughs which shake against the cold,\n于迎着寒冷而颤抖的枝叶，\nBare ruin\u0026rsquo;d choirs, where late the sweet birds sang.\n鸟儿大抵无言，——唱诗坛只余断壁残垣。\nIn me thou see\u0026rsquo;st the twilight of such day\n妳在我的身上见到了这样的黄昏——\nAs after sunset fadeth in the west,\n如晚阳在西边隐隐退避，\nWhich by and by black night doth take away,\n黑夜转瞬即至将其离分，\nDeath\u0026rsquo;s second self, that seals up all in rest.\n死亡的替身，封藏万物于沉寂。\nIn me thou see\u0026rsquo;st the glowing of such fire\n妳在我的身上可见那火光灼灼——\nThat on the ashes of his youth doth lie,\n燃烧在他青春的余灰上，\nAs the death-bed whereon it must expire,\n如病榻迎接命定的陨落，\nConsum\u0026rsquo;d with that which it was nourish\u0026rsquo;d by.\n被滋养它的火焰燃尽成殇。\nThis thou perceiv\u0026rsquo;st, which makes thy love more strong,\n妳既觉察此事，那末爱会愈发热烈，——\nTo love that well which thou must leave ere long.\n快去珍爱那不久后妳终将失去的一切。\n","permalink":"https://gopherding.github.io/posts/life/sonnet-73-%E8%AF%91/","summary":"\u003ch3 id=\"sonnet-73\"\u003eSonnet 73\u003c/h3\u003e\n\u003cp\u003eBy \u003ca href=\"https://www.poetryfoundation.org/poets/william-shakespeare\"\u003eWilliam Shakespeare\u003c/a\u003e\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eThat time of year thou mayst in me behold\u003c/p\u003e\n\u003cp\u003e妳也许会于我身上看到那样的时节——\u003c/p\u003e\n\u003cp\u003eWhen yellow leaves, or none, or few, do hang\u003c/p\u003e\n\u003cp\u003e如黄叶，稀疏，落罢，又孤悬\u003c/p\u003e\n\u003cp\u003eUpon those boughs which shake against the cold,\u003c/p\u003e\n\u003cp\u003e于迎着寒冷而颤抖的枝叶，\u003c/p\u003e\n\u003cp\u003eBare ruin\u0026rsquo;d choirs, where late the sweet birds sang.\u003c/p\u003e\n\u003cp\u003e鸟儿大抵无言，——唱诗坛只余断壁残垣。\u003c/p\u003e\n\u003cp\u003eIn me thou see\u0026rsquo;st the twilight of such day\u003c/p\u003e\n\u003cp\u003e妳在我的身上见到了这样的黄昏——\u003c/p\u003e\n\u003cp\u003eAs after sunset fadeth in the west,\u003c/p\u003e\n\u003cp\u003e如晚阳在西边隐隐退避，\u003c/p\u003e\n\u003cp\u003eWhich by and by black night doth take away,\u003c/p\u003e","title":"Sonnet 73-译"},{"content":"暴动之下无净土——香港科大教授之亲身经历 洪佳与\n政治是无所谓“恶”与“善”的，而本土主义乃至人性之自私更不能被扣以“恶”之罪名。不过，作为这次香港动乱的亲身经历者，我只想把此次发生在香港科技大学的事件讲述一下，细叙一下在十一月4-14号这十天里我所经历的一切。\n（一）\n自六月九号“反送中”运动大爆发以来，每一个周末，黑衣暴徒都是肆无忌惮地在本岛遍地开花：堵塞道路、锯倒四层楼高的电线杆柱子、砸烂交通信号灯、占领立法院、攻击警署、大肆打砸焚烧港铁站、破坏焚烧中资企业的门面、打砸破坏美心饭店（就因为美心集团的老板之女伍淑清女士批评了他们的暴力）、焚烧践踏中国国旗、玷污中国国徽、大肆纵火、捣毁反暴力区议员的办公室、惨无人道地“私了”不同政见的港人、凶残围殴大陆游客、毫无人性地殴打孕妇、令人发指般的偷割警察的脖颈、破坏铁轨、中学校长公开鼓吹杀死警察全家、再有的就是和香港警察进行的游击战 - 砖头，汽油弹，腐蚀液体，只要不是枪支和匕首，所有的攻击性武器都用上了。\n所有的这些暴行都是以实时真人秀的形式每天24小时在电视上直播，除了港警在疲于奔命，还有林郑港府的一句苍白无力的 “谴责” 外 ，整个香港不见任何知名人士站出来谴责，没有任何主流社会团体或机构发声予以抗争，即使想发声也无处可发，因为几乎所有的媒体都偏倒在了 “示威者” 一方。正如一位美国记者讲的，此次暴乱没有沉默的大多数，有的只是默许的大多数，和一群极度恐惧的少数。而这个 “少数” 指的就是反对暴乱的香港市民和在港人士，尤其是所谓的港漂，那些来自祖国大陆的说普通话的中国人，尽管他们大多持有香港特区护照，是堂堂正正的中华人民共和国香港特区公民。港漂里甚至流传着某个香港废青在连登上的留言，指导他的 “手足” 如何区分大陆普通话和台湾普通话，说他们要打的是NDS （内地生），不是台湾人。\n而就在这一片腥风血雨里，原本世外桃源般的香港科技大学迎来了必将永远被铭刻在它的校史簿上的一周。\n二零一九年十一月四号星期一。\n就在前一天的深夜，就在我的公寓下面（将军澳地铁站附近），又发生了我们已经看得麻木的警民大战。先是“示威者”聚众在一名警察的婚礼上砸场子，还在社交网站上美其名“悼念”。接着就是打砸将军澳地铁站，破坏交通信号灯，还在街头纵火。等到防暴警察来了，所有的人都开始叫喊，辱骂、砖头、汽油弹一齐飞向警察。而就在电光火石之间，有人在紧邻的停车库里发现了一位昏迷不醒的年轻人，后来证实是香港科大的一位周姓同学。\n翌日凌晨，当我早起从电视里看到这则报道后，我就知道，科大这一次是凶多吉少了。本周是科大一年一度的毕业典礼周，校方最初因怕出事，历史上首次宣布取消，可是后来因为许多家长的反对，又决定按时举行，近一周的准备后，讲台和近千把椅子都已在赛马会露天大堂里安置完毕，就等着周四和周五的典礼。我完全理解校方的担心，万一典礼时有人闹事，那可不仅仅会令校方出丑，更令人担心的是无法预料的安全隐患（如纵火之类）。可以想像，校方此刻一定是如坐针毡，祈祷着上帝，就让这一周平安地过去吧。谁知命中注定，偏偏就在这节骨眼上，发生了周姓同学这事。\n几乎是瞬时间，在暴乱的“第二战场”社交媒体上，各种流言开始漫天飞舞，说周是为了躲避催泪弹而摔落的，又说警察有意阻止救护车去救周，更有甚言周是被大陆政府派来的便衣武警暗害的。一如这五个月以来，笼罩于亢奋、迷惑、和仇恨的黑霾之中，此埠的年轻人群情激昂，科大想必是在劫难逃。果然，中午就传来消息，傍晚六点钟在学校的红鸟旁举行校长与学生对话会。毕业典礼在即，校长究于息事宁人，答应科大学生会的要求是唯一的选择。\n当天晚上我碰巧有堂MSc课。这课我已经教了十几年了，班上绝大多数的学生都来自大陆。像往常一样，今天依旧是几乎满员，我还特意留意了一下，仅有的几位本地生都在，而且皆坐在前排。我向学生们问候一声 “Good evening” ，竭尽全力讲了整整三个小时的课。这近五个月以来，每天香港街头毫无休止的打砸烧暴行，让人几近窒息。尤其是对于这批内地新生，两个多月前他们充满着幻想和希望来到科大报到，谁知却仿佛一下子置身到了一个敌对的国度，如今连在大街上说一句自己国家的国语都要小心翼翼，忍辱敌视的眼光以及恶言恶语，甚至暴徒人身攻击的威胁。我一介书生，无能为力，唯一能做的就是予以他们一丝微弱的安慰：只要不停课，至少在我这里，他们一定不会白付学费。\n等到十点钟下课后赶到红鸟处，就见学生里三层外三层围着校长，不少还是蒙面黑衣（据说许多不是科大学生），而记者们至少几十个，香港01的新闻车就停在红鸟旁。最初我很担心校长的安危。\n（就在不久之前，理工大学发生了一件令世人无语的学生羞辱老师的事件：一位香港本地讲师，就因为发声谴责暴力，被他的学生围困在讲台上近半个小时之久，极尽百般语言羞辱，DNLM 粤语港骂满天飞，十几条激光束定格在老师的私处，再伴以毫无羞耻的狂笑。不是一两个人，而是全班几十个男女学生。在任何一个正常的社会，出现这种礼崩乐坏的事件，整个社会一定会义愤填膺，极力谴责。可是香港几十家媒体没有一家公开谴责，整个社会集体噤声。而在几年前，就因为一位大陆两岁的小孩在香港大街上由于找不到厕所而便溺之事，香港的大小媒体却吵得沸沸扬扬，口诛笔伐。）\n不过，这次科大学生的举止比我想象的要好，除了语言粗暴之外，看情形并无意伤害校长。英语夹着粤语，他们要求校长立即公开谴责警方。校长坚持说一切都要基于事实，已经向警方去涵，索求CCTV录像。我个人认为他处理的很好。要知道，置身在几十架镁光灯之下，用词稍有不慎，翌日苹果日报就会头版头条大标“香港科大校长严词谴责警方暴力”。从六点开始，已经过了四个多小时，六十多岁的校长单人面对上百个二十岁的学生，真难为他了。我看不下去，十分钟后就离开了。\n谁知我刚离开，后面就出事了。学生们群情激愤，场面开始有些失控。就在此时，两位来自内地的须教授和Z教授（都是我的朋友）志愿站在了校长的两侧，意在保护他。推推嚷嚷之间，突然听到几声尖叫“非礼”。原来一下子冒出来三个香港女学生，指控须教授非礼她们。须教授立即回斥： “Show me the video proof” 。有这么多手持摄像机的记者在场，哪怕给他们捕捉到一个 “科大来自内地的教授非礼女学生” 的镜头，那可是天赐大礼。可惜没有。眼看 “非礼” 计谋不成，一个所谓学生会的干部开始对着须教授大喊 “返大陆，返大陆” 。\n这港味粤语的“返大陆”三个字 ，近十来年在香港可说是甚嚣尘上 – 上水区手里拎着两罐奶粉的湖南农村老太太，海港城里购买化妆品的江西情侣，东涌大街上等待港珠澳大桥旅游大巴的四川旅游团，中环IFC中庭中奋臂用普通话高呼“我们都是中国人”的年轻经融家，在湾仔搭乘的士的山东大妈，甚至在大陆本土开往香港西九龙高铁上的东北小伙子，都曾经遭受过“返大陆”的唾沫，领教了这唾沫之后所凸显的人类内心深处最原始的阴暗、丑陋、和胆怯。如今，对着一直在兢兢业业给他们上课的老师，这些大学生竟然也如此叫喊，而这一切都被香港01和无线电视实时地呈现在港人的面前。我不知道，如果这些学生的父母此刻也坐在电视机前的话，他们又会是哪般的感受？抑或这“返大陆”三字就是他们饭桌上的常语？\n整整近六个小时，这群学生都在无间断地围剿着一直站立着的校长。而当校长终于被他们放行之后，竟然又有一群人开始肆扰一位内地教授的夫人，就因为她用手机拍了当时的几张照片。又是近半个小时，恶声浪语，一大堆人围攻着孤零零的女士。女士删除了那几张照片，有人大叫“不行，还有Bin，要从Bin里面删除”，嗨呀嗨呀，跟着一片附和声。女士几乎带着哭腔说她不知怎么删除。旁边一个肥胖的中年人（据说是科大保安处的头头，已被科大降职）主动“相救”，硬是一张一张的检查，花了至少五分钟时间（当时电视前的我特意记了时间），最终才释放了女士。曾几何时，堂堂庄严的大学校园，变成了少数学生的私刑法庭。\n怎料此波未平，风云又起。周二校方就发了公告，周三下午五点又将举行校长–学生对话会，地点就在毕业典礼赛马会大会场。我们都知道，这些学生是绝对不会就此罢休的，而校方唯一的对策就是绥靖、接受。\n（二）\n那天我曾教过的一位学生特地从深圳赶了过来。我俩五点到了会场， 见到大约有两三百个本地学生，都身处中后排，而前排则坐着老师们和几十名内地生。我仔细注意了一下，来了大约二十多位老师，除了代表校方做主持的两位香港本地教授外，几乎全是来自内地的教授外加一位ABC。校长来自台湾，争论的是香港的事，可是来给他“撑场子”的却都是来自大陆的同事。不只是光来，大陆同事们显然做了准备，有的内地生手里擎了牌子，上书“请尊敬校长”等。学生们在一侧排队，依次发言。\n此时周同学已经被宣布脑死亡，年轻人感情冲动，我们完全理解。其实如果真的有证据证明周同学是因为警察暴力而摔倒的（后来公开的CCTV录像彻底地否定了这点），科大的教授们肯定会第一时间站出来谴责警方，替本校的学生伸冤。但学生们却一意强迫校长立即公开谴责警方。我想对于香港八所大学的校长们，除了中大的那位如今已是名扬四海的段XX外，绝对没有任何一位会“遵命”的。校长很明确，已经又催促警方公开CCTV录像，只要有证据，一定谴责。学生们开始鼓噪，尤其是那十几个黑衣人；最后在他们的引领下，响起了一片口号声“史维下台，史维下台。” 有内地生举起了“请尊敬校长”的牌子，立即遭到了唏嘘声。就在这时，轮到一位内地生讲话。他用流利的英文呼吁同学们要尊重事实，等到拿到具体确凿证据后再谴责警方。话音刚落，迎接他的是突起的嘘叫声夹杂着“大陆仔，返大陆”的呼喊。我还听到我身后的一位本地生使用了“双肯定”，用普通话大声对着那位内地生说：“大陆仔，说普通话啊，怎么不说普通话啊。” 曾几何时，在中国自己的国土上，十四亿人说的标准国语，竟然变成了被讥讽的对象。\n如此这般推了两个半小时的“磨”，接下来，就发生了如下的一幕。一位23岁的才入学不久的来自内地的研究生郑同学离席，他因为是坐在前排，很清楚地标明了自己的身份。背着书包，不招谁惹谁，还没走几步，一个香港女学生就冲着他尖叫了一声 “支那” 。郑同学走到那女生边，怒视她一眼，转身离开。而就在这时，突然窜出一个瘦骨如柴的黑衣人（后来据说是什么学生会的干事），挡在郑的面前。郑同学根本不屑与他，手插在口袋里，只管走自己的路。黑衣人 “啪” 的就这么摔在地上。顿时，几十把雨伞撑开形成一道屏障，而在屏障里面，这五个月以来针对大陆人或者持异议港人的 “私了” 丑剧又开始上演，拳打脚踢外加雨伞攻击，孤零零的郑同学顿时头破血流。感谢现代泛摄影技术，把这即凶残又丑陋的一幕展现在世人面前。也幸亏有了真实的录像，才让世人看清了那个黑衣小丑碰瓷的拙劣表演，令这班人事后无法再诬陷被打者。\n要加一句的是，郑同学被围殴后，脸上流着鲜血，被其他的内地生护送到学校保安室。可是他们却感到一种明显的冷漠甚至敌意，担心自己的生命安全，坚决要求离开。只是刚出到门外，一大堆凶神恶煞的人又冲了上来，到处围追堵截，最后被逼得躲进了校园内的一间厕所里。据后来别人转给我的一些本地生fb上的留言，虚词别字满满的港式汉语我看不懂，但能猜得大意，就是NDS已经被他们堵在了厕所里，赶紧去那里集合。那天要不是幸亏有位内地来的教授组织了一些内地生去救援，最终帮助郑同学得以逃脱，后果真不知如何。郑同学当夜就逃离到了深圳。再一次，香港这所堂堂高等学府变成了少数香港学生的私刑法庭。\n这一齣恶劣的丑剧瞬即在互联网上流传开来。不同于往常的是，这次是发生在大学校园里，原本应该是最讲理和最安全的地方。可以想象，这一定让在此地求学的上万名内地学生感受到了巨大的心理压力。这五个多月来，电视上滚雪球似的暴徒们凶残“私了”大陆人士和持异议港人的画面，已经把这些来自大陆的年轻学子压抑得喘不过气来，任何事件都可能变成压垮他们的最后一根稻草。\n果然，第二天上午，就在香港中文大学的毕业典礼上，当几十个黑衣黑罩的学生挥舞着黑色的大旗呼叫“时代革命，光复香港”之时，一位孤零零的内地男生突然屹立在了他们的前面，手里握着一把水果刀，直直的怼着他们。瞬时间几十架摄像机齐齐地射向了他，有记者用生硬的普通话发问，你干嘛举刀啊，干嘛举刀啊。镜头前，男孩子流着泪，话里带着哭腔：“我害怕，昨天科大内地生又被你们打了，我感到生命受到了威胁，我要保护自己。” 干嘛举刀啊，不用举刀嘛，嗨呀嗨呀嗨呀，记者们依旧不依不饶。男孩子扔掉了手中的水果刀，立即被几名保安带走了。\n我当时是在Youtube上看到此景的，禁不住自问：一位原本充满着憧憬和希望的阳光男孩，来到这个号称是东方之珠的中国自己的城市，又是什么逼了他竟然要举刀自卫，自毁前程？（据说这次香港法官反应迅速，立即判了男孩子一年徒刑，罪名是在公共场所举刀。）\n而在科大这里，只见美英国旗随风飘扬，洁白的墙上到处是黑色的涂鸦 – “时代革命”，“光复香港”，“血债血还”。满楼的山雨，迎来了下午的工学院毕业典礼。\n（三）\n毕业典礼原定三点举行，却延迟了半个小时。在这期间，几十个黑衣学生在讲台上摇旗呐喊，台下近千名毕业生和家长变成了观众。终于等到他们发放了典礼“许可证”，我们这六、七十位教员却不得不一改往常的正道，而从讲台的侧后面上台，就是因为正道被一群示威者占领了，外加一面高高举起的美国星条旗。\n起立，脱帽，奏中国国歌。奏到一半，大约二十几个人冲上了讲台，全部黑衣蒙面。印象里好像他们还敲打着什么鼓锣，劈里啪啦，叽里呱啦，全场寂静一片，观看着台上的这场闹剧。坐我前排的一位内地教授吼了“表演者”一声，我赶紧悄悄捅他一下，不值得的。我们其实都有思想准备 – 见证了这五个月以来本岛上所发生的光怪陆离，这一撮学生此时的行为不足为奇。毕竟，以他们那幼稚可悲的思维，他们正在侮辱的不是自己的国歌，因为他们根本就没有家国。\n闹剧持续了大约五分钟，等到最后一个黑衣人退场，典礼的主持才又获得了麦克风。照本宣科，主持读了几句话，大意是演奏国歌是一件庄严的事情，所有的人都应该尊敬国旗。我们完全理解，在目前这个政治气候下，这也是校方唯一可以做的了。主持话音刚落，讲台上就响起了激烈的掌声。我注意到坐我前排的一位来自内地的教授拼命地鼓掌，几次眼看掌声渐落，却又给他的掌声带动起来，强烈的掌声持续了近两分钟。闹剧的表演者，听见了吗？\n在接下来近两个小时的典礼中，我注意了一下，但凡是研究生（大多是内地生和国际生），没有人戴黑口罩上台，而本科生则有一些（5%吧）。迥异于理工大学，这次科大工学院院长来者不拒，照样笑容可掬地和戴黑口罩的毕业生握手。我个人认为这是非常明智和恰当的处理。只要你是和理非，你有权利拥有你的诉求。\n不过，戴黑口罩的你，请听着：\n多少年后，当你的心智渐长，终于愿意坐下来学习一下中国五千年的历史；当你终于不愿再做井底之蛙，苟且于这狭窄的小岛，而将眼光投向了你的祖先来自的中原大地；当你开始把那块大地上的十四亿人看作自己的同胞，理解他们曾经的落后，心疼他们的痛楚，更庆幸如今的进步，而不是自困于你那狭隘乃至病态的优越感之中（请问：如果是你自己的两岁的孩子因为在大街上找不到厕所而不得不便溺，你也会把过程录下来放到网上展览吗？）；当你终于明白了“家国”二字；我想，你会后悔这副黑色的口罩的。\n而就在当下这一片黑色的高压之下，讲台上却突然亮起了一道我们想都不敢想的红光！须教授，这位来自哈尔滨的铮铮男子汉，在给他的博士毕业生加授披肩时，从怀里掏出了一面半米见方的中国国旗，和他的学生一起展现在所有人的面前。当时因为他俩是背对着我们，我们并没有看见，只听到在研究生的区域响起了一片热烈的掌声。等到我典礼结束后观看Youtube，才发现了这一镜头。短短10秒钟，这需要多大的勇气！\n果然，就在次日，须教授的办公室就被人砸得一塌糊涂。天晓得，如果碰巧他在办公室里，后果可能就不堪设想了。\n而更大的恐怖已经迫在眉睫。\n（四）\n第二天（周五）上午我还有节本科生的课。来者寥寥无几，也许是因为香港的局势。等到中午下课回到办公室，才得知上午的MSc 毕业典礼中途被取消，因为周同学几个小时前去世了。\n校园里出奇的寂静，我却感到一种明显的恐怖。尽管后来网传的所谓“内地学生大逃亡”听起来有点夸张，但以当时的情景，内地生们确实是开始担心起自己的生命安全。此外，一些激进的本地生在他们自己的群里不断地散布着各种威胁性话语，比如抓到小粉红就打，打死为止，甚至号召组织所谓“私了兵团”，为周同学报仇。而这又更加剧了内地生的恐惧。其实，大家恐惧的只是一小撮黑衣暴徒。但是，看看他们残暴私了大陆人士的镜头，再想想他们当下的心态，在“仇恨”的驱使下，暴徒们也许真的会发疯杀人的。\n下午一点钟，学校应急广播系统开始广播，宣布学校关闭，并安排穿梭班车供学生和员工等出校。这些是对所有学生说的，但实际上就是针对内地生的，因为本地生说粤语，他们不用担心自己的安全。那一刻，校园里出现了一道极度的反差。本地生和他们的家长们依然有点像闲庭信步，在红鸟和校园各处拍照留念。可是内地生和他们的家长们却是行色匆匆，想法设法寻找各种交通工具离开此是非之地。等到学生们大肆的打砸活动开始时（下午两点以后），校园内已经几乎看不到内地生和他们的家长了。\n这过去的五个月里，打砸烧都是出现在香港的大街上，而今天却发生在自己的校园里。中国银行，美心餐厅，星巴克，凡是被这些学生认作和“中”字沾上关系的，都成了他们泄恨的目标，遭到了大肆的破坏。中国银行因为事先有准备，早就关门，铁栅栏下闸，黑衣人器拙无方，就从一旁的水龙头处接了水管拼命地向里面灌水，而两旁的恒生银行和东亚银行却安然无事。曾几何时，一个十四亿人口的国家银行，在自己的特区，竟然变成了区区一撮人仇恨的焦点。\n那天傍晚我离校时，见到原来临时搭起的毕业典礼讲台已经变成了一个巨大的祭台。我在祭台前向周同学致哀。无论如何，一个鲜活的生命，还没开始，就这样消失了，他的父母此刻该是何等的悲伤。此时有关周同学出事时的录像已经全部在网上传开，不仅确凿无疑地排除了警方的任何责任，而且证实了多人当初的猜想 – 周同学是在替“示威者”做“侦察”时不幸失足摔落，一个纯粹的事故。\n我想起了几天前看到了一个录像：就在暴徒们疯狂地肆虐打砸本岛和残忍殴打市民之时，正在中环享受牛扒大餐的香港“民主斗士“李柱铭遭到一位香港市民的痛骂：”你怂恿蛊惑香港的年轻人摧毁这个城市和他们的未来，本人却在此享受美好的晚餐，你还是人吗？你这样做是为了香港的福祉？你为何不把你自己的亲人送上前线？你是香港的千古罪人“。此人面无表情，只是腮边两道深深的沟堑微微一抖，那样子，与我小时候看的连环画里的汉奸一模一样，不多一丝，不少一毫，相由心生，这就是大奸大恶的样子。\n此刻，应该是这个千古罪人跪在此处向周同学谢罪。\n翌日的周末，照例是暴徒们全城的打砸烧和殴打残害市民。不过，自暴乱以来首次，他们将目标扩至到大型商场 – 光天化日之下，暴徒们捣毁了又一城商场中庭的所有的钢化玻璃，并点燃了巨大的圣诞树，火光直指屋顶，危险至极。照例的，人数几等暴徒的“记者“大队又筑成一道美丽的风景线，无视于暴徒们的暴行，却热衷于向外传播他们的英雄壮举。更甚于此，当暴徒们不限于破坏所谓”死物“，而是私刑般的残酷私了活人时，电视新闻里也从来没见过有哪位记者出于良心站出来替被打者说话，只是快感般的摁他们手上照相机的快门。而就在这个周末，在长长的遭暴徒残酷私了的受害者名单上，除了说普通话的大陆人士和所谓蓝丝港人，又增添了一位50多岁的日本人，就因为他的举止像大陆人。\n好不容易挨过了恐怖的周末。可是，一反过去五个月来的“周末群魔乱舞，周一偃旗息鼓”的规则，在这个双“11”周一，当深圳河对岸的国民喜气洋洋地的要争破网购纪录之时，此岛的暴乱却进入了它最疯狂的时刻，也即所谓的“大三罢”。\n我一早六点钟看TVB，就看到本岛各处犹如飓风掠过，到处都是黑衣暴徒，占领了几乎所有的交通要道。大马路上塞满了砖头和各类障碍物，洒满了尖钉，交通灯一片漆黑；高架桥上暴徒们犹如阻击战似的往下扔砸椅子和金属重物；而在桥下面，有货车司机冒死下车搬除路障，却被一群穿着校服的男女中学生暴打私了；大巴都被阻拦，玻璃砸得稀烂；地铁开始燃烧，交通枢纽红磡隧道燃起熊熊大火；浓烟四起，火光冲天。这哪里是什么东方明珠，分明已变成了硝烟弥漫的战场。不仅仅是“死物”，即便是对活人的摧残也又越过了一道红线：\n一位七十岁的清洁工参加市民自发的清除砖头活动，却被暴徒一转头砸在头上，立时命丧黄泉；\n一位五十七岁的铲车工，就因为对正在大肆破坏地铁站的“示威者”表示异议，竟然一边被人辱骂“返大湾区”，一边被残忍地点了“天灯”，全身（尤其是脸部）大面积烧伤，至今生命危殆；\n一名五十三岁的市民，勇敢地站出来，默默无声地清理路障，被一暴徒用半米直径的金属地沟盖凶残地猛击脑门，瞬时昏迷，而一旁的“记者”竟然拍手称快；\n······\n城市正在滑向万劫之渊，人性则早已堕至万恶之壑。\n而在香港科大这边厢，因为地处偏远，闹起来对社会的影响力不及其他大学（如理工大学和中文大学），所以逃过了一劫。可是，分分秒秒看着香港各处天昏地暗的暴乱镜头，再加上网上有人喧嚣要在周同学冥日的“头七“血洗科大的威胁，校园上空恐怖的黑云却变得越来越厚。就在周一，香港的八所大学同时宣布取消本学期的所有课程。终于，那些还留守校园的内地生们做下了”逃离香港“的决定。周一至周三，一连三天，在香港这个中国特区，上演了后来被媒体所描述的”上万内地生大逃亡“一幕。在中文大学，因为所有出校的道路交通都已中断，香港警方专门派了冲锋舟载运内地生撤离校园。而在我们科大，校方安排了大巴，每隔15分钟一趟，运送内地生去西九龙高铁站。\n周三一早去学校时，在大埔仔站见到上来两位女孩子，各自吃力地拎着重重的拉杆箱。她们一看就像是今秋刚入学的内地生，很可能是MSc学生。因为只剩短短的一小站路，司机提醒她俩“这是去科大哦”。果然，她俩一脸愕然，没听懂。我赶紧用普通话问她们，得到的是一声清脆的普通话“是啊，谢谢“。到了科大北门，我问她俩这是去哪儿，怎么把行李往学校搬。这才得知学校已经安排了大巴，她们这是回大陆，是回家。我向她们介绍了自己，告诉她们，不要怕，我们科大的内地教授会帮助她们的。我看到两个女孩子的眼泪都快出来了。当我协助她俩把箱子拎到大巴处时，见到我们机械系的两位内地教授已经在那儿帮忙了。\n到了办公室，我立即在我的博士生微信群里（八名内地生加一名本地生）发了通知，建议他们马上就去深圳避几天，保护好自己，视香港情况再做决定。\n电话铃响了，是国内八十几岁的老父母亲打来的，焦虑的问我的情况。我当即告诉二老，明天就回内地探望他们。\n（五）\n十一月十四号，周四，距周同学出事正好十天。\n在去机场的路上，远远地看到在红磡的上空弥漫着黑色的浓烟，那是理工大学在燃烧，那里现在已经变成了“示威者”和警察鏖战的战场。出租车司机六十多岁，原来是东莞乡下的农民，上世纪八十年代初翻梧桐山偷渡来到香港。整整五十分钟，我们的话题始终围绕着此次香港暴乱。老伯实际上很有文化，说他当年高中毕业差一点就考上了夜大，在香港也画了几年的工程图。他把我当作了中立的新加坡人，所以所言皆直出胸襟，毫无遮拦。就让我用这么一位普通香港市民的话来结束此文吧。孰是孰非？读者自有论断。不，就让历史来结断吧：\n“香港这两代后生仔，完了，垮了，至少85%，完完全全地被洗了脑，没得救了，伍淑清讲得一点不错。”\n“他们生活在他们自己的世界里，想赚钱却又偷懒，肯本就不懂什么叫吃苦，什么叫责任。”\n“那些黑衣人，都是港灿，无聊，冲动，就知道仇恨，贪生怕死还闹什么革命，一群乌合之众。”\n“不止这些后生仔，还有那些后面支持他们的人，你们称他们中产阶级。你们的总理李显龙不是说了嘛，他们就是要造反，夺权，自己做老大。那多爽啊，呸！”\n“他们太自私，只想自己的利益，在大陆做生意，赚大陆人的钱，却对十四亿的大陆人毫无感情，不想承担任何责任，有事没事就怪大陆，好像十四亿大陆人欠了他们什么似的，呸。”\n“我大陆亲戚也有骂大陆政府的，可那是女儿骂妈妈，骂的再凶，也是一家人，我们都在一个锅里。”\n“可是这班仆街，大陆穷时，他们讥笑，现在大陆富了，他们心里就不舒服了。”\n“我在大陆和香港都生活过，知道怎么回事。大陆那么多人，吃饭容易吗？我的广东的亲戚，现在过的多好，比香港好。现在还讲逃港吗？港逃啦。”\n“我的几个亲戚，到上水只是买几罐奶粉，就被人围着骂，要她们返大陆，奶粉也被人踢了。真他妈的自私。你们动不动就跑到深圳去按摩吃饭，享受那里的便宜，有种你别去啊！”\n“我看那些搞港独的泛民，怎么越看越像奴才翻身？”\n“你们几个人，想独立？呸，去问问大陆十四亿人。”\n​\n（2019年12月25日写于香港科技大学）\n","permalink":"https://gopherding.github.io/posts/read/%E6%9A%B4%E5%8A%A8%E4%B9%8B%E4%B8%8B%E6%97%A0%E5%87%80%E5%9C%9F_%E9%A6%99%E6%B8%AF%E7%A7%91%E5%A4%A7%E6%95%99%E6%8E%88%E4%B9%8B%E4%BA%B2%E8%BA%AB%E7%BB%8F%E5%8E%86/","summary":"\u003ch3 id=\"暴动之下无净土香港科大教授之亲身经历\"\u003e\u003ca href=\"https://mektang.people.ust.hk/public_files/%E6%9A%B4%E5%8A%A8%E4%B9%8B%E4%B8%8B%E6%97%A0%E5%87%80%E5%9C%9F.htm\"\u003e暴动之下无净土——香港科大教授之亲身经历\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e洪佳与\u003c/p\u003e\n\u003cp\u003e政治是无所谓“恶”与“善”的，而本土主义乃至人性之自私更不能被扣以“恶”之罪名。不过，作为这次香港动乱的亲身经历者，我只想把此次发生在香港科技大学的事件讲述一下，细叙一下在十一月4-14号这十天里我所经历的一切。\u003c/p\u003e\n\u003cp\u003e（一）\u003c/p\u003e\n\u003cp\u003e自六月九号“反送中”运动大爆发以来，每一个周末，黑衣暴徒都是肆无忌惮地在本岛遍地开花：堵塞道路、锯倒四层楼高的电线杆柱子、砸烂交通信号灯、占领立法院、攻击警署、大肆打砸焚烧港铁站、破坏焚烧中资企业的门面、打砸破坏美心饭店（就因为美心集团的老板之女伍淑清女士批评了他们的暴力）、焚烧践踏中国国旗、玷污中国国徽、大肆纵火、捣毁反暴力区议员的办公室、惨无人道地“私了”不同政见的港人、凶残围殴大陆游客、毫无人性地殴打孕妇、令人发指般的偷割警察的脖颈、破坏铁轨、中学校长公开鼓吹杀死警察全家、再有的就是和香港警察进行的游击战 - 砖头，汽油弹，腐蚀液体，只要不是枪支和匕首，所有的攻击性武器都用上了。\u003c/p\u003e","title":"暴动之下无净土_香港科大教授之亲身经历"},{"content":"Do not go gentle into that good night By Dylan Thomas \u0026amp; George Ding\nDo not go gentle into that good night,\n不要温和地走进那良夜，\nOld age should burn and rave at close of day;\n暮年就该当在日暮时燃烧、狂啸\nRage, rage against the dying of the light.\n愤怒罢，——愤怒着担起光明的消谢！\nThough wise men at their end know dark is right,\n虽智者临了方知黑暗或是正理，\nBecause their words had forked no lightning they\n因他们的话从未有迸过分叉的电光，那末，他们——\nDo not go gentle into that good night.\n便不肯温和地——走进那良夜。\nGood men, the last wave by, crying how bright\n好人，临了如末浪，遂哭喊罢\nTheir frail deeds might have danced in a green bay,\n自家微末的功业亦可在绿湾中舞得如此光亮，\nRage, rage against the dying of the light.\n愤怒罢，——愤怒着担起光明的消谢！\nWild men who caught and sang the sun in flight,\n彼狂徒者，逐日而歌，与光附和，\nAnd learn, too late, they grieved it on its way,\n而醒时已太迟，——他们早为日头西沉伤透了心，\nDo not go gentle into that good night.\n却仍旧不愿温和地跨入那良夜。\nGrave men, near death, who see with blinding sight\n勇者，将亡于昏晓，便怒视罢\nBlind eyes could blaze like meteors and be gay,\n既是失明的双目也能像星陨般燃得欢欣闪耀，\nRage, rage against the dying of the light.\n愤怒罢，——愤怒着担起光明的消谢！\nAnd you, my father, there on the sad height,\n而你，我的父亲，在那戚悲的高坡上，\nCurse, bless, me now with your fierce tears, I pray.\n我求你，——以你滚烫的泪，咒我，赐我！\nDo not go gentle into that good night.\n不要温和地走进那良夜，\nRage, rage against the dying of the light.\n愤怒罢，愤怒罢，——愤怒着担起光明的消谢！\n","permalink":"https://gopherding.github.io/posts/life/do-not-go-gentle-into-that-good-night-%E8%AF%91/","summary":"\u003ch3 id=\"do-not-go-gentle-into-that-good-night\"\u003eDo not go gentle into that good night\u003c/h3\u003e\n\u003cp\u003eBy Dylan Thomas \u0026amp; George Ding\u003c/p\u003e\n\u003cp\u003e\u003cbr\u003eDo not go gentle into that good night,\u003c/p\u003e\n\u003cp\u003e不要温和地走进那良夜，\u003c/p\u003e\n\u003cp\u003eOld age should burn and rave at close of day;\u003c/p\u003e\n\u003cp\u003e暮年就该当在日暮时燃烧、狂啸\u003c/p\u003e\n\u003cp\u003eRage, rage against the dying of the light.\u003c/p\u003e\n\u003cp\u003e愤怒罢，——愤怒着担起光明的消谢！\u003c/p\u003e\n\u003cp\u003eThough wise men at their end know dark is right,\u003c/p\u003e\n\u003cp\u003e虽智者临了方知黑暗或是正理，\u003c/p\u003e\n\u003cp\u003eBecause their words had forked no lightning they\u003c/p\u003e\n\u003cp\u003e因他们的话从未有迸过分叉的电光，那末，他们——\u003c/p\u003e\n\u003cp\u003eDo not go gentle into that good night.\u003c/p\u003e","title":"Do not go gentle into that good night-译"},{"content":"祭黄帝陵文 赫赫始祖，吾华肇造。胄衍祀绵，岳峨河浩。\n聪明睿知，光被遐荒。建此伟业，雄立东方。\n世变沧桑，中更蹉跌。越数千年，强邻蔑德。\n琉台不守，三韩为墟。辽海燕冀，汉奸何多！\n以地事敌，敌欲岂足？人执笞绳，我为奴辱。\n懿维我祖，命世之英。涿鹿奋战，区宇以宁。\n岂其苗裔，不武如斯。泱泱大国，让其沦胥？\n东等不才，剑屦俱奋。万里崎岖，为国效命。\n频年苦斗，备历险夷。匈奴未灭，何以家为？\n各党各界，团结坚固。不论军民，不分贫富。\n民族阵线，救国良方。四万万众，坚决抵抗。\n民主共和，改革内政。亿兆一心，战则必胜。\n还我河山，卫我国权。此物此志，永矢勿谖。\n经武整军，昭告列祖。实鉴临之，皇天后土。\n尚飨！\n","permalink":"https://gopherding.github.io/posts/read/%E7%A5%AD%E7%9A%87%E5%B8%9D%E9%99%B5%E6%96%87/","summary":"\u003ch3 id=\"祭黄帝陵文\"\u003e祭黄帝陵文\u003c/h3\u003e\n\u003cp\u003e赫赫始祖，吾华肇造。胄衍祀绵，岳峨河浩。\u003c/p\u003e\n\u003cp\u003e聪明睿知，光被遐荒。建此伟业，雄立东方。\u003c/p\u003e\n\u003cp\u003e世变沧桑，中更蹉跌。越数千年，强邻蔑德。\u003c/p\u003e\n\u003cp\u003e琉台不守，三韩为墟。辽海燕冀，汉奸何多！\u003c/p\u003e\n\u003cp\u003e以地事敌，敌欲岂足？人执笞绳，我为奴辱。\u003c/p\u003e\n\u003cp\u003e懿维我祖，命世之英。涿鹿奋战，区宇以宁。\u003c/p\u003e\n\u003cp\u003e岂其苗裔，不武如斯。泱泱大国，让其沦胥？\u003c/p\u003e\n\u003cp\u003e东等不才，剑屦俱奋。万里崎岖，为国效命。\u003c/p\u003e","title":"祭黄帝陵文"},{"content":"文化偏至论 ​\t中国既以自尊大昭闻天下，善诋谆者，或谓之顽固; 且将抱守残阙，以底于灭亡。 近世人士，稍稍耳新学之语，则亦引以为愧，翻然思变，言非同西方之理弗道，事非合西方之术弗行，掊击旧物，惟恐不力，曰将以革前缪而图富强也。 间尝论之：昔者帝轩辕氏之戡蚩尤而定居于华土也，典章文物，于以权舆，有苗裔之繁衍于兹，则更改张皇，益臻美大。 其蠢蠢于四方者，胥蕞尔小蛮夷耳，厥种之所创成，无一足为中国法，是故化成发达，咸出于己而无取乎人。 降及周秦，西方有希腊罗马起，艺文思理，灿然可观，顾以道路之艰，波涛之恶，交通梗塞，未能择其善者以为师资。 洎元明时，虽有一二景教父师，以教理暨历算质学于中国，而其道非盛。 故迄于海禁既开，皙人踵至之顷，中国之在天下，见夫四夷之则效上国，革面来宾者有之; 或野心怒发，狡焉思逞者有之; 若其文化昭明，诚足以相上下者，盖未之有也。 屹然出中央而无校雠，则其益自尊大，宝自有而傲睨万物，固人情所宜然，亦非甚背于理极者矣。 虽然，惟无校雠故，则宴安日久，苓落以胎，迫拶不来，上征亦辍，使人苶，使人屯，其极为见善而不思式。 有新国林起于西，以其殊异之方术来向，一施吹拂，块然踣傹，人心始自危，而輇才小慧之徒，于是竞言武事。 后有学于殊域者，近不知中国之情，远复不察欧美之实，以所拾尘芥，罗列人前，谓钩爪锯牙，为国家首事，又引文明之语，用以自文，征印度波兰，作之前鉴。 夫以力角盈绌者，于文野亦何关？ 远之则罗马之于东西戈尔，邇之则中国之于蒙古女真，此程度之离距为何如，决之不待智者。 然其胜负之数，果奈何矣？ 苟曰是惟往古为然，今则机械其先，非以力取，故胜负所判，即文野之由分也。 则曷弗启人智而开发其性灵，使知罟获戈矛，不过以御豺虎，而喋喋誉白人肉攫之心，以为极世界之文明者又何耶？ 且使如其言矣，而举国犹孱，授之巨兵，奚能胜任，仍有僵死而已矣。 嗟夫，夫子盖以习兵事为生，故不根本之图，而仅提所学以干天下; 虽兜牟深隐其面，威武若不可陵，而干禄之色，固灼然现于外矣！ 计其次者，乃复有制造商估立宪国会之说。 前二者素见重于中国青年间，纵不主张，治之者亦将不可缕数。 盖国若一日存，固足以假力图富强之名，博志士之誉; 即有不幸，宗社为墟，而广有金资，大能温饱，即使怙恃既失，或被虐杀如犹太遗黎，然善自退藏，或不至于身受; 纵大祸垂及矣，而幸免者非无人，其人又适为己，则能得温饱又如故也。 若夫后二，可无论已。 中较善者，或诚痛乎外侮迭来，不可终日，自既荒陋，则不得已，姑拾他人之绪余，思鸠大群以抗御，而又飞扬其性，善能攘扰，见异己者兴，必借众以陵寡，托言众治，压制乃尤烈于暴君。 此非独于理至悖也，即缘救国是图，不惜以个人为供献，而考索未用，思虑粗疏，茫未识其所以然，辄皈依于众志，盖无殊痼疾之人，去药石摄卫之道弗讲，而乞灵于不知之力，拜祷稽首于祝由之门者哉。 至尤下而居多数者，乃无过假是空名，遂其私欲，不顾见诸实事，将事权言议，悉归奔走干进之徒，或至愚屯之富人，否亦善垄断之市侩，特以自长营搰，当列其班，况复掩自利之恶名，以福群之令誉，捷径在目，斯不惮竭蹶以求之耳。 嗚呼，古之临民者，一独夫也; 由今之道，且顿变而为千万无赖之尤，民不堪命矣，于兴国究何与焉。 顾若而人者，当其号召张皇，盖蔑弗托近世文明为后盾，有佛戾其说者起，辄谥之曰野人，谓为辱国害群，罪当甚于流放。 第不知彼所谓文明者，将已立准则，慎施去取，指善美而可行诸中国之文明乎，抑成事旧章，咸弃捐不顾，独指西方文化而为言乎？ 物质也，众数也，十九世纪末叶文明之一面或在兹，而论者不以为有当。 盖今所成就，无一不绳前时之遗迹，则文明必日有其迁流，又或抗往代之大潮，则文明亦不能无偏至。 诚若为今立计，所当稽求既往，相度方来，掊物质而张灵明，任个人而排众数。 人既发扬踔厉矣，则邦国亦以兴起。 奚事抱枝拾叶，徒金铁国会立宪之云乎？ 夫势利之念昌狂于中，则是非之辨为之昧，措置张主，辄失其宜，况乎志行污下，将借新文明之名，以大遂其私欲者乎？ 是故今所谓识时之彦，为按其实，则多数常为盲子，宝赤菽以为玄珠，少数乃为巨奸，垂微饵以冀鲸鲵。 即不若是，中心皆中正无瑕玷矣，于是拮据辛苦，展其雄才，渐乃志遂事成，终致彼所谓新文明者，举而纳之中国，而此迁流偏至之物，已陈旧于殊方者，馨香顶礼，吾又何为若是其芒芒哉！ 是何也？ 曰物质也，众数也，其道偏至。 根史实而见于西方者不得已，横取而施之中国则非也。 借曰非乎？ 请循其本——\n​\t夫世纪之元，肇于耶稣出世，历年既百，是为一期，大故若兴，斯即此世纪所有事，盖从历来之旧贯，而假是为区分，无奥义也。 诚以人事连绵，深有本柢，如流水之必自原泉，卉木之茁于根茇，倏忽隐见，理之必无。 故苟为寻绎其条贯本末，大都蝉联而不可离，若所谓某世纪文明之特色何在者，特举荦荦大者而为言耳。 按之史实，乃如罗马统一欧洲以来，始生大洲通有之历史; 已而教皇以其权力，制御全欧，使列国靡然受圈，如同社会，疆域之判，等于一区; 益以梏亡人心，思想之自由几绝，聪明英特之士，虽摘发新理，怀抱新见，而束于教令，胥缄口结舌而不敢言。 虽然，民如大波，受沮益浩，则于是始思脱宗教之系缚，英德二国，不平者多，法皇宫庭，实为怨府，又以居于意也，乃并意太利人而疾之。 林林之民，咸致同情于不平者，凡有能阻泥教旨，抗拒法皇，无间是非，辄与赞和。 时则有路德（M.Luther）者起于德，谓宗教根元，在乎信仰，制度戒法，悉其荣华，力击旧教而仆之。 自所创建，在废弃阶级，黜法皇僧正诸号，而代以牧师，职宣神命，置身社会，弗殊常人; 仪式祷祈，亦简其法。 至精神所注，则在牧师地位，无所胜于平人也。 转轮既始，烈栗遍于欧洲，受其改革者，盖非独宗教而已，且波及于其他人事，如邦国离合，争战原因，后兹大变，多基于是。 加以束缚弛落，思索自由，社会蔑不有新色，则有尔后超形气学上之发见，与形气学上之发明。 以是胚胎，又作新事：发隐地也，善机械也，展学艺而拓贸迁也，非去羁勒而纵人心，不有此也。 顾世事之常，有动无定，宗教之改革已，自必益进而求政治之更张。 溯厥由来，则以往者颠覆法皇，一假君主之权力，变革既毕，其力乃张，以一意孤临万民，在下者不能加之抑制，日夕孳孳，惟开拓封域是务，驱民纳诸水火，绝无所动于心：生计绌，人力耗矣。 而物反于穷，民意遂动，革命于是见于英，继起于美，复次则大起于法朗西，扫荡门第，平一尊卑，政治之权，主以百姓，平等自由之念，社会民主之思，弥漫于人心。 流风至今，则凡社会政治经济上一切权利，义必悉公诸众人，而风俗习惯道德宗教趣味好尚言语暨其他为作，俱欲去上下贤不肖之闲，以大归乎无差别。 同是者是，独是者非，以多数临天下而暴独特者，实十九世纪大潮之一派，且曼衍入今而未有既者也。 更举其他，则物质文明之进步是已。 当旧教盛时，威力绝世，学者有见，大率默然，其有毅然表白于众者，每每获囚戮之祸。 递教力堕地，思想自由，凡百学术之事，勃焉兴起，学理为用，实益遂生，故至十九世纪，而物质文明之盛，直傲睨前此二千余年之业绩。 数其著者，乃有棉铁石炭之属，产生倍旧，应用多方，施之战斗制造交通，无不功越于往日; 为汽为电，咸听指挥，世界之情状顿更，人民之事业益利。 久食其赐，信乃弥坚，渐而奉为圭臬，视若一切存在之本根，且将以之范围精神界所有事，现实生活，胶不可移，惟此是尊，惟此是尚，此又十九世纪大潮之一派，且曼衍入今而未有既者也。 虽然，教权庞大，则覆之假手于帝王，比大权尽集一人，则又颠之以众庶。 理若极于众庶矣，而众庶果足以极是非之端也耶？ 宴安逾法，则矫之以教宗，递教宗淫用其权威，则又掊之以质力。 事若尽于物质矣，而物质果品尽人生之本也耶？ 平意思之，必不然矣。 然而大势如是者，盖如前言，文明无不根旧迹而演来，亦以矫往事而生偏至，缘督校量，其颇灼然，犹孑与躄焉耳。 特其见于欧洲也，为不得已，且亦不可去，去孑与躄，斯失孑与躄之德，而留者为空无。 不安受宝重之者奈何？ 顾横被之不相系之中国而膜拜之，又宁见其有当也？ 明者微睇，察逾众凡，大土哲人，乃蚤识其弊而生愤叹，此十九世纪末叶思潮之所以变矣。 德人尼佉（Fr.Nietzsche）氏，则假察罗图斯德罗（Zarathustra）之言曰，吾行太远，孑然失其侣，返而观夫今之世，文明之邦国矣，斑斓之社会矣。 特其为社会也，无确固之崇信; 众庶之于知识也，无作始之性质。 邦国如是，奚能淹留？ 吾见放于父母之邦矣！ 聊可望者，独苗裔耳。 此其深思遐瞩，见近世文明之伪与偏，又无望于今之人，不得已而念来叶者也。\n​\t然则十九世纪末思想之为变也，其原安在，其实若何，其力之及于将来也又奚若？ 曰言其本质，即以矫十九世纪文明而起者耳。 盖五十年来，人智弥进，渐乃返观前此，得其通弊，察其黮闇，于是浡焉兴作，会为大潮，以反动破坏充其精神，以获新生为其希望，专向旧有之文明，而加之掊击扫荡焉。 全欧人士，为之栗然震惊者有之，芒然自失者有之，其力之烈，盖深入于人之灵府矣。 然其根柢，乃远在十九世纪初叶神思一派; 递夫后叶，受感化于其时现实之精神，已而更立新形，起以抗前时之现实，即所谓神思宗之至新者也。 若夫影响，则眇眇来世，肊测殊难，特知此派之兴，决非突见而靡人心，亦不至突灭而归乌有，据地极固，函义甚深。 以是为二十世纪文化始基，虽云早计，然其为将来新思想之朕兆，亦新生活之先驱，则按诸史实所昭垂，可不俟繁言而解者已。 顾新者虽作，旧亦未僵，方遍满欧洲，冥通其地人民之呼吸，余力流衍，乃扰远东，使中国之人，由旧梦而入于新梦，冲决嚣叫，状犹狂酲。 夫方贱古尊新，而所得既非新，又至偏而至伪，且复横决，浩乎难收，则一国之悲哀亦大矣。 今为此篇，非云已尽西方最近思想之全，亦不为中国将来立则，惟疾其已甚，施之抨弹，犹神思新宗之意焉耳。 故所述止于二事：曰非物质，曰重个人。\n​\t个人一语，入中国未三四年，号称识时之士，多引以为大诟，苟被其谥，与民贼同。 意者未遑深知明察，而迷误为害人利己之义也歟？ 夷考其实，至不然矣。 而十九世纪末之重个人，则吊诡殊恒，尤不能与往者比论。 试案尔时人性，莫不绝异其前，入于自识，趣于我执，刚愎主己，于庸俗无所顾忌。 如诗歌说部之所记述，每以骄蹇不逊者为全局之主人。 此非觚之士，独凭神思构架而然也，社会思潮，先发其朕，则趍之载籍而已矣。 盖自法朗西大革命以来，平等自由，为凡事首，继而普通教育及国民教育，无不基是以遍施。 久浴文化，则渐悟人类之尊严; 既知自我，则顿识个性之价值; 加以往之习惯坠地，崇信荡摇，则其自觉之精神，自一转而之极端之主我。 且社会民主之倾向，势亦大张，凡个人者，即社会之一分子，夷隆实陷，是为指归，使天下人人归于一致，社会之内，荡无高卑。 此其为理想诚美矣，顾于个人殊特之性，视之蔑如，既不加之别分，且欲致之灭绝。 更举黮闇，则流弊所至，将使文化之纯粹者，精神益趋于固陋，颓波日逝，纤屑靡存焉。 盖所谓平社会者，大都夷峻而不湮卑，若信至程度大同，必在前此进步水平以下。 况人群之内，明哲非多，傖俗横行，浩不可御，风潮剥蚀，全体以沦于凡庸。 非超越尘埃，解脱人事，或愚屯罔识，惟众是从者，其能缄口而无言乎？ 物反于极，则先觉善斗之士出矣：德人斯契纳尔（M.Stirner）乃先以极端之个人主义现于世。 谓真之进步，在于己之足下。 人必发挥自性，而脱观念世界之执持。 惟此自性，即造物主。 惟有此我，本属自由; 既本有矣，而更外求也，是曰矛盾。 自由之得以力，而力即在乎个人，亦即资财，亦即权利。 故苟有外力来被，则无间出于寡人，或出于众庶，皆专制也。 国家谓吾当与国民合其意志，亦一专制也。 众意表现为法律，吾即受其束缚，虽曰为我之舆台，顾同是舆台耳。 去之奈何？ 曰：在绝义务。 义务废绝，而法律与偕亡矣。 意盖谓凡一个人，其思想行为，必以己为中枢，亦以己为终极：即立我性为绝对之自由者也。 至勖宾霍尔（A.Schopenhauer），则自既以兀傲刚愎有名，言行奇觚，为世希有;又见夫盲瞽鄙倍之众，充塞两间，乃视之与至劣之动物并等，愈益主我扬己而尊天才也。 至丹麦哲人契开迦尔（S.Kierkegaard）则愤发疾呼，谓惟发挥个性，为至高之道德，而顾瞻他事，胥无益焉。 其后有显理伊勃生（Henrik Ibsen）见于文界，瑰才卓识，以契开迦尔之诠释者称。 其所著书，往往反社会民主之倾向，精力旁注，则无间习惯信仰道德，苟有拘于虚而偏至者，无不加之觝排。 更睹近世人生，每托平等之名，实乃愈趋于恶浊，庸凡凉薄，日益以深，顽愚之道行，伪诈之势逞，而气宇品性，卓尔不群之士，乃反穷于草莽，辱于泥涂，个性之尊严，人类之价值，将咸归于无有，则常为慷慨激昂而不能自已也。 如其《民敌》一书，谓有人宝守真理，不阿世媚俗，而不见容于人群，狡獪之徒，乃巍然独为众愚领袖，借多陵寡，植党自私，于是战斗以兴，而其书亦止：社会之象，宛然具于是焉。 若夫尼夫，斯个人主义之至雄桀者矣，希望所寄，惟在大士天才; 而以愚民为本位，则恶之不殊蛇蝎。 意盖谓治任多数，则社会元气，一旦可隳，不若用庸众为牺牲，以冀一二天才之出世，递天才出而社会之活动亦以萌，即所谓超人之说，尝震惊欧洲之思想界者也。\n​\t由是观之，彼之讴歌众数，奉若神明者，盖仅见光明一端，他未遍知，因加赞颂，使反而观诸黑暗，当立悟其不然矣。 一梭格拉第也，而众希腊人鸩之，一耶稣基督也，而众犹太人磔之，后世论者，孰不云缪，顾其时则从众志耳。 设留今之众志，趍诸载籍，以俟评骘于来哲，则其是非倒置，或正如今人之视往古，未可知也。 故多数相朋，而仁义之途，是非之端，樊然殽乱; 惟常言是解，于奥义也漠然。 常言奥义，孰近正矣？ 是故布鲁多既杀该撒，昭告市人，其词秩然有条，名分大义，炳如观火; 而众之受感，乃不如安多尼指血衣之数言。 于是方群推为爱国之伟人，忽见逐于域外。 夫誉之者众数也，逐之者又众数也，一瞬息中，变易反复，其无特不俟言; 即观现象，已足知不祥之消息矣。 故是非不可公于众，公之则果不诚; 政事不可公于众，公之则治不郅。 惟超人出，世乃太平。 苟不能然，则在英哲。 嗟夫，彼持无政府主义者，其颠覆满盈，铲除阶级，亦已至矣，而建说创业诸雄，大都以导师自命。 夫一导众从，智愚之别即在斯。 与其抑英哲以就凡庸，曷若置众人而希英哲？ 则多数之说，缪不中经，个性之尊，所当张大，盖揆之是非利害，已不待繁言深虑而可知矣。 虽然，此亦赖夫勇猛无畏之人，独立自强，去离尘垢，排舆言而弗沦于俗囿者也。\n​\t若夫非物质主义者，犹个人主义然，亦兴起于抗俗。 盖唯物之倾向，固以现实为权舆，浸润人心，久而不止。 故在十九世纪，爰为大潮，据地极坚，且被来叶，一若生活本根，舍此将莫有在者。 不知纵令物质文明，即现实生活之大本，而崇奉逾度，倾向偏趋，外此诸端，悉弃置而不顾，则按其究竟，必将缘偏颇之恶因，失文明之神旨，先以消耗，终以灭亡，历世精神，不百年而具尽矣。 递夫十九世纪后叶，而其弊果益昭，诸凡事物，无不质化，灵明日以亏蚀，旨趣流于平庸，人惟客观之物质世界是趋，而主观之内面精神，乃舍置不之一省。 重其外，放其内，取其质，遗其神，林林众生，物欲来蔽，社会憔悴，进步以停，于是一切诈伪罪恶，蔑弗乘之而萌，使性灵之光，愈益就于黯淡：十九世纪文明一面之通弊，盖如此矣。 时乃有新神思宗徒出，或崇奉主观，或张皇意力，匡纠流俗，厉如电霆，使天下群伦，为闻声而摇荡。 即具他评骘之士，以至学者文家，虽意主和平，不与世迕，而见此唯物极端，且杀精神生活，则亦悲观愤叹，知主观与意力主义之兴，功有伟于洪水之有方舟者焉。 主观主义者，其趣凡二：一谓惟以主观为准则，用律诸物; 一谓视主观之心灵界，当较客观之物质界为尤尊。 前者为主观倾向之极端，力特着于十九世纪末叶，然其趋势，颇与主我及我执殊途，仅于客观之习惯，无所盲从，或不置重，而以自有之主观世界为至高之标准而已。 以是之故，则思虑动作，咸离外物，独往来于自心之天地，确信在是，满足亦在是，谓之渐自省具内曜之成果可也。 若夫兴起之由，则原于外者，为大势所向，胥在平庸之客观习惯，动不由己，发如机缄，识者不能堪，斯生反动; 其原于内者，乃实以近世人心，日进于自觉，知物质万能之说，且逸个人之情意，使独创之力，归于藁枯，故不得不以自悟者悟人，冀挽狂澜于方倒耳。 如尼佉伊勃生诸人，皆据其所信，力抗时俗，示主观倾向之极致; 而契开迦尔则谓真理准则，独在主观，惟主观性，即为真理，至凡有道德行为，亦可弗问客观之结果若何，而一任主观之善恶为判断焉。 其说出世，和者日多，于是思潮为之更张，骛外者渐转而趣内，渊思冥想之风作，自省抒情之意苏，去现实物质与自然之樊，以就其本有心灵之域; 知精神现象实人类生活之极颠，非发挥其辉光，于人生为无当; 而张大个人之人格，又人生之第一义也。 然尔时所要求之人格，有甚异于前者。 往所理想，在知见情，两皆调整，若主智一派，则在聪明睿智，能移客观之大世界于主观之中者。 如是思惟，迨黑该尔（F.Hegel）出而达其极。 若罗曼暨尚古一派，则息孚支培黎（Shaftesbury）承卢骚（J.Rousseau）之后，尚容情感之要求，特必与情相统一调和，始合其理想之人格。 而希籁（Fr.Schiller）氏者，乃谓必知感两性，圆满无间，然后谓之全人。 顾至十九世纪垂终，则理想为之一变。 明哲之士，反省于内面者深，因以知古人所设具足调协之人，决不能得之今世; 惟有意力轶众，所当希求，能于情意一端，处现实之世，而有勇猛奋斗之才，虽屡踣屡僵，终得现其理想：其为人格，如是焉耳。 故如勖宾霍尔所张主，则以内省诸己，豁然贯通，因曰意力为世界之本体也; 尼佉之所希冀，则意力绝世，几近神明之超人也; 伊勃生之所描写，则以更革为生命，多力善斗，即迕万众不慑之强者也。 夫诸凡理想，大致如斯者，诚以人丁转轮之时，处现实之世，使不若是，每至舍己从人，沉溺逝波，莫知所届，文明真髓，顷刻荡然; 惟有刚毅不挠，虽遇外物而弗为移，始足作社会桢干。 排斥万难，黾勉上征，人类尊严，于此攸赖，则具有绝大意力之士贵耳。 虽然，此又特其一端而已。 试察其他，乃亦以见末叶人民之弱点，盖往之文明流弊，浸灌性灵，众庶率纤弱颓靡，日益以甚，渐乃反观诸己，为之欿然，于是刻意求意力之人，冀倚为将来之柱石。 此正犹洪水横流，自将灭顶，乃神驰彼岸，出全力以呼善没者尔，悲夫！ 由是观之，欧洲十九世纪之文明，其度越前古，凌驾亚东，诚不俟明察而见矣。 然既以改革而胎，反抗为本，则偏于一极，固理势所必然。 洎夫末流，弊乃自显。 于是新宗蹶起，特反其初，复以热烈之情，勇猛之行，起大波而加之涤荡。 直至今日，益复浩然。 其将来之结果若何，盖未可以率测。 然作旧弊之药石，造新生之津梁，流衍方长，曼不遽已，则相其本质，察其精神，有可得而征信者。 意者文化常进于幽深，人心不安于固定，二十世纪之文明，当必沉邃庄严，至与十九世纪之文明异趣。 新生一作，虚伪道消，内部之生活，其将愈深且强欤？ 精神生活之光耀，将愈兴起而发扬欤？ 成然以觉，出客观梦幻之世界，而主观与自觉之生活，将由是而益张歔？ 内部之生活强，则人生之意义亦愈邃，个人尊严之旨趣亦愈明，二十世纪之新精神，殆将立狂风怒浪之间，恃意力以辟生路者也。 中国在今，内密既发，四邻竞集而迫拶，情状自不能无所变迁。 夫安弱守雌，笃于旧习，固无以争存于天下。 第所以匡救之者，缪而失正，则虽日易故常，哭泣叫号之不已，于忧患又何补矣？ 此所为明哲之士，必洞达世界之大势，权衡校量，去其偏颇，得其神明，施之国中，翕合无间。 外之既不后于世界之思潮，内之仍弗失固有之血脉，取今复古，别立新宗，人生意义，致之深邃，则国人之自觉至，个性张，沙聚之邦，由是转为人国。 人国既建，乃始雄厉无前，屹然独见于天下，更何有于肤浅凡庸之事物哉？ 顾今者翻然思变，历岁已多，青年之所思惟，大都归罪恶于古之文物，甚或斥言文为蛮野，鄙思想为简陋，风发浡起，皇皇焉欲进欧西之物而代之，而于适所言十九世纪末之思潮，乃漠然不一措意。 凡所张主，惟质为多，取其质犹可也，更按其实，则又质之至伪而偏，无所可用。 虽不为将来立计，仅图救今日之阽危，而其术其心，违戾亦已甚矣。 况乎凡造言任事者，又复有假改革公名，而阴以遂其私欲者哉？ 今敢问号称志士者曰，将以富有为文明歟，则犹太遗黎，性长居积，欧人之善贾者，莫与比伦，然其民之遭遇何如矣？ 将以路矿为文明欤，则五十年来非澳二洲，莫不兴铁路矿事，顾此二洲土著之文化何如矣？ 将以众治为文明欤，则西班牙波陀牙二国，立宪且久，顾其国之情状又何如矣？ 若曰惟物质为文化之基也，则列机括，陈粮食，遂足以雄长天下歔？ 曰惟多数得是非之正也，则以一人与众禺处，其亦将木居而茅食欤？ 此虽妇竖，必否之矣。 然欧美之强，莫不以是炫天下者，则根柢在人，而此特现象之末，本原深而难见，荣华昭而易识也。 是故将生存两间，角逐列国是务，其首在立人，人立而后凡事举; 若其道术，乃必尊个性而张精神。 假不如是，藁丧且不俟夫一世。 夫中国在昔，本尚物质而疾天才矣，先王之泽，日以殄绝，逮蒙外力，乃退然不可自存。 而輇才小慧之徒，则又号召张皇，重杀之以物质而囿之以多数，个人之性，剥夺无余。 往者为本体自发之偏枯，今则获以交通传来之新疫，二患交伐，而中国之沉沦遂以益速矣。 嗚呼，眷念方来，亦已焉哉！\n一九○七年作。\n","permalink":"https://gopherding.github.io/posts/read/%E6%96%87%E5%8C%96%E5%81%8F%E8%87%B3%E8%AE%BA/","summary":"\u003ch3 id=\"文化偏至论\"\u003e文化偏至论\u003c/h3\u003e\n\u003cp\u003e​\t\t中国既以自尊大昭闻天下，善诋谆者，或谓之顽固; 且将抱守残阙，以底于灭亡。 近世人士，稍稍耳新学之语，则亦引以为愧，翻然思变，言非同西方之理弗道，事非合西方之术弗行，掊击旧物，惟恐不力，曰将以革前缪而图富强也。 间尝论之：昔者帝轩辕氏之戡蚩尤而定居于华土也，典章文物，于以权舆，有苗裔之繁衍于兹，则更改张皇，益臻美大。 其蠢蠢于四方者，胥蕞尔小蛮夷耳，厥种之所创成，无一足为中国法，是故化成发达，咸出于己而无取乎人。 降及周秦，西方有希腊罗马起，艺文思理，灿然可观，顾以道路之艰，波涛之恶，交通梗塞，未能择其善者以为师资。 洎元明时，虽有一二景教父师，以教理暨历算质学于中国，而其道非盛。 故迄于海禁既开，皙人踵至之顷，中国之在天下，见夫四夷之则效上国，革面来宾者有之; 或野心怒发，狡焉思逞者有之; 若其文化昭明，诚足以相上下者，盖未之有也。 屹然出中央而无校雠，则其益自尊大，宝自有而傲睨万物，固人情所宜然，亦非甚背于理极者矣。 虽然，惟无校雠故，则宴安日久，苓落以胎，迫拶不来，上征亦辍，使人苶，使人屯，其极为见善而不思式。 有新国林起于西，以其殊异之方术来向，一施吹拂，块然踣傹，人心始自危，而輇才小慧之徒，于是竞言武事。 后有学于殊域者，近不知中国之情，远复不察欧美之实，以所拾尘芥，罗列人前，谓钩爪锯牙，为国家首事，又引文明之语，用以自文，征印度波兰，作之前鉴。 夫以力角盈绌者，于文野亦何关？ 远之则罗马之于东西戈尔，邇之则中国之于蒙古女真，此程度之离距为何如，决之不待智者。 然其胜负之数，果奈何矣？ 苟曰是惟往古为然，今则机械其先，非以力取，故胜负所判，即文野之由分也。 则曷弗启人智而开发其性灵，使知罟获戈矛，不过以御豺虎，而喋喋誉白人肉攫之心，以为极世界之文明者又何耶？ 且使如其言矣，而举国犹孱，授之巨兵，奚能胜任，仍有僵死而已矣。 嗟夫，夫子盖以习兵事为生，故不根本之图，而仅提所学以干天下; 虽兜牟深隐其面，威武若不可陵，而干禄之色，固灼然现于外矣！ 计其次者，乃复有制造商估立宪国会之说。 前二者素见重于中国青年间，纵不主张，治之者亦将不可缕数。 盖国若一日存，固足以假力图富强之名，博志士之誉; 即有不幸，宗社为墟，而广有金资，大能温饱，即使怙恃既失，或被虐杀如犹太遗黎，然善自退藏，或不至于身受; 纵大祸垂及矣，而幸免者非无人，其人又适为己，则能得温饱又如故也。 若夫后二，可无论已。 中较善者，或诚痛乎外侮迭来，不可终日，自既荒陋，则不得已，姑拾他人之绪余，思鸠大群以抗御，而又飞扬其性，善能攘扰，见异己者兴，必借众以陵寡，托言众治，压制乃尤烈于暴君。 此非独于理至悖也，即缘救国是图，不惜以个人为供献，而考索未用，思虑粗疏，茫未识其所以然，辄皈依于众志，盖无殊痼疾之人，去药石摄卫之道弗讲，而乞灵于不知之力，拜祷稽首于祝由之门者哉。 至尤下而居多数者，乃无过假是空名，遂其私欲，不顾见诸实事，将事权言议，悉归奔走干进之徒，或至愚屯之富人，否亦善垄断之市侩，特以自长营搰，当列其班，况复掩自利之恶名，以福群之令誉，捷径在目，斯不惮竭蹶以求之耳。 嗚呼，古之临民者，一独夫也; 由今之道，且顿变而为千万无赖之尤，民不堪命矣，于兴国究何与焉。 顾若而人者，当其号召张皇，盖蔑弗托近世文明为后盾，有佛戾其说者起，辄谥之曰野人，谓为辱国害群，罪当甚于流放。 第不知彼所谓文明者，将已立准则，慎施去取，指善美而可行诸中国之文明乎，抑成事旧章，咸弃捐不顾，独指西方文化而为言乎？ 物质也，众数也，十九世纪末叶文明之一面或在兹，而论者不以为有当。 盖今所成就，无一不绳前时之遗迹，则文明必日有其迁流，又或抗往代之大潮，则文明亦不能无偏至。 诚若为今立计，所当稽求既往，相度方来，掊物质而张灵明，任个人而排众数。 人既发扬踔厉矣，则邦国亦以兴起。 奚事抱枝拾叶，徒金铁国会立宪之云乎？ 夫势利之念昌狂于中，则是非之辨为之昧，措置张主，辄失其宜，况乎志行污下，将借新文明之名，以大遂其私欲者乎？ 是故今所谓识时之彦，为按其实，则多数常为盲子，宝赤菽以为玄珠，少数乃为巨奸，垂微饵以冀鲸鲵。 即不若是，中心皆中正无瑕玷矣，于是拮据辛苦，展其雄才，渐乃志遂事成，终致彼所谓新文明者，举而纳之中国，而此迁流偏至之物，已陈旧于殊方者，馨香顶礼，吾又何为若是其芒芒哉！ 是何也？ 曰物质也，众数也，其道偏至。 根史实而见于西方者不得已，横取而施之中国则非也。 借曰非乎？ 请循其本——\u003c/p\u003e","title":"文化偏至论"},{"content":"我的所爱在山腰\n想去寻她山太高，\n低头无法泪沾袍。\n爱人赠我百蝶巾；\n回她什么：猫头鹰。\n从此翻脸不理我，\n不知何故兮使我心惊。\n我的所爱在闹市；\n想去寻她人拥挤，\n仰头无法泪沾耳。\n爱人赠我双燕图\n回她什么：冰糖葫芦。\n从此翻脸不理我，\n不知何故兮使我糊涂。\n我的所爱在河滨\n想去寻她河水深，\n歪头无法泪沾襟。\n爱人赠我金表索；\n回她什么：发汗药。\n从此翻脸不理我，\n不知何故兮使我神经衰弱。\n我的所爱在豪家；\n想去寻她兮没有汽车，\n摇头无法泪如麻。\n爱人赠我玫瑰花\n回她什么：赤练蛇。\n从此翻脸不理我。\n不知何故兮——由她去罢。\n近代学者许寿裳《鲁迅的游戏文章》：“这诗挖苦当时那些‘阿唷！我活不了啰，失了主宰了！’之类的失恋诗的盛行，……阅读者多以为信口胡诌，觉得有趣而已，殊不知猫头鹰是他自己所钟爱的，冰糖壶卢是爱吃的，发汗药是常用的，赤练蛇也是爱看的。还是一本正经，没有什么做作。”\n","permalink":"https://gopherding.github.io/posts/read/%E6%88%91%E7%9A%84%E5%A4%B1%E6%81%8B/","summary":"\u003cp\u003e我的所爱在山腰\u003c/p\u003e\n\u003cp\u003e想去寻她山太高，\u003c/p\u003e\n\u003cp\u003e低头无法泪沾袍。\u003c/p\u003e\n\u003cp\u003e爱人赠我百蝶巾；\u003c/p\u003e\n\u003cp\u003e回她什么：猫头鹰。\u003c/p\u003e\n\u003cp\u003e从此翻脸不理我，\u003c/p\u003e\n\u003cp\u003e不知何故兮使我心惊。\u003c/p\u003e\n\u003cp\u003e我的所爱在闹市；\u003c/p\u003e\n\u003cp\u003e想去寻她人拥挤，\u003c/p\u003e\n\u003cp\u003e仰头无法泪沾耳。\u003c/p\u003e\n\u003cp\u003e爱人赠我双燕图\u003c/p\u003e\n\u003cp\u003e回她什么：冰糖葫芦。\u003c/p\u003e\n\u003cp\u003e从此翻脸不理我，\u003c/p\u003e\n\u003cp\u003e不知何故兮使我糊涂。\u003c/p\u003e\n\u003cp\u003e我的所爱在河滨\u003c/p\u003e\n\u003cp\u003e想去寻她河水深，\u003c/p\u003e\n\u003cp\u003e歪头无法泪沾襟。\u003c/p\u003e\n\u003cp\u003e爱人赠我金表索；\u003c/p\u003e\n\u003cp\u003e回她什么：发汗药。\u003c/p\u003e\n\u003cp\u003e从此翻脸不理我，\u003c/p\u003e","title":"我的失恋"},{"content":"Do not go gentle into that good night By Dylan Thomas\nDo not go gentle into that good night,\nOld age should burn and rave at close of day;\nRage, rage against the dying of the light.\nThough wise men at their end know dark is right,\nBecause their words had forked no lightning they\nDo not go gentle into that good night.\nGood men, the last wave by, crying how bright\nTheir frail deeds might have danced in a green bay,\nRage, rage against the dying of the light.\nWild men who caught and sang the sun in flight,\nAnd learn, too late, they grieved it on its way,\nDo not go gentle into that good night.\nGrave men, near death, who see with blinding sight\nBlind eyes could blaze like meteors and be gay,\nRage, rage against the dying of the light.\nAnd you, my father, there on the sad height,\nCurse, bless, me now with your fierce tears, I pray.\nDo not go gentle into that good night.\nRage, rage against the dying of the light.\n","permalink":"https://gopherding.github.io/posts/read/do-not-go-gentle-into-that-good-night/","summary":"\u003ch3 id=\"do-not-go-gentle-into-that-good-night\"\u003eDo not go gentle into that good night\u003c/h3\u003e\n\u003cp\u003eBy Dylan Thomas\u003c/p\u003e\n\u003cp\u003e\u003cbr\u003eDo not go gentle into that good night,\u003c/p\u003e\n\u003cp\u003eOld age should burn and rave at close of day;\u003c/p\u003e\n\u003cp\u003eRage, rage against the dying of the light.\u003c/p\u003e\n\u003cp\u003eThough wise men at their end know dark is right,\u003c/p\u003e\n\u003cp\u003eBecause their words had forked no lightning they\u003c/p\u003e\n\u003cp\u003eDo not go gentle into that good night.\u003c/p\u003e\n\u003cp\u003eGood men, the last wave by, crying how bright\u003c/p\u003e\n\u003cp\u003eTheir frail deeds might have danced in a green bay,\u003c/p\u003e\n\u003cp\u003eRage, rage against the dying of the light.\u003c/p\u003e\n\u003cp\u003eWild men who caught and sang the sun in flight,\u003c/p\u003e\n\u003cp\u003eAnd learn, too late, they grieved it on its way,\u003c/p\u003e\n\u003cp\u003eDo not go gentle into that good night.\u003c/p\u003e\n\u003cp\u003eGrave men, near death, who see with blinding sight\u003c/p\u003e\n\u003cp\u003eBlind eyes could blaze like meteors and be gay,\u003c/p\u003e\n\u003cp\u003eRage, rage against the dying of the light.\u003c/p\u003e","title":"Do not go gentle into that good night"},{"content":"归去来兮辞 魏晋·陶渊明\n余家贫，耕植不足以自给。幼稚盈室，瓶无储粟，生生所资，未见其术。亲故多劝余为长吏，脱然有怀，求之靡途。会有四方之事，诸侯以惠爱为德，家叔以余贫苦，遂见用于小邑。于时风波未静，心惮远役，彭泽去家百里，公田之利，足以为酒。故便求之。及少日，眷然有归欤之情。何则？质性自然，非矫厉所得。饥冻虽切，违己交病。尝从人事，皆口腹自役。于是怅然慷慨，深愧平生之志。犹望一稔，当敛裳宵逝。寻程氏妹丧于武昌，情在骏奔，自免去职。仲秋至冬，在官八十余日。因事顺心，命篇曰《归去来兮》。乙巳岁十一月也。\n归去来兮，田园将芜胡不归？既自以心为形役，奚惆怅而独悲？悟已往之不谏，知来者之可追。实迷途其未远，觉今是而昨非。舟遥遥以轻飏，风飘飘而吹衣。问征夫以前路，恨晨光之熹微。\n乃瞻衡宇，载欣载奔。僮仆欢迎，稚子候门。三径就荒，松菊犹存。携幼入室，有酒盈樽。引壶觞以自酌，眄庭柯以怡颜。倚南窗以寄傲，审容膝之易安。园日涉以成趣，门虽设而常关。策扶老以流憩，时矫首而遐观。云无心以出岫，鸟倦飞而知还。景翳翳以将入，抚孤松而盘桓。\n归去来兮，请息交以绝游。世与我而相违，复驾言兮焉求？悦亲戚之情话，乐琴书以消忧。农人告余以春及，将有事于西畴。或命巾车，或棹孤舟。既窈窕以寻壑，亦崎岖而经丘。木欣欣以向荣，泉涓涓而始流。善万物之得时，感吾生之行休。\n已矣乎！寓形宇内复几时？曷不委心任去留？胡为乎遑遑欲何之？富贵非吾愿，帝乡不可期。怀良辰以孤往，或植杖而耘耔。登东皋以舒啸，临清流而赋诗。聊乘化以归尽，乐夫天命复奚疑！\n","permalink":"https://gopherding.github.io/posts/read/%E5%BD%92%E5%8E%BB%E6%9D%A5%E5%85%AE%E8%BE%9E/","summary":"\u003ch3 id=\"归去来兮辞\"\u003e归去来兮辞\u003c/h3\u003e\n\u003cp\u003e魏晋·陶渊明\u003c/p\u003e\n\u003cp\u003e　　余家贫，耕植不足以自给。幼稚盈室，瓶无储粟，生生所资，未见其术。亲故多劝余为长吏，脱然有怀，求之靡途。会有四方之事，诸侯以惠爱为德，家叔以余贫苦，遂见用于小邑。于时风波未静，心惮远役，彭泽去家百里，公田之利，足以为酒。故便求之。及少日，眷然有归欤之情。何则？质性自然，非矫厉所得。饥冻虽切，违己交病。尝从人事，皆口腹自役。于是怅然慷慨，深愧平生之志。犹望一稔，当敛裳宵逝。寻程氏妹丧于武昌，情在骏奔，自免去职。仲秋至冬，在官八十余日。因事顺心，命篇曰《归去来兮》。乙巳岁十一月也。\u003c/p\u003e","title":"归去来兮辞"},{"content":"Ellen DeGeneres\u0026rsquo; 2009 Tulane University Commencement Speech\nThank you, President Cowan, Mrs. President Cowen; distinguished guests, undistinguished guests - you know who you are, honored faculty and creepy Spanish teacher. And thank you to all the graduating class of 2009, I realize most of you are hung over and have splitting headaches and haven\u0026rsquo;t slept since Fat Tuesday, but you can\u0026rsquo;t graduate \u0026rsquo;til I finish, so listen up.\n感谢考恩校长和夫人，各位尊敬的来宾和各位谦卑的来宾\u0026mdash;-你自己知道就行，各位尊敬的教授和恐怖的西班牙老师；谢谢所有2009届毕业生，我知道你们大多数还有着宿醉后的头痛，从周二的狂欢派对到今天还没有合过眼，但是我没讲完你们就不能毕业，所以听好了。\nWhen I was asked to make the commencement speech, I immediately said yes. Then I went to look up what commencement meant. Which would have been easy if I had a dictionary, but most of the books in our house are Portia\u0026rsquo;s, and they\u0026rsquo;re all written in Australian. So I had to break the word down myself, to find out the meaning.\n当我接到这个毕业典礼演讲邀请的时候，我毫不犹豫就答应了。然后我去查“毕业典礼”是什么意思。如果我有字典就好了，但我家的书大多是Portia的（她澳大利亚的妻子），而且都是澳文。所以。。。我得自己拆词，去揣摩它的意思。\nCommencement: common, and cement. Common cement. You commonly see cement on sidewalks. Sidewalks have cracks, and if you step on a crack, you break your mother\u0026rsquo;s back. So there\u0026rsquo;s that. But I\u0026rsquo;m honored that you\u0026rsquo;ve asked me here to speak at your common cement.\n“COMMEN”常见，“CEMENT”水泥，常见的水泥。你常常在人行道上见到水泥，人行道有裂缝，你要是踩到裂缝，你妈妈的背就要断了。就是这样。但是我很荣幸被邀请来“常见的水泥”做演讲。\nI thought that you had to be a famous alumnus - alumini - aluminum - alumis - you had to graduate from this school. And I didn\u0026rsquo;t go to college here, and I don\u0026rsquo;t know if President Cowan knows, I didn\u0026rsquo;t go to any college at all. Any college. And I\u0026rsquo;m not saying you wasted your time, or money, but look at me, I\u0026quot;m a huge celebrity.\n我以为一定要是名校友（校友这个词很多人拼错），而且是本校毕业的才能来。我没在这里念过大学，而且我不知考恩先生是否知道，我其实完全没有上过大学，完全没有。当然我不是说你们在这里浪费了时间和金钱，不过瞧，我可是个大名人。\nAlthough I did graduate from the school of hard knocks, our mascot was the knockers. I spent a lot of time here growing up. My mom worked at and I would go there every time I needed to steal something out of her purse. But why am I here today? Clearly not to steal, you\u0026rsquo;re too far away and I\u0026rsquo;d never get away with it.\n我是在社会大学毕业的。这所大学的吉祥物就是“门环”。我在这里渡过许多成长的岁月，我妈妈在这里工作时，每次我想偷钱时就会来找她。但是我今天在这里，显然不是为偷钱而来的，你们隔着那么远我可偷不着。\nI\u0026rsquo;m here because of you. Because I can\u0026rsquo;t think of a more tenacious, more courageous graduating class. I mean, look at you all, wearing your robes. Usually when you\u0026rsquo;re wearing a robe at 10 in the morning, it means you\u0026rsquo;ve given up.\n我来这里是因为你们。因为没有比你们更优秀、更勇敢的毕业生了。看看你们，身穿袍子（学士袍），通常我们说早上十点还穿着袍子（睡袍）代表你要放弃人生了。\nI\u0026rsquo;m here because I love New Orleans. I was born and raised here, I spent my formative years here, and like you, while I was living here I only did laundry six times. When I finished school, I was completely lost. And by school, I mean middle school, but I went ahead and finished high school anyway.\n我今天来到这里，是因为我热爱新奥尔良。我在这里出生、成长，度过少年时光，正如你们一样。我住在这里的时候，只洗过6次衣服。当我从学校毕业的时候，我完完全全地迷失了自己。学校我指的是初中，后来我好歹继续念完了高中。\nAnd I - I really, I had no ambition, I didn\u0026rsquo;t know what I wanted to do. I did everything from - I shucked oysters, I was a hostess, I was a bartender, I was a waitress, I painted houses, I sold vacuum cleaners, I had no idea. And I thought I\u0026rsquo;d just finally settle in some job, and I would make enough money to pay my rent, maybe have basic cable, maybe not, I didn\u0026rsquo;t really have a plan, my point is that, by the time I was your age, I really thought I knew who I was, but I had no idea.\n我当时真的没有什么雄心壮志，不知道自己想做什么。我什么工作都做，挖生蚝，当带位员，做酒保，当服务生，粉刷房子，卖吸尘器，完全不知道自己想做什么，我只想随便找个能糊口的工作，过一辈子，能有钱付得起我的房租就行。也许还有钱付有线电视，也许付不起，谈不上有什么计划。\nLike for example, when I was your age, I was dating men. So what I\u0026rsquo;m saying is, when you\u0026rsquo;re older, most of you will be gay. Anyone writing this stuff down? Parents?\n我想说的是，当我象你们这么大的时候，我真的以为我了解自己，但其实我并不了解。举例说，我象你们这么大的时候，还在和男人约会。所以我的意思是，等你们再长大些后，大多数人都会是同性恋。有记下来吗？家长有没有记下来？\nAnyway, I had no idea what I wanted to do with my life, and the way I ended up on this path was from a very tragic event. I was maybe 19, and my girlfriend at the time was killed in a car accident. And I passed the accident, and I didn\u0026rsquo;t know it was her and I kept going, and I found out shortly after that, it was her.\n总之我当时不知道我的人生要做什么，而最后因为一件悲剧使我找到了人生目标。我当时可能才19岁，我女朋友因为车祸死了，我途经事故现场却不知道是她，还在继续往前走，不久后我才知道那是她。\nAnd I was living in a basement apartment, I had no money, I had no heat, no air, I had a mattress on the floor and the apartment was infested with fleas. And I was soul-searching, I was like, why is she suddenly gone, and there are fleas here? I don\u0026rsquo;t understand, there must be a purpose, and wouldn\u0026rsquo;t it be so convenient if we could pick up the phone and call God, and ask these questions.\n那时候我住在公寓的一间地下室，没有钱，没暖气，没空调，我打地铺睡觉，房子里到处都是跳蚤，我困惑不已，心想她怎么突然就走了，而我为何又住在这么一个到处是跳骚的房子里，我不明白，但其中一定有什么理由，要是能直接拿起电话打给上帝问个清楚就好了。\nAnd I started writing and what poured out of me was an imaginary conversation with God, which was one-sided, and I finished writing it and I looked at it and I said to myself, and I hadn\u0026rsquo;t even been doing stand-up, ever, there was no club in town. I said, \u0026ldquo;I\u0026rsquo;m gonna do this on the Tonight Show With Johnny Carson\u0026rdquo;- at the time he was the king - \u0026ldquo;and I\u0026rsquo;m gonna be the first woman in the history of the show to be called over to sit down.\u0026rdquo;\n我开始写作，心里涌出一段我和上帝的对话，虽然只是我一个人的独白，写完了之后我阅读了这个剧本，对自己说，我还没有做过脱口秀，那里没有夜总会，我对自己说要在“今夜秀”上与强尼卡森一起表演这一段，强尼卡森是当时天王级人物，我对自己说我要成为该节目史上第一个被邀请的女性，\nAnd several years later, I was the first woman in the history of the show, and only woman in the history of the show to sit down, because of that phone conversation with God that I wrote. And I started this path of stand-up and it was successful and it was great, but it was hard, because I was trying to please everybody and I had this secret that I was keeping, that I was gay. And I thought if people found out they wouldn\u0026rsquo;t like me, they wouldn\u0026rsquo;t laugh at me.\n数年之后，我成为这个节目史上第一位也是唯一一位被邀请参与的女性，就因为那段我写的与上帝对话的己剧本，从此我开始做单人脱口秀，做得很成功，也很辛苦，因为我想讨好每一个人，同时又不让知道我是同性恋的秘密，我想要是别人发现了，就不会喜欢我了，就不会笑我了。\nThen my career turned into - I got my own sitcom, and that was very successful, another level of success. And I thought, what if they find out I\u0026rsquo;m gay, then they\u0026rsquo;ll never watch, and this was a long time ago, this was when we just had white presidents - this was back, many years ago - and I finally decided that I was living with so much shame, and so much fear, that I just couldn\u0026rsquo;t live that way anymore, and I decided to come out and make it creative.\n后来我又有了自己的情景喜剧，也很成功，更进一步的成功，我于是更担心被别人知道是同性恋后怎么办，而且当时是很久很久以前，那是只有白人当总统的年代，好久好久以前。最终我还是决定，与其一直带着耻辱和恐惧生活，不如对这种生活就此做个了结，于是我决定用创意的方式，让剧中的主角和我自己同时“出柜”，\nAnd my character would come out at the same time, and it wasn\u0026rsquo;t to make a political statement, it wasn\u0026rsquo;t to do anything other than to free myself up from this heaviness that I was carrying around, and I just wanted to be honest. And I thought, \u0026ldquo;What\u0026rsquo;s the worst that could happen? I can lose my career\u0026rdquo;. I did. I lost my career. The show was cancelled after six years, without even telling me, I read it in the paper. The phone didn\u0026rsquo;t ring for three years. I had no offers.\n不是为了什么政治原因和其它，只是为了让我自己从背负已久的学生枷锁中释放出来，我只是想做真我，我想，“最坏的结果是什么？我可能会失去我的演艺事业”。结果我失业了。我失去了我的事业，我的节目在做了6年后停播了，竟然没有人通知我，我在报纸上才看到这一消息，家里的电话三年都没有响起过，没人找我做节目。\nNobody wanted to touch me at all. Yet, I was getting letters from kids that almost committed suicide, but didn\u0026rsquo;t, because of what I did. And I realised that I had a purpose. And it wasn\u0026rsquo;t just about me and it wasn\u0026rsquo;t about celebrity, but I felt like I was being punished\u0026hellip; it was a bad time, I was angry, I was sad, and then I was offered a talkshow. And the people that offered me the talkshow tried to sell it. And most stations didn\u0026rsquo;t want to pick it up. Most people didn\u0026rsquo;t want to buy it because they thought nobody would watch me.\n没有人愿意启用我。然后我却一直收到想要自杀的同性恋孩子给我的来信，他们因为我的出现而没有自杀，我这才感到，我在这个世上是有意义的，不是因为我，也不是因为名声，但我觉得自己好像是受了惩罚一样，那是一段痛苦的日子，我很愤世嫉俗，很难过。后来有人找我做脱口秀，找我做节目的制作公司努力推销我的节目，然而大多数电视台都不愿意买，他们都不愿意买，因为他们以为没有人会想看我的节目。\nReally when I look back on it, I wouldn\u0026rsquo;t change a thing. I mean, it was so important for me to lose everything because I found out what the most important thing is, is to be true to yourself. Ultimately, that\u0026rsquo;s what\u0026rsquo;s gotten me to this place. I don\u0026rsquo;t live in fear, I\u0026rsquo;m free, I have no secrets. and I know I\u0026rsquo;ll always be ok, because no matter what, I know who I am.\n每当我回想起这段往事时，我觉得一切都应该这样，真的，对我而言，失去一切太重要了，因为我发现最重要的是要做真我。最终，是我的选择才有了今天的我。生活中没有恐惧和秘密，而且我知道自己是没问题的，因为无论怎样，我都清楚知道自己是谁。\nSo In conclusion, when I was younger I thought success was something different. I thought when I grow up, I want to be famous. I want to be a star. I want to be in movies. When I grow up I want to see the world, drive nice cars, I want to have groupies. To quote the Pussycat Dolls. How many people thought it was \u0026ldquo;boobies\u0026rdquo;, by the way? It\u0026rsquo;s not, it\u0026rsquo;s \u0026ldquo;groupies\u0026rdquo;.\n所以总的来说，我对成功的看法不同，我想等我长大以后，我要出名。我要当明星，我要拍电影，长大后要环游世界，开名车，有一群影迷跟着，就象“小野猫”里说的那样。顺便问一句，有多少人听成是“咪咪”？听错了，应该是影迷。\nBut my idea of success is different today. And as you grow, you\u0026rsquo;ll realize the definition of success changes. For many of you, today, success is being able to hold down 20 shots of tequila. For me, the most important thing in your life is to live your life with integrity, and not to give into peer pressure. To try to be something that you\u0026rsquo;re not. To live your life as an honest and compassionate person. To contribute in some way. So to conclude my conclusion: follow your passion, stay true to yourself. Never follow anyone else\u0026rsquo;s path, unless you\u0026rsquo;re in the woods and you\u0026rsquo;re lost and you see a path, and by all means you should follow that. Don\u0026rsquo;t give advice, it will come back and bite you in the ass. Don\u0026rsquo;t take anyone\u0026rsquo;s advice. So my advice to you is to be true to yourself and everything will be fine.\n但今天我对成功的看法不一样了。当你长大，你会发现成功的定义在改变。对你们中的很多人来说，今天的成功是能灌下20杯龙舌兰酒。对我来说，生命中最重要的事是：是真实地去生活！不要因为别人的压力去逼自己做不是真正的自己，做一个真实的、有爱心的人，在某些方面有所贡献的人。所以总结一下我的总结，追随自己的热情，绝对不要追随别人的脚步，除非你在森林里迷路时看到了路，那你一定要跟上。别给别人忠告，吃力不讨好；也别只是听从别人的忠告。所以我忠告大家：做真实的自己，一切会好的。\nAnd I know that a lot of you are concerned about your future, but there\u0026rsquo;s no need to worry. The economy is booming, the job market is wide open, the planet is just fine. It\u0026rsquo;s gonna be great. You\u0026rsquo;ve already survived a hurricane. What else can happen to you? And as I mentioned before, some of the most devastating things that happen to you will teach you the most. And now you know the right questions to ask in your first job interview. Like, \u0026ldquo;Is it above sea level?\u0026rdquo; .\n我知道在座的很多人都在担心自己的前途，其实不用担心，经济正“发展迅速”，就业机会“一大把”，地球也“好得很”，一切都会很棒，你们都经历过飓风了，还有什么可怕的？就象我以前说的那样，最惨痛的经历教育意义也最大。比如现在你第一次面试，就知道该问考官什么问题了，例如“咱公司的位置高于海平面吗？”\nSo to conclude my conclusion that I\u0026rsquo;ve previously concluded, in the common cement speech, I guess what I\u0026rsquo;m trying to say is life is like one big Mardi Gras. But instead of showing your boobs, show people your brain, and if they like what they see, you\u0026rsquo;ll have more beads than you know what to do with. And you\u0026rsquo;ll be drunk, most of the time. So the Katrina class of 2009, I say congratulations and if you don\u0026rsquo;t remember a thing I said today, remember this: you\u0026rsquo;re gonna be ok, dum de dum dum dum, just dance.\n因此，总结一下我刚才总结过的总结，配合这个“常见的水泥”演讲，我想我要说的是，人生犹如一场狂欢派对，不过要向人们展示你的头脑，而不是你的胸部，如果人们欣赏你，你就不必担心没活干了，然后你就可以安枕无忧。2009年的毕业生们，恭喜大家，那怕我今天说的你全都会忘记，请记住这句：你没问题的。哒哒哒，让我们跳舞吧。\n","permalink":"https://gopherding.github.io/posts/read/ellen-degeneres-2009-tulane-university-commencement-speech/","summary":"\u003cp\u003eEllen DeGeneres\u0026rsquo; 2009 Tulane University Commencement Speech\u003c/p\u003e\n\u003cp\u003eThank you, President Cowan, Mrs. President Cowen; distinguished guests, undistinguished guests - you know who you are, honored faculty and creepy Spanish teacher. And thank you to all the graduating class of 2009, I realize most of you are hung over and have splitting headaches and haven\u0026rsquo;t slept since Fat Tuesday, but you can\u0026rsquo;t graduate \u0026rsquo;til I finish, so listen up.\u003c/p\u003e\n\u003cp\u003e感谢考恩校长和夫人，各位尊敬的来宾和各位谦卑的来宾\u0026mdash;-你自己知道就行，各位尊敬的教授和恐怖的西班牙老师；谢谢所有2009届毕业生，我知道你们大多数还有着宿醉后的头痛，从周二的狂欢派对到今天还没有合过眼，但是我没讲完你们就不能毕业，所以听好了。\u003c/p\u003e","title":"Ellen DeGeneres' 2009 Tulane University Commencement Speech"},{"content":"发现很久以前便听过单曲，近期才发现是音乐剧，顺便提一嘴，总是把Evita看成德国军歌Erika哈哈哈:-)\nDon\u0026rsquo;t Cry For Me Argentina\nIt won‘t be easy.You‘ll think it strange\n我细诉心底话，大家都会惊讶\nWhen I try to explain how I feel.That I still need your love.\n我过去曾经犯错，却盼你们仍爱我\nAfter all that I‘ve done.You won‘t believe me\n你们未必会相信我！\nAll you will see is a girl. You once knew\n在你们眼中，是当年的旧相识\nAlthough she‘s dressed up to the nines.At sixes and sevens with you\n尽管锦衣绣袍，生活却混乱不堪，情非得已，只好如此\nI had to let it happen,I had to change.Couldn‘t stay all my life down at heel\n我想改变一下，不想永远屈居人下！\nLooking out of the window.Staying out of the sun\n我怎肯坐在窗边，渴望明媚的阳光又无能为力？！\nSo I chose freedom.Running around\n于是我争取自由，大声疾呼\nTrying everything new,but nothing impressed me at all,I never expected it to\n一切无足轻重，并非意料中事。\nDon‘t cry for me Argentina\n阿根廷，别为我哭泣\nThe truth is I never left you. All through my wild days\n说句心底话，我从未离开大家\nMy mad existence,I kept my promise.Don‘t keep your distance\n即使当年任性堕落，我仍遵守承诺，请勿拒我于千里之外！\nAnd as for fortune, and as for fame.\n名与利，\nI never invited them in.Though it seemed to the world\n我从不希冀，世人以为我热衷名与利，\nThey were all I desired.They are illusions.They are not the solutions\n名利如梦幻泡影，难把问题解决\nThey promised to be, the answer was here all the time\n解决之道，早在这里为你铺好\nI love you and hope you love me\n我爱你们，亦希望得到回报\nDon‘t cry for me Argentina\n阿根廷，别为我哭泣\nDon‘t cry for me Argentina\n阿根廷，别为我哭泣\nThe truth is I never left you.All through my wild days\n说句心底话，我从未离开大家\nMy mad existence.I kept my promise.Don‘t keep your distance\n即使当年任性堕落，我仍遵守承诺，请勿拒我于千里之外！\nHave I said too much?There‘s nothing more.I can think of to say to you\n我是否喋喋不休？我已欲语无言，\nBut all you have to do is.Look at me to know\n你们只要凝望我一下，\nThat every word is true\n就知我句句都是真心话！\n","permalink":"https://gopherding.github.io/posts/read/dont-cry-for-me-argentina_evita/","summary":"\u003cp\u003e发现很久以前便听过单曲，近期才发现是音乐剧，顺便提一嘴，总是把Evita看成德国军歌Erika哈哈哈:-)\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eDon\u0026rsquo;t Cry For Me Argentina\u003c/p\u003e\n\u003cp\u003eIt won‘t be easy.You‘ll think it strange\u003c/p\u003e\n\u003cp\u003e我细诉心底话，大家都会惊讶\u003c/p\u003e\n\u003cp\u003eWhen I try to explain how I feel.That I still need your love.\u003c/p\u003e\n\u003cp\u003e我过去曾经犯错，却盼你们仍爱我\u003c/p\u003e\n\u003cp\u003eAfter all that I‘ve done.You won‘t believe me\u003c/p\u003e\n\u003cp\u003e你们未必会相信我！\u003c/p\u003e","title":"Don't Cry For Me Argentina_Evita"},{"content":"Jobs每天早上都会问镜子里的自己：If today were the last day of my life, would I wanna do what I am about to do today?” 这句话像一根细针，刺破了我们对时间会冲淡一切伤痛的幻想。他抗癌时更明白，当生命被按下倒计时，所有外界的喧嚣都会退去，只剩下最赤裸的追问：“我真正想把时间花在哪里？”\n类似地，Gandalf的那句“All we have to decide is what to do with the time that is given us”——时间从不是被动流逝的沙，而是等着我们亲手描摹的画布。Kennedy选择把人类的时间投向月球，\u0026ldquo;Not because they are easy, but because they are hard\u0026rdquo;，这和乔布斯退学后\u0026quot;decided to take a calligraphy class to learn how to do this\u0026quot;，其实是同一种勇气——拒绝让时间耗在安全的平庸里，偏要为热爱留一块地盘——换言之，主动走出自己的舒适区——\u0026ldquo;And do the next right thing\u0026rdquo;。\nMia在试镜室里反复打磨台词，Seb在空荡的酒吧里弹奏未完成的旋律，他/她们没算过这样值不值，只知道若是不这么做会留下遗憾；Anna在黑暗里唱:\u0026ldquo;Take a step, step again. It is all that I can to do\u0026rdquo;，哪怕看不清前路，也\u0026quot;Stumbling blindly toward the light\u0026quot;；这些画面都在呼应乔布斯的清醒:\u0026ldquo;And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become.\u0026rdquo;\nKennedy推动登月计划时，无数人\u0026quot;do not now know what benefits await us\u0026quot;，可他看见的是\u0026quot;Well, space is there, and we\u0026rsquo;re going to climb it, and the moon and the planets are there, and new hopes for knowledge and peace are there\u0026quot;；Mia抱着原创剧本一次次被拒，却不肯改成市场喜欢的样子，\u0026ldquo;Here’s to the ones who dream. Foolish as they may seem. Here’s to the hearts that ache. Here’s to the mass we make.\u0026rdquo;\n就像书法课的知识成就了Mac的字体，登月的勇气点亮了人类的星空，Mia的剧本终会找到懂它的舞台，Anna的每一步都在靠近——热爱的珍贵，珍贵的热爱，从不在当下有用，\u0026ldquo;You can only connect them looking backwards, so you have to trust that the dots will somehow connect in your future.\u0026rdquo;\n《La La Land》结尾，Mia成了著名演员，Seb开了梦想中的爵士吧——他/她们并没能走到最后，却在Seb`s重逢时相视一笑——那些因热爱燃烧的时光，早已刻进彼此的生命，纵使别离也始终能在某个特定的时刻量子纠缠在一起；Anna在山洞中一步步前行，失去了Elsa，失去了Olaf，却从没失去\u0026quot;to do the next right thing\u0026quot;的勇气，她的行动里藏着和Jobs一样的韧性：热爱会带来失去，会带来懊悔，会带来疼痛，但只要内核还在，想必过去回忆的点点星光会映照未来的路，摔碎的碎片也并非不能拼出新的形状罢。\nJobs的演讲之所以动人，是因为他没讲大道理，只说了自己的故事：退学的迷茫，被解雇的疼痛，抗癌的恐惧，还有那些“傻傻坚持”的热爱。而Kennedy、Gandalf、Mia和Anna的故事，不过是让这些感受变得更具体——想必无论在硅谷、在月球、在Middle-earth，还是在L.A的街头与Arendelle的雪地里，人们都在做同一件事：在有限的时间里，带着热爱与勇气，认真活过每一刻。\nJust Do It !\nAND\nFollow Your Heart !\n\u0026ldquo;You have to trust in something: your gut, destiny, life, karma, whatever. Because believing that the dots will connect down the road will give you the confidence to follow your heart, even when it leads you off the well-worn path. And that will make all the difference.\u0026rdquo;\n","permalink":"https://gopherding.github.io/posts/life/just-do-it/","summary":"\u003cp\u003eJobs每天早上都会问镜子里的自己：If today were the last day of my life, would I wanna do what I am about to do today?” 这句话像一根细针，刺破了我们对时间会冲淡一切伤痛的幻想。他抗癌时更明白，当生命被按下倒计时，所有外界的喧嚣都会退去，只剩下最赤裸的追问：“我真正想把时间花在哪里？”\u003c/p\u003e\n\u003cp\u003e类似地，Gandalf的那句“All we have to decide is what to do with the time that is given us”——时间从不是被动流逝的沙，而是等着我们亲手描摹的画布。Kennedy选择把人类的时间投向月球，\u0026ldquo;Not because they are easy, but because they are hard\u0026rdquo;，这和乔布斯退学后\u0026quot;decided to take a calligraphy class to learn how to do this\u0026quot;，其实是同一种勇气——拒绝让时间耗在安全的平庸里，偏要为热爱留一块地盘——换言之，主动走出自己的舒适区——\u0026ldquo;And do the next right thing\u0026rdquo;。\u003c/p\u003e","title":"Just Do It"},{"content":"À la volonté du peuple dont on n\u0026rsquo;étouffe jamais la voix 遵從人民的意志，永遠扼止不了他們的聲音\nEt dont le chant renaît toujours et dont le chant renaît déjà 人民的歌聲總是因此一再重生，而且已經重生\nNous voulons que la lumière déchire le masque de la nuit 我們要用光撕裂夜的面具\nPour illuminer notre terre et changer la vie 點亮我們的土地，改變我們的生命\nIl viendra le jour glorieux où dans sa marche vers l\u0026rsquo;idéal 邁向理想實現的光榮的日子即將來到\nL\u0026rsquo;homme ira vers le progrès du mal au bien du faux au vrai 人類將會走向進步，從壞變好，從錯到對\nUn rêve peut mourir mais on n\u0026rsquo;enterre jamais l\u0026rsquo;avenir 夢想或許會死去，但我們絕不要葬送未來\nJoignez-vous à la croisade de ceux qui croient au genre humain 仍然相信人性的您/你們，請加入我們的行列\nPour une seule barricade qui tombe cent autres se lèveront demain 因為一個革命的街壘倒下，明天又會豎起一百個\nÀ la volonté du peuple un tambour chante dans le lointain 遠方的鼓聲高唱，遵從人民的意志\nIl vient annoncer le grand jour et c\u0026rsquo;est pour demain 宣告偉大的日子即將來到\nJoignez-vous à la croisade de ceux qui croient au genre humain 仍然相信人類的您/你們，請加入我們的行列\nPour une seule barricade qui tombe cent autres se lèveront demain 因為一個革命的街壘倒下，明天又會豎起一百個\nÀ la volonté du peuple un tambour chante dans le lointain 遠方的鼓聲高唱，遵從人民的意志\nIl vient annoncer le grand jour et c\u0026rsquo;est pour demain 宣告偉大的日子即將來到\nC\u0026rsquo;est pour demain! 即將來到！\nDo you hear the people sing?\nSinging a song of angry men?\nIt is the music of a people\nWho will not be slaves again\nWhen the beating of your heart\nEchoes the beating of the drums\nThere is a life about to start\nWhen tomorrow comes\nWill you join in our crusade?\nWho will be strong and stand with me?\nBeyond the barricade\nIs there a world you long to see?\nThen join in the fight\nThat will give you the right to be free\nDo you hear the people sing?\nSinging a song of angry men?\nIt is the music of a people\nWho will not be slaves again\nWhen the beating of your heart\nEchoes the beating of the drums\nThere is a life about to start\nWhen tomorrow comes\nWill you give all you can give\nSo that our banner may advance\nSome will fall and some will live\nWill you stand up and take your chance?\nThe blood of the martyrs\nWill water the meadows of France\nDo you hear the people sing?\nSinging a song of angry men?\nIt is the music of a people\nWho will not be slaves again\nWhen the beating of your heart\nEchoes the beating of the drums\nThere is a life about to start\nWhen tomorrow comes\n","permalink":"https://gopherding.github.io/posts/read/do-you-hear-the-people-sing_les-mis%C3%A9rables/","summary":"\u003cp\u003eÀ la volonté du peuple dont on n\u0026rsquo;étouffe jamais la voix 遵從人民的意志，永遠扼止不了他們的聲音\u003c/p\u003e\n\u003cp\u003eEt dont le chant renaît toujours et dont le chant renaît déjà 人民的歌聲總是因此一再重生，而且已經重生\u003c/p\u003e\n\u003cp\u003eNous voulons que la lumière déchire le masque de la nuit 我們要用光撕裂夜的面具\u003c/p\u003e\n\u003cp\u003ePour illuminer notre terre et changer la vie 點亮我們的土地，改變我們的生命\u003c/p\u003e","title":"Do You Hear the People Sing_Les Misérables"},{"content":"There\u0026rsquo;s a grief that can\u0026rsquo;t be spoken\nThere\u0026rsquo;s a pain goes on and on\nEmpty chairs at empty tables\nNow my friends are dead and gone\nHere they talked of revolution\nHere it was they lit the flame\nHere they sang about tomorrow\nAnd tomorrow never came\nFrom the table in the corner\nThey could see a world reborn\nAnd they rose with voices ringing\nAnd I can hear them now!\nThe very words that they had sung\nBecame their last communion\nOn this lonely barricade\nAt dawn\nOh my friends, my friends forgive me\nThat I live and you are gone\nThere\u0026rsquo;s a grief that can\u0026rsquo;t be spoken\nThere\u0026rsquo;s a pain goes on and on\nPhantom faces at the window\nPhantom shadows on the floor\nEmpty chairs at empty tables\nWhere my friends will meet no more\nOh my friends, my friends\nDon\u0026rsquo;t ask me what your sacrifice was for\nEmpty chairs at empty tables\nWhere my friends will sing no more\n","permalink":"https://gopherding.github.io/posts/read/empty-chairs-at-empty-tables_les-mis%C3%A9rables/","summary":"\u003cp\u003eThere\u0026rsquo;s a grief that can\u0026rsquo;t be spoken\u003c/p\u003e\n\u003cp\u003eThere\u0026rsquo;s a pain goes on and on\u003c/p\u003e\n\u003cp\u003eEmpty chairs at empty tables\u003c/p\u003e\n\u003cp\u003eNow my friends are dead and gone\u003c/p\u003e\n\u003cp\u003eHere they talked of revolution\u003c/p\u003e\n\u003cp\u003eHere it was they lit the flame\u003c/p\u003e\n\u003cp\u003eHere they sang about tomorrow\u003c/p\u003e\n\u003cp\u003eAnd tomorrow never came\u003c/p\u003e\n\u003cp\u003eFrom the table in the corner\u003c/p\u003e\n\u003cp\u003eThey could see a world reborn\u003c/p\u003e\n\u003cp\u003eAnd they rose with voices ringing\u003c/p\u003e\n\u003cp\u003eAnd I can hear them now!\u003c/p\u003e\n\u003cp\u003eThe very words that they had sung\u003c/p\u003e\n\u003cp\u003eBecame their last communion\u003c/p\u003e\n\u003cp\u003eOn this lonely barricade\u003c/p\u003e\n\u003cp\u003eAt dawn\u003c/p\u003e\n\u003cp\u003eOh my friends, my friends forgive me\u003c/p\u003e\n\u003cp\u003eThat I live and you are gone\u003c/p\u003e\n\u003cp\u003eThere\u0026rsquo;s a grief that can\u0026rsquo;t be spoken\u003c/p\u003e\n\u003cp\u003eThere\u0026rsquo;s a pain goes on and on\u003c/p\u003e\n\u003cp\u003ePhantom faces at the window\u003c/p\u003e\n\u003cp\u003ePhantom shadows on the floor\u003c/p\u003e\n\u003cp\u003eEmpty chairs at empty tables\u003c/p\u003e\n\u003cp\u003eWhere my friends will meet no more\u003c/p\u003e\n\u003cp\u003eOh my friends, my friends\u003c/p\u003e","title":"Empty Chairs at Empty Tables_Les Misérables"},{"content":"One day more\nAnother day, another destiny\nThis never-ending road to Calvary\nThese men who seem to know my crime will surely come a second time\nOne day more\nI did not live until today\nHow can I live when we are parted?\nOne day more\nTomorrow you\u0026rsquo;ll be worlds away\nAnd yet with you my world has started\nOne more day all on my own\nWill we ever meet again?\nOne more day with him not caring\nI was born to be with you\nWhat a life I might have known\nAnd I swear I will be true\nBut he never saw me there\nOne more day before the storm\nDo I follow where she goes?\nAt the barricades of freedom\nShall I join my brothers there?\nWhen our ranks begin to form\nDo I stay or do I dare?\nWill you take your place with me?\nThe time is now\nThe day is here\nOne day more\nOne day more to revolution\nWe will nip it in the bud\nWe\u0026rsquo;ll be ready for these schoolboys\nThey will wet themselves with the blood (one day more)\nWatch \u0026rsquo;em run amuck\nCatch \u0026rsquo;em as they fall\nNever know your luck when there\u0026rsquo;s a free for all\nHere a little dip\nThere a little touch\nMost of them are goners, so they won\u0026rsquo;t miss much\nOne day to a new beginning\nRaise the flag of freedom high\nEvery man will be a king\nEvery man will be a king (every day)\nThere\u0026rsquo;s a new world for the winning\n(There\u0026rsquo;s a new world to be won)\nDo you hear the people sing?\nMy place is here\nI fight with you\nOne day more\nWe will join these people\u0026rsquo;s heroes\nWe will follow where they go\nWe will learn their little secrets\nWe will know the things they know (one day more)\nWatch \u0026rsquo;em run amuck, Catch \u0026rsquo;em as they fall\nNever know you luck, when there\u0026rsquo;s a free for all\nWe\u0026rsquo;ll be ready for the schoolboys (tomorrow we\u0026rsquo;ll be far away)\nTomorrow is the judgment day\nTomorrow we\u0026rsquo;ll discover what our God in Heaven has in store\nOne more dawn\nOne more day\nOne day more\n","permalink":"https://gopherding.github.io/posts/read/one-day-more_les-mis%C3%A9rables/","summary":"\u003cp\u003eOne day more\u003c/p\u003e\n\u003cp\u003eAnother day, another destiny\u003c/p\u003e\n\u003cp\u003eThis never-ending road to Calvary\u003c/p\u003e\n\u003cp\u003eThese men who seem to know my crime will surely come a second time\u003c/p\u003e\n\u003cp\u003eOne day more\u003c/p\u003e\n\u003cp\u003eI did not live until today\u003c/p\u003e\n\u003cp\u003eHow can I live when we are parted?\u003c/p\u003e\n\u003cp\u003eOne day more\u003c/p\u003e\n\u003cp\u003eTomorrow you\u0026rsquo;ll be worlds away\u003c/p\u003e\n\u003cp\u003eAnd yet with you my world has started\u003c/p\u003e\n\u003cp\u003eOne more day all on my own\u003c/p\u003e\n\u003cp\u003eWill we ever meet again?\u003c/p\u003e\n\u003cp\u003eOne more day with him not caring\u003c/p\u003e\n\u003cp\u003eI was born to be with you\u003c/p\u003e\n\u003cp\u003eWhat a life I might have known\u003c/p\u003e\n\u003cp\u003eAnd I swear I will be true\u003c/p\u003e\n\u003cp\u003eBut he never saw me there\u003c/p\u003e\n\u003cp\u003eOne more day before the storm\u003c/p\u003e\n\u003cp\u003eDo I follow where she goes?\u003c/p\u003e\n\u003cp\u003eAt the barricades of freedom\u003c/p\u003e\n\u003cp\u003eShall I join my brothers there?\u003c/p\u003e\n\u003cp\u003eWhen our ranks begin to form\u003c/p\u003e\n\u003cp\u003eDo I stay or do I dare?\u003c/p\u003e","title":"One Day More_Les Misérables"},{"content":" 原文 直译 可唱版 第一节Allons enfants de la Patrie, Le jour de gloire est arrivé! Contre nous de la tyrannie, L\u0026rsquo;étendard sanglant est levé (bis) Entendez-vous dans les campagnes Mugir ces féroces soldats? Ils viennent jusque dans vos bras Egorger vos fils, vos compagnes! Refrain Aux armes, citoyens! Formez vos bataillons! Marchons, marchons! Qu\u0026rsquo;un sang impur Abreuve nos sillons! 第一节一起走吧，祖国的子民们！荣耀之日来临了！我们面对的是暴政，将染血的军旗升起！（重复）你们可听到在乡间残暴士兵们的吼叫？他们会来到你们的臂膀中残杀你们的孩子，你们的伴侣！副歌武装起来，公民们，组织起你们的队伍！前进，前进！只有（敌人的）不洁之血才能灌溉我们的犁沟！ 第一节前进吧，祖国儿女，快奋起，光荣的一天等着你！专制暴政对着我们升起染满鲜血的旗！（重复）你可听见残暴的士兵？在乡间嚎叫不停，他们冲进你的臂膀，杀死你的妻子儿女。副歌公民，拿起武器，将队伍组织起！前进！前进！用敌人的污血，浇灌我们田野！ 第二节Que veut cette horde d\u0026rsquo;esclaves De traîtres, de rois conjurés? Pour qui ces ignobles entraves Ces fers dès longtemps préparés? (bis) Français, pour nous, ah! quel outrage! Quels transports il doit exciter? C\u0026rsquo;est nous qu\u0026rsquo;on ose méditer De rendre à l\u0026rsquo;antique esclavage! Refrain 第二节这些家伙想做什么，作为叛国者与疯国王的奴隶?何来那些卑贱的枷锁，还有那些准备已久的凶器！（重复）法国人，冲着我们呐，啊！何等羞辱多令人愤慨！冲着我们呐，有人胆敢算计回到那陈腐的奴隶制！副歌 第二节这一帮卖国贼和保王党，都怀着些什么妄想？试问这该死的铐蹽，是要戴上谁的脚？（重复）法兰西人，给我们戴啊！奇耻大辱叫人愤慨！要倒退回奴隶时代，我们绝不忍耐！副歌 第三节Quoi ces cohortes étrangères! Feraient la loi dans nos foyers! Quoi! ces phalanges mercenaires Terrasseraient nos fils guerriers! (bis) Grand Dieu! par des mains enchaînées Nos fronts sous le joug se ploieraient De vils despotes deviendraient Les maîtres des destinées. Refrain 第三节什么！异国军队在我们家园建立法律！什么！佣兵集团击溃我们引以为傲的战士们！（重复）伟大的天主啊！若双手被铐住，我们只能低头伸向恶人的枷锁独裁者们将会成为我们命运的主宰！副歌 第三节什么！这群外国匪帮，竟敢统治我们家乡！什么！我们的子弟兵，竟被雇佣军欺凌！（重复）难道我们要缚住双手，屈服在他们的脚底下！难道我们要低下头任由卑鄙的暴君管辖？副歌 第四节Tremblez, tyrans et vous perfides L\u0026rsquo;opprobre de tous les partis Tremblez! vos projets parricides Vont enfin recevoir leurs prix! (bis) Tout est soldat pour vous combattre S\u0026rsquo;ils tombent, nos jeunes héros La France en produit de nouveaux, Contre vous tout prêts à se battre Refrain 第四节战栗吧！暴君与尔等背信者整个令人耻辱的狗党，战栗吧！你们那弑亲的阴谋终将得到应有的报应！（重复）人人都会是讨罚你们的士兵如果他们倒下，年轻的英雄们，大地会孕育新血全都为了对抗你们而战！副歌 第四节发抖吧！暴君和背信奸佞，无耻的狗党狐群！发抖吧！卖国的阴谋诡计，终究要得到报应！（重复）四处都是反对你的战士，前仆后继有少年兵，法兰西不断出新人，随时准备杀敌效命！副歌 第五节Français, en guerriers magnanimes Portez ou retenez vos coups! Épargnez ces tristes victimes À regret s\u0026rsquo;armant contre nous (bis) Mais ces despotes sanguinaires, Mais ces complices de Bouillé Tous ces tigres qui, sans pitié Déchirent le sein de leur mère! Refrain 第五节法国人呐，身为宽宏的战士，适时收放自己的攻击！放了那些可悲的受迫者，他们后悔对我们动武！（重复）而那些嗜血的独裁者，而那布耶侯爵的共犯，那群豺狼虎豹正毫不留情地，撕裂着他们母亲的胸口！副歌 第五节法兰西人，宽宏的战士，要学会忍耐与战斗！赦免那些悲惨的人们，使敌后悔拿起刀枪！（重复）但这些嗜血的暴君，这些布耶的同党，无情的虎豹豺狼，竟撕裂母亲的胸膛！副歌 第六节Amour sacré de la Patrie, Conduis, soutiens nos bras vengeurs Liberté, Liberté chérie, Combats avec tes défenseurs! (bis) Sous nos drapeaux que la victoire Accoure à tes mâles accents, Que tes ennemis expirants Voient ton triomphe et notre gloire! Refrain 第六节祖国神圣的爱啊，引领，支持我们洗冤的手自由啊，挚爱的自由，与你的守护者们一起战斗吧！（重复）在我们的旗帜下，让胜利奔向你那雄壮的音符，让你残喘中的敌人们看看你的凯旋与我们的荣耀！副歌 第六节来自对祖国神圣的爱，指引着我们去复仇！自由啊，亲爱的自由，请与你的保卫者同战斗。（重复）在我们胜利旗帜下，奔向你雄伟的乐章。让垂死的敌人看见你的凯旋，我们的荣光！副歌 第七节Nous entrerons dans la carrière Quand nos aînés n\u0026rsquo;y seront plus, Nous y trouverons leur poussière Et la trace de leurs vertus! (bis) Bien moins jaloux de leur survivre Que de partager leur cercueil, Nous aurons le sublime orgueil De les venger ou de les suivre!Refrain 第七节当前辈们不在世上时，我们也将延续志业我们会找到他们的灰烬和他们美德的足迹（重复）不红着眼希望他们生还而是希望与他们共享灵柩，我们将感到无比的光荣为他们洗冤或追随他们而去！副歌 第七节当我们投入战事，前辈们已然殉职；追随他们的美德气概，去寻回英雄的遗骸。（重复）我们不再羡慕生命，却愿战死在斗争中；为他们复仇而牺牲，便是我们的无上光荣！副歌 ","permalink":"https://gopherding.github.io/posts/read/la-marseillaise/","summary":"\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e原文\u003c/th\u003e\n          \u003cth\u003e直译\u003c/th\u003e\n          \u003cth\u003e可唱版\u003c/th\u003e\n          \u003cth\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e第一节\u003c/strong\u003eAllons enfants de la Patrie, Le jour de gloire est arrivé! Contre nous de la tyrannie, L\u0026rsquo;étendard sanglant est levé \u003cem\u003e(bis)\u003c/em\u003e Entendez-vous dans les campagnes Mugir ces féroces soldats? Ils viennent jusque dans vos bras Egorger vos fils, vos compagnes! \u003cstrong\u003eRefrain\u003c/strong\u003e Aux armes, citoyens! Formez vos bataillons! Marchons, marchons! Qu\u0026rsquo;un sang impur Abreuve nos sillons!\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第一节\u003c/strong\u003e一起走吧，祖国的子民们！荣耀之日来临了！我们面对的是暴政，将染血的军旗升起！（重复）你们可听到在乡间残暴士兵们的吼叫？他们会来到你们的臂膀中残杀你们的孩子，你们的伴侣！\u003cstrong\u003e副歌\u003c/strong\u003e武装起来，公民们，组织起你们的队伍！前进，前进！只有（敌人的）不洁之血才能灌溉我们的犁沟！\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第一节\u003c/strong\u003e前进吧，祖国儿女，快奋起，光荣的一天等着你！专制暴政对着我们升起染满鲜血的旗！（重复）你可听见残暴的士兵？在乡间嚎叫不停，他们冲进你的臂膀，杀死你的妻子儿女。\u003cstrong\u003e副歌\u003c/strong\u003e公民，拿起武器，将队伍组织起！前进！前进！用敌人的污血，浇灌我们田野！\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e第二节\u003c/strong\u003eQue veut cette horde d\u0026rsquo;esclaves De traîtres, de rois conjurés? Pour qui ces ignobles entraves Ces fers dès longtemps préparés? \u003cem\u003e(bis)\u003c/em\u003e Français, pour nous, ah! quel outrage! Quels transports il doit exciter? C\u0026rsquo;est nous qu\u0026rsquo;on ose méditer De rendre à l\u0026rsquo;antique esclavage! \u003cem\u003eRefrain\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第二节\u003c/strong\u003e这些家伙想做什么，作为叛国者与疯国王的奴隶?何来那些卑贱的枷锁，还有那些准备已久的凶器！（重复）法国人，冲着我们呐，啊！何等羞辱多令人愤慨！冲着我们呐，有人胆敢算计回到那陈腐的奴隶制！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第二节\u003c/strong\u003e这一帮卖国贼和保王党，都怀着些什么妄想？试问这该死的铐蹽，是要戴上谁的脚？（重复）法兰西人，给我们戴啊！奇耻大辱叫人愤慨！要倒退回奴隶时代，我们绝不忍耐！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e第三节\u003c/strong\u003eQuoi ces cohortes étrangères! Feraient la loi dans nos foyers! Quoi! ces phalanges mercenaires Terrasseraient nos fils guerriers! \u003cem\u003e(bis)\u003c/em\u003e Grand Dieu! par des mains enchaînées Nos fronts sous le joug se ploieraient De vils despotes deviendraient Les maîtres des destinées. \u003cem\u003eRefrain\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第三节\u003c/strong\u003e什么！异国军队在我们家园建立法律！什么！佣兵集团击溃我们引以为傲的战士们！（重复）伟大的天主啊！若双手被铐住，我们只能低头伸向恶人的枷锁独裁者们将会成为我们命运的主宰！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第三节\u003c/strong\u003e什么！这群外国匪帮，竟敢统治我们家乡！什么！我们的子弟兵，竟被雇佣军欺凌！（重复）难道我们要缚住双手，屈服在他们的脚底下！难道我们要低下头任由卑鄙的暴君管辖？\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e第四节\u003c/strong\u003eTremblez, tyrans et vous perfides L\u0026rsquo;opprobre de tous les partis Tremblez! vos projets parricides Vont enfin recevoir leurs prix! \u003cem\u003e(bis)\u003c/em\u003e Tout est soldat pour vous combattre S\u0026rsquo;ils tombent, nos jeunes héros La France en produit de nouveaux, Contre vous tout prêts à se battre \u003cem\u003eRefrain\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第四节\u003c/strong\u003e战栗吧！暴君与尔等背信者整个令人耻辱的狗党，战栗吧！你们那弑亲的阴谋终将得到应有的报应！（重复）人人都会是讨罚你们的士兵如果他们倒下，年轻的英雄们，大地会孕育新血全都为了对抗你们而战！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第四节\u003c/strong\u003e发抖吧！暴君和背信奸佞，无耻的狗党狐群！发抖吧！卖国的阴谋诡计，终究要得到报应！（重复）四处都是反对你的战士，前仆后继有少年兵，法兰西不断出新人，随时准备杀敌效命！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e第五节\u003c/strong\u003eFrançais, en guerriers magnanimes Portez ou retenez vos coups! Épargnez ces tristes victimes À regret s\u0026rsquo;armant contre nous \u003cem\u003e(bis)\u003c/em\u003e Mais ces despotes sanguinaires, Mais ces complices de Bouillé Tous ces tigres qui, sans pitié Déchirent le sein de leur mère! \u003cem\u003eRefrain\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第五节\u003c/strong\u003e法国人呐，身为宽宏的战士，适时收放自己的攻击！放了那些可悲的受迫者，他们后悔对我们动武！（重复）而那些嗜血的独裁者，而那布耶侯爵的共犯，那群豺狼虎豹正毫不留情地，撕裂着他们母亲的胸口！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第五节\u003c/strong\u003e法兰西人，宽宏的战士，要学会忍耐与战斗！赦免那些悲惨的人们，使敌后悔拿起刀枪！（重复）但这些嗜血的暴君，这些布耶的同党，无情的虎豹豺狼，竟撕裂母亲的胸膛！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e第六节\u003c/strong\u003eAmour sacré de la Patrie, Conduis, soutiens nos bras vengeurs Liberté, Liberté chérie, Combats avec tes défenseurs! \u003cem\u003e(bis)\u003c/em\u003e Sous nos drapeaux que la victoire Accoure à tes mâles accents, Que tes ennemis expirants Voient ton triomphe et notre gloire! \u003cem\u003eRefrain\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第六节\u003c/strong\u003e祖国神圣的爱啊，引领，支持我们洗冤的手自由啊，挚爱的自由，与你的守护者们一起战斗吧！（重复）在我们的旗帜下，让胜利奔向你那雄壮的音符，让你残喘中的敌人们看看你的凯旋与我们的荣耀！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第六节\u003c/strong\u003e来自对祖国神圣的爱，指引着我们去复仇！自由啊，亲爱的自由，请与你的保卫者同战斗。（重复）在我们胜利旗帜下，奔向你雄伟的乐章。让垂死的敌人看见你的凯旋，我们的荣光！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e第七节\u003c/strong\u003eNous entrerons dans la carrière Quand nos aînés n\u0026rsquo;y seront plus, Nous y trouverons leur poussière Et la trace de leurs vertus! \u003cem\u003e(bis)\u003c/em\u003e Bien moins jaloux de leur survivre Que de partager leur cercueil, Nous aurons le sublime orgueil De les venger ou de les suivre!\u003cem\u003eRefrain\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第七节\u003c/strong\u003e当前辈们不在世上时，我们也将延续志业我们会找到他们的灰烬和他们美德的足迹（重复）不红着眼希望他们生还而是希望与他们共享灵柩，我们将感到无比的光荣为他们洗冤或追随他们而去！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003e第七节\u003c/strong\u003e当我们投入战事，前辈们已然殉职；追随他们的美德气概，去寻回英雄的遗骸。（重复）我们不再羡慕生命，却愿战死在斗争中；为他们复仇而牺牲，便是我们的无上光荣！\u003cem\u003e副歌\u003c/em\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"La Marseillaise"},{"content":"一种更高级的爱情——《爱乐之城》影评\n​\t有人说，要理解这部电影，要从它的名字开始，我深以为然。比起中文名称《爱乐之城》或许英文原版《La La Land》更契合电影的内容。《爱乐之城》四字俗套又不契合主题，而《La La Land》更带有一种预言的味道。天使之城洛杉矶别名\u0026quot;La La Land\u0026quot;即梦幻之城，这也在冥冥中暗示了男女主角在洛杉矶的相遇和热恋，到最后不过是一场美丽而不切实际的梦。\n​\t明星之城洛杉矶从来不缺一夜成名的神话，也不缺一次次被现实打败的逐梦者。显然故事的主人公是后者。比起电影中怀着明星梦的咖啡店打工妹和嗜好爵士乐的钢琴家在落魄时相遇并在相互支持中追梦的故事，男女主一段相识于微时，相守于贫贱，却耗不过时光，抵不过现实的爱情更耐人寻味。\n​\t电影以季节为节点，将两人的故事分为：冬-春-夏-秋-冬五个阶段，冬季的初次相遇，两个人都处在生活的低谷，被餐厅老板开除的一脸懊丧的男主撞过正要表达赞美之情的女主离开餐馆。春季，男女主再次在派对上相遇。双方被对方的才华吸引，情愫暗生。柠檬一般酸涩而又清新的爱情悄然萌芽。夏季，两人的爱情一如玫瑰花香一般浓郁炽烈，女主的事业也开始顺风顺水，然而没有面包的爱情似乎总是隐患重重。 秋季，梦想和爱情的双重幻灭。小塞为了谋生偏离自己的梦想，米娅独幕剧失败并对塞巴斯蒂安彻底失望。 五年后的冬天，米娅成了当红的演员，却早已嫁作他人妇，小塞也终于开起了名叫Seb\u0026rsquo;s的爵士俱乐部，身边却没有了米娅的陪伴。\n​\t还记得在秋天的末尾，塞巴斯蒂安对即将远赴巴黎的爱人说：\u0026ldquo;我会永远爱你\u0026rdquo;。米娅答：\u0026ldquo;我也会永远爱你。\u0026ldquo;而第二个冬天来临，米娅看到爵士俱乐部里自己亲手设计的Logo，塞巴斯蒂安看到米娅身边的男人时，两人眼中闪过的些许苦涩是对\u0026quot;我会永远爱你\u0026quot;的打脸吗？时过境迁，两人再次相遇，隔着舞台深情的一望，无需多言，就能让人理解\u0026quot;我会永远爱你\u0026quot;的真实含义。\n​\t有人问霍金，人世间最让你感动的是什么？霍金想了想说，是遥远的相似性。米娅爱塞巴斯蒂安身上那种即使失魂落魄也还能自命清高的孤傲劲。塞巴斯蒂安也爱米娅身上像石头一般倔强又坚毅的味道。比起恋人，他们更像彼此的一个复刻版，两人的爱情大致也就始于这种对待梦想的惊人的相似性，一种始于失魂落魄时的惺惺相惜和一种原来你也在这里的默契感。他们爱的方式就是在对方遭遇相同境遇时给予对方一种更加恰当和感同身受的安慰，当对方失去这种相似性时，当对方的梦想成真时，他们的爱情反倒没有了立足之地。当小塞首先认识到这其中的问题，于是他开始违心地加入乐队，努力想要给米娅一份稳定的生活。而米娅发展现实将小塞身上唯一的闪光点被现实磨灭时，她对小塞的爱也被现实敲碎了。\n​\t我想电影春夏秋冬的叙述方式也预示着他们的感情发展的阶段，此时两个人同他们之间的感情都是不够成熟和理智的，而秋天两人感情的风云突变使他们快速成长，并逐渐懂得爱就是在自己不能给予时要勇敢放手。塞巴斯蒂安在米娅即将离开时说出那句\u0026quot;我会永远爱你\u0026quot;代表着青涩感情的成熟，但为时已晚。\n​\t片尾两人再次相遇，四目相对时眼中闪过的惊愕，酸涩，遗憾让人久久不能忘怀。蒙太奇镜头将两个人脑海之中的幻想呈现出来，重新梳理了两人的故事，更让观众心中的悲喜一同涌上心头。作为电影中点睛之笔的蒙太奇镜头给了我们许多假设，如果两人在初次相遇时小塞没有粗鲁地撞开米娅，如果小塞能来支持米娅的独幕剧，也许现在米娅挽着的是小塞的手臂。然而一切早已注定。假如一切可以重来，他们也不会后悔当时的决定，因为他们已经能足够成熟和理智地对待梦想同爱情。两人能共苦却不能同甘的结局令人唏嘘，但又像我们的生活一样真实，原来一切都能完满的电影里也没有那么多如果。\n​\t与电影中吵闹又浮华的歌舞相比，男女主人公的感情似乎太平淡无奇，甚至落入俗套，欢喜冤家式的开头，仓皇带有烂尾之嫌的结尾。但是这平淡而又真实的感情才更能让人感同身受，最好的爱情应如这般，是抛开鲜花美酒的浮华后的真实与平淡。最好的爱情也应该是这般，是两个独立灵魂的互相尊重，而不是一方一味的妥协退让。学会放弃情感洁癖，相爱的人有一个理由会在一起，也有一万个理由不在一起。生活不会永远像预想中那样发展，学会接受，学会理解爱情的另一种存在方式。即便米娅最后牵了别人的手，或许小塞也会再遇良人，但那句\u0026quot;我会永远爱你\u0026quot;却不会失效，他们早已是彼此生命中的无可替代。时过境迁，当他们足够成熟时，早已懂得爱就是放手让爱的人去做他所想的事，爱就是在身后默默的支持鼓励，爱也是灵魂上的高度契合而非时时常伴左右。\n​\t两人因梦想结缘的高起点的爱情，最终被现实打破草草收场的结局多少让人感到怅然若失，但也称不上遗憾。他们的幸运之处在于在失魂落魄的追梦路上，还有一个和自己同样失魂落魄的对方。即使最终没有收获爱情的果实，却获得了比这更为重要的梦想力量。他们会在彼此的爱中不断成长，直至成为自己想要成为的模样。电影在用\u0026quot;美国梦\u0026quot;激励着年轻人勇于踏入现实的激流中找寻梦想的同时，更向我们诠释了一种真正成熟的更高级的爱情。\n​\t四季有终始，电影也会散场。网友的一句话深得我心：\u0026ldquo;愿你一生努力，一生被爱，想要的都拥有，得不到的都释怀。\u0026ldquo;也希望生活中的你，努力追求你的所爱，学会用一种更高级的方式去爱与被爱，努力生活，拿的起也放的下。\n","permalink":"https://gopherding.github.io/posts/read/%E4%B8%80%E7%A7%8D%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E7%88%B1%E6%83%85%E7%88%B1%E4%B9%90%E4%B9%8B%E5%9F%8E%E5%BD%B1%E8%AF%84-/","summary":"\u003cp\u003e\u003ca href=\"https://www.sohu.com/a/273234049_807547\"\u003e一种更高级的爱情——《爱乐之城》影评\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e​\t\t有人说，要理解这部电影，要从它的名字开始，我深以为然。比起中文名称《爱乐之城》或许英文原版《La La Land》更契合电影的内容。《爱乐之城》四字俗套又不契合主题，而《La La Land》更带有一种预言的味道。天使之城洛杉矶别名\u0026quot;La La Land\u0026quot;即梦幻之城，这也在冥冥中暗示了男女主角在洛杉矶的相遇和热恋，到最后不过是一场美丽而不切实际的梦。\u003c/p\u003e","title":"一种更高级的爱情——《爱乐之城》影评 "},{"content":"近日，连刷La La Land，感慨万千，窗外小雨碎碎零零，深夜无眠，起身伏案，悲从中来，遂得此篇。\n夜沉无云星缀天，伊行光影自悠然。\n明暗佳色融眉睫，柔辉不似白日喧。\n稍增暗影光偏减，便损风姿韵不显。\n乌发轻摇藏秀色，颊边清辉静漫敛。\n额角温润容光软，浅笑含情意未言。\n岁月皆从善念过，心安世路爱纯全。\n","permalink":"https://gopherding.github.io/posts/life/%E5%86%8D%E8%AF%91%E4%B8%83%E8%A8%80she-walks-in-beauty/","summary":"\u003cp\u003e近日，连刷La La Land，感慨万千，窗外小雨碎碎零零，深夜无眠，起身伏案，悲从中来，遂得此篇。\u003c/p\u003e\n\u003cp\u003e夜沉无云星缀天，伊行光影自悠然。\u003c/p\u003e\n\u003cp\u003e明暗佳色融眉睫，柔辉不似白日喧。\u003c/p\u003e\n\u003cp\u003e稍增暗影光偏减，便损风姿韵不显。\u003c/p\u003e\n\u003cp\u003e乌发轻摇藏秀色，颊边清辉静漫敛。\u003c/p\u003e\n\u003cp\u003e额角温润容光软，浅笑含情意未言。\u003c/p\u003e\n\u003cp\u003e岁月皆从善念过，心安世路爱纯全。\u003c/p\u003e","title":"再译七言She Walks in Beauty"},{"content":"She Walks in Beauty-译 By George Gordon Byron \u0026amp; George Ding\nShe walks in beauty, like the night\nOf cloudless climes and starry skies;\n行于美的光影中，她，恰如此夜 ——\n天无云，星密缀。\nAnd all that’s best of dark and bright\nMeet in her aspect and her eyes;\n巧色携着光影闪烁，聚焦眉梢眼角间；\nThus mellowed to that tender light\nWhich heaven to gaudy day denies.\n那温吞者何？便是白日光焰也不敌这流明淡淡。\nOne shade the more, one ray the less,\nHad half impaired the nameless grace\n多缕暗，少份光，\n那说不出的好光景便要消减了罢 ——\nWhich waves in every raven tress,\nOr softly lightens o’er her face;\n于乌发里漾着，于脸畔稍亮着；\nWhere thoughts serenely sweet express,\nHow pure, how dear their dwelling - place.\n思绪恬然轻诉处，显见得洁瑜同辉。\nAnd on that cheek, and o’er that brow,\nSo soft, so calm, yet eloquent;\n呵！那额际，那面颊，那般柔，那般静，脉脉含情；\nThe smiles that win, the tints that glow,\nBut tell of days in goodness spent;\n那笑影，那光彩，悠悠善居；\nA mind at peace with all below,\nA heart whose love is innocent!\n一念安然相迎，一心真纯爱情。\n","permalink":"https://gopherding.github.io/posts/life/she-walks-in-beauty-%E8%AF%91/","summary":"\u003ch3 id=\"she-walks-in-beauty-译\"\u003eShe Walks in Beauty-译\u003c/h3\u003e\n\u003cp\u003eBy George Gordon Byron \u0026amp; George Ding\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eShe walks in beauty, like the night\u003c/p\u003e\n\u003cp\u003eOf cloudless climes and starry skies;\u003c/p\u003e\n\u003cp\u003e行于美的光影中，她，恰如此夜 ——\u003c/p\u003e\n\u003cp\u003e天无云，星密缀。\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eAnd all that’s best of dark and bright\u003c/p\u003e\n\u003cp\u003eMeet in her aspect and her eyes;\u003c/p\u003e\n\u003cp\u003e巧色携着光影闪烁，聚焦眉梢眼角间；\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eThus mellowed to that tender light\u003c/p\u003e\n\u003cp\u003eWhich heaven to gaudy day denies.\u003c/p\u003e\n\u003cp\u003e那温吞者何？便是白日光焰也不敌这流明淡淡。\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eOne shade the more, one ray the less,\u003c/p\u003e\n\u003cp\u003eHad half impaired the nameless grace\u003c/p\u003e\n\u003cp\u003e多缕暗，少份光，\u003c/p\u003e","title":"She Walks in Beauty-译"},{"content":"Shall I compare thee to a harbor\u0026rsquo;s dawn?\n我可否将你比作港口的黎明？\nThou art more vivid, more enduring far:\n你却更鲜活，更恒久绵长：\nThe river loops, a silken belt drawn on,\n河水蜿蜒，如丝绸玉带轻绕，\nHills knot like guards where tides and shadows are.\n群山如卫，环伺潮汐与暗影周遭。\nSometimes the sun blazes o\u0026rsquo;er the quay,\n时而骄阳灼灼，洒满码头岸桥，\nSudden rains dim the neon\u0026rsquo;s glow awhile;\n骤雨忽然而至，暂暗霓虹轻耀；\nSeasons shift with hasty urgency,\n四季更迭匆匆，步履急如飞鸟，\nYet thy lamps pierce the dark with steady smile.\n光亮却破暗夜，笑意稳稳不摇。\nTyphoons cannot steal thy bell tower\u0026rsquo;s chime,\n台风卷不走钟楼的钟鸣袅袅，\nTime fails to fade thy streets\u0026rsquo; warm bustle dear;\n岁月磨不灭街巷的暖意迢迢；\nWhen mists cloak Victoria\u0026rsquo;s gentle climb,\n当薄雾轻笼维港的缓坡，\nThy starlight dances on the waves so clear.\n星光便舞在浪尖，跳得清亮明耀。\nAs long as tides kiss shore and stars take flight,\n只要潮汐轻吻海岸，星辰升向穹霄，\nThou liv\u0026rsquo;st in verse, forever bright.\n你便永活于诗行，恒久明亮如朝。\n","permalink":"https://gopherding.github.io/posts/life/sonnet-to-hong-kong/","summary":"\u003cp\u003eShall I compare thee to a harbor\u0026rsquo;s dawn?\u003c/p\u003e\n\u003cp\u003e我可否将你比作港口的黎明？\u003c/p\u003e\n\u003cp\u003eThou art more vivid, more enduring far:\u003c/p\u003e\n\u003cp\u003e你却更鲜活，更恒久绵长：\u003c/p\u003e\n\u003cp\u003eThe river loops, a silken belt drawn on,\u003c/p\u003e\n\u003cp\u003e河水蜿蜒，如丝绸玉带轻绕，\u003c/p\u003e\n\u003cp\u003eHills knot like guards where tides and shadows are.\u003c/p\u003e\n\u003cp\u003e群山如卫，环伺潮汐与暗影周遭。\u003c/p\u003e\n\u003cp\u003eSometimes the sun blazes o\u0026rsquo;er the quay,\u003c/p\u003e\n\u003cp\u003e时而骄阳灼灼，洒满码头岸桥，\u003c/p\u003e\n\u003cp\u003eSudden rains dim the neon\u0026rsquo;s glow awhile;\u003c/p\u003e\n\u003cp\u003e骤雨忽然而至，暂暗霓虹轻耀；\u003c/p\u003e\n\u003cp\u003eSeasons shift with hasty urgency,\u003c/p\u003e\n\u003cp\u003e四季更迭匆匆，步履急如飞鸟，\u003c/p\u003e\n\u003cp\u003eYet thy lamps pierce the dark with steady smile.\u003c/p\u003e","title":"Sonnet to Hong Kong"},{"content":"You got the invitation\nYou got the right address\nYou need some medication?\nThe answer\u0026rsquo;s always yes\nA little chance encounter\nCould be the one you\u0026rsquo;ve waited for\nJust squeeze a bit more\nTonight we\u0026rsquo;re on a mission\nTonight\u0026rsquo;s the casting call\nIf this is the real audition\nOh, God, help us all\nYou make the right impression\nThen everybody knows your name\nWe\u0026rsquo;re in the fast lane\nSomeone in the crowd could be the one you need to know\nThe one to finally lift you off the ground\nSomeone in the crowd could take you where you wanna go\nIf you\u0026rsquo;re the someone ready to be found\nThe someone ready to be found\nDo what you need to do\n\u0026lsquo;Til they discover you\nAnd make you more than who\nYou\u0026rsquo;re seeing now\nSo with the stars aligned\nI think I\u0026rsquo;ll stay behind\nYou\u0026rsquo;ve got to go and find\nThat someone in the crowd\nThat someone in the crowd\nIs someone in the crowd the only thing you really see?\nWatching while the world keeps spinning \u0026lsquo;round?\nSomewhere there\u0026rsquo;s a place where I find who I\u0026rsquo;m gonna be\nA somewhere that\u0026rsquo;s just waiting to be found\nSomeone in the crowd could be the one you need to know\nThe someone who could lift you off the ground\nSomeone in the crowd could take you where you wanna go\nSomeone in the crowd could make you-\nSomeone in the crowd could take you flying off the ground\nIf you\u0026rsquo;re the someone ready to be found\n","permalink":"https://gopherding.github.io/posts/read/someone-in-the-crowd_la-la-land/","summary":"\u003cp\u003eYou got the invitation\u003c/p\u003e\n\u003cp\u003eYou got the right address\u003c/p\u003e\n\u003cp\u003eYou need some medication?\u003c/p\u003e\n\u003cp\u003eThe answer\u0026rsquo;s always yes\u003c/p\u003e\n\u003cp\u003eA little chance encounter\u003c/p\u003e\n\u003cp\u003eCould be the one you\u0026rsquo;ve waited for\u003c/p\u003e\n\u003cp\u003eJust squeeze a bit more\u003c/p\u003e\n\u003cp\u003eTonight we\u0026rsquo;re on a mission\u003c/p\u003e\n\u003cp\u003eTonight\u0026rsquo;s the casting call\u003c/p\u003e\n\u003cp\u003eIf this is the real audition\u003c/p\u003e\n\u003cp\u003eOh, God, help us all\u003c/p\u003e\n\u003cp\u003eYou make the right impression\u003c/p\u003e\n\u003cp\u003eThen everybody knows your name\u003c/p\u003e\n\u003cp\u003eWe\u0026rsquo;re in the fast lane\u003c/p\u003e\n\u003cp\u003eSomeone in the crowd could be the one you need to know\u003c/p\u003e\n\u003cp\u003eThe one to finally lift you off the ground\u003c/p\u003e\n\u003cp\u003eSomeone in the crowd could take you where you wanna go\u003c/p\u003e\n\u003cp\u003eIf you\u0026rsquo;re the someone ready to be found\u003c/p\u003e\n\u003cp\u003eThe someone ready to be found\u003c/p\u003e\n\u003cp\u003eDo what you need to do\u003c/p\u003e\n\u003cp\u003e\u0026lsquo;Til they discover you\u003c/p\u003e\n\u003cp\u003eAnd make you more than who\u003c/p\u003e\n\u003cp\u003eYou\u0026rsquo;re seeing now\u003c/p\u003e\n\u003cp\u003eSo with the stars aligned\u003c/p\u003e\n\u003cp\u003eI think I\u0026rsquo;ll stay behind\u003c/p\u003e","title":"Someone in the Crowd_La La Land"},{"content":"My aunt used to live in Paris\nI remember,\nshe used to come home and tell us these stories about being abroad\nAnd I remember she told us that she\njumped into the river once, barefoot\nShe smiled\nLeapt, without looking\nAnd tumbled into the Seine\nThe water was freezing\nShe spent a month sneezing\nBut said she would do it again\nHere\u0026rsquo;s to the ones who dream\nFoolish as they may seem\nHere\u0026rsquo;s to the hearts that ache\nHere\u0026rsquo;s to the mess we make\nShe captured a feeling\nSky with no ceiling\nThe sunset inside a frame\nShe lived in her liquor\nAnd died with a flicker\nI\u0026rsquo;ll always remember the flame\nHere\u0026rsquo;s to the ones who dream\nFoolish as they may seem\nHere\u0026rsquo;s to the hearts that ache\nHere\u0026rsquo;s to the mess we make\nShe told me\n\u0026ldquo;A bit of madness is key\nTo give us new colors to see\nWho knows where it will lead us?\nAnd that\u0026rsquo;s why they need us\u0026rdquo;\nSo bring on the rebels\nThe ripples from pebbles\nThe painters, and poets, and plays\nAnd here\u0026rsquo;s to the fools who dream\nCrazy as they may seem\nHere\u0026rsquo;s to the hearts that break\nHere\u0026rsquo;s to the mess we make\nI trace it all back to then\nHer, and the snow, and the Seine\nSmiling through it\nShe said she\u0026rsquo;d do it again\n","permalink":"https://gopherding.github.io/posts/read/the-fools-who-dream_la-la-land/","summary":"\u003cp\u003eMy aunt used to live in Paris\u003c/p\u003e\n\u003cp\u003eI remember,\u003c/p\u003e\n\u003cp\u003eshe used to come home and tell us these stories about being abroad\u003c/p\u003e\n\u003cp\u003eAnd I remember she told us that she\u003c/p\u003e\n\u003cp\u003ejumped into the river once, barefoot\u003c/p\u003e\n\u003cp\u003eShe smiled\u003c/p\u003e\n\u003cp\u003eLeapt, without looking\u003c/p\u003e\n\u003cp\u003eAnd tumbled into the Seine\u003c/p\u003e\n\u003cp\u003eThe water was freezing\u003c/p\u003e\n\u003cp\u003eShe spent a month sneezing\u003c/p\u003e\n\u003cp\u003eBut said she would do it again\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s to the ones who dream\u003c/p\u003e\n\u003cp\u003eFoolish as they may seem\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s to the hearts that ache\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s to the mess we make\u003c/p\u003e\n\u003cp\u003eShe captured a feeling\u003c/p\u003e\n\u003cp\u003eSky with no ceiling\u003c/p\u003e\n\u003cp\u003eThe sunset inside a frame\u003c/p\u003e\n\u003cp\u003eShe lived in her liquor\u003c/p\u003e\n\u003cp\u003eAnd died with a flicker\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;ll always remember the flame\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s to the ones who dream\u003c/p\u003e\n\u003cp\u003eFoolish as they may seem\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s to the hearts that ache\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s to the mess we make\u003c/p\u003e\n\u003cp\u003eShe told me\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;A bit of madness is key\u003c/p\u003e","title":"The Fools Who Dream_La La Land"},{"content":"吊古战场文 唐·李华\n浩浩乎，平沙无垠，夐不见人。河水萦带，群山纠纷。黯兮惨悴，风悲日曛。蓬断草枯，凛若霜晨。鸟飞不下，兽铤亡群。亭长告余曰：“此古战场也，常覆三军。往往鬼哭，天阴则闻。”伤心哉！秦欤汉欤？将近代欤？\n吾闻夫齐魏徭戍，荆韩召募。万里奔走，连年暴露。沙草晨牧，河冰夜渡。地阔天长，不知归路。寄身锋刃，腷臆谁愬？秦汉而还，多事四夷，中州耗斁，无世无之。古称戎夏，不抗王师。文教失宣，武臣用奇。奇兵有异于仁义，王道迂阔而莫为。呜呼噫嘻！\n吾想夫北风振漠，胡兵伺便。主将骄敌，期门受战。野竖旌旗，川回组练。法重心骇，威尊命贱。利镞穿骨，惊沙入面，主客相搏，山川震眩。声析江河，势崩雷电。至若穷阴凝闭，凛冽海隅，积雪没胫，坚冰在须。鸷鸟休巢，征马踟蹰。缯纩无温，堕指裂肤。当此苦寒，天假强胡，凭陵杀气，以相剪屠。径截辎重，横攻士卒。都尉新降，将军复没。尸踣巨港之岸，血满长城之窟。无贵无贱，同为枯骨。可胜言哉！鼓衰兮力尽，矢尽兮弦绝，白刃交兮宝刀折，两军蹙兮生死决。降矣哉，终身夷狄；战矣哉，骨暴沙砾。鸟无声兮山寂寂，夜正长兮风淅淅。魂魄结兮天沉沉，鬼神聚兮云幂幂。日光寒兮草短，月色苦兮霜白。伤心惨目，有如是耶！\n吾闻之：牧用赵卒，大破林胡，开地千里，遁逃匈奴。汉倾天下，财殚力痡。任人而已，岂在多乎！周逐猃狁，北至太原。既城朔方，全师而还。饮至策勋，和乐且闲。穆穆棣棣，君臣之间。秦起长城，竟海为关。荼毒生民，万里朱殷。汉击匈奴，虽得阴山，枕骸徧野，功不补患。\n苍苍蒸民，谁无父母？提携捧负，畏其不寿。谁无兄弟？如足如手。谁无夫妇？如宾如友。生也何恩，杀之何咎？其存其没，家莫闻知。人或有言，将信将疑。悁悁心目，寤寐见之。布奠倾觞，哭望天涯。天地为愁，草木凄悲。吊祭不至，精魂无依。必有凶年，人其流离。呜呼噫嘻！时耶命耶？从古如斯！为之奈何？守在四夷。\n乙巳年闰六月十八日，飞机至香港，绕岛一周，俯瞰——但见港岛绿水环抱，货船间或穿行其间；太平山周高楼林立，矮丘接踵连绵不绝，故想起“河水萦带，群山纠纷”一句，可谓妙极，故将此文摘录之。\n","permalink":"https://gopherding.github.io/posts/read/%E5%90%8A%E5%8F%A4%E6%88%98%E5%9C%BA%E6%96%87/","summary":"\u003ch3 id=\"吊古战场文\"\u003e吊古战场文\u003c/h3\u003e\n\u003cp\u003e唐·李华\u003c/p\u003e\n\u003cp\u003e　　浩浩乎，平沙无垠，夐不见人。河水萦带，群山纠纷。黯兮惨悴，风悲日曛。蓬断草枯，凛若霜晨。鸟飞不下，兽铤亡群。亭长告余曰：“此古战场也，常覆三军。往往鬼哭，天阴则闻。”伤心哉！秦欤汉欤？将近代欤？\u003c/p\u003e\n\u003cp\u003e　　吾闻夫齐魏徭戍，荆韩召募。万里奔走，连年暴露。沙草晨牧，河冰夜渡。地阔天长，不知归路。寄身锋刃，腷臆谁愬？秦汉而还，多事四夷，中州耗斁，无世无之。古称戎夏，不抗王师。文教失宣，武臣用奇。奇兵有异于仁义，王道迂阔而莫为。呜呼噫嘻！\u003c/p\u003e","title":"吊古战场文"},{"content":"求职生涯暂时告一段落，期间精彩纷呈，收获颇丰，故写此博文以记录之。须知：本文并非经验性文章，故不提供论据，亦不提供方法论，而仅是为记录之杂文一篇——至于面试经验、技巧等技术性问题，后续会更新，此处按下不表。\n我以为，花费在找工作上的这数个月是我近几年最值得的时间。这段经历——让我得以接触到形形色色的人并尽力同其中的多数交谈甚欢；得以更好地在尊重他人的前提下提出自己的看法并发表自己的见解；得以同名校背景的同学在竞聘时“我剑也未尝不利”地与之一较高下；得以坦然地接受失败的事实并从中吸取教训；得以在遇到问题时主动进攻而非被动等待；得以能够在自发地通过实践终而认识到“世界就是个巨大的草台班子”后学会对他人去魅、对工作去魅；得以在面试后及时调整自己并准备\u0026quot;Do the next right thing\u0026quot;；得以收获了“知其不可而为之”的勇气——使我能够跳出“我学历不够，大厂肯定进不去”、“我专业不对口，这个岗位没机会”这样的自我预设。\n最重要的是，这段时间——或是说这段经历——在较大的程度上使得我有了机会去审视社会面貌中的自己，并在一次次面试中初次认识到自己性格上的重大弱点：偏激、自负、易怒、胡搅蛮缠——然而这一点的认识属实是较同龄人过晚了一些。我有了充分的机会乃至机遇同各种各样的人验证并磨练自己的性格，承认错误，弥补过失，并积极地在对话中仔细体会其情绪并尽力与之共情——这一点原是曾经“特立独行”的我所不耻，但人的本质毕竟不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和。\n学会了丧事喜办，学会了如何承担责任，学会了如何独立，学会了如何稳定自己的情绪并感受他人的情绪，学会了保持灵性和对生活的热情，并不断追求新的人生可能性——这段时间足矣使我受益终生——这一点是断然无法通过他人诚恳但无用的说教，或是单纯躲进小楼成一统的自省能够认识到的。\nI did not wish to take a cabin passage, but rather to go before the mast and on the deck of the world, for there I could best see the moonlight amid the mountains. I do not wish to go below now.\n我不愿意坐在船舱里，而要站在世界甲板之上的桅杆前，因为在那里，我可以看到照耀着群峰的明月——我再也不愿意下到舱底去了。\n注：本文会在求职季隐藏——本Blog的URL是写在简历上的 :-)\n","permalink":"https://gopherding.github.io/posts/life/%E6%B1%82%E8%81%8C%E6%9D%82%E8%AE%B0%E6%95%B0%E6%9C%88%E5%A5%94%E8%B5%B0%E9%97%B4%E7%AB%9F%E5%BE%97%E5%8D%8A%E7%94%9F%E5%91%B3/","summary":"\u003cp\u003e求职生涯暂时告一段落，期间精彩纷呈，收获颇丰，故写此博文以记录之。须知：本文并非经验性文章，故不提供论据，亦不提供方法论，而仅是为记录之杂文一篇——至于面试经验、技巧等技术性问题，后续会更新，此处按下不表。\u003c/p\u003e\n\u003cp\u003e我以为，花费在找工作上的这数个月是我近几年最值得的时间。这段经历——让我得以接触到形形色色的人并尽力同其中的多数交谈甚欢；得以更好地在尊重他人的前提下提出自己的看法并发表自己的见解；得以同名校背景的同学在竞聘时“我剑也未尝不利”地与之一较高下；得以坦然地接受失败的事实并从中吸取教训；得以在遇到问题时主动进攻而非被动等待；得以能够在自发地通过实践终而认识到“世界就是个巨大的草台班子”后学会对他人去魅、对工作去魅；得以在面试后及时调整自己并准备\u0026quot;Do the next right thing\u0026quot;；得以收获了“知其不可而为之”的勇气——使我能够跳出“我学历不够，大厂肯定进不去”、“我专业不对口，这个岗位没机会”这样的自我预设。\u003c/p\u003e","title":"求职杂记：数月奔走间，竟得半生味"},{"content":"Steve Jobs\u0026rsquo; Stanford Commencement Address 2005\n\u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e I’m honored to be with you today for your commencement from one of the finest universities in the world. Truth be told, I never graduated from college. And this is the closest I’ve ever gotten to a college graduation.\n今天，我很荣幸能和你们一同参加这场毕业典礼 —— 你们即将从世界上最顶尖的大学之一毕业。说实话，我从未大学毕业，这是我离大学毕业典礼最近的一次。\nToday I want to tell you three stories from my life. That’s it. No big deal. Just three stories.\n今天我想给你们讲三个我人生中的故事。仅此而已，没什么特别的，就三个故事。\nThe first story is about connecting the dots. I dropped out of Reed College after the first six months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why’d I drop out?\n第一个故事，关于 “串联生命中的点滴”。我在里德学院读了六个月就退学了，但之后又以旁听生的身份在学校待了大约 18 个月才彻底离开。我为什么要退学呢？\nIt started before I was born. My biological mother was a young, unwed graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife.\n这要从我出生前说起。我的生母是一位年轻的未婚研究生，她决定将我送养。她坚信我应该被大学毕业生收养，所以一切都安排妥当，我一出生就会被一对律师夫妇收养。\nExcept that when I popped out, they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking, “We’ve got an unexpected baby boy. Do you want him?” They said, “Of course.”\n可当我出生时，那对夫妇却在最后一刻变了卦 —— 他们其实想要个女孩。于是我的养父母 —— 当时他们在收养等待名单上 —— 半夜接到了一个电话：“我们有一个意外出生的男婴，你们愿意收养他吗？” 他们回答：“当然愿意。”\nMy biological mother found out later that my mother had never graduated from college, and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later, when my parents promised that I would go to college. This was the start in my life.\n后来我的生母发现，我的养母从未大学毕业，养父甚至没读完高中。她拒绝签署最终的收养文件。几个月后，当我的养父母承诺一定会送我上大学时，她才松了口。这就是我人生的开端。\nAnd 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford. And all of my working class parents’ savings were being spent on my college tuition.\n17 年后，我确实走进了大学。但我天真地选了一所学费几乎和斯坦福一样昂贵的学校，而我工薪阶层的父母将毕生积蓄都花在了我的学费上。\nAfter six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life, and no idea how college was going to help me figure it out. And here I was, spending all of the money my parents had saved their entire life.\n六个月后，我看不到这一切的意义所在。我完全不知道自己这辈子想做什么，也不知道大学能帮我找到答案。可我却在挥霍着父母一辈子攒下的血汗钱。\nSo I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made.\n于是我决定退学，相信一切总会有好的结果。当时这个决定很吓人，但现在回头看，这是我做过的最正确的决定之一。\nThe minute I dropped out, I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked far more interesting.\n退学的那一刻，我终于可以不用再上那些毫无兴趣的必修课，转而旁听那些看起来更有意思的课程。\nIt wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms. I returned Coke bottles for the five-cent deposits to buy food with. And I would walk the seven miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it.\n当然，这并非全是浪漫的冒险。我没有宿舍，只能睡在朋友房间的地板上；靠退可乐瓶换五美分押金买食物；每周日晚上要步行七英里穿过城镇，去 Hare Krishna 寺庙吃一顿像样的饭。但我热爱这样的生活。\nAnd much of what I stumbled into, by following my curiosity and intuition, turned out to be priceless later on. Let me give you one example.\n而很多我凭着好奇心和直觉偶然接触的东西，后来都成了无价之宝。我举个例子吧。\nReed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus, every poster, every label on every drawer, was beautifully hand-calligraphed. Because I had dropped out, and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this. I learned about serif and sans-serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle, in a way that science can’t capture. And I found it fascinating.\n当时的里德学院开设了全美最棒的书法课程。校园里的每一张海报、每一个抽屉上的标签，都是精美的手写书法。因为我退学了，不用上常规课程，便决定去上书法课，学习书写技巧。我学会了衬线字体和无衬线字体的区别，学会了调整不同字母组合间的间距，也明白了是什么让优秀的排版如此出众。那种美感、历史感和艺术上的细腻，是科学无法诠释的，我深深为之着迷。\nNone of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, it’s likely that no personal computer would have them.\n当时我完全想不到这些知识在日后会有什么实际用途。但十年后，当我们设计第一台麦金塔电脑时，这些记忆全都涌上心头。我们将这些书法知识融入了麦金塔的设计中，让它成为了第一台拥有精美排版的电脑。如果我当年没有旁听那门书法课，麦金塔就不会有多种字体和比例间距的字体。而因为 Windows 抄袭了麦金塔，很可能所有个人电脑都不会有这些功能。\nIf I had never dropped out, I would have never dropped in on that calligraphy class, and personal computers might not have the wonderful typography that they do. Of course, it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards, ten years later. Again, you can’t connect the dots looking forward. You can only connect them looking backwards, so you have to trust that the dots will somehow connect in your future.\n如果我从未退学，就不会旁听那门书法课，个人电脑可能就不会有如今这般美妙的排版。当然，在大学时，我不可能前瞻性地串联起这些点滴；但十年后回头看，一切都清晰无比。再说一次，你无法前瞻性地串联生命中的点滴，只能在回顾时才明白它们的联系。所以你要相信，这些点滴总会在未来以某种方式串联起来。\nYou have to trust in something: your gut, destiny, life, karma, whatever. Because believing that the dots will connect down the road will give you the confidence to follow your heart, even when it leads you off the well-worn path. And that will make all the difference.\n你必须相信一些东西 —— 你的直觉、命运、生活、因果报应，诸如此类。因为相信这些点滴终将串联，会给你追随内心的勇气，即便它会带你偏离寻常的道路。而这，会让一切变得不同。\nMy second story is about love and loss. I was lucky. I found what I loved to do early in life. Woz and I started Apple in my parents’ garage when I was 20. We worked hard, and in ten years Apple had grown from just the two of us in a garage into a $2 billion company with over 4,000 employees.\n第二个故事，关于爱与失去。我很幸运，很早就找到了自己热爱的事业。20 岁时，我和沃兹在父母的车库里创办了苹果公司。我们努力工作，十年后，苹果从车库里的两个人发展成了一家市值 20 亿美元、拥有 4000 多名员工的公司。\nWe just released our finest creation—the Macintosh—a year earlier, and I’d just turned 30. And then I got fired. How can you get fired from a company you started?\n一年前，我们刚推出了最棒的产品 —— 麦金塔电脑，而我刚满 30 岁。就在这时，我被解雇了。自己创办的公司，怎么会被解雇呢？\nWell, as Apple grew, we hired someone—who I thought was very talented—to run the company with me. And for the first year or so, things went well. But then our visions of the future began to diverge. And eventually we had a falling out. When we did, our board of directors sided with him. And so at 30 I was out, and very publicly out.\n事情是这样的：随着苹果的发展，我们聘请了一位我认为很有才华的人来和我一起管理公司。最初一年左右，一切都很顺利。但后来，我们对未来的愿景开始出现分歧，最终闹得不欢而散。当矛盾爆发时，董事会站在了他那边。就这样，30 岁的我出局了，而且是非常公开地出局。\nWhat had been the focus of my entire adult life was gone, and it was devastating. I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down, that I had dropped the baton as it was being passed to me.\n我成年后生活的重心突然消失了，这简直是毁灭性的打击。有好几个月，我真的不知道该做什么。我觉得自己让上一代企业家失望了，像是在接力赛中弄丢了接力棒。\nI met with David Packard and Bob Noyce, and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the Valley.\n我见了戴维・帕卡德和鲍勃・诺伊斯，为自己搞砸了一切而道歉。我成了一个公开的失败者，甚至想过逃离硅谷。\nBut something slowly began to dawn on me: I still loved what I did. The turn of events at Apple had not changed that one bit. I’d been rejected, but I was still in love.\n但渐渐地，我明白了一件事：我依然热爱自己所做的事。苹果的变故丝毫没有改变这一点。我被拒绝了，但我依然热爱。\nAnd so I decided to start over.\n于是我决定从头再来。\nI didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.\n当时我并没有意识到，但后来发现，被苹果解雇是我人生中最幸运的事之一。成功带来的沉重压力被重新做回初学者的轻松所取代，对一切都不再那么确定。这让我得以进入人生中最具创造力的时期之一。\nDuring the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the world’s first computer-animated feature film, Toy Story, and is now the most successful animation studio in the world.\n在接下来的五年里，我创办了 NeXT 公司，又创办了皮克斯，还爱上了一位很棒的女性，她后来成了我的妻子。皮克斯推出了世界上第一部电脑动画长片《玩具总动员》，如今已成为全球最成功的动画工作室。\nIn a remarkable turn of events, Apple bought NeXT, and I returned to Apple. And the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together.\n戏剧性的是，苹果后来收购了 NeXT，我也回到了苹果。我们在 NeXT 研发的技术，成了苹果复兴的核心。而我和劳伦也拥有了一个幸福的家庭。\nI’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful-tasting medicine, but I guess the patient needed it.\n我敢肯定，如果当初没有被苹果解雇，这一切都不会发生。这就像一剂难吃的药，但病人确实需要它。\nSometimes life’s gonna hit you in the head with a brick. Don’t lose faith.\n有时候，生活会给你当头一棒。但请不要失去信念。\nI’m convinced that the only thing that kept me going was that I loved what I did. You’ve got to find what you love—and that is as true for work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do.\n我坚信，支撑我走下去的唯一动力，是我热爱自己所做的事。你们必须找到自己热爱的东西 —— 无论是工作还是爱情，都是如此。工作会占据你人生的很大一部分，要想真正满意，就必须做你认为伟大的工作；而要做伟大的工作，就必须热爱自己所做的事。\nIf you haven’t found it yet, keep looking—and don’t settle. As with all matters of the heart, you’ll know when you find it. And like any great relationship, it just gets better and better as the years roll on. So keep looking. Don’t settle.\n如果你还没找到，那就继续寻找，不要妥协。就像所有与心有关的事一样，当你找到它时，你会明白的。而就像一段美好的感情，它会随着岁月的流逝变得越来越好。所以，继续寻找吧，不要妥协。\nMy third story is about death. When I was 17, I read a quote that went something like, “If you live each day as if it was your last, someday you’ll most certainly be right.”\n第三个故事，关于死亡。17 岁时，我读到一句话，大概是：“如果你把每一天都当作生命的最后一天来过，那么总有一天你会是对的。”\nIt made an impression on me. And since then, for the past 33 years, I have looked in the mirror every morning and asked myself, “If today were the last day of my life, would I wanna do what I am about to do today?” And whenever the answer has been no for too many days in a row, I know I need to change something.\n这句话给我留下了深刻的印象。从那以后，33 年来，我每天早上都会对着镜子问自己：“如果今天是生命的最后一天，我还会做今天要做的事吗？” 如果连续多天答案都是 “不”，我就知道自己需要改变了。\nRemembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything, all external expectations, all pride, all fear of embarrassment or failure—these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.\n时刻提醒自己终将死去，是我在人生重大抉择时最有用的工具。因为几乎所有一切 —— 他人的期待、骄傲、对尴尬或失败的恐惧 —— 在死亡面前都会烟消云散，只留下真正重要的东西。明白自己终将死去，是我所知避免 “患得患失” 的最好方法。你本就一无所有，没理由不追随自己的内心。\nAbout a year ago, I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was.\n大约一年前，我被诊断出癌症。早上 7 点半做的扫描，清楚地显示我的胰腺上有个肿瘤。我当时甚至不知道胰腺是什么。\nThe doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctors’ code for “Prepare to die.”\n医生告诉我，这几乎肯定是一种无法治愈的癌症，我可能只剩三到六个月的生命。医生建议我回家打理好后事 —— 这是医生对 “准备好死亡” 的委婉说法。\nIt means to try and tell your kids everything you thought you’d have the next ten years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.\n这意味着，要在短短几个月里，把本以为能在未来十年里对孩子们说的话都讲完；意味着要把一切安排妥当，让家人日后能轻松些；意味着要和所有人告别。\nI lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach, and into my intestines, put a needle into my pancreas, and got a few cells from the tumor.\n我一整天都被这个诊断结果笼罩着。当天晚上，我做了活检：医生把内窥镜从我的喉咙插入，穿过胃，进入肠道，用针头从肿瘤中取出了一些细胞。\nI was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope, the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery, and thankfully I’m fine now.\n我当时处于麻醉状态，但在场的妻子告诉我，当医生在显微镜下观察细胞时，他们都哭了 —— 因为这是一种非常罕见的胰腺癌，可以通过手术治愈。我接受了手术，幸运的是，现在我没事了。\nThis was the closest I’ve been to facing death, and I hope it’s the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept.\n这是我离死亡最近的一次，希望未来几十年都不会再这么近。有过这样的经历后，我现在能更肯定地对你们说这些话，而不再是把死亡当作一个有用却抽象的概念。\nNo one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet, death is the destination we all share. No one has ever escaped it. And that is as it should be, because death is very likely the single best invention of life. It’s life’s change agent. It clears out the old to make way for the new.\n没有人想死。即使是想上天堂的人，也不想通过死亡到达那里。然而，死亡是我们共同的终点，没人能逃脱。这很合理，因为死亡很可能是生命最棒的发明。它是生命的变革者，清除旧的，为新的让路。\nRight now, the new is you. But someday, not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it’s quite true.\n现在，你们就是 “新的”。但不久的将来，你们也会逐渐变成 “旧的”，被清除掉。抱歉说得这么伤感，但这是事实。\nYour time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma, which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice.\n你们的时间有限，不要浪费在重复别人的生活上。不要被教条束缚，教条就是活在别人的思考结果里。不要让他人的意见淹没你内心的声音。\nAnd most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.\n最重要的是，要有勇气追随自己的内心和直觉。它们早已知道你真正想成为什么样的人，其他一切都是次要的。\nWhen I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand, not far from here in Menlo Park. And he brought it to life with his poetic touch.\n我年轻时，有一本很棒的杂志叫《全球概览》，它是我们那一代人的圣经之一。创办者是斯图尔特・布兰德，就在不远处的门洛帕克。他用诗意的笔触让这本杂志充满生命力。\nThis was in the late sixties, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and Polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along. It was idealistic, overflowing with neat tools and great notions.\n那是在 60 年代末，个人电脑和桌面出版还没出现，所以杂志全是用打字机、剪刀和宝丽来相机制作的。它有点像纸质版的谷歌，比谷歌早了 35 年。它充满理想主义，满是实用的工具和伟大的想法。\nStewart and his team put out several issues of The Whole Earth Catalog. And then, when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age.\n斯图尔特和他的团队出版了好几期《全球概览》。当它完成使命时，他们推出了最后一期。那是 70 年代中期，我正和你们现在一样大。\nOn the back cover of their final issue was a photograph of an early-morning country road—the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words “Stay hungry. Stay foolish.” It was their farewell message as they signed off.\n最后一期的封底是一张照片，拍的是清晨的乡间小路 —— 如果你足够大胆，可能会在这条路上搭便车。照片下方写着：“求知若渴，虚心若愚。” 这是他们的告别语。\n“Stay hungry. Stay foolish.” And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you. Stay hungry. Stay foolish. Thank you all very much.\n“求知若渴，虚心若愚。” 我一直以此自勉。现在，在你们毕业、即将开启新旅程之际，我也把这句话送给你们。求知若渴，虚心若愚。非常感谢大家。\n","permalink":"https://gopherding.github.io/posts/read/steve-jobs-stanford-commencement-address-2005/","summary":"\u003cp\u003e\u003ca href=\"https://news.stanford.edu/stories/2005/06/youve-got-find-love-jobs-says\"\u003eSteve Jobs\u0026rsquo; Stanford Commencement Address 2005\u003c/a\u003e\u003c/p\u003e\n\u003c!DOCTYPE HTML\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cstyle type=\"text/css\"\u003e\n        .youtube_shortcodes {\n            position: relative;\n            width: 100%;\n            height: 0;\n            padding-bottom: 66%;\n            margin: auto;\n            overflow: hidden;\n            text-align: center;\n             \n        }\n\n        .youtube_shortcodes iframe {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            left: 0;\n            top: 0;\n        }\n    \u003c/style\u003e\n    \u003ctitle\u003e\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cdiv class=\"youtube_shortcodes\"\u003e\n    \u003ciframe\n            class=\"youtube-player\"\n            type=\"text/html\"\n            width=\"640\"\n            height=\"385\"\n            src=\"https://www.youtube.com/embed/UF8uR6Z6KLc?autoplay=0\"\n            style=\"\n                 position: absolute;\n                 top: 0;\n                 left: 0;\n                 width: 100%;\n                 height: 100%;\n                 border:0;\"\n            allowfullscreen frameborder=\"0\"\u003e\n    \u003c/iframe\u003e\n\u003c/div\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\u003chr\u003e\n\u003c!DOCTYPE HTML\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cstyle type=\"text/css\"\u003e\n        .bilibili_shortcodes {\n            position: relative;\n            width: 100%;\n            height: 0;\n            padding-bottom: 66%;\n            margin: auto;\n            overflow: hidden;\n            text-align: center;\n             \n        }\n\n        .bilibili_shortcodes iframe {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            left: 0;\n            top: 0;\n        }\n    \u003c/style\u003e\n    \u003ctitle\u003e\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cdiv class=\"bilibili_shortcodes\"\u003e\n    \u003ciframe\n            src=\"https://player.bilibili.com/player.html?bvid=BV1oW411h7Ea\u0026page=1\u0026high_quality=1\u0026danmaku=0\u0026as_wide=0\"\n            scrolling=\"no\"\n            border=\"0\"\n            frameborder=\"no\"\n            framespacing=\"0\"\n            allowfullscreen=\"true\"\n    \u003e\n    \u003c/iframe\u003e\n    \n    \n    \n\n    \n\n\u003c/div\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\u003cp\u003eI’m honored to be with you today for your commencement from one of the finest universities in the world. Truth be told, I never graduated from college. And this is the closest I’ve ever gotten to a college graduation.\u003c/p\u003e\n\u003cp\u003e今天，我很荣幸能和你们一同参加这场毕业典礼 —— 你们即将从世界上最顶尖的大学之一毕业。说实话，我从未大学毕业，这是我离大学毕业典礼最近的一次。\u003c/p\u003e","title":"Steve Jobs' Stanford Commencement Address 2005"},{"content":"碧梧何荫郁，绿满庭宇。\n羽毛犹未丰，飞向何处？\n乘车戴笠，求无愧于生。\n清歌一曲，行色匆匆。\n","permalink":"https://gopherding.github.io/posts/read/%E6%98%A5%E6%99%96%E4%B8%AD%E5%AD%A6%E6%AF%95%E4%B8%9A%E6%AD%8C/","summary":"\u003cp\u003e碧梧何荫郁，绿满庭宇。\u003c/p\u003e\n\u003cp\u003e羽毛犹未丰，飞向何处？\u003c/p\u003e\n\u003cp\u003e乘车戴笠，求无愧于生。\u003c/p\u003e\n\u003cp\u003e清歌一曲，行色匆匆。\u003c/p\u003e","title":"春晖中学毕业歌"},{"content":"骊歌初动，离情辘辘，惊惜韶光匆促，\n毋忘所训，谨遵所嘱，从今知行弥笃，\n更愿诸君，矢勤矢勇，指戈长白山麓。\n去矣男儿，切莫踯躅，矢志复兴民族。\n怀昔叙首，朝夕同堂，亲爱兮未能忘，\n今朝隔别，天各一方，山高兮水又长，\n依稀往事，费煞思量，一思兮一心伤。\n前途茫茫，何时相见，相见兮在何方。\n","permalink":"https://gopherding.github.io/posts/read/%E9%AA%8A%E6%AD%8C/","summary":"\u003cp\u003e骊歌初动，离情辘辘，惊惜韶光匆促，\u003c/p\u003e\n\u003cp\u003e毋忘所训，谨遵所嘱，从今知行弥笃，\u003c/p\u003e\n\u003cp\u003e更愿诸君，矢勤矢勇，指戈长白山麓。\u003c/p\u003e\n\u003cp\u003e去矣男儿，切莫踯躅，矢志复兴民族。\u003c/p\u003e\n\u003cp\u003e怀昔叙首，朝夕同堂，亲爱兮未能忘，\u003c/p\u003e\n\u003cp\u003e今朝隔别，天各一方，山高兮水又长，\u003c/p\u003e\n\u003cp\u003e依稀往事，费煞思量，一思兮一心伤。\u003c/p\u003e\n\u003cp\u003e前途茫茫，何时相见，相见兮在何方。\u003c/p\u003e","title":"骊歌"},{"content":"长亭外，古道边，芳草碧连天。\n晚风拂柳笛声残，夕阳山外山。\n天之涯，地之角，知交半零落。\n一瓢浊酒尽余欢，今宵别梦寒。\n（陈哲甫 续）\n长亭外，古道边，芳草碧连天。\n孤云一片雁声酸，日暮塞烟寒。\n伯劳东，飞燕西，与君长别离。\n把裤牵衣泪如雨，此情谁与语。\n长亭外，古道边，芳草碧连天。\n晚风拂柳笛声残，夕阳山外山。\n","permalink":"https://gopherding.github.io/posts/read/%E9%80%81%E5%88%AB/","summary":"\u003cp\u003e长亭外，古道边，芳草碧连天。\u003c/p\u003e\n\u003cp\u003e晚风拂柳笛声残，夕阳山外山。\u003c/p\u003e\n\u003cp\u003e天之涯，地之角，知交半零落。\u003c/p\u003e\n\u003cp\u003e一瓢浊酒尽余欢，今宵别梦寒。\u003c/p\u003e\n\u003cp\u003e（陈哲甫 续）\u003c/p\u003e\n\u003cp\u003e长亭外，古道边，芳草碧连天。\u003c/p\u003e\n\u003cp\u003e孤云一片雁声酸，日暮塞烟寒。\u003c/p\u003e\n\u003cp\u003e伯劳东，飞燕西，与君长别离。\u003c/p\u003e\n\u003cp\u003e把裤牵衣泪如雨，此情谁与语。\u003c/p\u003e\n\u003cp\u003e长亭外，古道边，芳草碧连天。\u003c/p\u003e\n\u003cp\u003e晚风拂柳笛声残，夕阳山外山。\u003c/p\u003e","title":"送别"},{"content":"0.提前进入会议室等面试官\n1.互相打招呼，这里我习惯绕一圈我的屏幕摄像头让他看看我没用其它手机查ai，自信:-）\n2.确认网络情况和通话质量\n3.一般情况下面试官会让你做一个自我介绍（部分面试官也会先自己介绍一下自己的小组和自己的职位，这里可以记住，以便于后续针对性地提出自己的看法——比如他说他是SRE组，那我自我介绍就是我干过SRE；他是开发，那我就是开发；他们组的氛围是怎样的，那我的性格就是怎样的，etc.这里可以活泛一点），我习惯控制在3分钟以内，简历上有的就不必说了，我更倾向于简略地说一说自己的技术栈，干过的项目的综述，实习的话还有自己的预期到岗时间，以及对所面试公司的了解（也就是价值观认同之类的，证明不是海投）诸如此类，水一段时间\n4.这时候面试官大概率就要开始问八股或者算法或是深挖项目了，这里我的经验是来上一句“面试官，我可以为您简要介绍一下我的项目以便于您能从中发现一些您感兴趣的点，我们可以展开聊一聊”\n5.然后这时候面试官大概率就会被引导先问项目，前提是项目真的有亮点（就我本人而言，因为面试时间是一定的，八股文浩浩汤汤我记不全，算法水平我不高，说项目是相对轻松的——如果更倾向于被提问八股或者算法，那也可以自己把面试官往那些个方向引）\n6.那末就开始吹项目，反正自己写的心里有数，注意提前进行一些宏观的顶层的设计意图的思考——比如：为什么设计思路用kafka的哲学不用rocketMQ的哲学，为什么存储引擎设计参考postgreSQL而不用MySQL这方面的（不过这是因为我是基架项目所以这方面问的多，这个因人而异），这也没有对错，言之有理即可\n7.然后这段时间基本上就能深挖1h到1.5hs，我习惯自己吹牛逼，尽量不让对面问我太多哈哈哈；面试官有想要问的，如果我会，我就回答“您问的很对，这一点我当初也考虑到了，我之前是这么想的阿巴阿巴阿巴，但是后来实践过程中发现阿巴阿巴阿巴，所以考虑到成本和性能我选择了阿巴阿巴阿巴”；如果不太会，那这里切忌不懂装懂，知识库里实在没说的就老老实实说不会，宁可不说也不要说错太多，或者我更倾向于宏观一点直接说类似于：“面试官，我认为这是伪需求，实际项目中考虑这些容易导致代码冗余，并且如果真有这方面的需求，我的基架是天生代码下沉的，支持互相解耦”这类的话；btw，网上有的面经会让你道歉并说什么“您说得对，我考虑不周，我进入公司可以学“，我认为大可不必，这是没有思考没有主见的体现\n8.到了这时候，我本人的话一般面试就进入反问阶段了，因为我挺能吹，能水够时间，所以我被问到算法和八股的情况比较少啊哈\n9.所以说一说一般情况，面试官应该还会问一问八股，那八股就老老实实吟诵——这玩意儿不会是真没法，编也编不出来，此处按下不表\n10.然后有的公司有手撸算法的需求（顺序看面试官，有的算法题在开头问，有的在结尾问），开发岗大概率hot100，运维岗一般手写shell或者各种file（dockerfile啊，k8s的那些个配置文件啊，etc），这是硬功夫我也不太行，按下不表\n11.于是就进入了最后的反问环节，可以问一问面试官他/她们组的技术栈啊、团队氛围啊、工作时间啊，etc；这里我会结合面试官最一开始的自我介绍（如果有的话），问一问一些自己的项目和他们公司重合的点的技术选型相关的问题，比如他们公司SQL是跑实体机还是k8s还是上云啊这些，如果前面面试官聊的不错的话，这里是很轻松并且会很有收获的（技术上和经验上的收获），我曾经和一个面试官在此处聊了一个半小时以至于他错过了晚饭啊哈；避雷：不要问自己薪资、不要问对方薪资、不要问面试结果、不要问加班多不多（不要问加班是我的血泪教训呜呜呜）、不要问对方觉得这个公司怎么样；同时，也可以在这个环节对之前答的不好的地方进行找补\n12.互相”感谢您的时间”，夸一夸面试官的专业性（当然傻呗面试官也不少，我一般发现傻呗可能第三个环节就和他爆了）\n13.根据自己的面试体验其实能猜出来面试结果了，这个完全靠面的多了的经验，如果觉得面的不错可以大胆加微信，面的不好就甭加了，挂了也尴尬\n14.面试结束，记得好评\n15.如果面试结果5天以上不出，可以微信骚扰一下，或者发邮件问问情况；如果加了微信，过了就感谢一下；挂了就祝他工作顺利，希望以后可以做同事\n注：本文会在求职季隐藏——本Blog的URL是写在简历上的 :-)\n","permalink":"https://gopherding.github.io/posts/life/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93/","summary":"\u003cp\u003e0.提前进入会议室等面试官\u003c/p\u003e\n\u003cp\u003e1.互相打招呼，这里我习惯绕一圈我的屏幕摄像头让他看看我没用其它手机查ai，自信:-）\u003c/p\u003e\n\u003cp\u003e2.确认网络情况和通话质量\u003c/p\u003e\n\u003cp\u003e3.一般情况下面试官会让你做一个自我介绍（部分面试官也会先自己介绍一下自己的小组和自己的职位，这里可以记住，以便于后续针对性地提出自己的看法——比如他说他是SRE组，那我自我介绍就是我干过SRE；他是开发，那我就是开发；他们组的氛围是怎样的，那我的性格就是怎样的，etc.这里可以活泛一点），我习惯控制在3分钟以内，简历上有的就不必说了，我更倾向于简略地说一说自己的技术栈，干过的项目的综述，实习的话还有自己的预期到岗时间，以及对所面试公司的了解（也就是价值观认同之类的，证明不是海投）诸如此类，水一段时间\u003c/p\u003e","title":"关于面试的一些复盘总结"},{"content":"O Captain! My Captain! By Walt Whitman\nO Captain! My Captain! Our fearful trip is done,\nThe ship has weather\u0026rsquo;d every rack, the prize we sought is won,\nThe port is near, the bells I hear, the people all exulting,\nWhile follow eyes the steady keel, the vessel grim and daring;\nBut O heart! heart! heart!\nO the bleeding drops of red!\nWhere on the deck my Captain lies,\nFallen cold and dead.\nO Captain! my Captain! rise up and hear the bells;\nRise up - for you the flag is flung - for you the bugle trills,\nFor you bouquets and ribbon\u0026rsquo;d wreaths - for you the shores crowding,\nFor you they call, the swaying mass, their eager faces turning;\nHere, Captain! dear father!\nThis arm beneath your head;\nIt is some dream that on the deck\nYou\u0026rsquo;ve fallen cold and dead.\nMy Captain does not answer, his lips are pale and still,\nMy father does not feel my arm, he has no pulse nor will;\nThe ship is anchor\u0026rsquo;d safe and sound, its voyage closed and done;\nFrom fearful trip the victor ship comes in with object won;\nExult, Oh shores! and ring, Oh bells!\nI, with mournful tread,\nWalk the deck my captain lies,\nFallen cold and dead.\n","permalink":"https://gopherding.github.io/posts/read/o-captain-my-captain/","summary":"\u003ch3 id=\"o-captain-my-captain\"\u003eO Captain! My Captain!\u003c/h3\u003e\n\u003cp\u003eBy Walt Whitman\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eO Captain! My Captain! Our fearful trip is done,\u003c/p\u003e\n\u003cp\u003eThe ship has weather\u0026rsquo;d every rack, the prize we sought is won,\u003c/p\u003e\n\u003cp\u003eThe port is near, the bells I hear, the people all exulting,\u003c/p\u003e\n\u003cp\u003eWhile follow eyes the steady keel, the vessel grim and daring;\u003c/p\u003e\n\u003cp\u003eBut O heart! heart! heart!\u003c/p\u003e\n\u003cp\u003eO the bleeding drops of red!\u003c/p\u003e\n\u003cp\u003eWhere on the deck my Captain lies,\u003c/p\u003e\n\u003cp\u003eFallen cold and dead.\u003c/p\u003e\n\u003cp\u003eO Captain! my Captain! rise up and hear the bells;\u003c/p\u003e\n\u003cp\u003eRise up - for you the flag is flung - for you the bugle trills,\u003c/p\u003e\n\u003cp\u003eFor you bouquets and ribbon\u0026rsquo;d wreaths - for you the shores crowding,\u003c/p\u003e\n\u003cp\u003eFor you they call, the swaying mass, their eager faces turning;\u003c/p\u003e\n\u003cp\u003eHere, Captain! dear father!\u003c/p\u003e\n\u003cp\u003eThis arm beneath your head;\u003c/p\u003e\n\u003cp\u003eIt is some dream that on the deck\u003c/p\u003e\n\u003cp\u003eYou\u0026rsquo;ve fallen cold and dead.\u003c/p\u003e","title":"O Captain! My Captain!"},{"content":"Ode to a Nightingale By John Keats\nMy heart aches, and a drowsy numbness pains My sense, as though of hemlock I had drunk,\nOr emptied some dull opiate to the drains\nOne minute past, and Lethe-wards had sunk:\n\u0026lsquo;Tis not through envy of thy happy lot,\nBut being too happy in thine happiness \u0026ndash;\nThat thou, light-winged Dryad of the trees,\nIn some melodious plot\nOf beechen green, and shadows numberless,\nSingest of summer in full-throated ease.\nO, for a draught of vintage! that hath been\nCooled a long age in the deep-delved earth,\nTasting of Flora and the country green,\nDance, and Provencal song, and sunburnt mirth!\nO for a beaker full of the warm South,\nFull of the true, the blushful Hippocrene,\nWith beaded bubbles winking at the brim,\nAnd purple-stained mouth,\nThat I may drink, and leave the world unseen,\nAnd with thee fade away into the forest dim.\nFade far away, dissolve, and quite forget\nWhat thou amongst the leaves hast never known,\nThe weariness, the fever, and the fret\nHere, where men sit and hear each other groan;\nWhere palsy shakes a few, sad, last grey hairs.\nWhere youth grows pale, and spectre-thin, and dies;\nWhere nut to think is to be full of sorrow\nAnd leaden-eyed despairs;\nWhere Beauty cannot keep her lustrous eyes,\nOr new Love pine at them beyond to-morrow.\nAway! away! for I will fly to thee,\nNot charioted by Bacchus and his pards, But on the viewless wings of Poesy,\nThough the dull brain perplexes and retards. Already with thee! tender is the night,\nAnd haply the Queen-Moon is on her throne,\nCluster\u0026rsquo;d around by all her starry Fays;\nBut here there is no light,\nSave what from heaven is with the breezes blown\nThrough verduous glooms and winding mossy ways.\nI cannot see what flowers are at my feet,\nNor what soft incense hangs upon the boughs,\nBut, in embalmed darkness, guess each sweet\nWherewith the seasonable month endows\nThe grass, the thicket, and the fruit-tree wild \u0026ndash;\nWhite hawthorn, and the pastoral eglantine;\nFast fading violets covered up in leaves;\nAnd mid-May\u0026rsquo;s eldest child,\nThe coming musk-rose, full of dewy wine,\nThe murmurous haunt of flies on summer eves.\nDarkling I listen; and for many a time\nI have been half in love with easeful Death,\nCalled him soft names in many a mused rhyme,\nTo take into the air my quiet breath;\nNow more than ever seems it rich to die,\nTo cease upon the midnight with no pain,\nWhile thou art pouring forth thy soul abroad\nIn such an ecstasy!\nStill wouldst thou sing, and I have ears in vain \u0026ndash;\nTo thy high requiem become a sod.\nThou wast not born for death, immortal Bird!\nNo hungry generations tread thee down;\nThe voice I hear this passing night was heard\nIn ancient days by emperor and clown:\nPerhaps the self-same song that found a path\nThrough the sad heart of Ruth, when, sick for home,\nShe stood in tears amid the alien corn;\nThe same that oft-times hath\nCharmed magic casements, opening on the foam\nOf perilous seas, in faery lands forlorn.\nForlorn! the very word is like a bell\nTo toll me back from thee to my sole self!\nAdieu! the fancy cannot cheat so well\nAs she is famed to do, deceiving elf.\nAdieu! adieu! thy plaintive anthem fades\nPast the near meadows, over the still stream,\nUp the hill-side; and now \u0026rsquo;tis buried deep\nIn the next valley-glades:\nWas is a vision, or a waking dream?\nFled is that music \u0026ndash; Do I wake or sleep?\n（查良铮 译）\n我的心在痛,困顿和麻木\n刺进了感官有如饮过毒鸩\n又像是刚把鸦片吞服\n於是向列斯忘川下沉\n并不是我忌妒你的好运\n而是你的快乐使我太欢欣\u0026ndash;\n因为在林间嘹亮的天地里\n你呵,轻翅的仙灵\n你躲进山毛榉的葱绿和荫影\n放开了歌喉,歌唱著夏季\n唉,要是有一口酒,那冷藏\n在地下多年的清醇饮料\n一尝就令人想起绿色之邦\n想起花神,恋歌,阳光和舞蹈\n要是有一杯南国的温暖\n充满了鲜红的灵感之泉\n杯缘明灭著珍珠的泡沫\n给嘴唇染上紫斑\n我要一饮而尽而悄然离开尘寰\n和你同去幽暗的林中隐没\n远远地,远远隐没,让我忘掉\n你在树叶间从不知道的一切\n忘记这疲劳,热病,和焦躁\n这使人对坐而悲叹的世界\n在这里,青春,苍白,削瘦,死亡\n而瘫痪有几根白发在摇摆\n在这里,稍一思索就充满了\n忧伤和灰暗的绝望\n而美保持不住明眸的光彩\n新生的爱情活不到明天就枯凋\n去吧!去吧!我要朝你飞去\n不用和酒神坐文豹的车驾\n我要展开诗歌底无形的羽翼\n尽管这头脑已经困顿,疲乏\n去了,我已经和你同往\n夜这般温柔,月后正登上宝座\n周围是侍卫她的一群星星\n但这儿不甚明亮\n除了有一线天光,被微风带过\n葱绿的幽暗和藓苔的曲径\n我看不出是哪种花在脚旁\n什麼清香的花挂在树枝上\n在温馨的幽暗理,我只能猜想\n这时令该把哪种芬芳\n赋予这果树,林莽和草丛\n这白枳花,和田野的玫瑰\n这绿叶堆中易凋谢的紫罗兰\n还有五月中旬的娇宠\n这缀满了露酒的麝香蔷薇\n它成了夏夜蚊蚋嗡营的港湾\n我在黑暗中里倾听,多少次\n我几乎爱上了静谧的死亡\n我在诗思里用尽了我言辞\n求他把我的一息散入空茫\n而现在,死更是多麼的富丽\n在午夜里溘然魂离人间\n当你正倾泻你的心怀\n发出这般的狂喜\n你仍将歌唱,但我却不再听\n你的莽歌只能唱给泥草一块\n永生的鸟,你不会死去\n饿的世代无法将你蹂躏\n今夜,我偶然听到的歌曲\n当使古代的帝王和村夫喜悦\n或许这同样的歌也曾激荡\n露丝忧郁的心,使她不禁落泪\n站在异邦的谷田里想著家\n就是这声音常常\n在失掉了的仙域里引动窗扉\n一个美女望著大海险恶的浪花\n失掉了,这句话好比一声钟\n使我猛省到我站脚的地方\n别了!幻想,这骗人的妖童\n不能老耍弄它盛传的伎俩\n别了!别了!你怨诉的歌声\n流过草坪,越过幽静的溪水\n溜上山坡,而此时它正深深\n埋在附近的溪谷中\n这是个幻觉,还是梦寐\n那歌声去了-我是睡?是醒?\n","permalink":"https://gopherding.github.io/posts/read/ode-to-a-nightingale/","summary":"\u003ch3 id=\"ode-to-a-nightingale\"\u003eOde to a Nightingale\u003c/h3\u003e\n\u003cp\u003eBy John Keats\u003c/p\u003e\n\u003cbr\u003e\nMy heart aches, and a drowsy numbness pains\n\u003cp\u003eMy sense, as though of hemlock I had drunk,\u003c/p\u003e\n\u003cp\u003eOr emptied some dull opiate to the drains\u003c/p\u003e\n\u003cp\u003eOne minute past, and Lethe-wards had sunk:\u003c/p\u003e\n\u003cp\u003e\u0026lsquo;Tis not through envy of thy happy lot,\u003c/p\u003e\n\u003cp\u003eBut being too happy in thine happiness \u0026ndash;\u003c/p\u003e\n\u003cp\u003eThat thou, light-winged Dryad of the trees,\u003c/p\u003e\n\u003cp\u003eIn some melodious plot\u003c/p\u003e\n\u003cp\u003eOf beechen green, and shadows numberless,\u003c/p\u003e\n\u003cp\u003eSingest of summer in full-throated ease.\u003c/p\u003e\n\u003cp\u003eO, for a draught of vintage! that hath been\u003c/p\u003e\n\u003cp\u003eCooled a long age in the deep-delved earth,\u003c/p\u003e\n\u003cp\u003eTasting of Flora and the country green,\u003c/p\u003e\n\u003cp\u003eDance, and Provencal song, and sunburnt mirth!\u003c/p\u003e\n\u003cp\u003eO for a beaker full of the warm South,\u003c/p\u003e\n\u003cp\u003eFull of the true, the blushful Hippocrene,\u003c/p\u003e\n\u003cp\u003eWith beaded bubbles winking at the brim,\u003c/p\u003e\n\u003cp\u003eAnd purple-stained mouth,\u003c/p\u003e\n\u003cp\u003eThat I may drink, and leave the world unseen,\u003c/p\u003e","title":"Ode to a Nightingale"},{"content":"Hey there! It\u0026rsquo;s GopherDing Here! 本博客目前旨在记录技术沉淀、阅读收获、生活体验及建站技巧，未来内容或有整合及变化，同时将尽力保持滚动更新。\n预期更新列表 曹丕-典论·论文 Bagging和Boosting的区别 论文精读：Time, Clocks, and the Ordering of Events in a Distributed System 论文精读：Insights into DeepSeek-V3: Scaling Challenges and Reflections on Hardware for AI Architectures 毛泽东-改造我们的学习 Transformer系列精讲——Attention Is All You Need 区块链共识算法简介 最近在做什么 构建领英 学习粤语（50%）、英语（30%）、法语（20%） 猛猛刷Leetcode Hot100 过一遍Pytorch 速通量化交易 手撸一个Transformer 学习Markov random fields 本地博客补完计划——运维部分 博客评论区bug修复 博客预期增加在线音乐播放功能，需考虑合规化 凌晨刷大悲25周年、La La Land导致失眠 地铁上看The Lord of the Rings导致坐过站 晚上看看鲁迅全集辅助睡眠，——显然效果不佳 练英语听力，攻关专有名词 有兴致了就翻译一些简短的英语诗歌 研究怎么让博客加载更快（烦 去深圳爽吃一顿 爽爽撸狗 套磁导师 吃麦麦到昏迷，吃三送饭到中毒:-（ 待办事项 改简历，投实习 重学偏微分方程（bushi 老老实实看看动态规划算法 看看Langevin Dynamics怎么搞的 参与一些AI相关的开源 博客功能扩展——PDF支持 本地博客上传——Redis部分 修复评论异常关闭的BUG 看看《雨中曲》《闻香识女人》（此片让名字耽误了） 学学怎么写报告文学 学着做点饭*^____^* 刷一刷法红黑、剧院魅影、小王子 现场听一次正规的交响乐团演出，——大编制的那种 继续学吉他，Hey Jude＞︿＜ 想逛Disney——纠结-ing 想看火箭发射，同时幻想何时能够登月 技术方面 期待成为一名DevOps / AI Infra工程师 | 在读人工智能硕士研究生\nAspiring DevOps / AI Infra Engineer | MSc Artificial Intelligence Student\n• 编程语言：Go, Rust, Java, JavaScript, Python, C, SQL\n• Web开发技术：Gin, Hertz, Spring Framework, Vue, Ajax, HTML, CSS\n• 数据库相关：Gorm, Xorm, MongoDB, MySQL, Redis, PostgreSQL, HBase\n• RPC框架、服务治理与Web服务器：gRPC, Kitex, Nacos, Etcd, PolarisMesh, Nginx\n• 容器编排与集群监控部署：Docker, Kubernetes, Rancher, Helm3, Prometheus, Grafana\n• 分布式与消息队列：Raft, Gossip, ZAB, CAP , BASE, MapReduce, NSQ, Kafka, Zookeeper\n• 开源工具及云平台相关：Git, Gerrit, Hadoop, Elasticsearch, ESXI, OpenWrt, ShadowsocksR, WireShark, GitLab CI/CD, Argo CD, Jupyter Notebook, Alibaba Cloud( ECS, SLB, RDS )\nFocused on:\n重点关注：\n• Embracing \u0026ldquo;Less is More\u0026rdquo; in AI Infra scenarios — pursuing simplicity in system design and adhering to the essence of values during technology selection\n• AI 基础设施场景拥抱“Less is More”——系统设计追求极简，技术选型坚持价值本质\n• Tackling \u0026ldquo;difficult yet correct\u0026rdquo; challenges: optimizing resource scheduling for distributed training clusters \u0026amp; building highly available model deployment pipelines\n• 解决“难而正确”的挑战：优化分布式训练集群的资源调度和构建高可用的模型部署管道\n• Tracking cutting-edge technologies (cloud native, large-model engineering, etc.) and translating tech advancements into practical productivity for infrastructure\n• 跟踪前沿技术（云原生、大模型工程等），将技术进步转化为基础设施的实际生产力\n• Addressing uncertainties in tech iterations with a positive attitude, making data-backed rational judgments, and taking responsibility to drive implementation\n• 以积极心态应对技术迭代中的不确定性，基于数据做出理性判断，并承担责任推动落地\n我的照片 Anyone who has never made a mistake has never tried anything new.\n","permalink":"https://gopherding.github.io/about/","summary":"\u003ch2 id=\"hey-there-it\"\u003e\u003cstrong\u003eHey there! It\u0026rsquo;s GopherDing Here!\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e本博客目前旨在记录技术沉淀、阅读收获、生活体验及建站技巧，未来内容或有整合及变化，同时将尽力保持滚动更新。\u003c/strong\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"预期更新列表\"\u003e\u003cstrong\u003e预期更新列表\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e曹丕-典论·论文\u003c/li\u003e\n\u003cli\u003eBagging和Boosting的区别\u003c/li\u003e\n\u003cli\u003e论文精读：Time, Clocks, and the Ordering of Events in a Distributed System\u003c/li\u003e\n\u003cli\u003e论文精读：Insights into DeepSeek-V3: Scaling Challenges and Reflections on Hardware for AI Architectures\u003c/li\u003e\n\u003cli\u003e毛泽东-改造我们的学习\u003c/li\u003e\n\u003cli\u003eTransformer系列精讲——Attention Is All You Need\u003c/li\u003e\n\u003cli\u003e区块链共识算法简介\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"最近在做什么\"\u003e\u003cstrong\u003e最近在做什么\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e构建领英\u003c/li\u003e\n\u003cli\u003e学习粤语（50%）、英语（30%）、法语（20%）\u003c/li\u003e\n\u003cli\u003e猛猛刷Leetcode Hot100\u003c/li\u003e\n\u003cli\u003e过一遍Pytorch\u003c/li\u003e\n\u003cli\u003e速通量化交易\u003c/li\u003e\n\u003cli\u003e手撸一个Transformer\u003c/li\u003e\n\u003cli\u003e学习Markov random fields\u003c/li\u003e\n\u003cli\u003e本地博客补完计划——运维部分\u003c/li\u003e\n\u003cli\u003e博客评论区bug修复\u003c/li\u003e\n\u003cli\u003e博客预期增加在线音乐播放功能，需考虑合规化\u003c/li\u003e\n\u003cli\u003e凌晨刷大悲25周年、La La Land导致失眠\u003c/li\u003e\n\u003cli\u003e地铁上看The Lord of the Rings导致坐过站\u003c/li\u003e\n\u003cli\u003e晚上看看鲁迅全集辅助睡眠，——显然效果不佳\u003c/li\u003e\n\u003cli\u003e练英语听力，攻关专有名词\u003c/li\u003e\n\u003cli\u003e有兴致了就翻译一些简短的英语诗歌\u003c/li\u003e\n\u003cli\u003e研究怎么让博客加载更快（烦\u003c/li\u003e\n\u003cli\u003e去深圳爽吃一顿\u003c/li\u003e\n\u003cli\u003e爽爽撸狗\u003c/li\u003e\n\u003cli\u003e套磁导师\u003c/li\u003e\n\u003cli\u003e吃麦麦到昏迷，吃三送饭到中毒:-（\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"待办事项\"\u003e\u003cstrong\u003e待办事项\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e改简历，投实习\u003c/li\u003e\n\u003cli\u003e重学偏微分方程（bushi\u003c/li\u003e\n\u003cli\u003e老老实实看看动态规划算法\u003c/li\u003e\n\u003cli\u003e看看Langevin Dynamics怎么搞的\u003c/li\u003e\n\u003cli\u003e参与一些AI相关的开源\u003c/li\u003e\n\u003cli\u003e博客功能扩展——PDF支持\u003c/li\u003e\n\u003cli\u003e本地博客上传——Redis部分\u003c/li\u003e\n\u003cli\u003e修复评论异常关闭的BUG\u003c/li\u003e\n\u003cli\u003e看看《雨中曲》《闻香识女人》（此片让名字耽误了）\u003c/li\u003e\n\u003cli\u003e学学怎么写报告文学\u003c/li\u003e\n\u003cli\u003e学着做点饭*^____^*\u003c/li\u003e\n\u003cli\u003e刷一刷法红黑、剧院魅影、小王子\u003c/li\u003e\n\u003cli\u003e现场听一次正规的交响乐团演出，——大编制的那种\u003c/li\u003e\n\u003cli\u003e继续学吉他，Hey Jude＞︿＜\u003c/li\u003e\n\u003cli\u003e想逛Disney——纠结-ing\u003c/li\u003e\n\u003cli\u003e想看火箭发射，同时幻想何时能够登月\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"技术方面\"\u003e\u003cstrong\u003e技术方面\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e期待成为一名DevOps / AI Infra工程师 | 在读人工智能硕士研究生\u003c/p\u003e","title":"🙋🏻‍♂️关于"},{"content":"CDN失效的解决办法：在Edge中发现页面加载缓慢，本地hugo server -D发现本地依旧缓慢，Edge中F12发现原先的CDN失效，每次请求时间很长。现在，我将把整个发现和解决问题的过程分享出来，希望能帮助到有类似困扰的朋友。\n问题发现 在一次日常浏览自己的 Hugo 博客时，我明显感觉到页面加载速度变得异常缓慢。打开浏览器的开发者工具，在网络面板中发现 Font Awesome 图标无法正常显示，jQuery 相关的交互功能也失效了。查看网络请求，发现引入的 CDN 资源加载时间过长，甚至出现了请求超时的情况。具体涉及的 CDN 代码如下：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 排查过程 寻找代码位置 搜索相关的 CDN 链接关键词，最终在一个模板文件（HUGO\\geo-hugo-papermod\\layouts\\partials\\extend_head.html）中找到了这些代码：\n{{- /* Head custom content area start */ -}} {{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} {{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} {{- /* Head custom content area end */ -}} {{- /* Head custom content area start */ -}} {{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} {{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} {{- /* Head custom content area end */ -}} {{ if (.Params.mermaid) }} \u0026lt;script defer src=\u0026#34;https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var _hmt = _hmt || []; (function() { var hm = document.createElement(\u0026#34;script\u0026#34;); hm.src = \u0026#34;\u0026#34;; var s = document.getElementsByTagName(\u0026#34;script\u0026#34;)[0]; s.parentNode.insertBefore(hm, s); })(); \u0026lt;/script\u0026gt; 分析可能原因 经过分析，我认为 CDN 资源加载缓慢或失效可能是由以下几个原因导致的：\n网络问题：CDN 服务器可能由于维护、故障或网络拥堵等原因，导致资源无法正常访问。 缓存问题：浏览器缓存了旧的资源文件，或者 Hugo 本身的缓存机制影响了新资源的加载。 配置问题：Hugo 的配置文件或模板文件可能存在错误，导致资源链接不正确。 解决办法 更换 CDN 服务 为了避免原 CDN 服务器的问题，我决定更换 CDN 服务。对于 Font Awesome，我将链接替换为 cdnjs 的 CDN：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt; 对于 jQuery，我也使用 cdnjs 的 CDN：\n\u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 清除缓存 为了确保浏览器加载的是新的资源，我清除了浏览器缓存。同时，为了避免 Hugo 缓存的影响，我使用 hugo server -D --gc 命令重新启动开发服务器，其中 --gc 选项会触发垃圾回收，清除无用的缓存文件。\n综合修改后的代码 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 注意：不能直接改public文件夹下的index.html，重启Hugo后会覆盖之，解铃还需系铃人！\n","permalink":"https://gopherding.github.io/posts/blog/cdn%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","summary":"\u003cp\u003eCDN失效的解决办法：在Edge中发现页面加载缓慢，本地hugo server -D发现本地依旧缓慢，Edge中F12发现原先的CDN失效，每次请求时间很长。现在，我将把整个发现和解决问题的过程分享出来，希望能帮助到有类似困扰的朋友。\u003c/p\u003e\n\u003ch3 id=\"问题发现\"\u003e问题发现\u003c/h3\u003e\n\u003cp\u003e在一次日常浏览自己的 Hugo 博客时，我明显感觉到页面加载速度变得异常缓慢。打开浏览器的开发者工具，在网络面板中发现 Font Awesome 图标无法正常显示，jQuery 相关的交互功能也失效了。查看网络请求，发现引入的 CDN 资源加载时间过长，甚至出现了请求超时的情况。具体涉及的 CDN 代码如下：\u003c/p\u003e","title":"CDN失效的解决办法"},{"content":" 太原理工大学创新实验室 太原理工大学创新实验室官网 klenkiven | 凛冬将至 klenkiven的博客 uublog | 博识笔记 一只yodama的博客 Halfrost\u0026#39;s Field | 冰霜之地 Dezhi Yu的博客 👉友链格式 名称： uublog 网址： https://uublog.xyz/ 图标： https://uublog.xyz/avatar.jpg 描述： 一只youdama的博客 👉友链申请要求 来E-Mail我就好啦，欢迎骚扰 : -）\nwenzong.ding@foxmail.com\nwenzongding2003@gmail.com\n","permalink":"https://gopherding.github.io/links/","summary":"\u003cdiv class=\"friend\"\u003e\n\u003ca target=\"_blank\" href=http://www.cxlab.tech/ title=太原理工大学创新实验室 class=\"friendurl\"\u003e\n  \u003cdiv class=\"frienddiv\"\u003e\n    \u003cdiv class=\"frienddivleft\"\u003e\n      \u003cimg class=\"myfriend\" src=https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/22763c70dab62daa6921c1a339b1789cceecbb99a892f6906a6e5f39ca314a207c4ad423ff5262cf31e8e59c5622e859?pictype\u0026#61;scale\u0026amp;from\u0026#61;30013\u0026amp;version\u0026#61;3.3.3.3\u0026amp;fname\u0026#61;2024-08-30bwY42.png\u0026amp;size\u0026#61;1000 /\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"frienddivright\"\u003e\n      \u003cdiv class=\"friendname\"\u003e太原理工大学创新实验室\u003c/div\u003e\n      \u003cdiv class=\"friendinfo\"\u003e太原理工大学创新实验室官网\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/a\u003e\n\n\u003ca target=\"_blank\" href=https://www.klenkiven.xyz/ title=klenkiven\u0026#32;|\u0026#32;凛冬将至 class=\"friendurl\"\u003e\n  \u003cdiv class=\"frienddiv\"\u003e\n    \u003cdiv class=\"frienddivleft\"\u003e\n      \u003cimg class=\"myfriend\" src=https://klenkiven-blog-image.oss-cn-zhangjiakou.aliyuncs.com/img/ARCHLINUXLOGO.png /\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"frienddivright\"\u003e\n      \u003cdiv class=\"friendname\"\u003eklenkiven | 凛冬将至\u003c/div\u003e\n      \u003cdiv class=\"friendinfo\"\u003eklenkiven的博客\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/a\u003e\n\n\u003ca target=\"_blank\" href=http://47.94.211.21:88/ title=uublog\u0026#32;|\u0026#32;博识笔记 class=\"friendurl\"\u003e\n  \u003cdiv class=\"frienddiv\"\u003e\n    \u003cdiv class=\"frienddivleft\"\u003e\n      \u003cimg class=\"myfriend\" src=http://47.94.211.21:88/avatar.jpg /\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"frienddivright\"\u003e\n      \u003cdiv class=\"friendname\"\u003euublog | 博识笔记\u003c/div\u003e\n      \u003cdiv class=\"friendinfo\"\u003e一只yodama的博客\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/a\u003e\n\n\u003ca target=\"_blank\" href=https://halfrost.com/ title=Halfrost\u0026#39;s\u0026#32;Field\u0026#32;|\u0026#32;冰霜之地 class=\"friendurl\"\u003e\n  \u003cdiv class=\"frienddiv\"\u003e\n    \u003cdiv class=\"frienddivleft\"\u003e\n      \u003cimg class=\"myfriend\" src=https://img.halfrost.com/Blog/ArticleTitleImage/me.jpg /\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"frienddivright\"\u003e\n      \u003cdiv class=\"friendname\"\u003eHalfrost\u0026#39;s Field | 冰霜之地\u003c/div\u003e\n      \u003cdiv class=\"friendinfo\"\u003eDezhi Yu的博客\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/a\u003e\n\n\u003c/div\u003e\n\u003cbr/\u003e\n\u003cbr/\u003e\n\u003cdiv style=\"font-size: 20px;\" class=\"youlian\"\u003e👉友链格式\u003c/div\u003e\n\u003cdiv style=\"font-size: 16px;\"\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e名称：\u003c/td\u003e\n          \u003ctd\u003euublog\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e网址：\u003c/td\u003e\n          \u003ctd\u003e\u003ca href=\"https://uublog.xyz/\"\u003ehttps://uublog.xyz/\u003c/a\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e图标：\u003c/td\u003e\n          \u003ctd\u003e\u003ca href=\"https://uublog.xyz/avatar.jpg\"\u003ehttps://uublog.xyz/avatar.jpg\u003c/a\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e描述：\u003c/td\u003e\n          \u003ctd\u003e一只youdama的博客\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/div\u003e\n\u003cbr/\u003e\n\u003cdiv style=\"font-size: 20px;\"\u003e👉友链申请要求\u003c/div\u003e\n\u003cblockquote\u003e\n\u003cp\u003e来E-Mail我就好啦，欢迎骚扰 : -）\u003c/p\u003e","title":"🤝友链"},{"content":"在 Go 语言中，sync.RWMutex 读写锁的实现原理涉及多个关键部分，下面从其核心数据结构、获取读锁、获取写锁、释放读锁和释放写锁等方面详细介绍：\n核心数据结构 type RWMutex struct { w Mutex // 用于保护写操作的互斥锁 writerSem uint32 // 写操作的信号量 readerSem uint32 // 读操作的信号量 readerCount int32 // 当前读操作的数量 readerWait int32 // 写操作等待时需要等待的读操作数量 } w：这是一个普通的互斥锁（Mutex），用于保护对 readerCount 和 readerWait 等字段的并发访问，确保在修改这些关键状态时的原子性。 writerSem：写操作的信号量，用于阻塞和唤醒等待的写操作 goroutine。当写操作需要等待读操作完成时，会通过这个信号量进入阻塞状态；当所有读操作完成后，会通过这个信号量唤醒等待的写操作。 readerSem：读操作的信号量，用于阻塞和唤醒等待的读操作 goroutine。当写操作正在进行时，新的读操作会通过这个信号量进入阻塞状态；当写操作完成后，会通过这个信号量唤醒等待的读操作。 readerCount：记录当前正在进行的读操作的数量。读操作开始时会增加这个计数器，读操作结束时会减少这个计数器。 readerWait：记录写操作等待时需要等待的读操作数量。当写操作请求锁时，会将当前的 readerCount 值赋给 readerWait，表示写操作需要等待这些读操作完成。 获取读锁（RLock 方法） func (rw *RWMutex) RLock() { if atomic.AddInt32(\u0026amp;rw.readerCount, 1) \u0026lt; 0 { // 有写操作正在进行或者有写操作在等待，当前读操作需要阻塞 runtime_SemacquireMutex(\u0026amp;rw.readerSem, false, 0) } } 调用 atomic.AddInt32(\u0026amp;rw.readerCount, 1) 原子地将 readerCount 加 1，表示有一个新的读操作开始。 如果 readerCount 变为负数，说明有写操作正在进行或者有写操作在等待（因为在写操作请求锁时，会将 readerCount 减去一个特定的常量 rwmutexMaxReaders，使其变为负数），此时当前读操作会调用 runtime_SemacquireMutex 方法，通过 readerSem 信号量进入阻塞状态，直到写操作完成。 获取写锁（Lock 方法） func (rw *RWMutex) Lock() { // 先获取互斥锁，保证对后续操作的独占访问 rw.w.Lock() // 记录当前需要等待的读操作数量 r := atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders if r != 0 \u0026amp;\u0026amp; atomic.AddInt32(\u0026amp;rw.readerWait, r) != 0 { // 有读操作正在进行，当前写操作需要阻塞 runtime_SemacquireMutex(\u0026amp;rw.writerSem, false, 0) } } 首先调用 rw.w.Lock() 获取互斥锁，确保在修改 readerCount 和 readerWait 时的原子性。 调用 atomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders) 将 readerCount 减去一个特定的常量 rwmutexMaxReaders，使其变为负数，表示有写操作正在请求锁。然后加上 rwmutexMaxReaders 得到当前正在进行的读操作数量 r。 如果 r 不为 0，说明有读操作正在进行，将 r 赋值给 readerWait，表示写操作需要等待这些读操作完成。如果 readerWait 不为 0，当前写操作会调用 runtime_SemacquireMutex 方法，通过 writerSem 信号量进入阻塞状态，直到所有读操作完成。 释放读锁（RUnlock 方法） func (rw *RWMutex) RUnlock() { if r := atomic.AddInt32(\u0026amp;rw.readerCount, -1); r \u0026lt; 0 { // 有写操作在等待，检查是否所有读操作都完成了 if atomic.AddInt32(\u0026amp;rw.readerWait, -1) == 0 { // 所有读操作都完成了，唤醒等待的写操作 runtime_Semrelease(\u0026amp;rw.writerSem, false, 1) } } } 调用 atomic.AddInt32(\u0026amp;rw.readerCount, -1) 原子地将 readerCount 减 1，表示一个读操作结束。 如果 readerCount 为负数，说明有写操作在等待。此时将 readerWait 减 1，如果 readerWait 变为 0，说明所有读操作都完成了，调用 runtime_Semrelease 方法，通过 writerSem 信号量唤醒等待的写操作。 释放写锁（Unlock 方法） func (rw *RWMutex) Unlock() { // 恢复读操作计数器 r := atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders) // 唤醒所有等待的读操作 for i := 0; i \u0026lt; int(r); i++ { runtime_Semrelease(\u0026amp;rw.readerSem, false, 0) } // 释放互斥锁 rw.w.Unlock() } 调用 atomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders) 将 readerCount 恢复为正数，表示写操作结束。 根据 readerCount 的值，循环调用 runtime_Semrelease 方法，通过 readerSem 信号量唤醒所有等待的读操作。 最后调用 rw.w.Unlock() 释放互斥锁，允许其他操作继续进行。 总结 Go 语言的 sync.RWMutex 读写锁通过使用互斥锁、信号量和计数器等机制，实现了对共享资源的读写分离控制。多个读操作可以并发进行，提高了系统的并发性能；而写操作具有独占性，保证了数据的一致性和完整性。在实际应用中，根据不同的场景合理使用读写锁，可以有效地提高程序的性能和并发处理能力。\n说人话版： 核心规则和数据 把读写锁想象成图书馆的管理规则，而图书馆里的书就是共享资源。读写锁有几个重要的 “规则记录本”（对应代码里的数据）：\n普通门锁钥匙（w）：这就像是一把特殊的钥匙，只有拿到它才能去修改 “规则记录本” 上的内容，保证记录信息的准确性。 写操作等待室门铃（writerSem）：当有读者想要修改图书内容（写操作），但前面有其他读者正在看书（读操作）时，他就得去等待室，等待室的门铃响了才代表可以进去修改图书。 读操作等待室门铃（readerSem）：要是有读者想进图书馆看书（读操作），但刚好有人在修改图书（写操作），他就得去另一个等待室，等门铃响了才能进去看书。 正在看书的读者数量（readerCount）：记录当前有多少读者正在图书馆里看书。 修改图书的人要等的看书读者数量（readerWait）：当有读者想要修改图书时，要先看看有多少人正在看书，把这个数量记下来，等这些人都看完书才能去修改。 获取读锁（读者想进图书馆看书） 图书馆门口有个计数器，代表正在看书的读者数量。有新读者想进来时，计数器加 1。 如果发现计数器变成负数了（这就好像图书馆挂出了 “有人正在修改图书，暂时不能进” 的牌子），那新读者就得去读操作等待室等着，等门铃响了才能进去。 获取写锁（读者想修改图书内容） 想修改图书的读者得先拿到普通门锁钥匙，这样才能去改 “规则记录本” 上的信息。 他会先看一下当前有多少读者正在看书，把这个数量记下来当作要等的人数。同时，他会把计数器改成负数，告诉后面来的读者 “有人要修改图书啦，先别进”。 如果还有读者正在看书，那想修改图书的读者就得去写操作等待室等着，等门铃响了才能去修改。 释放读锁（读者看完书离开图书馆） 读者看完书离开时，计数器减 1。 如果发现计数器是负数（说明有人在等着修改图书），那就看一下要等的看书读者数量，如果这个数量变成 0 了，就按一下写操作等待室的门铃，告诉等着修改图书的人可以进来了。 释放写锁（读者修改完图书） 读者修改完图书后，把计数器恢复成正常的正数，代表可以有新读者进来看书了。 根据计数器上记录的之前因为修改图书而在等待的读者数量，挨个按读操作等待室的门铃，让他们进来看书。 最后把普通门锁钥匙还回去，其他人又可以来修改 “规则记录本” 了。 通过这样的方式，读写锁实现了多个读者可以同时看书（多个读操作并发），但有人修改图书时其他人不能看也不能改（写操作独占），提高了图书馆（程序）的使用效率。\n","permalink":"https://gopherding.github.io/posts/tech/go%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"\u003cp\u003e在 Go 语言中，\u003ccode\u003esync.RWMutex\u003c/code\u003e 读写锁的实现原理涉及多个关键部分，下面从其核心数据结构、获取读锁、获取写锁、释放读锁和释放写锁等方面详细介绍：\u003c/p\u003e\n\u003ch3 id=\"核心数据结构\"\u003e核心数据结构\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eRWMutex\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ew\u003c/span\u003e           \u003cspan style=\"color:#a6e22e\"\u003eMutex\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// 用于保护写操作的互斥锁\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ewriterSem\u003c/span\u003e   \u003cspan style=\"color:#66d9ef\"\u003euint32\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e// 写操作的信号量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ereaderSem\u003c/span\u003e   \u003cspan style=\"color:#66d9ef\"\u003euint32\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e// 读操作的信号量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ereaderCount\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint32\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// 当前读操作的数量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ereaderWait\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint32\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// 写操作等待时需要等待的读操作数量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ew\u003c/code\u003e：这是一个普通的互斥锁（\u003ccode\u003eMutex\u003c/code\u003e），用于保护对 \u003ccode\u003ereaderCount\u003c/code\u003e 和 \u003ccode\u003ereaderWait\u003c/code\u003e 等字段的并发访问，确保在修改这些关键状态时的原子性。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewriterSem\u003c/code\u003e：写操作的信号量，用于阻塞和唤醒等待的写操作 goroutine。当写操作需要等待读操作完成时，会通过这个信号量进入阻塞状态；当所有读操作完成后，会通过这个信号量唤醒等待的写操作。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereaderSem\u003c/code\u003e：读操作的信号量，用于阻塞和唤醒等待的读操作 goroutine。当写操作正在进行时，新的读操作会通过这个信号量进入阻塞状态；当写操作完成后，会通过这个信号量唤醒等待的读操作。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereaderCount\u003c/code\u003e：记录当前正在进行的读操作的数量。读操作开始时会增加这个计数器，读操作结束时会减少这个计数器。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereaderWait\u003c/code\u003e：记录写操作等待时需要等待的读操作数量。当写操作请求锁时，会将当前的 \u003ccode\u003ereaderCount\u003c/code\u003e 值赋给 \u003ccode\u003ereaderWait\u003c/code\u003e，表示写操作需要等待这些读操作完成。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"获取读锁rlock-方法\"\u003e获取读锁（\u003ccode\u003eRLock\u003c/code\u003e 方法）\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eRWMutex\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eRLock\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eatomic\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAddInt32\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ereaderCount\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) \u0026lt; \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// 有写操作正在进行或者有写操作在等待，当前读操作需要阻塞\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eruntime_SemacquireMutex\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ereaderSem\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e调用 \u003ccode\u003eatomic.AddInt32(\u0026amp;rw.readerCount, 1)\u003c/code\u003e 原子地将 \u003ccode\u003ereaderCount\u003c/code\u003e 加 1，表示有一个新的读操作开始。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003ereaderCount\u003c/code\u003e 变为负数，说明有写操作正在进行或者有写操作在等待（因为在写操作请求锁时，会将 \u003ccode\u003ereaderCount\u003c/code\u003e 减去一个特定的常量 \u003ccode\u003erwmutexMaxReaders\u003c/code\u003e，使其变为负数），此时当前读操作会调用 \u003ccode\u003eruntime_SemacquireMutex\u003c/code\u003e 方法，通过 \u003ccode\u003ereaderSem\u003c/code\u003e 信号量进入阻塞状态，直到写操作完成。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"获取写锁lock-方法\"\u003e获取写锁（\u003ccode\u003eLock\u003c/code\u003e 方法）\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eRWMutex\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eLock\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 先获取互斥锁，保证对后续操作的独占访问\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ew\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eLock\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 记录当前需要等待的读操作数量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eatomic\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAddInt32\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ereaderCount\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erwmutexMaxReaders\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003erwmutexMaxReaders\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eatomic\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAddInt32\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ereaderWait\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// 有读操作正在进行，当前写操作需要阻塞\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eruntime_SemacquireMutex\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ewriterSem\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e首先调用 \u003ccode\u003erw.w.Lock()\u003c/code\u003e 获取互斥锁，确保在修改 \u003ccode\u003ereaderCount\u003c/code\u003e 和 \u003ccode\u003ereaderWait\u003c/code\u003e 时的原子性。\u003c/li\u003e\n\u003cli\u003e调用 \u003ccode\u003eatomic.AddInt32(\u0026amp;rw.readerCount, -rwmutexMaxReaders)\u003c/code\u003e 将 \u003ccode\u003ereaderCount\u003c/code\u003e 减去一个特定的常量 \u003ccode\u003erwmutexMaxReaders\u003c/code\u003e，使其变为负数，表示有写操作正在请求锁。然后加上 \u003ccode\u003erwmutexMaxReaders\u003c/code\u003e 得到当前正在进行的读操作数量 \u003ccode\u003er\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003er\u003c/code\u003e 不为 0，说明有读操作正在进行，将 \u003ccode\u003er\u003c/code\u003e 赋值给 \u003ccode\u003ereaderWait\u003c/code\u003e，表示写操作需要等待这些读操作完成。如果 \u003ccode\u003ereaderWait\u003c/code\u003e 不为 0，当前写操作会调用 \u003ccode\u003eruntime_SemacquireMutex\u003c/code\u003e 方法，通过 \u003ccode\u003ewriterSem\u003c/code\u003e 信号量进入阻塞状态，直到所有读操作完成。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"释放读锁runlock-方法\"\u003e释放读锁（\u003ccode\u003eRUnlock\u003c/code\u003e 方法）\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eRWMutex\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eRUnlock\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eatomic\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAddInt32\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ereaderCount\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e); \u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e \u0026lt; \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// 有写操作在等待，检查是否所有读操作都完成了\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eatomic\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAddInt32\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ereaderWait\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e// 所有读操作都完成了，唤醒等待的写操作\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003eruntime_Semrelease\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ewriterSem\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e调用 \u003ccode\u003eatomic.AddInt32(\u0026amp;rw.readerCount, -1)\u003c/code\u003e 原子地将 \u003ccode\u003ereaderCount\u003c/code\u003e 减 1，表示一个读操作结束。\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003ereaderCount\u003c/code\u003e 为负数，说明有写操作在等待。此时将 \u003ccode\u003ereaderWait\u003c/code\u003e 减 1，如果 \u003ccode\u003ereaderWait\u003c/code\u003e 变为 0，说明所有读操作都完成了，调用 \u003ccode\u003eruntime_Semrelease\u003c/code\u003e 方法，通过 \u003ccode\u003ewriterSem\u003c/code\u003e 信号量唤醒等待的写操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"释放写锁unlock-方法\"\u003e释放写锁（\u003ccode\u003eUnlock\u003c/code\u003e 方法）\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eRWMutex\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eUnlock\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 恢复读操作计数器\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eatomic\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAddInt32\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ereaderCount\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003erwmutexMaxReaders\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 唤醒所有等待的读操作\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u0026lt; int(\u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e); \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eruntime_Semrelease\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ereaderSem\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 释放互斥锁\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003erw\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ew\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eUnlock\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e调用 \u003ccode\u003eatomic.AddInt32(\u0026amp;rw.readerCount, rwmutexMaxReaders)\u003c/code\u003e 将 \u003ccode\u003ereaderCount\u003c/code\u003e 恢复为正数，表示写操作结束。\u003c/li\u003e\n\u003cli\u003e根据 \u003ccode\u003ereaderCount\u003c/code\u003e 的值，循环调用 \u003ccode\u003eruntime_Semrelease\u003c/code\u003e 方法，通过 \u003ccode\u003ereaderSem\u003c/code\u003e 信号量唤醒所有等待的读操作。\u003c/li\u003e\n\u003cli\u003e最后调用 \u003ccode\u003erw.w.Unlock()\u003c/code\u003e 释放互斥锁，允许其他操作继续进行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"总结\"\u003e总结\u003c/h3\u003e\n\u003cp\u003eGo 语言的 \u003ccode\u003esync.RWMutex\u003c/code\u003e 读写锁通过使用互斥锁、信号量和计数器等机制，实现了对共享资源的读写分离控制。多个读操作可以并发进行，提高了系统的并发性能；而写操作具有独占性，保证了数据的一致性和完整性。在实际应用中，根据不同的场景合理使用读写锁，可以有效地提高程序的性能和并发处理能力。\u003c/p\u003e","title":"Go读写锁的实现"},{"content":"移动端显示测试 这是一篇用于测试移动端显示效果的文章。\n二级标题测试 这里是一些普通的段落文本，用来测试在移动设备上的显示效果。文本应该具有良好的可读性，合适的行高和字体大小。\n三级标题测试 代码块测试 function mobileTest() { console.log(\u0026#34;这是一个代码块测试\u0026#34;); const longVariableName = \u0026#34;测试长代码在移动端的显示\u0026#34;; return longVariableName; } 列表测试 这是一个无序列表项 第二个列表项，内容比较长，用来测试在移动端的换行效果 第三个列表项 有序列表第一项 有序列表第二项，同样内容较长，测试移动端显示 有序列表第三项 引用块测试 这是一个引用块的内容，用来测试在移动设备上的显示效果。引用块应该具有明显的视觉区分，并且在小屏幕上保持良好的可读性。\n表格测试 列1 列2 列3 内容1 内容2 内容3 较长的内容测试 另一个较长的内容 第三列内容 图片测试 总结 这篇文章包含了各种常见的内容元素，用于测试移动端的显示效果。\n","permalink":"https://gopherding.github.io/posts/blog/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%B5%8B%E8%AF%95/","summary":"\u003ch1 id=\"移动端显示测试\"\u003e移动端显示测试\u003c/h1\u003e\n\u003cp\u003e这是一篇用于测试移动端显示效果的文章。\u003c/p\u003e\n\u003ch2 id=\"二级标题测试\"\u003e二级标题测试\u003c/h2\u003e\n\u003cp\u003e这里是一些普通的段落文本，用来测试在移动设备上的显示效果。文本应该具有良好的可读性，合适的行高和字体大小。\u003c/p\u003e\n\u003ch3 id=\"三级标题测试\"\u003e三级标题测试\u003c/h3\u003e\n\u003ch4 id=\"代码块测试\"\u003e代码块测试\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emobileTest\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003econsole\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elog\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;这是一个代码块测试\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003elongVariableName\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;测试长代码在移动端的显示\u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003elongVariableName\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"列表测试\"\u003e列表测试\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e这是一个无序列表项\u003c/li\u003e\n\u003cli\u003e第二个列表项，内容比较长，用来测试在移动端的换行效果\u003c/li\u003e\n\u003cli\u003e第三个列表项\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e有序列表第一项\u003c/li\u003e\n\u003cli\u003e有序列表第二项，同样内容较长，测试移动端显示\u003c/li\u003e\n\u003cli\u003e有序列表第三项\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"引用块测试\"\u003e引用块测试\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这是一个引用块的内容，用来测试在移动设备上的显示效果。引用块应该具有明显的视觉区分，并且在小屏幕上保持良好的可读性。\u003c/p\u003e","title":"移动端显示测试"},{"content":"非常推荐去看原文↓\n字节跳动技术团队\n单元化概述 概念：将业务按维度划分成单元，理想情况下单元自包含，能独立处理业务流程，数据分散在各单元且组合完整，流量按分区维度调度，保证同一分区数据写入同一单元。 原因：解决资源限制、合规要求和容灾需求，同时带来业务体验提升、成本降低、隔离风险等收益。 挑战：包括机房延迟、数据同步、流量路由、数据正确性、成本和管理复杂度等问题。 字节跳动异地单元化架构 架构设计：围绕客户端选路、接入层纠偏、计算层纠偏、存储访问层管控构建流量调度和管控能力，确保流量和数据访问正确性，生产环境已接入众多核心微服务和实例。 关键问题及解决方式 单元维度选择：综合业务特性和核心问题，选择 Region 维度构建单元，形成同城容灾 + 异地多活架构。 分区维度选择：常见以用户（UserID）或 Region 为分区维度，需考虑数据不重叠、流量调度灵活性、路由计算轻量和单元内调用闭环等因素。 流量单元化调度：通过映射表和表达式管理分区和单元映射，在客户端、接入层、计算层和存储层根据必要性进行路由信息计算和纠偏。 复杂业务调度适配：区分本地服务和中心服务，不同服务类型决定流量调度方式和数据同步方式，降低业务理解和管理复杂度。 多单元数据管理：单元间数据同步分单向和双向，考虑防回环和唯一 Key 冲突处理，通过实时增量比对和周期全量比对保证数据同步一致性，重点检测和处理热键。 数据多活正确性保证：日常态通过存储访问中间件识别和拦截异常单元化流量；切流态采用两阶段配置变更 + 存储访问禁写避免数据脏写，同时优化配置下发时效、防止路由死循环并检查各层状态。 切流可靠性和风险控制：包括优化配置下发时效、防止路由死循环和检查业务架构各层状态。 跨地区 RPC 质量提升：通过跨单元 RPC 通道收敛和跨单元网络分级 QoS 管控优化跨地区 RPC 质量。 未来演进思考 多单元研发成本和效率优化：降低多 Region 视角下的研发和业务管理成本。 极致成本优化：计算资源和存储资源成本在异地单元化架构下有望进一步优化。 复杂单元化架构演进：应对区域增多和业务发展带来的流量调度、数据单元化和同步模型的变化，解决数据识别和搬迁问题。 完善数据多活能力：满足电商、支付类等高数据一致性要求业务的需求，发展跨 Region 强一致数据库。 ","permalink":"https://gopherding.github.io/posts/tech/%E5%8D%95%E5%85%83%E5%8C%96%E6%9E%B6%E6%9E%84%E5%9C%A8%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E7%9A%84%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/","summary":"\u003cp\u003e非常推荐去看原文↓\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s/ODogMQ0N6ppNjssRK_uD_A\"\u003e字节跳动技术团队\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"单元化概述\"\u003e单元化概述\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e概念\u003c/strong\u003e：将业务按维度划分成单元，理想情况下单元自包含，能独立处理业务流程，数据分散在各单元且组合完整，流量按分区维度调度，保证同一分区数据写入同一单元。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e原因\u003c/strong\u003e：解决资源限制、合规要求和容灾需求，同时带来业务体验提升、成本降低、隔离风险等收益。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e挑战\u003c/strong\u003e：包括机房延迟、数据同步、流量路由、数据正确性、成本和管理复杂度等问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"字节跳动异地单元化架构\"\u003e字节跳动异地单元化架构\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e架构设计\u003c/strong\u003e：围绕客户端选路、接入层纠偏、计算层纠偏、存储访问层管控构建流量调度和管控能力，确保流量和数据访问正确性，生产环境已接入众多核心微服务和实例。\u003c/li\u003e\n\u003cli\u003e关键问题及解决方式\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e单元维度选择\u003c/strong\u003e：综合业务特性和核心问题，选择 Region 维度构建单元，形成同城容灾 + 异地多活架构。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e分区维度选择\u003c/strong\u003e：常见以用户（UserID）或 Region 为分区维度，需考虑数据不重叠、流量调度灵活性、路由计算轻量和单元内调用闭环等因素。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e流量单元化调度\u003c/strong\u003e：通过映射表和表达式管理分区和单元映射，在客户端、接入层、计算层和存储层根据必要性进行路由信息计算和纠偏。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e复杂业务调度适配\u003c/strong\u003e：区分本地服务和中心服务，不同服务类型决定流量调度方式和数据同步方式，降低业务理解和管理复杂度。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e多单元数据管理\u003c/strong\u003e：单元间数据同步分单向和双向，考虑防回环和唯一 Key 冲突处理，通过实时增量比对和周期全量比对保证数据同步一致性，重点检测和处理热键。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据多活正确性保证\u003c/strong\u003e：日常态通过存储访问中间件识别和拦截异常单元化流量；切流态采用两阶段配置变更 + 存储访问禁写避免数据脏写，同时优化配置下发时效、防止路由死循环并检查各层状态。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e切流可靠性和风险控制\u003c/strong\u003e：包括优化配置下发时效、防止路由死循环和检查业务架构各层状态。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e跨地区 RPC 质量提升\u003c/strong\u003e：通过跨单元 RPC 通道收敛和跨单元网络分级 QoS 管控优化跨地区 RPC 质量。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"未来演进思考\"\u003e未来演进思考\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e多单元研发成本和效率优化\u003c/strong\u003e：降低多 Region 视角下的研发和业务管理成本。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e极致成本优化\u003c/strong\u003e：计算资源和存储资源成本在异地单元化架构下有望进一步优化。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e复杂单元化架构演进\u003c/strong\u003e：应对区域增多和业务发展带来的流量调度、数据单元化和同步模型的变化，解决数据识别和搬迁问题。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e完善数据多活能力\u003c/strong\u003e：满足电商、支付类等高数据一致性要求业务的需求，发展跨 Region 强一致数据库。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/zjtdOPS.png\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"单元化架构在字节跳动的落地实践"},{"content":"转载自：https://mp.weixin.qq.com/s/_P1-w-eMS0R2YRWCT71gg\n基础架构概述 架构目标与挑战：架构的核心是解决软件系统复杂性，互联网大体量业务面临高可用、高性能、高扩展、低成本、安全性和多功能等挑战。高可用要减少故障影响并快速恢复；高性能需应对海量请求和高并发；高扩展要适应多变的业务；低成本追求投入产出比最大化；安全性保护数据和隐私；多功能要求架构有前瞻性。 基础架构构成：基础架构包括接入层、逻辑层、数据层。接入层负责用户接入，逻辑层处理业务逻辑，数据层存储和管理数据，数据层是异地多活架构设计的关键切入点。 异地多活解析 容灾需求演变：业务发展使容灾需求从应对单机器故障（如数据备份、主从搭建），到单机房故障（多机房部署），最终到解决城市单点故障（异地多活）。 异地多活的必要性：城市级灾害影响范围大，需将服务部署在千里之外，如不同城市圈的城市组合，以实现异地多活的容灾目标。 写时延的关键作用 数据层写操作核心地位：逻辑层无状态可无缝切换，数据层的写操作因涉及数据同步、一致性保障，成为基础架构容灾的关键。 跨城写时延影响及应对策略：跨城写时延显著增加，影响业务可用性。若业务能接受，可采用跨城同步复制；否则，可选择缩短距离同步复制（如 100 - 200 公里城市间，时延 5 - 7ms）或异步复制就近分片。异步复制适用于数据一致性要求不高的业务（如微博、视频），而对一致性要求高的业务（如金融、支付）需特殊处理，如圈定影响数据并拒绝相关操作。 写量大与隔离的分片策略 写量大拆分片：写请求量大时需分片处理，就近分片可减少耗时。对于膨胀型数据（如电商订单数据），可通过分库分表和存档处理，避免硬件资源浪费。 做隔离拆分片：为降低故障影响，数据层及相关依赖需进行隔离，如 “单元化”“SET 化”“条带化” 等方案，这在同城和异地容灾中均常用。 其他影响因素 读操作影响：读操作影响主要体现在副本管理、缓存机制和连接管理上。写后立即读归入写操作范畴；适当延迟读可通过就近副本满足。业务对读时延要求更严苛，多数读场景可接受适当延迟。 读量大与连接管理：读多写少业务可扩充副本，副本扩展到一定规模时可采用级联同步减少写点负载。同时，为避免数据库连接过多导致性能下降，可添加代理收拢连接。 数据复制架构 常见架构模式：常见数据复制架构包括三地五中心（1 主 4 从分布在 3 个城市 5 个 IDC 机房，写请求需写入 3 个实例）、三地三中心（可满足容灾但跨城切换复杂，一般较少采用）、同城三中心（用于不能接受跨城时延的场景，可实现有损跨城容灾）、双主互复制（每个实例有完整数据，规避写冲突，跨城容灾时通过时间位点记录处理，但可能产生重复数据和写冲突）。 未同步名单机制：为解决重复数据问题，可采用未同步名单机制。写操作前记录数据属主，同步后清理，写入前检查，存在于名单中则拒绝请求，配合双主互复制可保障数据一致性。 数据对路由的影响 跨城全局数据路由：数据不分片，写入点唯一，多副本提供就近读取，适合全链路就近路由，也可在接入层路由分流，但意义不大。 就近分片数据路由：为减少写操作跨城时延，需在接入层将请求路由到数据所在城市（机房），读请求可采用相同策略。 跨城分片数据路由：能接受跨城延时，分片主写点分布在不同城市和机房，路由与就近分片类似，但需引入第三城市做数据容灾。 架构选型模式 架构选型需综合考虑跨城写时延、写量支撑、隔离要求等因素，同时成本等因素也可能起决定性作用，应根据业务具体情况分析确定。\n","permalink":"https://gopherding.github.io/posts/tech/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","summary":"\u003cp\u003e转载自：https://mp.weixin.qq.com/s/_P1-w-eMS0R2YRWCT71gg\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"基础架构概述\"\u003e\u003cstrong\u003e基础架构概述\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e架构目标与挑战\u003c/strong\u003e：架构的核心是解决软件系统复杂性，互联网大体量业务面临高可用、高性能、高扩展、低成本、安全性和多功能等挑战。高可用要减少故障影响并快速恢复；高性能需应对海量请求和高并发；高扩展要适应多变的业务；低成本追求投入产出比最大化；安全性保护数据和隐私；多功能要求架构有前瞻性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e基础架构构成\u003c/strong\u003e：基础架构包括接入层、逻辑层、数据层。接入层负责用户接入，逻辑层处理业务逻辑，数据层存储和管理数据，数据层是异地多活架构设计的关键切入点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"异地多活解析\"\u003e\u003cstrong\u003e异地多活解析\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e容灾需求演变\u003c/strong\u003e：业务发展使容灾需求从应对单机器故障（如数据备份、主从搭建），到单机房故障（多机房部署），最终到解决城市单点故障（异地多活）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e异地多活的必要性\u003c/strong\u003e：城市级灾害影响范围大，需将服务部署在千里之外，如不同城市圈的城市组合，以实现异地多活的容灾目标。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"写时延的关键作用\"\u003e\u003cstrong\u003e写时延的关键作用\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e数据层写操作核心地位\u003c/strong\u003e：逻辑层无状态可无缝切换，数据层的写操作因涉及数据同步、一致性保障，成为基础架构容灾的关键。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e跨城写时延影响及应对策略\u003c/strong\u003e：跨城写时延显著增加，影响业务可用性。若业务能接受，可采用跨城同步复制；否则，可选择缩短距离同步复制（如 100 - 200 公里城市间，时延 5 - 7ms）或异步复制就近分片。异步复制适用于数据一致性要求不高的业务（如微博、视频），而对一致性要求高的业务（如金融、支付）需特殊处理，如圈定影响数据并拒绝相关操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"写量大与隔离的分片策略\"\u003e\u003cstrong\u003e写量大与隔离的分片策略\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e写量大拆分片\u003c/strong\u003e：写请求量大时需分片处理，就近分片可减少耗时。对于膨胀型数据（如电商订单数据），可通过分库分表和存档处理，避免硬件资源浪费。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e做隔离拆分片\u003c/strong\u003e：为降低故障影响，数据层及相关依赖需进行隔离，如 “单元化”“SET 化”“条带化” 等方案，这在同城和异地容灾中均常用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"其他影响因素\"\u003e\u003cstrong\u003e其他影响因素\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e读操作影响\u003c/strong\u003e：读操作影响主要体现在副本管理、缓存机制和连接管理上。写后立即读归入写操作范畴；适当延迟读可通过就近副本满足。业务对读时延要求更严苛，多数读场景可接受适当延迟。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e读量大与连接管理\u003c/strong\u003e：读多写少业务可扩充副本，副本扩展到一定规模时可采用级联同步减少写点负载。同时，为避免数据库连接过多导致性能下降，可添加代理收拢连接。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"数据复制架构\"\u003e\u003cstrong\u003e数据复制架构\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e常见架构模式\u003c/strong\u003e：常见数据复制架构包括三地五中心（1 主 4 从分布在 3 个城市 5 个 IDC 机房，写请求需写入 3 个实例）、三地三中心（可满足容灾但跨城切换复杂，一般较少采用）、同城三中心（用于不能接受跨城时延的场景，可实现有损跨城容灾）、双主互复制（每个实例有完整数据，规避写冲突，跨城容灾时通过时间位点记录处理，但可能产生重复数据和写冲突）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e未同步名单机制\u003c/strong\u003e：为解决重复数据问题，可采用未同步名单机制。写操作前记录数据属主，同步后清理，写入前检查，存在于名单中则拒绝请求，配合双主互复制可保障数据一致性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"数据对路由的影响\"\u003e\u003cstrong\u003e数据对路由的影响\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e跨城全局数据路由\u003c/strong\u003e：数据不分片，写入点唯一，多副本提供就近读取，适合全链路就近路由，也可在接入层路由分流，但意义不大。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e就近分片数据路由\u003c/strong\u003e：为减少写操作跨城时延，需在接入层将请求路由到数据所在城市（机房），读请求可采用相同策略。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e跨城分片数据路由\u003c/strong\u003e：能接受跨城延时，分片主写点分布在不同城市和机房，路由与就近分片类似，但需引入第三城市做数据容灾。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"架构选型模式\"\u003e\u003cstrong\u003e架构选型模式\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e架构选型需综合考虑跨城写时延、写量支撑、隔离要求等因素，同时成本等因素也可能起决定性作用，应根据业务具体情况分析确定。\u003c/p\u003e","title":"异地多活架构设计"},{"content":"匆匆 燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候。但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？——是有人偷了他们罢：那是谁？又藏在何处呢？是他们自己逃走了罢：现在又到了哪里呢？我不知道他们给了我多少日子；但我的手确乎是渐渐空虚了。在默默里算着，八千多个日子已经从我手中溜去；像针尖上一滴水滴在大海里，我的日子滴在时间的流里，没有声音，也没有影子。我不禁头涔涔而泪潸潸了。\n去的尽管去了，来的尽管来着；去来的中间，又怎样地匆匆呢？早上我起来的时候，小屋里射进两三方斜斜的太阳。太阳他有脚啊，轻轻悄悄地挪移了；我也茫茫然跟着旋转。于是——洗手的时候，日子从水盆里过去；吃饭的时候，日子从饭碗里过去；默默时，便从凝然的双眼前过去。我觉察他去的匆匆了，伸出手遮挽时，他又从遮挽着的手边过去，天黑时，我躺在床上，他便伶伶俐俐地从我身上跨过，从我脚边飞去了。等我睁开眼和太阳再见，这算又溜走了一日。我掩着面叹息。但是新来的日子的影儿又开始在叹息里闪过了。\n在逃去如飞的日子里，在千门万户的世界里的我能做些什么呢？只有徘徊罢了，只有匆匆罢了；在八千多日的匆匆里，除徘徊外，又剩些什么呢？过去的日子如轻烟，被微风吹散了，如薄雾，被初阳蒸融了；我留着些什么痕迹呢？我何曾留着像游丝样的痕迹呢？我赤裸裸来到这世界，转眼间也将赤裸裸的回去罢？但不能平的，为什么偏要白白走这一遭啊？\n你聪明的，告诉我，我们的日子为什么一去不复返呢？\n1922年3月28日\n","permalink":"https://gopherding.github.io/posts/read/%E5%8C%86%E5%8C%86/","summary":"\u003ch3 id=\"匆匆\"\u003e匆匆\u003c/h3\u003e\n\u003cp\u003e燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候。但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？——是有人偷了他们罢：那是谁？又藏在何处呢？是他们自己逃走了罢：现在又到了哪里呢？我不知道他们给了我多少日子；但我的手确乎是渐渐空虚了。在默默里算着，八千多个日子已经从我手中溜去；像针尖上一滴水滴在大海里，我的日子滴在时间的流里，没有声音，也没有影子。我不禁头涔涔而泪潸潸了。\u003c/p\u003e","title":"匆匆"},{"content":"详解及图片来源：https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\n","permalink":"https://gopherding.github.io/posts/tech/%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/","summary":"\u003cp\u003e详解及图片来源：\u003ca href=\"https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\"\u003ehttps://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/MQ.png\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"常见消息队列的技术选型"},{"content":"一、GitLab CI/CD 概述： GitLab CI/CD 是 GitLab 提供的一套持续集成和持续部署（CI/CD）解决方案。它与 GitLab 紧密集成，可以在代码提交到 GitLab 仓库后自动触发构建、测试和部署流程。 通过在项目中定义 .gitlab-ci.yml 文件，开发人员可以配置各种 CI/CD 任务，如编译代码、运行测试、构建容器镜像和部署应用程序等。 主要功能： 持续集成：自动检测代码变更并触发构建和测试流程，确保代码的质量和稳定性。 持续部署：支持将应用程序部署到不同的环境，如开发、测试和生产环境。可以通过定义部署策略和流程来确保部署的可靠性和安全性。 集成其他工具：可以与各种工具和服务集成，如 Docker、Kubernetes、Jenkins 等，以实现更复杂的 CI/CD 流程。 可视化和监控：提供可视化的管道界面，方便用户查看 CI/CD 流程的状态和进度。同时，还可以设置监控和报警机制，及时发现和解决问题。 适用场景： 适用于使用 GitLab 作为代码托管平台的团队，特别是那些需要在同一个平台上管理代码、问题跟踪和 CI/CD 流程的团队。 对于小型到中型规模的项目，GitLab CI/CD 提供了一个简单而强大的解决方案，可以快速搭建和管理 CI/CD 流程。 二、Argo CD 概述： Argo CD 是一个用于实现 GitOps 持续部署的工具。它遵循 GitOps 原则，将应用程序的期望状态定义在 Git 存储库中，并通过监控 Git 存储库的变化来自动同步和部署应用程序。 Argo CD 可以与各种 Git 存储库和 Kubernetes 集群集成，实现应用程序的自动化部署和管理。 主要功能： GitOps 驱动：通过将应用程序的配置和部署定义存储在 Git 存储库中，实现了应用程序的版本控制和可追溯性。开发人员可以通过提交代码到 Git 存储库来触发应用程序的部署，而运维人员可以通过查看 Git 历史记录来了解应用程序的变更情况。 多环境管理：支持在不同的环境中部署应用程序，如开发、测试和生产环境。可以通过定义不同的 Git 存储库或分支来实现环境之间的隔离和差异管理。 应用程序同步和部署：自动监控 Git 存储库的变化，并将应用程序的配置和部署定义同步到 Kubernetes 集群中。可以实现自动化的部署、升级和回滚等操作，提高部署的效率和可靠性。 可视化和监控：提供可视化的界面，方便用户查看应用程序的状态和部署历史。同时，还可以设置监控和报警机制，及时发现和解决问题。 适用场景： 适用于采用 GitOps 原则进行应用程序部署和管理的团队。特别是对于大型企业和复杂的分布式系统，Argo CD 可以提供更好的可扩展性和管理性。 对于需要在多个环境中部署应用程序的团队，Argo CD 的多环境管理功能可以帮助实现环境之间的一致性和可重复性。 三、两者的比较 一、功能定位 Argo CD： 主要聚焦于持续部署（CD），遵循 GitOps 理念，将应用的期望状态定义在 Git 仓库中，并自动同步和部署到 Kubernetes 集群。 强调对 Kubernetes 资源的管理和部署，确保集群中的应用状态与 Git 仓库中的定义保持一致。 GitLab CI/CD： 提供完整的持续集成（CI）和持续部署流程。 涵盖从代码提交触发的构建、测试，到部署到各种环境的全过程。不仅限于 Kubernetes，还可以部署到其他平台。 二、工作流程 Argo CD： 监控 Git 仓库的变化，当发现应用配置发生改变时，自动将新的配置同步到 Kubernetes 集群中。 通常与 Kubernetes 紧密结合，通过 Kubernetes API 进行资源的管理和部署。 GitLab CI/CD： 通过在项目中定义.gitlab-ci.yml文件，配置一系列的 CI/CD 任务。 当代码提交到 GitLab 仓库后，触发流水线执行任务，包括构建、测试、部署等步骤。 三、适用场景 Argo CD： 适用于以 Kubernetes 为基础的云原生应用部署场景。 对于希望采用 GitOps 方式管理 Kubernetes 应用的团队来说非常合适。 GitLab CI/CD： 适用于各种软件开发项目，无论是传统的应用还是云原生应用。 尤其对于使用 GitLab 作为代码托管和项目管理平台的团队，能够提供一站式的 CI/CD 解决方案。 四、集成性 Argo CD： 主要与 Kubernetes 集成，也可以与一些其他工具配合使用，但相对来说集成范围较窄。 GitLab CI/CD： 可以与众多工具集成，如 Docker、Jenkins、Ansible 等，具有更广泛的集成能力。 五、配置复杂度 Argo CD： 配置相对较为复杂，需要对 Kubernetes 和 GitOps 有一定的了解。 涉及到 Kubernetes 资源的定义和管理，以及 Git 仓库的配置。 GitLab CI/CD： 配置相对较为直观，通过.gitlab-ci.yml文件进行任务定义，对于熟悉 YAML 格式的开发人员来说比较容易上手。 ","permalink":"https://gopherding.github.io/posts/tech/gitlab-cicd-%E5%92%8C-argo-cd/","summary":"\u003ch3 id=\"一gitlab-cicd\"\u003e\u003cstrong\u003e一、GitLab CI/CD\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"概述\"\u003e\u003cstrong\u003e概述\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eGitLab CI/CD 是 GitLab 提供的一套持续集成和持续部署（CI/CD）解决方案。它与 GitLab 紧密集成，可以在代码提交到 GitLab 仓库后自动触发构建、测试和部署流程。\u003c/li\u003e\n\u003cli\u003e通过在项目中定义 \u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e 文件，开发人员可以配置各种 CI/CD 任务，如编译代码、运行测试、构建容器镜像和部署应用程序等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"主要功能\"\u003e\u003cstrong\u003e主要功能\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e持续集成\u003c/strong\u003e：自动检测代码变更并触发构建和测试流程，确保代码的质量和稳定性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e持续部署\u003c/strong\u003e：支持将应用程序部署到不同的环境，如开发、测试和生产环境。可以通过定义部署策略和流程来确保部署的可靠性和安全性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e集成其他工具\u003c/strong\u003e：可以与各种工具和服务集成，如 Docker、Kubernetes、Jenkins 等，以实现更复杂的 CI/CD 流程。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e可视化和监控\u003c/strong\u003e：提供可视化的管道界面，方便用户查看 CI/CD 流程的状态和进度。同时，还可以设置监控和报警机制，及时发现和解决问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"适用场景\"\u003e\u003cstrong\u003e适用场景\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e适用于使用 GitLab 作为代码托管平台的团队，特别是那些需要在同一个平台上管理代码、问题跟踪和 CI/CD 流程的团队。\u003c/li\u003e\n\u003cli\u003e对于小型到中型规模的项目，GitLab CI/CD 提供了一个简单而强大的解决方案，可以快速搭建和管理 CI/CD 流程。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二argo-cd\"\u003e\u003cstrong\u003e二、Argo CD\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"概述-1\"\u003e\u003cstrong\u003e概述\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eArgo CD 是一个用于实现 GitOps 持续部署的工具。它遵循 GitOps 原则，将应用程序的期望状态定义在 Git 存储库中，并通过监控 Git 存储库的变化来自动同步和部署应用程序。\u003c/li\u003e\n\u003cli\u003eArgo CD 可以与各种 Git 存储库和 Kubernetes 集群集成，实现应用程序的自动化部署和管理。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"主要功能-1\"\u003e\u003cstrong\u003e主要功能\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGitOps 驱动\u003c/strong\u003e：通过将应用程序的配置和部署定义存储在 Git 存储库中，实现了应用程序的版本控制和可追溯性。开发人员可以通过提交代码到 Git 存储库来触发应用程序的部署，而运维人员可以通过查看 Git 历史记录来了解应用程序的变更情况。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e多环境管理\u003c/strong\u003e：支持在不同的环境中部署应用程序，如开发、测试和生产环境。可以通过定义不同的 Git 存储库或分支来实现环境之间的隔离和差异管理。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e应用程序同步和部署\u003c/strong\u003e：自动监控 Git 存储库的变化，并将应用程序的配置和部署定义同步到 Kubernetes 集群中。可以实现自动化的部署、升级和回滚等操作，提高部署的效率和可靠性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e可视化和监控\u003c/strong\u003e：提供可视化的界面，方便用户查看应用程序的状态和部署历史。同时，还可以设置监控和报警机制，及时发现和解决问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"适用场景-1\"\u003e\u003cstrong\u003e适用场景\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e适用于采用 GitOps 原则进行应用程序部署和管理的团队。特别是对于大型企业和复杂的分布式系统，Argo CD 可以提供更好的可扩展性和管理性。\u003c/li\u003e\n\u003cli\u003e对于需要在多个环境中部署应用程序的团队，Argo CD 的多环境管理功能可以帮助实现环境之间的一致性和可重复性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三两者的比较\"\u003e\u003cstrong\u003e三、两者的比较\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"一功能定位\"\u003e\u003cstrong\u003e一、功能定位\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch5 id=\"argo-cd\"\u003e\u003cstrong\u003eArgo CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e主要聚焦于持续部署（CD），遵循 GitOps 理念，将应用的期望状态定义在 Git 仓库中，并自动同步和部署到 Kubernetes 集群。\u003c/li\u003e\n\u003cli\u003e强调对 Kubernetes 资源的管理和部署，确保集群中的应用状态与 Git 仓库中的定义保持一致。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"gitlab-cicd\"\u003e\u003cstrong\u003eGitLab CI/CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e提供完整的持续集成（CI）和持续部署流程。\u003c/li\u003e\n\u003cli\u003e涵盖从代码提交触发的构建、测试，到部署到各种环境的全过程。不仅限于 Kubernetes，还可以部署到其他平台。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"二工作流程\"\u003e\u003cstrong\u003e二、工作流程\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch5 id=\"argo-cd-1\"\u003e\u003cstrong\u003eArgo CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e监控 Git 仓库的变化，当发现应用配置发生改变时，自动将新的配置同步到 Kubernetes 集群中。\u003c/li\u003e\n\u003cli\u003e通常与 Kubernetes 紧密结合，通过 Kubernetes API 进行资源的管理和部署。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"gitlab-cicd-1\"\u003e\u003cstrong\u003eGitLab CI/CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e通过在项目中定义\u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e文件，配置一系列的 CI/CD 任务。\u003c/li\u003e\n\u003cli\u003e当代码提交到 GitLab 仓库后，触发流水线执行任务，包括构建、测试、部署等步骤。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"三适用场景\"\u003e\u003cstrong\u003e三、适用场景\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch5 id=\"argo-cd-2\"\u003e\u003cstrong\u003eArgo CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e适用于以 Kubernetes 为基础的云原生应用部署场景。\u003c/li\u003e\n\u003cli\u003e对于希望采用 GitOps 方式管理 Kubernetes 应用的团队来说非常合适。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"gitlab-cicd-2\"\u003e\u003cstrong\u003eGitLab CI/CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e适用于各种软件开发项目，无论是传统的应用还是云原生应用。\u003c/li\u003e\n\u003cli\u003e尤其对于使用 GitLab 作为代码托管和项目管理平台的团队，能够提供一站式的 CI/CD 解决方案。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"四集成性\"\u003e\u003cstrong\u003e四、集成性\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch5 id=\"argo-cd-3\"\u003e\u003cstrong\u003eArgo CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e主要与 Kubernetes 集成，也可以与一些其他工具配合使用，但相对来说集成范围较窄。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"gitlab-cicd-3\"\u003e\u003cstrong\u003eGitLab CI/CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e可以与众多工具集成，如 Docker、Jenkins、Ansible 等，具有更广泛的集成能力。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"五配置复杂度\"\u003e\u003cstrong\u003e五、配置复杂度\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch5 id=\"argo-cd-4\"\u003e\u003cstrong\u003eArgo CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e配置相对较为复杂，需要对 Kubernetes 和 GitOps 有一定的了解。\u003c/li\u003e\n\u003cli\u003e涉及到 Kubernetes 资源的定义和管理，以及 Git 仓库的配置。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"gitlab-cicd-4\"\u003e\u003cstrong\u003eGitLab CI/CD\u003c/strong\u003e：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e配置相对较为直观，通过\u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e文件进行任务定义，对于熟悉 YAML 格式的开发人员来说比较容易上手。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"GitLab CICD 和 Argo CD"},{"content":"中国人失掉自信力了吗 从公开的文字上看起来：两年以前，我们总自夸着 “地大物博”，是事实；不久就不再自夸了，只希望着国联，也是事实；现在是既不夸自己，也不信国联，改为一味求神拜佛，怀古伤今了 —— 却也是事实。\n于是有人慨叹曰：中国人失掉自信力了。\n如果单据这一点现象而论，自信其实是早就失掉了的。先前信 “地”，信 “物”，后来信 “国联”，都没有相信过 “自己”。假使这也算一种 “信”，那也只能说中国人曾经有过 “他信力”，自从对国联失望之后，便把这他信力都失掉了。\n失掉了他信力，就会疑，一个转身，也许能够只相信了自己，倒是一条新生路，但不幸的是逐渐玄虚起来了。信 “地” 和 “物”，还是切实的东西，国联就渺茫，不过这还可以令人不久就省悟到依赖它的不可靠。一到求神拜佛，可就玄虚之至了，有益或是有害，一时就找不出分明的结果来，它可以令人更长久的麻醉着自己。\n中国人现在是在发展着 “自欺力”。\n“自欺” 也并非现在的新东西，现在只不过日见其明显，笼罩了一切罢了。然而，在这笼罩之下，我们有并不失掉自信力的中国人在。\n我们从古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人，…… 虽是等于为帝王将相作家谱的所谓 “正史”，也往往掩不住他们的光耀，这就是中国的脊梁。\n这一类的人们，就是现在也何尝少呢？他们有确信，不自欺；他们在前仆后继的战斗，不过一面总在被摧残，被抹杀，消灭于黑暗中，不能为大家所知道罢了。说中国人失掉了自信力，用以指一部分人则可，倘若加于全体，那简直是诬蔑。\n要论中国人，必须不被搽在表面的自欺欺人的脂粉所诓骗，却看看他的筋骨和脊梁。自信力的有无，状元宰相的文章是不足为据的，要自己去看地底下。\n九月二十五日\n","permalink":"https://gopherding.github.io/posts/read/%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%A4%B1%E6%8E%89%E8%87%AA%E4%BF%A1%E5%8A%9B%E4%BA%86%E5%90%97/","summary":"\u003ch3 id=\"中国人失掉自信力了吗\"\u003e中国人失掉自信力了吗\u003c/h3\u003e\n\u003cp\u003e从公开的文字上看起来：两年以前，我们总自夸着 “地大物博”，是事实；不久就不再自夸了，只希望着国联，也是事实；现在是既不夸自己，也不信国联，改为一味求神拜佛，怀古伤今了 —— 却也是事实。\u003c/p\u003e\n\u003cp\u003e于是有人慨叹曰：中国人失掉自信力了。\u003c/p\u003e\n\u003cp\u003e如果单据这一点现象而论，自信其实是早就失掉了的。先前信 “地”，信 “物”，后来信 “国联”，都没有相信过 “自己”。假使这也算一种 “信”，那也只能说中国人曾经有过 “他信力”，自从对国联失望之后，便把这他信力都失掉了。\u003c/p\u003e","title":"中国人失掉自信力了吗"},{"content":"以下是关于 ELK 和 EFK 的对比解析：\nELK 核心组件 Elasticsearch 分布式搜索引擎，负责存储、检索和分析海量数据。支持实时查询和高可用性，适用于日志、指标等场景。 Logstash 数据收集和处理引擎，支持多种输入源（如文件、数据库、消息队列）。提供强大的过滤和转换能力（如正则解析、字段提取），但资源消耗较高。 Kibana 数据可视化平台，用于生成图表、仪表盘，支持交互式查询和分析。 典型架构 日志采集：Logstash 从文件、数据库等读取原始日志。 数据处理：Logstash 通过解析规则（如 grok 插件）清洗数据。 存储与检索：清洗后的数据存入 Elasticsearch。 可视化：Kibana 展示日志趋势、错误分布等。 优点 功能全面：Logstash 支持复杂的数据处理逻辑。 生态成熟：丰富的插件体系（如 beats 输入插件）。 缺点 资源消耗大：Logstash 在数据量大时易成为性能瓶颈。 复杂度高：配置和维护成本较高。 EFK 核心组件 Elasticsearch（同上） Fluentd/Fluent Bit 轻量级日志收集器，专为容器化环境设计。Fluentd 功能全面，Fluent Bit 更轻量（适合边缘设备）。 Kibana（同上） 典型架构（以 Kubernetes 为例） 日志采集： Fluentd 以 DaemonSet 部署在每个节点，通过 tail 插件采集容器日志。 自动关联 Kubernetes 元数据（如 Pod 名称、命名空间）。 数据处理： Fluentd 使用过滤器（如 record_transformer）添加标签或删除冗余字段。 存储与检索：数据发送到 Elasticsearch。 可视化：Kibana 展示日志，支持按集群、节点、Pod 等多维度过滤。 优点 轻量化：Fluentd/Fluent Bit 资源占用低，适合容器环境。 云原生友好：天然支持 Kubernetes 元数据，集成 Prometheus 监控。 灵活性：支持插件扩展（如 kafka 输出插件）。 缺点 功能限制：相比 Logstash，复杂数据处理能力较弱（如多层嵌套日志解析）。 ELK vs EFK 关键区别 对比项 ELK EFK 日志收集器 Logstash Fluentd/Fluent Bit 资源消耗 高（JVM 内存占用大） 低（适合容器化环境） 适用场景 传统服务器日志处理 云原生、Kubernetes 环境 数据处理能力 强大（支持复杂解析） 中等（依赖插件扩展） 部署复杂度 较高 较低 应用场景 ELK 传统服务器日志分析，需复杂清洗（如多行日志合并）。 大数据场景，需 Logstash 的丰富插件支持（如 JDBC 读取数据库）。 EFK Kubernetes / 容器化环境，需低资源占用的日志采集。 云原生场景，需与 Prometheus、Grafana 等工具集成。 总结 选择 ELK：适合需要复杂数据处理且资源充足的传统环境。 选择 EFK：适合云原生、Kubernetes 等轻量化场景，尤其是资源敏感型应用。 混合使用：例如用 Fluentd 采集日志，Logstash 做二次处理（通过 fluentd 输入插件）。 ","permalink":"https://gopherding.github.io/posts/tech/elk%E5%92%8Cefk/","summary":"\u003cp\u003e以下是关于 \u003cstrong\u003eELK\u003c/strong\u003e 和 \u003cstrong\u003eEFK\u003c/strong\u003e 的对比解析：\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"elk\"\u003e\u003cstrong\u003eELK\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"核心组件\"\u003e核心组件\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eElasticsearch\u003c/strong\u003e\n分布式搜索引擎，负责存储、检索和分析海量数据。支持实时查询和高可用性，适用于日志、指标等场景。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLogstash\u003c/strong\u003e\n数据收集和处理引擎，支持多种输入源（如文件、数据库、消息队列）。提供强大的过滤和转换能力（如正则解析、字段提取），但资源消耗较高。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKibana\u003c/strong\u003e\n数据可视化平台，用于生成图表、仪表盘，支持交互式查询和分析。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"典型架构\"\u003e典型架构\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e日志采集\u003c/strong\u003e：Logstash 从文件、数据库等读取原始日志。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据处理\u003c/strong\u003e：Logstash 通过解析规则（如 \u003ccode\u003egrok\u003c/code\u003e 插件）清洗数据。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e存储与检索\u003c/strong\u003e：清洗后的数据存入 Elasticsearch。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e可视化\u003c/strong\u003e：Kibana 展示日志趋势、错误分布等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"优点\"\u003e优点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e功能全面\u003c/strong\u003e：Logstash 支持复杂的数据处理逻辑。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e生态成熟\u003c/strong\u003e：丰富的插件体系（如 \u003ccode\u003ebeats\u003c/code\u003e 输入插件）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"缺点\"\u003e缺点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e资源消耗大\u003c/strong\u003e：Logstash 在数据量大时易成为性能瓶颈。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e复杂度高\u003c/strong\u003e：配置和维护成本较高。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"efk\"\u003e\u003cstrong\u003eEFK\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"核心组件-1\"\u003e核心组件\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eElasticsearch\u003c/strong\u003e（同上）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFluentd/Fluent Bit\u003c/strong\u003e\n轻量级日志收集器，专为容器化环境设计。Fluentd 功能全面，Fluent Bit 更轻量（适合边缘设备）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKibana\u003c/strong\u003e（同上）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"典型架构以-kubernetes-为例\"\u003e典型架构（以 Kubernetes 为例）\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e日志采集：\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eFluentd 以 DaemonSet 部署在每个节点，通过 \u003ccode\u003etail\u003c/code\u003e 插件采集容器日志。\u003c/li\u003e\n\u003cli\u003e自动关联 Kubernetes 元数据（如 Pod 名称、命名空间）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据处理：\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eFluentd 使用过滤器（如 \u003ccode\u003erecord_transformer\u003c/code\u003e）添加标签或删除冗余字段。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e存储与检索\u003c/strong\u003e：数据发送到 Elasticsearch。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e可视化\u003c/strong\u003e：Kibana 展示日志，支持按集群、节点、Pod 等多维度过滤。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"优点-1\"\u003e优点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e轻量化\u003c/strong\u003e：Fluentd/Fluent Bit 资源占用低，适合容器环境。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e云原生友好\u003c/strong\u003e：天然支持 Kubernetes 元数据，集成 Prometheus 监控。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e灵活性\u003c/strong\u003e：支持插件扩展（如 \u003ccode\u003ekafka\u003c/code\u003e 输出插件）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"缺点-1\"\u003e缺点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e功能限制\u003c/strong\u003e：相比 Logstash，复杂数据处理能力较弱（如多层嵌套日志解析）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"elk-vs-efk-关键区别\"\u003e\u003cstrong\u003eELK vs EFK 关键区别\u003c/strong\u003e\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003cstrong\u003e对比项\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003e\u003cstrong\u003eELK\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003e\u003cstrong\u003eEFK\u003c/strong\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e日志收集器\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eLogstash\u003c/td\u003e\n          \u003ctd\u003eFluentd/Fluent Bit\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e资源消耗\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e高（JVM 内存占用大）\u003c/td\u003e\n          \u003ctd\u003e低（适合容器化环境）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e适用场景\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e传统服务器日志处理\u003c/td\u003e\n          \u003ctd\u003e云原生、Kubernetes 环境\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e数据处理能力\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e强大（支持复杂解析）\u003c/td\u003e\n          \u003ctd\u003e中等（依赖插件扩展）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e部署复杂度\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e较高\u003c/td\u003e\n          \u003ctd\u003e较低\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch3 id=\"应用场景\"\u003e\u003cstrong\u003e应用场景\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eELK\n\u003cul\u003e\n\u003cli\u003e传统服务器日志分析，需复杂清洗（如多行日志合并）。\u003c/li\u003e\n\u003cli\u003e大数据场景，需 Logstash 的丰富插件支持（如 \u003ccode\u003eJDBC\u003c/code\u003e 读取数据库）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eEFK\n\u003cul\u003e\n\u003cli\u003eKubernetes / 容器化环境，需低资源占用的日志采集。\u003c/li\u003e\n\u003cli\u003e云原生场景，需与 Prometheus、Grafana 等工具集成。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch3 id=\"总结\"\u003e\u003cstrong\u003e总结\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e选择 ELK\u003c/strong\u003e：适合需要复杂数据处理且资源充足的传统环境。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e选择 EFK\u003c/strong\u003e：适合云原生、Kubernetes 等轻量化场景，尤其是资源敏感型应用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e混合使用\u003c/strong\u003e：例如用 Fluentd 采集日志，Logstash 做二次处理（通过 \u003ccode\u003efluentd\u003c/code\u003e 输入插件）。\u003c/li\u003e\n\u003c/ul\u003e","title":"ELK和EFK"},{"content":"交换机层面 在交换机层面实现网络带宽 quota 平均，主要可通过以下几种方式：\n基于端口的带宽限制 原理：利用交换机的端口限速功能，为每个端口设定固定的带宽上限。可以基于物理端口进行设置，也可以针对端口下的不同 VLAN 进行设置。 实现方式：在交换机的配置界面中，进入相应端口或 VLAN 的配置模式，使用命令设置带宽限制值。例如，在 Cisco 交换机中，可使用 “interface FastEthernet0/1” 进入端口 1 的配置模式，然后通过 “speed 100” 和 “duplex full” 设置端口速率和双工模式，再使用 “traffic-shape rate 10000000” 命令将该端口的带宽限制为 10Mbps。 基于队列的调度算法 原理：将端口的流量划分为多个队列，每个队列对应不同类型的业务或用户。交换机根据预设的调度算法，如加权轮询（WRR）、严格优先级（SP）等，在各个队列之间分配带宽。 实现方式：以华为交换机为例，首先创建队列并绑定到端口，如 “interface GigabitEthernet0/0/1” 进入端口配置，然后 “queue-scheduler wrr 10 20 30 40” 配置 WRR 调度算法，为四个队列分别分配 10%、20%、30%、40% 的带宽权重。若采用 SP 算法，可设置 “queue-scheduler sp”，并为不同队列配置优先级，高优先级队列优先获得带宽。 基于流量分类的带宽分配 原理：通过访问控制列表（ACL）或 MAC 地址表等对流量进行分类，识别出不同来源、目的或协议类型的流量，然后为不同类别的流量分配相应的带宽 quota。 实现方式：在 H3C 交换机上，先定义 ACL 规则来匹配流量，如 “acl number 2000” 创建 ACL 2000，然后 “rule 0 permit source 192.168.1.0 0.0.0.255” 允许源 IP 为 192.168.1.0/24 网段的流量通过。接着创建 QoS 策略，将 ACL 与带宽分配关联起来，“qos policy policy1” 创建 QoS 策略，“classifier c1 operator or acl 2000” 将 ACL 2000 与分类器关联，“behavior b1 bandwidth committed-rate 20480” 为匹配的流量分配 20Mbps 的带宽。 基于端口镜像的流量监测与控制 原理：将交换机某个端口或 VLAN 的流量复制一份到监控端口，通过连接到监控端口的流量监测设备，实时监测流量情况。根据监测结果，对异常流量或超出 quota 的流量进行控制。 实现方式：在锐捷交换机中，使用 “monitor session 1 source interface GigabitEthernet 0/1” 命令将端口 1 的流量作为源流量进行镜像，再使用 “monitor session 1 destination interface GigabitEthernet 0/2” 将镜像流量发送到端口 2。通过连接到端口 2 的流量监测设备，如网络分析仪，实时查看流量数据。若发现某个 IP 地址的流量超出 quota，可在交换机上通过配置 ACL 或 QoS 策略，对该 IP 的流量进行限制。 基于流控的带宽管理 原理：当交换机检测到某个端口或链路的流量即将超出带宽 quota 时，通过发送流控帧等方式，通知上游设备降低发送速率，以避免网络拥塞，实现带宽的平均分配。 实现方式：在多数交换机中，流控功能默认是关闭的，需要手动开启。如在戴尔交换机中，进入全局配置模式 “configure terminal”，然后进入端口配置模式 “interface Ethernet1/0/1”，使用 “flowcontrol receive on” 命令开启端口的接收流控功能，“flowcontrol transmit on” 开启发送流控功能。交换机将根据端口的带宽使用情况，自动发送或接收流控帧，调节流量。 OpenWrt实现 在 OpenWRT 系统中，可以通过多种方式实现网络带宽 quota 平均，以下是一些常见的方法：\n使用 LuCI 界面配置 安装 LuCI：OpenWRT 默认可能没有安装 LuCI 图形界面，需要通过命令行安装。连接到 OpenWRT 设备的命令行界面，使用包管理工具 opkg 进行安装，如opkg update \u0026amp;\u0026amp; opkg install luci。 配置 QoS：安装完成后，在浏览器中输入 OpenWRT 设备的 IP 地址，进入 LuCI 界面。在 LuCI 界面中找到 “网络” 选项卡，点击 “QoS”。在这里可以创建 QoS 规则，通过 “添加规则” 按钮，选择要设置带宽限制的接口，如 LAN 口。在 “目标” 字段中，可以选择 “网络中的主机”，然后输入要限制带宽的设备 IP 地址。在 “带宽限制” 部分，设置上传和下载带宽的具体数值，以实现对特定设备的带宽 quota 平均分配。 设置调度算法：在 QoS 设置页面，通常可以选择调度算法，如令牌桶算法等。令牌桶算法可以通过控制令牌的生成速率和桶的容量来限制流量速率，确保带宽的合理分配。选择合适的算法后，根据实际需求配置相关参数，如令牌生成速率、桶容量等。 使用 SQM 插件 安装 SQM：SQM（Simple Queue Management）是 OpenWRT 中常用的带宽管理插件。通过命令行安装，opkg install sqm-scripts。 配置 SQM：安装完成后，编辑 SQM 配置文件，通常位于/etc/config/sqm。在配置文件中，定义要管理的接口和带宽限制参数。例如，以下配置将对 eth0 接口进行带宽管理，下载带宽限制为 20Mbps，上传带宽限制为 10Mbps。 config queue option interface \u0026#39;eth0\u0026#39; option download \u0026#39;20mbit\u0026#39; option upload \u0026#39;10mbit\u0026#39; 保存配置文件后，重启 SQM 服务使配置生效，/etc/init.d/sqm restart。\n","permalink":"https://gopherding.github.io/posts/tech/%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4quota%E5%B9%B3%E5%9D%87%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"\u003ch3 id=\"交换机层面\"\u003e交换机层面\u003c/h3\u003e\n\u003cp\u003e在交换机层面实现网络带宽 quota 平均，主要可通过以下几种方式：\u003c/p\u003e\n\u003ch4 id=\"基于端口的带宽限制\"\u003e基于端口的带宽限制\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e原理\u003c/strong\u003e：利用交换机的端口限速功能，为每个端口设定固定的带宽上限。可以基于物理端口进行设置，也可以针对端口下的不同 VLAN 进行设置。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实现方式\u003c/strong\u003e：在交换机的配置界面中，进入相应端口或 VLAN 的配置模式，使用命令设置带宽限制值。例如，在 Cisco 交换机中，可使用 “interface FastEthernet0/1” 进入端口 1 的配置模式，然后通过 “speed 100” 和 “duplex full” 设置端口速率和双工模式，再使用 “traffic-shape rate 10000000” 命令将该端口的带宽限制为 10Mbps。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"基于队列的调度算法\"\u003e基于队列的调度算法\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e原理\u003c/strong\u003e：将端口的流量划分为多个队列，每个队列对应不同类型的业务或用户。交换机根据预设的调度算法，如加权轮询（WRR）、严格优先级（SP）等，在各个队列之间分配带宽。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实现方式\u003c/strong\u003e：以华为交换机为例，首先创建队列并绑定到端口，如 “interface GigabitEthernet0/0/1” 进入端口配置，然后 “queue-scheduler wrr 10 20 30 40” 配置 WRR 调度算法，为四个队列分别分配 10%、20%、30%、40% 的带宽权重。若采用 SP 算法，可设置 “queue-scheduler sp”，并为不同队列配置优先级，高优先级队列优先获得带宽。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"基于流量分类的带宽分配\"\u003e基于流量分类的带宽分配\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e原理\u003c/strong\u003e：通过访问控制列表（ACL）或 MAC 地址表等对流量进行分类，识别出不同来源、目的或协议类型的流量，然后为不同类别的流量分配相应的带宽 quota。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实现方式\u003c/strong\u003e：在 H3C 交换机上，先定义 ACL 规则来匹配流量，如 “acl number 2000” 创建 ACL 2000，然后 “rule 0 permit source 192.168.1.0 0.0.0.255” 允许源 IP 为 192.168.1.0/24 网段的流量通过。接着创建 QoS 策略，将 ACL 与带宽分配关联起来，“qos policy policy1” 创建 QoS 策略，“classifier c1 operator or acl 2000” 将 ACL 2000 与分类器关联，“behavior b1 bandwidth committed-rate 20480” 为匹配的流量分配 20Mbps 的带宽。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"基于端口镜像的流量监测与控制\"\u003e基于端口镜像的流量监测与控制\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e原理\u003c/strong\u003e：将交换机某个端口或 VLAN 的流量复制一份到监控端口，通过连接到监控端口的流量监测设备，实时监测流量情况。根据监测结果，对异常流量或超出 quota 的流量进行控制。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实现方式\u003c/strong\u003e：在锐捷交换机中，使用 “monitor session 1 source interface GigabitEthernet 0/1” 命令将端口 1 的流量作为源流量进行镜像，再使用 “monitor session 1 destination interface GigabitEthernet 0/2” 将镜像流量发送到端口 2。通过连接到端口 2 的流量监测设备，如网络分析仪，实时查看流量数据。若发现某个 IP 地址的流量超出 quota，可在交换机上通过配置 ACL 或 QoS 策略，对该 IP 的流量进行限制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"基于流控的带宽管理\"\u003e基于流控的带宽管理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e原理\u003c/strong\u003e：当交换机检测到某个端口或链路的流量即将超出带宽 quota 时，通过发送流控帧等方式，通知上游设备降低发送速率，以避免网络拥塞，实现带宽的平均分配。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实现方式\u003c/strong\u003e：在多数交换机中，流控功能默认是关闭的，需要手动开启。如在戴尔交换机中，进入全局配置模式 “configure terminal”，然后进入端口配置模式 “interface Ethernet1/0/1”，使用 “flowcontrol receive on” 命令开启端口的接收流控功能，“flowcontrol transmit on” 开启发送流控功能。交换机将根据端口的带宽使用情况，自动发送或接收流控帧，调节流量。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"openwrt实现\"\u003eOpenWrt实现\u003c/h3\u003e\n\u003cp\u003e在 OpenWRT 系统中，可以通过多种方式实现网络带宽 quota 平均，以下是一些常见的方法：\u003c/p\u003e","title":"网络运维—Quota平均的实现"},{"content":"论辩的魂灵 二十年前到黑市，买得一张符，名叫 “鬼画符”。虽然不过一团糟，但帖在壁上看起来，却随时显出各样的文字，是处世的宝训，立身的金箴。今年又到黑市去，又买得一张符，也是 “鬼画符”。但帖了起来看，也还是那一张，并不见什么增补和修改。今夜看出来的大题目是 “论辩的魂灵”；细注道：“祖传老年中年青年‘逻辑’扶乩灭洋必胜妙法太上老君急急如律令敕”。今谨摘录数条，以公同好 ——\n“洋奴会说洋话。你主张读洋书，就是洋奴，人格破产了！受人格破产的洋奴崇拜的洋书，其价值从可知矣！但我读洋文是学校的课程，是政府的功令，反对者，即反对政府也。无父无君之无政府党，人人得而诛之。”\n“你说中国不好。你是外国人么？为什么不到外国去？可惜外国人看你不起……。”\n“你说甲生疮。甲是中国人，你就是说中国人生疮了。既然中国人生疮，你是中国人，就是你也生疮了。你既然也生疮，你就和甲一样。而你只说甲生疮，则竟无自知之明，你的话还有什么价值？倘你没有生疮，是说诳也。卖国贼是说诳的，所以你是卖国贼。我骂卖国贼，所以我是爱国者。爱国者的话是最有价值的，所以我的话是不错的，我的话既然不错，你就是卖国贼无疑了！”\n“自由结婚未免太过激了。其实，我也并非老顽固，中国提倡女学的还是我第一个。但他们却太趋极端了，太趋极端，即有亡国之祸，所以气得我偏要说‘男女授受不亲’。况且，凡事不可过激；过激派都主张共妻主义的。乙赞成自由结婚，不就是主张共妻主义么？他既然主张共妻主义，就应该先将他的妻拿出来给我们‘共’。”\n“丙讲革命是为的要图利：不为图利，为什么要讲革命？我亲眼看见他三千七百九十一箱半的现金抬进门。你说不然，反对我么？那么，你就是他的同党。呜呼，党同伐异之风，于今为烈，提倡欧化者不得辞其咎矣！”\n“丁牺牲了性命，乃是闹得一塌糊涂，活不下去了的缘故。现在妄称志士，诸君切勿为其所愚。况且，中国不是更坏了么？”\n“戊能算什么英雄呢？听说，一声爆竹，他也会吃惊。还怕爆竹，能听枪炮声么？怕听枪炮声，打起仗来不要逃跑么？打起仗来就逃跑的反称英雄，所以中国糟透了。”\n“你自以为是‘人’，我却以为非也。我是畜类，现在我就叫你爹爹。你既然是畜类的爹爹，当然也就是畜类了。”\n“勿用惊叹符号，这是足以亡国的。但我所用的几个在例外。\n中庸太太提起笔来，取精神文明精髓，作明哲保身大吉大利格言二句云：\n中学为体西学用，\n不薄今人爱古人。”\n","permalink":"https://gopherding.github.io/posts/read/%E8%AE%BA%E8%BE%A9%E7%9A%84%E9%AD%82%E7%81%B5/","summary":"\u003ch3 id=\"论辩的魂灵\"\u003e论辩的魂灵\u003c/h3\u003e\n\u003cp\u003e二十年前到黑市，买得一张符，名叫 “鬼画符”。虽然不过一团糟，但帖在壁上看起来，却随时显出各样的文字，是处世的宝训，立身的金箴。今年又到黑市去，又买得一张符，也是 “鬼画符”。但帖了起来看，也还是那一张，并不见什么增补和修改。今夜看出来的大题目是 “论辩的魂灵”；细注道：“祖传老年中年青年‘逻辑’扶乩灭洋必胜妙法太上老君急急如律令敕”。今谨摘录数条，以公同好 ——\u003c/p\u003e","title":"论辩的魂灵"},{"content":"看个帖子：\n一、什么是 PGO PGO 即配置文件引导优化。它通过在实际运行场景中收集程序的执行信息，然后利用这些信息来指导编译器进行更有针对性的优化，从而使生成的可执行程序在特定的使用场景下具有更好的性能表现。\n二、工作原理 首先，使用一个特殊的构建标志来编译程序，这个版本的程序在运行时会收集执行信息并生成一个配置文件。 在运行过程中，程序会记录函数的调用次数、执行时间等信息，这些信息会被写入到配置文件中。 然后，使用这个配置文件再次编译程序。 编译器会根据配置文件中的信息，对那些频繁执行的代码路径进行更积极的优化，比如内联函数调用、优化循环等。同时，也可以根据执行频率调整代码布局，以提高缓存命中率。 三、优势 性能提升：通过针对实际使用场景进行优化，可以显著提高程序的执行速度和响应时间。 例如，在一个高并发的网络服务中，PGO 可以优化那些频繁被调用的处理函数，减少处理时间，提高服务的吞吐量。 资源利用效率提高：可以使程序更有效地利用 CPU 和内存等资源。 因为优化后的代码可能会减少不必要的计算和内存访问，从而降低资源消耗。 四、使用方法 收集配置文件（Profiling）：\n确保你的程序中导入了net/http/pprof包，这会在程序运行时自动添加一个用于获取 CPU 配置文件的端点，通常是/debug/pprof/profile。 在程序运行一段时间后，通过访问http://localhost:8080/debug/pprof/profile（其中localhost:8080是你的程序运行的地址和端口，根据实际情况替换），并设置合适的查询参数（如seconds=30表示收集 30 秒的运行数据）来获取配置文件。这会生成一个cpu.pprof文件。 生成 PGO 配置文件：\n将获取到的cpu.pprof文件重命名为default.pgo（或者其他你指定的文件名）。如果使用-pgo参数指定了特定的配置文件路径，就不需要重命名。 编译时开启 PGO：使用go build命令编译程序时，添加\n-pgo 参数来启用 PGO 优化。\n如果使用auto模式（推荐），编译器会自动寻找程序主目录下名为default.pgo的配置文件并应用优化。例如：go build -pgo=auto -o your_program。 也可以手动指定配置文件的路径，如：go build -pgo=/path/to/your/profile.pgo -o your_program，这里/path/to/your/profile.pgo是你指定的配置文件的完整路径。 五、注意事项 配置文件的代表性：为了获得最佳的优化效果，收集配置文件时的运行场景应该尽可能接近实际的生产环境。如果收集配置文件的场景与实际使用场景差异较大，可能会导致优化效果不佳。 重新编译：每次程序的行为发生重大变化时，可能需要重新收集配置文件并进行优化编译，以确保优化的准确性。 兼容性：不同版本的 Go 编译器对 PGO 的支持可能会有所不同。在升级 Go 版本时，需要重新评估 PGO 的效果，并可能需要进行一些调整。 ","permalink":"https://gopherding.github.io/posts/tech/pgo%E7%9B%B8%E5%85%B3/","summary":"\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/585640586\"\u003e看个帖子：\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"一什么是-pgo\"\u003e\u003cstrong\u003e一、什么是 PGO\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003ePGO 即配置文件引导优化。它通过在实际运行场景中收集程序的执行信息，然后利用这些信息来指导编译器进行更有针对性的优化，从而使生成的可执行程序在特定的使用场景下具有更好的性能表现。\u003c/p\u003e\n\u003ch3 id=\"二工作原理\"\u003e\u003cstrong\u003e二、工作原理\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e首先，使用一个特殊的构建标志来编译程序，这个版本的程序在运行时会收集执行信息并生成一个配置文件。\n\u003cul\u003e\n\u003cli\u003e在运行过程中，程序会记录函数的调用次数、执行时间等信息，这些信息会被写入到配置文件中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e然后，使用这个配置文件再次编译程序。\n\u003cul\u003e\n\u003cli\u003e编译器会根据配置文件中的信息，对那些频繁执行的代码路径进行更积极的优化，比如内联函数调用、优化循环等。同时，也可以根据执行频率调整代码布局，以提高缓存命中率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三优势\"\u003e\u003cstrong\u003e三、优势\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e性能提升：通过针对实际使用场景进行优化，可以显著提高程序的执行速度和响应时间。\n\u003cul\u003e\n\u003cli\u003e例如，在一个高并发的网络服务中，PGO 可以优化那些频繁被调用的处理函数，减少处理时间，提高服务的吞吐量。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e资源利用效率提高：可以使程序更有效地利用 CPU 和内存等资源。\n\u003cul\u003e\n\u003cli\u003e因为优化后的代码可能会减少不必要的计算和内存访问，从而降低资源消耗。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"四使用方法\"\u003e\u003cstrong\u003e四、使用方法\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e收集配置文件（Profiling）：\u003c/p\u003e","title":"Golang的PGO优化"},{"content":"游褒禅山记 宋·王安石\n褒禅山亦谓之华山，唐浮图慧褒始舍于其址，而卒葬之；以故其后名之曰“褒禅”。今所谓慧空禅院者，褒之庐冢也。距其院东五里，所谓华山洞者，以其乃华山之阳名之也。距洞百余步，有碑仆道，其文漫灭，独其为文犹可识曰“花山”。今言“华”如“华实”之“华”者，盖音谬也。\n其下平旷，有泉侧出，而记游者甚众，所谓前洞也。由山以上五六里，有穴窈然，入之甚寒，问其深，则其好游者不能穷也，谓之后洞。余与四人拥火以入，入之愈深，其进愈难，而其见愈奇。有怠而欲出者，曰：“不出，火且尽。”遂与之俱出。盖余所至，比好游者尚不能十一，然视其左右，来而记之者已少。盖其又深，则其至又加少矣。方是时，余之力尚足以入，火尚足以明也。既其出，则或咎其欲出者，而余亦悔其随之，而不得极夫游之乐也。\n于是余有叹焉。古人之观于天地、山川、草木、虫鱼、鸟兽，往往有得，以其求思之深而无不在也。夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！\n余于仆碑，又以悲夫古书之不存，后世之谬其传而莫能名者，何可胜道也哉！此所以学者不可以不深思而慎取之也。\n四人者：庐陵萧君圭君玉，长乐王回深父，余弟安国平父、安上纯父。\n至和元年七月某日，临川王某记。\n","permalink":"https://gopherding.github.io/posts/read/%E6%B8%B8%E8%A4%92%E7%A6%85%E5%B1%B1%E8%AE%B0/","summary":"\u003ch3 id=\"游褒禅山记\"\u003e游褒禅山记\u003c/h3\u003e\n\u003cp\u003e宋·王安石\u003c/p\u003e\n\u003cp\u003e　　褒禅山亦谓之华山，唐浮图慧褒始舍于其址，而卒葬之；以故其后名之曰“褒禅”。今所谓慧空禅院者，褒之庐冢也。距其院东五里，所谓华山洞者，以其乃华山之阳名之也。距洞百余步，有碑仆道，其文漫灭，独其为文犹可识曰“花山”。今言“华”如“华实”之“华”者，盖音谬也。\u003c/p\u003e\n\u003cp\u003e　　其下平旷，有泉侧出，而记游者甚众，所谓前洞也。由山以上五六里，有穴窈然，入之甚寒，问其深，则其好游者不能穷也，谓之后洞。余与四人拥火以入，入之愈深，其进愈难，而其见愈奇。有怠而欲出者，曰：“不出，火且尽。”遂与之俱出。盖余所至，比好游者尚不能十一，然视其左右，来而记之者已少。盖其又深，则其至又加少矣。方是时，余之力尚足以入，火尚足以明也。既其出，则或咎其欲出者，而余亦悔其随之，而不得极夫游之乐也。\u003c/p\u003e","title":"游褒禅山记"},{"content":"如何设计一个高并发系统?\n一、页面静态化 模板引擎 html/template：Go 标准库自带的模板引擎，用于生成 HTML 页面。它具有简单易用、安全（防止跨站脚本攻击等）的特点，适合用于页面静态化。 jet：这是一个高性能的 Go 模板引擎，语法简洁，在性能上有一定优势。 二、缓存 内存缓存 go - cache：这是一个简单的内存缓存库，适合在 Go 应用中缓存一些临时数据，例如短时间内频繁访问的数据。它提供了基本的缓存操作，如设置、获取和删除。 groupcache：由 Google 开发，用于在分布式环境下实现高效的内存缓存。它可以在多台机器之间共享缓存数据，减少数据库或其他后端存储的访问压力。 三、异步 消息队列客户端 go - kafka - client：用于在 Go 应用中与 Kafka 消息队列进行交互。通过它可以实现异步消息的发送和接收，将耗时的操作异步处理，例如日志记录、事件通知等。 rabbitmq - go：这是 RabbitMQ 的 Go 语言客户端库，支持 AMQP 协议，允许 Go 程序与 RabbitMQ 进行通信，实现异步消息处理机制。 异步编程 Go 语言原生支持：Go 语言的goroutine和channel机制天然支持异步编程。通过go关键字可以轻松启动一个异步执行的函数（goroutine），而channel用于在goroutine之间进行通信和同步数据。 四、多线程处理（Go 中的 goroutine 类似多线程概念） 标准库并发原语 goroutine：Go 语言中轻量级的并发执行单元，类似于线程，但比传统线程更轻量，创建和销毁的开销较小。可以通过go关键字轻松启动一个goroutine来并发执行函数。 channel：用于在goroutine之间进行数据传递和同步。有缓冲通道和无缓冲通道之分，可以根据实际需求选择合适的通道类型来实现并发控制和数据共享。 sync 包：包含了如Mutex（互斥锁）、RWMutex（读写锁）、WaitGroup（用于等待一组goroutine完成）等并发原语，用于解决并发访问共享资源时的同步问题。 五、分库分表 数据库操作库 gorm：一个功能强大且易用的 Go 语言 ORM（对象关系映射）库。虽然它本身不直接提供分库分表功能，但可以通过自定义插件或者在业务逻辑层根据一定规则（如哈希算法、范围划分等）来实现数据的分库分表操作。 xorm：另一个 Go 语言的 ORM 库，类似 gorm，通过结合一些分库分表的策略和算法，可以在 Go 应用中实现数据库的分库分表。 六、池化技术 数据库连接池 go - sql - driver/mysql：这是 MySQL 数据库的 Go 语言驱动，配合database/sql标准库，可以通过设置连接池参数来实现数据库连接池功能，例如设置最大连接数、空闲连接数等。 pgx：这是一个高性能的 PostgreSQL 数据库的 Go 语言驱动，也支持连接池机制，通过合理配置连接池参数，可以优化数据库连接的管理和使用。 资源池（通用池化框架） go - pool：这是一个通用的资源池框架，可以用于创建各种类型的资源池，例如数据库连接池、网络连接池等。它提供了资源的获取、释放、空闲资源管理等功能。 七、读写分离 数据库中间件（结合 Go 应用） vitess：这是一个用于 MySQL 水平扩展的数据库中间件，支持读写分离、分库分表等功能。虽然它本身是用 C++ 编写的，但可以通过 Go 语言编写客户端来与之交互，实现 Go 应用中的读写分离操作。 Sharding -Sphere（Go - Sharding -Sphere）：Sharding -Sphere 有 Go 语言的客户端实现，它可以帮助 Go 应用实现数据库的读写分离以及分库分表等操作。 八、索引 数据库索引操作（通过数据库驱动实现） 在使用数据库驱动（如 go - sql - driver/mysql、pgx 等）操作数据库时：可以在 SQL 语句中使用CREATE INDEX、ALTER TABLE ADD INDEX等语句来创建索引。这与具体的数据库（如 MySQL、PostgreSQL 等）的索引操作语法相关，Go 语言通过执行这些 SQL 语句来操作数据库索引。 九、批处理 数据库批处理（通过数据库驱动实现） go - sql - driver/mysql 等数据库驱动：在 Go 语言中操作数据库时，可以使用数据库驱动提供的批处理功能。例如，在插入多条记录时，可以使用exec方法的批处理模式，将多条INSERT语句一次性提交给数据库执行，提高数据处理效率。 大数据批处理（结合大数据框架） Go - Hadoop：Go 语言有一些用于与 Hadoop 生态系统交互的库，例如可以使用 Go - Hadoop 来编写 MapReduce 程序，实现大数据的批处理操作。虽然 Go 不是 Hadoop 原生支持的编程语言，但通过这些库可以在 Go 语言中利用 Hadoop 的批处理能力。 十、集群 Web 服务器集群（Go 服务器框架） Gin：这是一个轻量级的 Go Web 框架，在构建 Web 服务器集群时，可以将多个 Gin 实例部署在不同的服务器上，通过负载均衡器（如 Nginx）将请求分发到这些 Gin 服务器上，实现集群服务。 Beego：一个全功能的 Go Web 框架，同样可以用于构建 Web 服务器集群。它具有丰富的功能，如路由、模板引擎、数据库访问等，方便在集群环境中部署和运行。 分布式集群（结合分布式框架） etcd：这是一个分布式键值存储系统，由 CoreOS 开发，用于分布式系统中的配置管理、服务发现等。Go 语言是 etcd 的开发语言，在 Go 应用中可以方便地使用 etcd 来构建分布式集群，实现节点间的通信和协调。 Consul：这是 HashiCorp 开发的一个用于实现分布式系统服务发现和配置的工具。Go 应用可以通过 Consul 的 Go 语言客户端来参与到分布式集群中，实现服务注册、发现和健康检查等功能。 十一、负载均衡 软件负载均衡（Go 实现） go - reverseproxy：这是一个用 Go 语言实现的简单反向代理库，可以作为负载均衡器的基础。它可以将接收到的请求转发到后端的多个服务器上，通过一定的负载均衡算法（如轮询、随机等）来分配请求。 Fabio：这是一个基于 Go 语言的快速、简单的 HTTP 和 TCP 负载均衡器，它可以自动发现后端服务，并根据配置的策略进行负载均衡。 十二、限流 限流框架 uber - go/ratelimit：这是由 Uber 开源的一个简单的 Go 语言限流库，它基于令牌桶算法实现，可以用于限制对某些资源（如 API 接口）的访问频率。 go - limiter：这是一个 Go 语言的通用限流库，支持多种限流算法，如漏桶算法、令牌桶算法等，可以根据实际需求选择合适的算法来实现对系统流量的控制。 十三、服务降级 微服务框架（Go - Micro 等） Go - Micro：这是一个用于构建微服务的 Go 语言框架，它提供了服务发现、配置管理、消息传递等功能。在 Go - Micro 中，可以通过编写降级逻辑来实现服务降级，例如当某个服务不可用时，返回默认值或者调用备用服务。 Kratos：这是由字节跳动开源的一个 Go 语言的微服务框架，它注重性能和可靠性。在 Kratos 框架中，可以通过设计合理的服务治理策略来实现服务降级操作，保障系统在高负载或部分服务故障时的可用性。 十四、故障转移 数据库故障转移（结合数据库特性和 Go 应用） 通过 MySQL 等数据库的复制和高可用性机制：在 Go 应用中，当使用 MySQL 数据库时，可以利用 MySQL 的主从复制和故障转移机制（如 MySQL MHA 等）。Go 语言通过数据库驱动和相关的监控逻辑来检测数据库主节点的故障，并在故障发生时切换到从节点继续服务。 etcd 的故障转移机制：如前文所述，etcd 是一个分布式键值存储系统，具有自动的故障转移机制。Go 应用在使用 etcd 进行分布式协调和存储时，可以依赖 etcd 的故障转移特性来保障系统的稳定性。 十五、异地多活 数据库异地多活（结合分布式数据库和 Go 应用） TiDB：这是一个开源的分布式数据库，具有水平扩展、强一致性等特点。在 Go 应用中，可以使用 TiDB 来实现数据库的异地多活，通过合理配置 TiDB 的集群和数据复制策略，保障数据在不同地域的数据中心都能正常访问和更新。 CockroachDB：这是一个分布式的 SQL 数据库，旨在提供全球范围内的分布式数据存储和处理能力。Go 语言可以通过 CockroachDB 的 Go 客户端来操作数据库，实现异地多活的数据库架构。 应用层异地多活（结合微服务和网络架构） 通过 Go - Micro 等微服务框架和网络优化策略：在微服务架构中，Go 应用可以通过 Go - Micro 等框架实现服务的跨地域部署。同时，结合网络优化技术（如低延迟网络、网络隧道等）和数据同步机制，可以保障应用服务在不同地域的数据中心都能稳定运行，实现异地多活。 十六、压测 性能测试工具（Go 编写） hey：这是一个用 Go 语言编写的 HTTP 性能测试工具，类似于ab（ApacheBench）。它可以对 Web 应用的 HTTP 接口进行压力测试，测量响应时间、吞吐量等性能指标。 vegeta：这是另一个高性能的 HTTP 负载测试工具，由 Go 语言实现。它可以生成不同负载的 HTTP 请求，用于测试 Go Web 应用以及其他基于 HTTP 协议的服务的性能和稳定性。 十七、监控 系统监控（Go 实现） prometheus/client_golang：这是 Prometheus 监控系统的 Go 语言客户端库。Go 应用可以通过这个库来暴露自身的性能指标（如 CPU 使用率、内存占用、请求处理时间等），方便 Prometheus 进行数据采集和监控。 expvar：这是 Go 标准库中的一个包，用于在运行时暴露应用程序的变量。虽然它比较简单，但可以用于一些基础的监控需求，例如查看当前应用中的连接数、请求数等。 应用性能监控（APM） jaeger - client - go：这是 Jaeger 分布式追踪系统的 Go 语言客户端。通过在 Go 应用中集成 jaeger - client - go，可以实现对应用程序的性能追踪和故障排查，监控请求在各个服务和组件之间的流转情况。 opentelemetry - go：这是 OpenTelemetry 项目的 Go 语言实现，它提供了一套标准的、跨语言的应用性能监控和分布式追踪的工具和接口。Go 应用可以使用 opentelemetry - go 来实现全面的 APM 功能。 ","permalink":"https://gopherding.github.io/posts/tech/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/","summary":"\u003cp\u003e如何设计一个高并发系统?\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/gaobingfaSYS.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch3 id=\"一页面静态化\"\u003e一、页面静态化\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"模板引擎\"\u003e模板引擎\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ehtml/template\u003c/strong\u003e：Go 标准库自带的模板引擎，用于生成 HTML 页面。它具有简单易用、安全（防止跨站脚本攻击等）的特点，适合用于页面静态化。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ejet\u003c/strong\u003e：这是一个高性能的 Go 模板引擎，语法简洁，在性能上有一定优势。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二缓存\"\u003e二、缓存\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"内存缓存\"\u003e内存缓存\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ego - cache\u003c/strong\u003e：这是一个简单的内存缓存库，适合在 Go 应用中缓存一些临时数据，例如短时间内频繁访问的数据。它提供了基本的缓存操作，如设置、获取和删除。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003egroupcache\u003c/strong\u003e：由 Google 开发，用于在分布式环境下实现高效的内存缓存。它可以在多台机器之间共享缓存数据，减少数据库或其他后端存储的访问压力。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三异步\"\u003e三、异步\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"消息队列客户端\"\u003e消息队列客户端\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ego - kafka - client\u003c/strong\u003e：用于在 Go 应用中与 Kafka 消息队列进行交互。通过它可以实现异步消息的发送和接收，将耗时的操作异步处理，例如日志记录、事件通知等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003erabbitmq - go\u003c/strong\u003e：这是 RabbitMQ 的 Go 语言客户端库，支持 AMQP 协议，允许 Go 程序与 RabbitMQ 进行通信，实现异步消息处理机制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"异步编程\"\u003e异步编程\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGo 语言原生支持\u003c/strong\u003e：Go 语言的\u003ccode\u003egoroutine\u003c/code\u003e和\u003ccode\u003echannel\u003c/code\u003e机制天然支持异步编程。通过\u003ccode\u003ego\u003c/code\u003e关键字可以轻松启动一个异步执行的函数（\u003ccode\u003egoroutine\u003c/code\u003e），而\u003ccode\u003echannel\u003c/code\u003e用于在\u003ccode\u003egoroutine\u003c/code\u003e之间进行通信和同步数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"四多线程处理go-中的-goroutine-类似多线程概念\"\u003e四、多线程处理（Go 中的 goroutine 类似多线程概念）\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"标准库并发原语\"\u003e标准库并发原语\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003egoroutine\u003c/strong\u003e：Go 语言中轻量级的并发执行单元，类似于线程，但比传统线程更轻量，创建和销毁的开销较小。可以通过\u003ccode\u003ego\u003c/code\u003e关键字轻松启动一个\u003ccode\u003egoroutine\u003c/code\u003e来并发执行函数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003echannel\u003c/strong\u003e：用于在\u003ccode\u003egoroutine\u003c/code\u003e之间进行数据传递和同步。有缓冲通道和无缓冲通道之分，可以根据实际需求选择合适的通道类型来实现并发控制和数据共享。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003esync 包\u003c/strong\u003e：包含了如\u003ccode\u003eMutex\u003c/code\u003e（互斥锁）、\u003ccode\u003eRWMutex\u003c/code\u003e（读写锁）、\u003ccode\u003eWaitGroup\u003c/code\u003e（用于等待一组\u003ccode\u003egoroutine\u003c/code\u003e完成）等并发原语，用于解决并发访问共享资源时的同步问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"五分库分表\"\u003e五、分库分表\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"数据库操作库\"\u003e数据库操作库\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003egorm\u003c/strong\u003e：一个功能强大且易用的 Go 语言 ORM（对象关系映射）库。虽然它本身不直接提供分库分表功能，但可以通过自定义插件或者在业务逻辑层根据一定规则（如哈希算法、范围划分等）来实现数据的分库分表操作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003exorm\u003c/strong\u003e：另一个 Go 语言的 ORM 库，类似 gorm，通过结合一些分库分表的策略和算法，可以在 Go 应用中实现数据库的分库分表。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"六池化技术\"\u003e六、池化技术\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"数据库连接池\"\u003e数据库连接池\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ego - sql - driver/mysql\u003c/strong\u003e：这是 MySQL 数据库的 Go 语言驱动，配合\u003ccode\u003edatabase/sql\u003c/code\u003e标准库，可以通过设置连接池参数来实现数据库连接池功能，例如设置最大连接数、空闲连接数等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epgx\u003c/strong\u003e：这是一个高性能的 PostgreSQL 数据库的 Go 语言驱动，也支持连接池机制，通过合理配置连接池参数，可以优化数据库连接的管理和使用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"资源池通用池化框架\"\u003e资源池（通用池化框架）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ego - pool\u003c/strong\u003e：这是一个通用的资源池框架，可以用于创建各种类型的资源池，例如数据库连接池、网络连接池等。它提供了资源的获取、释放、空闲资源管理等功能。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"七读写分离\"\u003e七、读写分离\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"数据库中间件结合-go-应用\"\u003e数据库中间件（结合 Go 应用）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003evitess\u003c/strong\u003e：这是一个用于 MySQL 水平扩展的数据库中间件，支持读写分离、分库分表等功能。虽然它本身是用 C++ 编写的，但可以通过 Go 语言编写客户端来与之交互，实现 Go 应用中的读写分离操作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSharding -Sphere（Go - Sharding -Sphere）\u003c/strong\u003e：Sharding -Sphere 有 Go 语言的客户端实现，它可以帮助 Go 应用实现数据库的读写分离以及分库分表等操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"八索引\"\u003e八、索引\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"数据库索引操作通过数据库驱动实现\"\u003e数据库索引操作（通过数据库驱动实现）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e在使用数据库驱动（如 go - sql - driver/mysql、pgx 等）操作数据库时\u003c/strong\u003e：可以在 SQL 语句中使用\u003ccode\u003eCREATE INDEX\u003c/code\u003e、\u003ccode\u003eALTER TABLE ADD INDEX\u003c/code\u003e等语句来创建索引。这与具体的数据库（如 MySQL、PostgreSQL 等）的索引操作语法相关，Go 语言通过执行这些 SQL 语句来操作数据库索引。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"九批处理\"\u003e九、批处理\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"数据库批处理通过数据库驱动实现\"\u003e数据库批处理（通过数据库驱动实现）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ego - sql - driver/mysql 等数据库驱动\u003c/strong\u003e：在 Go 语言中操作数据库时，可以使用数据库驱动提供的批处理功能。例如，在插入多条记录时，可以使用\u003ccode\u003eexec\u003c/code\u003e方法的批处理模式，将多条\u003ccode\u003eINSERT\u003c/code\u003e语句一次性提交给数据库执行，提高数据处理效率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"大数据批处理结合大数据框架\"\u003e大数据批处理（结合大数据框架）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGo - Hadoop\u003c/strong\u003e：Go 语言有一些用于与 Hadoop 生态系统交互的库，例如可以使用 Go - Hadoop 来编写 MapReduce 程序，实现大数据的批处理操作。虽然 Go 不是 Hadoop 原生支持的编程语言，但通过这些库可以在 Go 语言中利用 Hadoop 的批处理能力。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"十集群\"\u003e十、集群\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"web-服务器集群go-服务器框架\"\u003eWeb 服务器集群（Go 服务器框架）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGin\u003c/strong\u003e：这是一个轻量级的 Go Web 框架，在构建 Web 服务器集群时，可以将多个 Gin 实例部署在不同的服务器上，通过负载均衡器（如 Nginx）将请求分发到这些 Gin 服务器上，实现集群服务。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBeego\u003c/strong\u003e：一个全功能的 Go Web 框架，同样可以用于构建 Web 服务器集群。它具有丰富的功能，如路由、模板引擎、数据库访问等，方便在集群环境中部署和运行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"分布式集群结合分布式框架\"\u003e分布式集群（结合分布式框架）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eetcd\u003c/strong\u003e：这是一个分布式键值存储系统，由 CoreOS 开发，用于分布式系统中的配置管理、服务发现等。Go 语言是 etcd 的开发语言，在 Go 应用中可以方便地使用 etcd 来构建分布式集群，实现节点间的通信和协调。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConsul\u003c/strong\u003e：这是 HashiCorp 开发的一个用于实现分布式系统服务发现和配置的工具。Go 应用可以通过 Consul 的 Go 语言客户端来参与到分布式集群中，实现服务注册、发现和健康检查等功能。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"十一负载均衡\"\u003e十一、负载均衡\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"软件负载均衡go-实现\"\u003e软件负载均衡（Go 实现）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ego - reverseproxy\u003c/strong\u003e：这是一个用 Go 语言实现的简单反向代理库，可以作为负载均衡器的基础。它可以将接收到的请求转发到后端的多个服务器上，通过一定的负载均衡算法（如轮询、随机等）来分配请求。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFabio\u003c/strong\u003e：这是一个基于 Go 语言的快速、简单的 HTTP 和 TCP 负载均衡器，它可以自动发现后端服务，并根据配置的策略进行负载均衡。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"十二限流\"\u003e十二、限流\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"限流框架\"\u003e限流框架\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003euber - go/ratelimit\u003c/strong\u003e：这是由 Uber 开源的一个简单的 Go 语言限流库，它基于令牌桶算法实现，可以用于限制对某些资源（如 API 接口）的访问频率。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ego - limiter\u003c/strong\u003e：这是一个 Go 语言的通用限流库，支持多种限流算法，如漏桶算法、令牌桶算法等，可以根据实际需求选择合适的算法来实现对系统流量的控制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"十三服务降级\"\u003e十三、服务降级\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"微服务框架go---micro-等\"\u003e微服务框架（Go - Micro 等）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGo - Micro\u003c/strong\u003e：这是一个用于构建微服务的 Go 语言框架，它提供了服务发现、配置管理、消息传递等功能。在 Go - Micro 中，可以通过编写降级逻辑来实现服务降级，例如当某个服务不可用时，返回默认值或者调用备用服务。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKratos\u003c/strong\u003e：这是由字节跳动开源的一个 Go 语言的微服务框架，它注重性能和可靠性。在 Kratos 框架中，可以通过设计合理的服务治理策略来实现服务降级操作，保障系统在高负载或部分服务故障时的可用性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"十四故障转移\"\u003e十四、故障转移\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"数据库故障转移结合数据库特性和-go-应用\"\u003e数据库故障转移（结合数据库特性和 Go 应用）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e通过 MySQL 等数据库的复制和高可用性机制\u003c/strong\u003e：在 Go 应用中，当使用 MySQL 数据库时，可以利用 MySQL 的主从复制和故障转移机制（如 MySQL MHA 等）。Go 语言通过数据库驱动和相关的监控逻辑来检测数据库主节点的故障，并在故障发生时切换到从节点继续服务。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eetcd 的故障转移机制\u003c/strong\u003e：如前文所述，etcd 是一个分布式键值存储系统，具有自动的故障转移机制。Go 应用在使用 etcd 进行分布式协调和存储时，可以依赖 etcd 的故障转移特性来保障系统的稳定性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"十五异地多活\"\u003e十五、异地多活\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"数据库异地多活结合分布式数据库和-go-应用\"\u003e数据库异地多活（结合分布式数据库和 Go 应用）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTiDB\u003c/strong\u003e：这是一个开源的分布式数据库，具有水平扩展、强一致性等特点。在 Go 应用中，可以使用 TiDB 来实现数据库的异地多活，通过合理配置 TiDB 的集群和数据复制策略，保障数据在不同地域的数据中心都能正常访问和更新。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCockroachDB\u003c/strong\u003e：这是一个分布式的 SQL 数据库，旨在提供全球范围内的分布式数据存储和处理能力。Go 语言可以通过 CockroachDB 的 Go 客户端来操作数据库，实现异地多活的数据库架构。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"应用层异地多活结合微服务和网络架构\"\u003e应用层异地多活（结合微服务和网络架构）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e通过 Go - Micro 等微服务框架和网络优化策略\u003c/strong\u003e：在微服务架构中，Go 应用可以通过 Go - Micro 等框架实现服务的跨地域部署。同时，结合网络优化技术（如低延迟网络、网络隧道等）和数据同步机制，可以保障应用服务在不同地域的数据中心都能稳定运行，实现异地多活。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"十六压测\"\u003e十六、压测\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"性能测试工具go-编写\"\u003e性能测试工具（Go 编写）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ehey\u003c/strong\u003e：这是一个用 Go 语言编写的 HTTP 性能测试工具，类似于\u003ccode\u003eab\u003c/code\u003e（ApacheBench）。它可以对 Web 应用的 HTTP 接口进行压力测试，测量响应时间、吞吐量等性能指标。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003evegeta\u003c/strong\u003e：这是另一个高性能的 HTTP 负载测试工具，由 Go 语言实现。它可以生成不同负载的 HTTP 请求，用于测试 Go Web 应用以及其他基于 HTTP 协议的服务的性能和稳定性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"十七监控\"\u003e十七、监控\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"系统监控go-实现\"\u003e系统监控（Go 实现）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eprometheus/client_golang\u003c/strong\u003e：这是 Prometheus 监控系统的 Go 语言客户端库。Go 应用可以通过这个库来暴露自身的性能指标（如 CPU 使用率、内存占用、请求处理时间等），方便 Prometheus 进行数据采集和监控。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eexpvar\u003c/strong\u003e：这是 Go 标准库中的一个包，用于在运行时暴露应用程序的变量。虽然它比较简单，但可以用于一些基础的监控需求，例如查看当前应用中的连接数、请求数等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"应用性能监控apm\"\u003e应用性能监控（APM）\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ejaeger - client - go\u003c/strong\u003e：这是 Jaeger 分布式追踪系统的 Go 语言客户端。通过在 Go 应用中集成 jaeger - client - go，可以实现对应用程序的性能追踪和故障排查，监控请求在各个服务和组件之间的流转情况。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eopentelemetry - go\u003c/strong\u003e：这是 OpenTelemetry 项目的 Go 语言实现，它提供了一套标准的、跨语言的应用性能监控和分布式追踪的工具和接口。Go 应用可以使用 opentelemetry - go 来实现全面的 APM 功能。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"如何设计一个高并发系统"},{"content":" Here’s to the crazy ones. 向那些疯狂的家伙致敬 The misfits. 他们特立独行 The rebels. 他们桀骜不驯 The troublemakers. 他们惹是生非 The round pegs in the square holes. 他们格格不入 The ones who see things differently. 他们用与众不同的眼光看待事物 They’re not fond of rules. 他们不喜欢墨守成规 And they have no respect for the status quo. 他们也不愿安于现状 You can quote them, disagree with them, 你可以赞美他们，否定他们 glorify or vilify them. 颂扬抑或是诋毁他们 About the only thing you can’t do is ignore them. 但是唯独不能漠视他们 Because they change things. 因为他们改变了事物 They push the human race forward. 他们让人类向前跨越了一大步 And while some may see them as the crazy ones, 有人视他们为疯子 we see genius. 而我们却视他们为天才 Because the people who are crazy enough to think they can change the world, 因为，只有疯狂到认为自己能够改变世界的人 are the ones who do. 才能真正的改变世界 ","permalink":"https://gopherding.github.io/posts/read/heres-to-the-crazy-ones/","summary":"\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eHere’s to the crazy ones.\u003c/th\u003e\n          \u003cth\u003e向那些疯狂的家伙致敬\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eThe misfits.\u003c/td\u003e\n          \u003ctd\u003e他们特立独行\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eThe rebels.\u003c/td\u003e\n          \u003ctd\u003e他们桀骜不驯\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eThe troublemakers.\u003c/td\u003e\n          \u003ctd\u003e他们惹是生非\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eThe round pegs in the square holes.\u003c/td\u003e\n          \u003ctd\u003e他们格格不入\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eThe ones who see things differently.\u003c/td\u003e\n          \u003ctd\u003e他们用与众不同的眼光看待事物\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eThey’re not fond of rules.\u003c/td\u003e\n          \u003ctd\u003e他们不喜欢墨守成规\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAnd they have no respect for the status quo.\u003c/td\u003e\n          \u003ctd\u003e他们也不愿安于现状\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eYou can quote them, disagree with them,\u003c/td\u003e\n          \u003ctd\u003e你可以赞美他们，否定他们\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eglorify or vilify them.\u003c/td\u003e\n          \u003ctd\u003e颂扬抑或是诋毁他们\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAbout the only thing you can’t do is ignore them.\u003c/td\u003e\n          \u003ctd\u003e但是唯独不能漠视他们\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eBecause they change things.\u003c/td\u003e\n          \u003ctd\u003e因为他们改变了事物\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eThey push the human race forward.\u003c/td\u003e\n          \u003ctd\u003e他们让人类向前跨越了一大步\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAnd while some may see them as the crazy ones,\u003c/td\u003e\n          \u003ctd\u003e有人视他们为疯子\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ewe see genius.\u003c/td\u003e\n          \u003ctd\u003e而我们却视他们为天才\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eBecause the people who are crazy enough to think they can change the world,\u003c/td\u003e\n          \u003ctd\u003e因为，只有疯狂到认为自己能够改变世界的人\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eare the ones who do.\u003c/td\u003e\n          \u003ctd\u003e才能真正的改变世界\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Here’s to the crazy ones"},{"content":"项脊轩志 明·归有光\n项脊轩，旧南阁子也。室仅方丈，可容一人居。百年老屋，尘泥渗漉，雨泽下注；每移案，顾视无可置者。又北向，不能得日，日过午已昏。余稍为修葺，使不上漏。前辟四窗，垣墙周庭，以当南日，日影反照，室始洞然。又杂植兰桂竹木于庭，旧时栏楯，亦遂增胜。借书满架，偃仰啸歌，冥然兀坐，万籁有声；而庭阶寂寂，小鸟时来啄食，人至不去。三五之夜，明月半墙，桂影斑驳，风移影动，珊珊可爱。(借书 一作：积书；阶寂寂 一作：堦寂寂)\n然余居于此，多可喜，亦多可悲。先是庭中通南北为一。迨诸父异爨，内外多置小门墙，往往而是，东犬西吠，客逾庖而宴，鸡栖于厅。庭中始为篱，已为墙，凡再变矣。家有老妪，尝居于此。妪，先大母婢也，乳二世，先妣抚之甚厚。室西连于中闺，先妣尝一至。妪每谓余曰：“某所，而母立于兹。”妪又曰：“汝姊在吾怀，呱呱而泣；娘以指叩门扉曰：‘儿寒乎？欲食乎？’吾从板外相为应答。”语未毕，余泣，妪亦泣。余自束发读书轩中，一日，大母过余曰：“吾儿，久不见若影，何竟日默默在此，大类女郎也？”比去，以手阖门，自语曰：“吾家读书久不效，儿之成，则可待乎！”顷之，持一象笏至，曰：“此吾祖太常公宣德间执此以朝，他日汝当用之！”瞻顾遗迹，如在昨日，令人长号不自禁。(内外多置小门墙，往往而是 一作：内外多置小门，墙往往而是)\n轩东故尝为厨，人往，从轩前过。余扃牖而居，久之，能以足音辨人。轩凡四遭火，得不焚，殆有神护者。\n项脊生曰：“蜀清守丹穴，利甲天下，其后秦皇帝筑女怀清台；刘玄德与曹操争天下，诸葛孔明起陇中。方二人之昧昧于一隅也，世何足以知之，余区区处败屋中，方扬眉、瞬目，谓有奇景。人知之者，其谓与坎井之蛙何异？”\n余既为此志，后五年，吾妻来归，时至轩中，从余问古事，或凭几学书。吾妻归宁，述诸小妹语曰：“闻姊家有阁子，且何谓阁子也？”其后六年，吾妻死，室坏不修。其后二年，余久卧病无聊，乃使人复葺南阁子，其制稍异于前。然自后余多在外，不常居。\n庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。\n","permalink":"https://gopherding.github.io/posts/read/%E9%A1%B9%E8%84%8A%E8%BD%A9%E5%BF%97/","summary":"\u003ch3 id=\"项脊轩志\"\u003e项脊轩志\u003c/h3\u003e\n\u003cp\u003e明·归有光\u003c/p\u003e\n\u003cp\u003e　　项脊轩，旧南阁子也。室仅方丈，可容一人居。百年老屋，尘泥渗漉，雨泽下注；每移案，顾视无可置者。又北向，不能得日，日过午已昏。余稍为修葺，使不上漏。前辟四窗，垣墙周庭，以当南日，日影反照，室始洞然。又杂植兰桂竹木于庭，旧时栏楯，亦遂增胜。借书满架，偃仰啸歌，冥然兀坐，万籁有声；而庭阶寂寂，小鸟时来啄食，人至不去。三五之夜，明月半墙，桂影斑驳，风移影动，珊珊可爱。(借书 一作：积书；阶寂寂 一作：堦寂寂)\u003c/p\u003e","title":"项脊轩志"},{"content":"有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生竞态问题（数据竞态race condition）。\n原则：对一个共享资源的读和写操作必须是原子化的——同一时刻只能有一个 goroutine 对共享资源进行读和写操作。\n互斥锁： Go 语言中使用sync包中提供的Mutex类型来实现互斥锁。\nfunc (m *Mutex) Lock() 获取互斥锁 func (m *Mutex) Unlock() 释放互斥锁 使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。\n锁的两种模式 互斥锁在设计上主要有两种模式： 正常模式和饥饿模式。\n之所以引入了饥饿模式，是为了保证goroutine获取互斥锁的公平性。所谓公平性，其实就是多个goroutine在获取锁时，goroutine获取锁的顺序，和请求锁的顺序一致，则为公平。\n正常模式下，所有阻塞在等待队列中的goroutine会按顺序进行锁获取，当唤醒一个等待队列中的goroutine时，此goroutine并不会直接获取到锁，而是会和新请求锁的goroutine竞争。 通常新请求锁的goroutine更容易获取锁，这是因为新请求锁的goroutine正在占用cpu片执行，大概率可以直接执行到获取到锁的逻辑。\n饥饿模式下， 新请求锁的goroutine不会进行锁获取，而是加入到队列尾部阻塞等待获取锁。\n饥饿模式的触发条件： 当一个goroutine等待锁的时间超过1ms时，互斥锁会切换到饥饿模式 饥饿模式的取消条件： 当获取到锁的这个goroutine是等待锁队列中的最后一个goroutine，互斥锁会切换到正常模式 当获取到锁的这个goroutine的等待时间在1ms之内，互斥锁会切换到正常模式 sync.Mutex的数据结构 Go中的sync.Mutex的结构体为：\ntype Mutex struct { state int32 sema uint32 } Sync.Mutex由两个字段构成，state用来表示当前互斥锁处于的状态，sema用于控制锁状态的信号量。相信各位道友读完这两个字段的描述后，好像懂了，又好像没懂。下面我们详细理解下这两个字段到底都作了哪些事。\n互斥锁state主要记录了如下四种状态：\n![image-20240320224646795](C:\\Users\\GEORGE DING\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240320224646795.png)\nwaiter_num： 记录了当前等待抢这个锁的goroutine数量\nstarving： 当前锁是否处于饥饿状态 (后文会详解锁的饥饿状态) 0: 正常状态 1: 饥饿状态\nwoken： 当前锁是否有goroutine已被唤醒。 0：没有goroutine被唤醒； 1: 有goroutine正在加锁过程\nlocked： 当前锁是否被goroutine持有。 0: 未被持有 1: 已被持有\nsema信号量的作用：\n当持有锁的gorouine释放锁后，会释放sema信号量，这个信号量会唤醒之前抢锁阻塞的gorouine来获取锁。\nTo know much more, here （Mutex底层结构）!\n读写互斥锁： 互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用sync包中的RWMutex类型。\n方法名 功能 func (rw *RWMutex) Lock() 获取写锁 func (rw *RWMutex) Unlock() 释放写锁 func (rw *RWMutex) RLock() 获取读锁 func (rw *RWMutex) RUnlock() 释放读锁 func (rw *RWMutex) RLocker() Locker 返回一个实现Locker接口的读写锁 当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。\n即：读锁可读不可写，写锁读写均不可。\nsync.WaitGroup 方法名 功能 func (wg * WaitGroup) Add(delta int) 计数器+delta (wg *WaitGroup) Done() 计数器-1 (wg *WaitGroup) Wait() 阻塞直到计数器变为0 sync.WaitGroup 内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done 方法将计数器减1。通过调用 Wait 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。\nsync.Once 在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。\nGo语言中的sync包中提供了一个针对只执行一次场景的解决方案——sync.Once，sync.Once只有一个Do方法，其签名如下：\nfunc (o *Once) Do(f func()) sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次，源码如下：\nfunc (o *Once) doSlow(f func()) { o.m.Lock() defer o.m.Unlock() if o.done.Load() == 0 { defer o.done.Store(1) f() } } sync.Map 先来看一下源码注释罢：\n// The Map type is optimized for two common use cases: (1) when the entry for a given // key is only ever written once but read many times, as in caches that only grow, // or (2) when multiple goroutines read, write, and overwrite entries for disjoint // sets of keys. In these two cases, use of a Map may significantly reduce lock // contention compared to a Go map paired with a separate Mutex or RWMutex. 使用方法：\nfunc main() { var m sync.Map // 1. 写入 m.Store(\u0026#34;qwe\u0026#34;, 18) m.Store(\u0026#34;asd\u0026#34;, 20) // 2. 读取 age, _ := m.Load(\u0026#34;qwe\u0026#34;) fmt.Println(age.(int)) // 3. 遍历 m.Range(func(key, value interface{}) bool { name := key.(string) age := value.(int) fmt.Println(name, age) return true }) // 4. 删除 m.Delete(\u0026#34;qwe\u0026#34;) age, ok := m.Load(\u0026#34;qwe\u0026#34;) fmt.Println(age, ok) // 5. 读取或写入，这个 key 已经存在，因此写入不成功，并且读出原值。 m.LoadOrStore(\u0026#34;asd\u0026#34;, 100) age, _ = m.Load(\u0026#34;asd\u0026#34;) fmt.Println(age) } 方法名 功能 func (m *Map) Store(key, value interface{}) 存储key-value数据 func (m *Map) Load(key interface{}) (value interface{}, ok bool) 查询key对应的value func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) 查询或存储key对应的value func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) 查询并删除key func (m *Map) Delete(key interface{}) 删除key func (m *Map) Range(f func(key, value interface{}) bool) 对map中的每个key-value依次调用f 浅浅看一下源码罢：\ntype Map struct { mu Mutex // readOnly,`read` 是 atomic.Value 类型，可以并发地读。但如果需要更新 `read`，则需要加锁保护。对于 read 中存储的 entry 字段，可能会被并发地 CAS 更新。但是如果要更新一个之前已被删除的 entry，则需要先将其状态从 expunged 改为 nil，再拷贝到 dirty 中，然后再更新。 read atomic.Value //`dirty` 是一个非线程安全的原始 map。包含新写入的 key，并且包含 `read` 中的所有未被删除的 key。这样，可以快速地将 `dirty` 提升为 `read` 对外提供服务。如果 `dirty` 为 nil，那么下一次写入时，会新建一个新的 `dirty`，这个初始的 `dirty` 是 `read` 的一个拷贝，但除掉了其中已被删除的 key。 dirty map[interface{}]*entry //每当从 read 中读取失败，都会将 `misses` 的计数值加 1，当加到一定阈值以后，需要将 dirty 提升为 read，以期减少 miss 的情形。 misses int } sync.map 适用于读多写少的场景。对于写多的场景，会导致 read map 缓存失效，需要加锁，导致冲突变多；而且由于未命中 read map 次数过多，导致 dirty map 提升为 read map，这是一个 O(N) 的操作，会进一步降低性能。\n总之： sync.map 是线程安全的，读取，插入，删除也都保持着常数级的时间复杂度。 通过读写分离，降低锁时间来提高效率，适用于读多写少的场景。 Range 操作需要提供一个函数，参数是 k,v，返回值是一个布尔值：f func(key, value interface{}) bool。 调用 Load 或 LoadOrStore 函数时，如果在 read 中没有找到 key，则会将 misses 值原子地增加 1，当 misses 增加到和 dirty 的长度相等时，会将 dirty 提升为 read。以期减少“读 miss”。 新写入的 key 会保存到 dirty 中，如果这时 dirty 为 nil，就会先新创建一个 dirty，并将 read 中未被删除的元素拷贝到 dirty。 当 dirty 为 nil 的时候，read 就代表 map 所有的数据；当 dirty 不为 nil 的时候，dirty 才代表 map 所有的数据。 ","permalink":"https://gopherding.github.io/posts/tech/%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E9%94%81/","summary":"\u003cp\u003e有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生竞态问题（数据竞态race condition）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原则：对一个共享资源的读和写操作必须是原子化的——同一时刻只能有一个 goroutine 对共享资源进行读和写操作。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"互斥锁\"\u003e互斥锁：\u003c/h3\u003e\n\u003cp\u003eGo 语言中使用\u003ccode\u003esync\u003c/code\u003e包中提供的\u003ccode\u003eMutex\u003c/code\u003e类型来实现互斥锁。\u003c/p\u003e","title":"同步并发\u0026锁"},{"content":" ","permalink":"https://gopherding.github.io/posts/tech/postgresql%E5%92%8Cmysql%E5%8C%BA%E5%88%AB/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/PgSQL\u0026amp;\u0026amp;MySQL.png\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"PostgreSQL和MySQL区别"},{"content":"一、内部结构 sync.Map主要由两个数据结构组成：\n一个原生的map：用于存储实际的键值对。这个map在读取时无需加锁，但在写入时需要加锁。 一个read结构体：包含一个只读的原生map（称为dirty map）和一个misses计数器。这个read结构体在读取操作时被优先使用，因为读取它无需加锁，只有在发生读未命中且misses计数达到一定阈值时，才会将dirty map中的内容写入到主map中并重置read结构体。 二、读写操作 读操作： 首先尝试从read结构体中的dirty map读取键对应的值。如果找到了值，直接返回。 如果在dirty map中未找到值，再尝试从主map中读取。如果找到了值，更新read结构体中的dirty map并返回值。 如果在主map中也未找到值，增加misses计数器。如果misses计数器达到一定阈值，会将dirty map中的内容写入主map，并重置read结构体和misses计数器。 写操作： 首先锁定主map，然后进行写入操作。 同时，如果read结构体中的dirty map为空，将主map复制一份到dirty map中，以便后续的读操作可以更快地访问。 三、并发安全 一、读写分离设计 内部包含两个主要的数据结构： 一个是普通的map，用于存储实际的键值对，称为 “dirty map”。这个map在写操作时会被锁定，以确保写操作的原子性和一致性。 另一个是只读的map结构，在执行读操作时优先从这个结构中读取数据，无需加锁，从而允许多个线程并发读取。 二、写操作的同步机制 互斥锁保护： 当进行写操作（存储新的键值对、更新现有键值对或删除键值对）时，会获取一个互斥锁，确保同一时刻只有一个线程可以对 “dirty map” 进行写操作。 这样可以防止多个线程同时修改map时可能导致的数据不一致和竞争条件。 三、读操作的优化与同步 优先从只读map读取：\n读操作首先尝试从只读的map中获取键对应的值，因为这个map不需要加锁，所以多个线程可以同时进行读操作，提高了读操作的并发性能。 动态更新只读map：\n如果读操作在只读map中未找到键对应的值，会尝试从 “dirty map” 中读取。如果在 “dirty map” 中找到了值，会将这个值更新到只读map中，以便后续的读操作可以更快地获取到这个值。 misses计数器：\n每次读操作在只读map和 “dirty map” 中都未找到值时，会增加一个misses计数器。当misses计数器达到一定阈值时，会触发将 “dirty map” 中的内容复制到只读map中，并重置misses计数器。这个机制确保了在一段时间内如果读操作频繁未命中，会动态地更新只读map，以提高后续读操作的效率。 四、删除操作的安全处理 标记删除：\n当执行删除操作时，会在 “dirty map” 中标记键值对为已删除状态。这样在后续的读操作中，如果在只读map中未找到键对应的值，并且在 “dirty map” 中发现该键被标记为已删除，就可以确定该键不存在于map中。 ","permalink":"https://gopherding.github.io/posts/tech/%E5%AF%B9sync.map%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/","summary":"\u003ch3 id=\"一内部结构\"\u003e\u003cstrong\u003e一、内部结构\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esync.Map\u003c/code\u003e主要由两个数据结构组成：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e一个原生的\u003ccode\u003emap\u003c/code\u003e：用于存储实际的键值对。这个\u003ccode\u003emap\u003c/code\u003e在读取时无需加锁，但在写入时需要加锁。\u003c/li\u003e\n\u003cli\u003e一个\u003ccode\u003eread\u003c/code\u003e结构体：包含一个只读的原生\u003ccode\u003emap\u003c/code\u003e（称为\u003ccode\u003edirty map\u003c/code\u003e）和一个\u003ccode\u003emisses\u003c/code\u003e计数器。这个\u003ccode\u003eread\u003c/code\u003e结构体在读取操作时被优先使用，因为读取它无需加锁，只有在发生读未命中且\u003ccode\u003emisses\u003c/code\u003e计数达到一定阈值时，才会将\u003ccode\u003edirty map\u003c/code\u003e中的内容写入到主\u003ccode\u003emap\u003c/code\u003e中并重置\u003ccode\u003eread\u003c/code\u003e结构体。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二读写操作\"\u003e\u003cstrong\u003e二、读写操作\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"读操作\"\u003e读操作：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e首先尝试从\u003ccode\u003eread\u003c/code\u003e结构体中的\u003ccode\u003edirty map\u003c/code\u003e读取键对应的值。如果找到了值，直接返回。\u003c/li\u003e\n\u003cli\u003e如果在\u003ccode\u003edirty map\u003c/code\u003e中未找到值，再尝试从主\u003ccode\u003emap\u003c/code\u003e中读取。如果找到了值，更新\u003ccode\u003eread\u003c/code\u003e结构体中的\u003ccode\u003edirty map\u003c/code\u003e并返回值。\u003c/li\u003e\n\u003cli\u003e如果在主\u003ccode\u003emap\u003c/code\u003e中也未找到值，增加\u003ccode\u003emisses\u003c/code\u003e计数器。如果\u003ccode\u003emisses\u003c/code\u003e计数器达到一定阈值，会将\u003ccode\u003edirty map\u003c/code\u003e中的内容写入主\u003ccode\u003emap\u003c/code\u003e，并重置\u003ccode\u003eread\u003c/code\u003e结构体和\u003ccode\u003emisses\u003c/code\u003e计数器。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"写操作\"\u003e写操作：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e首先锁定主\u003ccode\u003emap\u003c/code\u003e，然后进行写入操作。\u003c/li\u003e\n\u003cli\u003e同时，如果\u003ccode\u003eread\u003c/code\u003e结构体中的\u003ccode\u003edirty map\u003c/code\u003e为空，将主\u003ccode\u003emap\u003c/code\u003e复制一份到\u003ccode\u003edirty map\u003c/code\u003e中，以便后续的读操作可以更快地访问。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三并发安全\"\u003e\u003cstrong\u003e三、并发安全\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"一读写分离设计\"\u003e一、读写分离设计\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch5 id=\"内部包含两个主要的数据结构\"\u003e内部包含两个主要的数据结构：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e一个是普通的\u003ccode\u003emap\u003c/code\u003e，用于存储实际的键值对，称为 “dirty map”。这个\u003ccode\u003emap\u003c/code\u003e在写操作时会被锁定，以确保写操作的原子性和一致性。\u003c/li\u003e\n\u003cli\u003e另一个是只读的\u003ccode\u003emap\u003c/code\u003e结构，在执行读操作时优先从这个结构中读取数据，无需加锁，从而允许多个线程并发读取。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"二写操作的同步机制\"\u003e二、写操作的同步机制\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch5 id=\"互斥锁保护\"\u003e互斥锁保护：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e当进行写操作（存储新的键值对、更新现有键值对或删除键值对）时，会获取一个互斥锁，确保同一时刻只有一个线程可以对 “dirty map” 进行写操作。\u003c/li\u003e\n\u003cli\u003e这样可以防止多个线程同时修改\u003ccode\u003emap\u003c/code\u003e时可能导致的数据不一致和竞争条件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"三读操作的优化与同步\"\u003e三、读操作的优化与同步\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e优先从只读map读取：\u003c/p\u003e","title":"对sync.Map的一些看法"},{"content":"与妻书 林觉民\n意映卿卿如晤，吾今以此书与汝永别矣！吾作此书时，尚是世中一人；汝看此书时，吾已成为阴间一鬼。吾作此书，泪珠和笔墨齐下，不能竟书而欲搁笔，又恐汝不察吾衷，谓吾忍舍汝而死，谓吾不知汝之不欲吾死也，故遂忍悲为汝言之。\n吾至爱汝，即此爱汝一念，使吾勇就死也。吾自遇汝以来，常愿天下有情人都成眷属；然遍地腥云，满街狼犬，称心快意，几家能彀？司马青衫，吾不能学太上之忘情也。语云：仁者 “老吾老，以及人之老；幼吾幼，以及人之幼”。吾充吾爱汝之心，助天下人爱其所爱，所以敢先汝而死，不顾汝也。汝体吾此心，于啼泣之余，亦以天下人为念，当亦乐牺牲吾身与汝身之福利，为天下人谋永福也。汝其勿悲！\n汝忆否？四五年前某夕，吾尝语曰：“与使吾先死也，无宁汝先吾而死。” 汝初闻言而怒，后经吾婉解，虽不谓吾言为是，而亦无词相答。吾之意盖谓以汝之弱，必不能禁失吾之悲，吾先死，留汝而无所依，吾心不忍，故宁请汝先死，吾担悲也。嗟夫！谁知吾卒先汝而死乎？\n吾真真不能忘汝也！回忆后街之屋，入门穿廊，过前后厅，又三四折，有小厅，厅旁一室，为吾与汝双栖之所。初婚三四个月，适冬之望日前后，窗外疏梅筛月影，依稀掩映；吾与汝并肩携手，低低切切，何事不语？何情不诉？及今思之，空余泪痕。又回忆六七年前，吾之逃家复归也，汝泣告我：“望今后有远行，必以告妾，妾愿随君行。” 吾亦既许汝矣。前十余日回家，即欲乘便以此行之事语汝，及与汝相对，又不能启口，且以汝之有身也，更恐不胜悲，故惟日日呼酒买醉。\n嗟夫！当时余心之悲，盖不能以寸管形容之。吾诚愿与汝相守以死，第以今日事势观之，天灾可以死，盗贼可以死，瓜分之日可以死，奸官污吏虐民可以死，吾辈处今日之中国，无时无地不可以死，到那时使吾眼睁睁看汝死，或者使汝眼睁睁看吾死，吾能之乎？抑汝能之乎？即可不死，而离散不相见，徒使两地眼成穿而骨化石，试问古来几对夫妻能到此境？此吾所以敢率性就死不顾汝也。吾今死无余憾，国事成不成自有同志者在。依新已五岁，转眼成人，汝其善抚之，使之肖我。汝腹中之物，吾疑其女也，女必像汝，吾心甚慰。或又是男，则亦教其以父志为志，则吾死后尚有二意映在也。甚幸，甚幸！吾家后日当甚贫，贫无所苦，清静过日而已。\n吾今与汝无言矣。吾居九泉之下遥闻汝哭声，当哭相和也。吾平日不信有鬼，今则又望其真有。今人又言心电感应有道，吾亦望其言是实，则吾之死，吾灵尚依依旁汝也，汝不必以无侣悲。\n吾平生未尝以吾所志语汝，是吾不是处；然语之，又恐汝日日为吾担忧。吾牺牲百死而不辞，而使汝担忧，的的非吾所忍。吾爱汝至，所以为汝谋者惟恐未尽。汝幸而偶我，又何不幸而生今日之中国！吾幸而得汝，又何不幸而生今日之中国！卒不忍独善其身。嗟夫！巾短情长，所未尽者，尚有万千，汝可以模拟得之。吾今不能见汝矣！汝不能舍吾，吾亦不能舍汝，汝当体吾此心，于啼泣之余，亦以天下人为念，当亦乐牺牲吾身与汝身之福利，为天下人谋永福也。汝其勿悲！\n","permalink":"https://gopherding.github.io/posts/read/%E4%B8%8E%E5%A6%BB%E4%B9%A6/","summary":"\u003ch3 id=\"与妻书\"\u003e与妻书\u003c/h3\u003e\n\u003cp\u003e林觉民\u003c/p\u003e\n\u003cp\u003e意映卿卿如晤，吾今以此书与汝永别矣！吾作此书时，尚是世中一人；汝看此书时，吾已成为阴间一鬼。吾作此书，泪珠和笔墨齐下，不能竟书而欲搁笔，又恐汝不察吾衷，谓吾忍舍汝而死，谓吾不知汝之不欲吾死也，故遂忍悲为汝言之。\u003c/p\u003e\n\u003cp\u003e吾至爱汝，即此爱汝一念，使吾勇就死也。吾自遇汝以来，常愿天下有情人都成眷属；然遍地腥云，满街狼犬，称心快意，几家能彀？司马青衫，吾不能学太上之忘情也。语云：仁者 “老吾老，以及人之老；幼吾幼，以及人之幼”。吾充吾爱汝之心，助天下人爱其所爱，所以敢先汝而死，不顾汝也。汝体吾此心，于啼泣之余，亦以天下人为念，当亦乐牺牲吾身与汝身之福利，为天下人谋永福也。汝其勿悲！\u003c/p\u003e","title":"与妻书"},{"content":"Kubernetes 针对 Pod 资源对象主要有以下两种健康监测机制：\n一、就绪性探测（Readiness Probe） 作用： 确定容器是否准备好服务请求。当一个 Pod 中的容器的就绪性探测成功时，该容器才会被视为准备好接收流量，被添加到服务的后端列表中。如果就绪性探测失败，容器将从服务的后端列表中移除，新的请求不会被分发到该容器，直到它再次变为就绪状态。 实现方式： HTTP GET 探测：向容器内指定的路径和端口发送 HTTP GET 请求。如果响应的状态码在 200 到 399 之间，则认为容器就绪。 TCP 套接字探测：尝试与容器内指定的端口建立 TCP 连接。如果连接成功，则认为容器就绪。 Exec 探测：在容器内执行指定的命令。如果命令的退出状态码为 0，则认为容器就绪。 二、存活态探测（Liveness Probe） 作用： 检查容器是否正在运行。如果存活态探测失败，Kubernetes 会尝试重启容器，以确保应用持续运行。 实现方式： HTTP GET 探测：与就绪性探测的 HTTP GET 方式类似，但目的是检查容器的运行状态而不是准备接收请求的状态。 TCP 套接字探测：与就绪性探测的 TCP 套接字方式类似，用于判断容器是否在运行。 Exec 探测：在容器内执行指定的命令，根据命令的退出状态码判断容器是否存活。 两者区别： 目的不同： 就绪性探测主要关注容器是否准备好接收请求，决定容器是否应该被纳入服务的后端列表。 存活态探测主要关注容器是否正在运行，以确保应用的持续可用性，如果容器出现问题则尝试重启。 影响不同： 就绪性探测失败只会影响容器是否接收新的请求，不会导致容器被重启。 存活态探测失败可能会导致容器被重启。 触发时机不同： 就绪性探测在容器启动后以及在容器运行过程中定期进行，以确保容器始终处于可以接收请求的状态。 存活态探测在容器运行期间持续进行，以检测容器是否出现故障。 ","permalink":"https://gopherding.github.io/posts/tech/k8s%E9%92%88%E5%AF%B9pod%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%81%A5%E5%BA%B7%E7%9B%91%E6%B5%8B%E6%9C%BA%E5%88%B6/","summary":"\u003cp\u003eKubernetes 针对 Pod 资源对象主要有以下两种健康监测机制：\u003c/p\u003e\n\u003ch3 id=\"一就绪性探测readiness-probe\"\u003e\u003cstrong\u003e一、就绪性探测（Readiness Probe）\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"作用\"\u003e作用：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e确定容器是否准备好服务请求。当一个 Pod 中的容器的就绪性探测成功时，该容器才会被视为准备好接收流量，被添加到服务的后端列表中。如果就绪性探测失败，容器将从服务的后端列表中移除，新的请求不会被分发到该容器，直到它再次变为就绪状态。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"实现方式\"\u003e实现方式：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eHTTP GET 探测：向容器内指定的路径和端口发送 HTTP GET 请求。如果响应的状态码在 200 到 399 之间，则认为容器就绪。\u003c/li\u003e\n\u003cli\u003eTCP 套接字探测：尝试与容器内指定的端口建立 TCP 连接。如果连接成功，则认为容器就绪。\u003c/li\u003e\n\u003cli\u003eExec 探测：在容器内执行指定的命令。如果命令的退出状态码为 0，则认为容器就绪。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二存活态探测liveness-probe\"\u003e\u003cstrong\u003e二、存活态探测（Liveness Probe）\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"作用-1\"\u003e作用：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e检查容器是否正在运行。如果存活态探测失败，Kubernetes 会尝试重启容器，以确保应用持续运行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"实现方式-1\"\u003e实现方式：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eHTTP GET 探测：与就绪性探测的 HTTP GET 方式类似，但目的是检查容器的运行状态而不是准备接收请求的状态。\u003c/li\u003e\n\u003cli\u003eTCP 套接字探测：与就绪性探测的 TCP 套接字方式类似，用于判断容器是否在运行。\u003c/li\u003e\n\u003cli\u003eExec 探测：在容器内执行指定的命令，根据命令的退出状态码判断容器是否存活。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"两者区别\"\u003e\u003cstrong\u003e两者区别\u003c/strong\u003e：\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"目的不同\"\u003e目的不同：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e就绪性探测主要关注容器是否准备好接收请求，决定容器是否应该被纳入服务的后端列表。\u003c/li\u003e\n\u003cli\u003e存活态探测主要关注容器是否正在运行，以确保应用的持续可用性，如果容器出现问题则尝试重启。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"影响不同\"\u003e影响不同：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e就绪性探测失败只会影响容器是否接收新的请求，不会导致容器被重启。\u003c/li\u003e\n\u003cli\u003e存活态探测失败可能会导致容器被重启。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"触发时机不同\"\u003e触发时机不同：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e就绪性探测在容器启动后以及在容器运行过程中定期进行，以确保容器始终处于可以接收请求的状态。\u003c/li\u003e\n\u003cli\u003e存活态探测在容器运行期间持续进行，以检测容器是否出现故障。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"K8s针对pod资源对象的健康监测机制"},{"content":" 环境准备 安装 Rancher：在控制平面服务器上安装 Rancher，可以通过容器方式安装。例如，使用 Docker 运行 Rancher 服务器容器，运行命令如下： docker run -d --restart=unless -stopped -p 80:80 -p 443:443 rancher/rancher:latest 配置 Kubernetes 集群接入 Rancher：对于要管理的每个 Kubernetes 集群，获取集群的 Kube - config 文件等信息，然后在 Rancher 界面中将集群添加进来。 安装 Helm 3：在可以访问 Kubernetes 集群的机器上安装 Helm 3，具体安装步骤根据操作系统不同而不同。例如，在 Linux 系统上，可以使用官方提供的脚本安装： curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get -helm -3.sh chmod 700 get_helm.sh ./get_helm.sh 使用 Helm 3 部署应用并关联 ConfigMap（以一个简单的 Web 应用为例） 创建 Helm Chart： 首先创建一个新的 Helm Chart 目录结构。可以使用helm create my - web - app命令来创建一个名为my - web - app的基本 Chart 模板。 在values.yaml文件中定义应用的配置参数，例如： app: config: port: 8080 db - connection - string: \u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34; 在templates目录下创建configmap.yaml文件来定义 ConfigMap，内容如下： apiVersion: v1 kind: ConfigMap metadata: name: {{.Release.Name}} - config - map data: app - port: \u0026#34;{{.Values.app.config.port}}\u0026#34; db - connection - string: \u0026#34;{{.Values.app.config.db - connection - string}}\u0026#34; 在templates目录下的deployment.yaml文件中，挂载 ConfigMap 到容器中。修改volumes和volumeMounts部分，示例如下： apiVersion: apps/v1 kind: Deployment metadata: name: {{.Release.Name}} - deployment spec: replicas: 1 selector: matchLabels: app: {{.Release.Name}} template: metadata: labels: app: {{.Release.Name}} spec: containers: - name: my - web - app - container image: my - web - app - image:latest ports: - containerPort: {{.Values.app.config.port}} volumeMounts: - name: config - volume mountPath: /app/config volumes: - name: config - volume configMap: name: {{.Release.Name}} - config - map 部署应用到多集群： 使用 Helm 3 将应用部署到 Rancher 管理的多个 Kubernetes 集群。例如，在每个集群对应的上下文中，运行以下命令： helm install my - web - app my - web - app - chart - path -n my - namespace 这样就将应用部署到了多个集群中，并且每个集群中的应用都关联了一个 ConfigMap，其中包含应用的配置信息。 实现 ConfigMap 热更新 更新 ConfigMap 内容： 在 Rancher 界面中，找到对应的 ConfigMap 资源（可以通过命名空间和名称来查找），或者通过 Kubernetes 命令行kubectl edit configmap my - web - app - config - map -n my - namespace来编辑 ConfigMap 的内容。例如，修改app - port的值为8081。 使应用感知 ConfigMap 更新（以支持热重载的应用为例）： 对于支持热重载配置文件的应用，应用内部需要有相应的机制来监听配置文件的变化。例如，一些基于 Spring Boot 的 Java 应用，可以通过配置spring - cloud - config - monitor来实现配置文件的热重载。在应用代码中，需要读取挂载的 ConfigMap 中的配置文件路径下的配置内容，并且在文件变化时重新加载配置。 对于不支持热重载的应用： 可以通过更新应用的 Deployment 来触发容器的重新创建。例如，通过修改 Deployment 的annotations或者labels等元数据信息，使得 Deployment 触发滚动更新。可以使用kubectl patch deployment my - web - app - deployment -n my - namespace -p '{\u0026quot;spec\u0026quot;:{\u0026quot;template\u0026quot;:{\u0026quot;metadata\u0026quot;:{\u0026quot;annotations\u0026quot;:{\u0026quot;date\u0026quot;:\u0026quot;'$(date +%s)'\u0026quot;}}}}}'命令来更新 Deployment 的元数据，从而触发滚动更新，让容器重新加载新的 ConfigMap 配置。 跨集群同步和监控更新过程 在 Rancher 中同步更新： Rancher 提供了集群组和全局资源的功能。可以将多个集群组成一个集群组，然后通过集群组来同步某些资源的更新。对于 ConfigMap，可以尝试将其定义为集群组的共享资源（部分高级版本功能支持），这样在一个集群中更新 ConfigMap 后，Rancher 可以辅助将更新同步到其他集群。 监控更新状态： 在 Rancher 界面中，利用其内置的监控和告警功能，监控应用在各个集群中的更新过程。可以查看应用的 Pod 状态、资源使用情况等指标。同时，设置告警规则，例如当应用的更新失败或者出现大量 Pod 异常时，及时收到通知。也可以通过 Kubernetes 原生的监控工具（如 Prometheus 集成到 Rancher）来深入监控应用的更新过程和配置生效情况。 ","permalink":"https://gopherding.github.io/posts/tech/rancher+helm3+-configmap%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%83%AD%E6%9B%B4%E6%96%B0/","summary":"\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"环境准备\"\u003e\u003cstrong\u003e环境准备\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e安装 Rancher\u003c/strong\u003e：在控制平面服务器上安装 Rancher，可以通过容器方式安装。例如，使用 Docker 运行 Rancher 服务器容器，运行命令如下：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edocker run -d --restart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eunless -stopped -p 80:80 -p 443:443 rancher/rancher:latest\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e配置 Kubernetes 集群接入 Rancher\u003c/strong\u003e：对于要管理的每个 Kubernetes 集群，获取集群的 Kube - config 文件等信息，然后在 Rancher 界面中将集群添加进来。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安装 Helm 3\u003c/strong\u003e：在可以访问 Kubernetes 集群的机器上安装 Helm 3，具体安装步骤根据操作系统不同而不同。例如，在 Linux 系统上，可以使用官方提供的脚本安装：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get -helm -3.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     chmod \u003cspan style=\"color:#ae81ff\"\u003e700\u003c/span\u003e get_helm.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ./get_helm.sh\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003ch3 id=\"使用-helm-3-部署应用并关联-configmap以一个简单的-web-应用为例\"\u003e\u003cstrong\u003e使用 Helm 3 部署应用并关联 ConfigMap\u003c/strong\u003e（以一个简单的 Web 应用为例）\u003c/h3\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e创建 Helm Chart：\n\u003cul\u003e\n\u003cli\u003e首先创建一个新的 Helm Chart 目录结构。可以使用\u003ccode\u003ehelm create my - web - app\u003c/code\u003e命令来创建一个名为\u003ccode\u003emy - web - app\u003c/code\u003e的基本 Chart 模板。\u003c/li\u003e\n\u003cli\u003e在\u003ccode\u003evalues.yaml\u003c/code\u003e文件中定义应用的配置参数，例如：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003econfig\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#f92672\"\u003eport\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e8080\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#f92672\"\u003edb - connection - string\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e在\u003ccode\u003etemplates\u003c/code\u003e目录下创建\u003ccode\u003econfigmap.yaml\u003c/code\u003e文件来定义 ConfigMap，内容如下：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ev1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eConfigMap\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: {{\u003cspan style=\"color:#ae81ff\"\u003e.Release.Name}} - config - map\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003edata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eapp - port\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;{{.Values.app.config.port}}\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003edb - connection - string\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;{{.Values.app.config.db - connection - string}}\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e在\u003ccode\u003etemplates\u003c/code\u003e目录下的\u003ccode\u003edeployment.yaml\u003c/code\u003e文件中，挂载 ConfigMap 到容器中。修改\u003ccode\u003evolumes\u003c/code\u003e和\u003ccode\u003evolumeMounts\u003c/code\u003e部分，示例如下：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eapps/v1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eDeployment\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: {{\u003cspan style=\"color:#ae81ff\"\u003e.Release.Name}} - deployment\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003ereplicas\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eselector\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#f92672\"\u003ematchLabels\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: {{\u003cspan style=\"color:#ae81ff\"\u003e.Release.Name}}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003etemplate\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             \u003cspan style=\"color:#f92672\"\u003elabels\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: {{\u003cspan style=\"color:#ae81ff\"\u003e.Release.Name}}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             \u003cspan style=\"color:#f92672\"\u003econtainers\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy - web - app - container\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               \u003cspan style=\"color:#f92672\"\u003eimage\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy - web - app - image:latest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               \u003cspan style=\"color:#f92672\"\u003eports\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               - \u003cspan style=\"color:#f92672\"\u003econtainerPort\u003c/span\u003e: {{\u003cspan style=\"color:#ae81ff\"\u003e.Values.app.config.port}}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               \u003cspan style=\"color:#f92672\"\u003evolumeMounts\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003econfig - volume\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 \u003cspan style=\"color:#f92672\"\u003emountPath\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e/app/config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             \u003cspan style=\"color:#f92672\"\u003evolumes\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003econfig - volume\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               \u003cspan style=\"color:#f92672\"\u003econfigMap\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: {{\u003cspan style=\"color:#ae81ff\"\u003e.Release.Name}} - config - map\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e部署应用到多集群：\n\u003cul\u003e\n\u003cli\u003e使用 Helm 3 将应用部署到 Rancher 管理的多个 Kubernetes 集群。例如，在每个集群对应的上下文中，运行以下命令：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       helm install my - web - app my - web - app - chart - path -n my - namespace\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e这样就将应用部署到了多个集群中，并且每个集群中的应用都关联了一个 ConfigMap，其中包含应用的配置信息。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003ch3 id=\"实现-configmap-热更新\"\u003e\u003cstrong\u003e实现 ConfigMap 热更新\u003c/strong\u003e\u003c/h3\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"更新-configmap-内容\"\u003e更新 ConfigMap 内容：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在 Rancher 界面中，找到对应的 ConfigMap 资源（可以通过命名空间和名称来查找），或者通过 Kubernetes 命令行\u003ccode\u003ekubectl edit configmap my - web - app - config - map -n my - namespace\u003c/code\u003e来编辑 ConfigMap 的内容。例如，修改\u003ccode\u003eapp - port\u003c/code\u003e的值为\u003ccode\u003e8081\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"使应用感知-configmap-更新以支持热重载的应用为例\"\u003e使应用感知 ConfigMap 更新（以支持热重载的应用为例）：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e对于支持热重载配置文件的应用，应用内部需要有相应的机制来监听配置文件的变化。例如，一些基于 Spring Boot 的 Java 应用，可以通过配置\u003ccode\u003espring - cloud - config - monitor\u003c/code\u003e来实现配置文件的热重载。在应用代码中，需要读取挂载的 ConfigMap 中的配置文件路径下的配置内容，并且在文件变化时重新加载配置。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"对于不支持热重载的应用\"\u003e对于不支持热重载的应用：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e可以通过更新应用的 Deployment 来触发容器的重新创建。例如，通过修改 Deployment 的\u003ccode\u003eannotations\u003c/code\u003e或者\u003ccode\u003elabels\u003c/code\u003e等元数据信息，使得 Deployment 触发滚动更新。可以使用\u003ccode\u003ekubectl patch deployment my - web - app - deployment -n my - namespace -p '{\u0026quot;spec\u0026quot;:{\u0026quot;template\u0026quot;:{\u0026quot;metadata\u0026quot;:{\u0026quot;annotations\u0026quot;:{\u0026quot;date\u0026quot;:\u0026quot;'$(date +%s)'\u0026quot;}}}}}'\u003c/code\u003e命令来更新 Deployment 的元数据，从而触发滚动更新，让容器重新加载新的 ConfigMap 配置。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\n\u003ch3 id=\"跨集群同步和监控更新过程\"\u003e\u003cstrong\u003e跨集群同步和监控更新过程\u003c/strong\u003e\u003c/h3\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"在-rancher-中同步更新\"\u003e在 Rancher 中同步更新：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eRancher 提供了集群组和全局资源的功能。可以将多个集群组成一个集群组，然后通过集群组来同步某些资源的更新。对于 ConfigMap，可以尝试将其定义为集群组的共享资源（部分高级版本功能支持），这样在一个集群中更新 ConfigMap 后，Rancher 可以辅助将更新同步到其他集群。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"监控更新状态\"\u003e监控更新状态：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在 Rancher 界面中，利用其内置的监控和告警功能，监控应用在各个集群中的更新过程。可以查看应用的 Pod 状态、资源使用情况等指标。同时，设置告警规则，例如当应用的更新失败或者出现大量 Pod 异常时，及时收到通知。也可以通过 Kubernetes 原生的监控工具（如 Prometheus 集成到 Rancher）来深入监控应用的更新过程和配置生效情况。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Rancher+Helm3 + ConfigMap集群配置项热更新"},{"content":"k8s Helm3详解 （部署，自定义，仓库）\nHelm 的核心概念 Chart：Helm 的 Chart 是一个软件包，它包含了一组定义 Kubernetes 资源的 YAML 文件。Chart 可以看作是 Kubernetes 应用的模板，它描述了如何部署一个应用，包括所需的 Deployments、Services、ConfigMaps 等资源。\nRepository：Helm 的 Repository 是一个存储 Chart 的仓库。用户可以从这些仓库中搜索、下载和安装 Chart。每个 Repository 都有一个索引文件，列出了可用的 Chart 和它们的版本。\nRelease：当使用 helm install 命令部署一个 Chart 到 Kubernetes 集群时，Helm 会创建一个 Release。Release 是 Chart 在集群中的一个实例，它代表了特定版本的应用部署。用户可以对同一个 Chart 创建多个 Release，每个 Release 都有自己的配置和状态。\nHelm 3 与 Helm 2 的区别 Helm 2：在 Helm 2 中，采用了客户端-服务器模型，其中客户端是 Helm，服务器端是 Tiller。Tiller 作为 Kubernetes 集群中的一个 Deployment 运行，负责管理 Helm 的 Release 和执行 Kubernetes 操作。\nHelm 3：Helm 3 移除了 Tiller，简化了架构。现在，Helm 客户端直接与 Kubernetes API 服务器通信，执行所有的 Kubernetes 操作。这减少了复杂性，并提高了安全性，因为不再需要在集群中运行一个具有广泛权限的 Tiller 服务。\n","permalink":"https://gopherding.github.io/posts/tech/helm3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","summary":"\u003cp\u003e\u003ca href=\"https://blog.csdn.net/qq_51545656/article/details/136648792\"\u003ek8s Helm3详解 （部署，自定义，仓库）\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHelm 的核心概念\u003c/strong\u003e\nChart：Helm 的 Chart 是一个软件包，它包含了一组定义 Kubernetes 资源的 YAML 文件。Chart 可以看作是 Kubernetes 应用的模板，它描述了如何部署一个应用，包括所需的 Deployments、Services、ConfigMaps 等资源。\u003c/p\u003e\n\u003cp\u003eRepository：Helm 的 Repository 是一个存储 Chart 的仓库。用户可以从这些仓库中搜索、下载和安装 Chart。每个 Repository 都有一个索引文件，列出了可用的 Chart 和它们的版本。\u003c/p\u003e","title":"Helm3的使用方法"},{"content":"Cluster Autoscaler 和 Horizontal Pod Autoscaler（HPA）在 Kubernetes 中有着不同的作用，主要区别如下：\n一、作用对象 Cluster Autoscaler： 作用于 Kubernetes 集群中的节点（node）。它会根据整个集群的资源需求情况，自动调整节点的数量。例如，当集群中的 Pod 由于资源不足而无法被调度时，Cluster Autoscaler 会自动添加新的节点到集群中，以提供更多的资源供 Pod 运行。 你在管理一个大规模的分布式应用时，如果发现应用的负载持续增加，导致现有节点无法满足 Pod 的资源需求，Cluster Autoscaler 就会发挥作用，自动增加节点来承载更多的工作负载。 Horizontal Pod Autoscaler： 作用于特定的 Deployment、ReplicaSet 或 StatefulSet 中的 Pod 副本数量。它根据 Pod 的资源使用情况（如 CPU 使用率、内存使用率等）自动调整 Pod 的副本数量。例如，如果一个 Deployment 中的 Pod 的平均 CPU 使用率超过了预设的阈值，HPA 会自动增加 Pod 的副本数量，以分担负载。 当你的应用面临不同的负载变化时，HPA 可以动态地调整 Pod 的数量，确保应用始终有足够的资源来处理请求，同时避免资源浪费。 二、调整方式 Cluster Autoscaler： 通过添加或删除节点来调整集群的资源容量。这通常涉及到云服务提供商的 API 调用，以启动新的虚拟机实例作为节点加入集群，或者删除不再需要的节点以节省成本。例如，在 AWS 上使用 Kubernetes，Cluster Autoscaler 可以调用 AWS EC2 API 来启动或终止 EC2 实例作为 Kubernetes 节点。 调整过程相对较慢，因为涉及到节点的创建和初始化等操作。但是，它可以从根本上解决集群资源不足的问题，适用于大规模的资源需求变化。 Horizontal Pod Autoscaler： 直接调整 Pod 的副本数量。当需要增加资源时，它会创建更多的 Pod 副本；当资源需求减少时，它会减少 Pod 的副本数量。这个过程相对较快，因为 Pod 的创建和销毁通常比节点的创建和删除要快得多。 调整的粒度相对较细，可以根据具体的应用负载变化进行快速响应。但是，它只能在现有节点的资源范围内进行调整，如果整个集群的资源都不足，就需要 Cluster Autoscaler 来添加新的节点。 三、应用场景 Cluster Autoscaler： 适用于大规模的资源需求变化，尤其是当现有节点无法满足应用的资源需求时。例如，在处理突发的高流量事件、大规模数据处理任务等情况下，Cluster Autoscaler 可以快速增加节点数量，以确保应用的可用性和性能。 对于长期运行的大规模分布式系统，Cluster Autoscaler 可以根据负载的变化自动调整节点数量，以实现资源的优化配置和成本控制。 Horizontal Pod Autoscaler： 适用于应用负载变化较为频繁，但资源需求变化相对较小的情况。例如，Web 应用、API 服务等，这些应用的负载可能会随着用户请求的数量而变化，但通常不需要大规模的资源扩展。 可以帮助优化资源使用，确保应用在不同负载下都能高效运行，同时避免资源浪费。 综上所述，Cluster Autoscaler 和 Horizontal Pod Autoscaler 在 Kubernetes 中分别从不同的层面调整资源，以满足应用的需求。它们可以结合使用，共同实现 Kubernetes 集群的自动扩缩容，提高资源利用率和和应用的可靠性。\n","permalink":"https://gopherding.github.io/posts/tech/cluster-autoscaler%E5%92%8Chorizontal-pod-autoscaler%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"\u003cp\u003eCluster Autoscaler 和 Horizontal Pod Autoscaler（HPA）在 Kubernetes 中有着不同的作用，主要区别如下：\u003c/p\u003e\n\u003ch3 id=\"一作用对象\"\u003e\u003cstrong\u003e一、作用对象\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"cluster-autoscaler\"\u003eCluster Autoscaler：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e作用于 Kubernetes 集群中的节点（node）。它会根据整个集群的资源需求情况，自动调整节点的数量。例如，当集群中的 Pod 由于资源不足而无法被调度时，Cluster Autoscaler 会自动添加新的节点到集群中，以提供更多的资源供 Pod 运行。\u003c/li\u003e\n\u003cli\u003e你在管理一个大规模的分布式应用时，如果发现应用的负载持续增加，导致现有节点无法满足 Pod 的资源需求，Cluster Autoscaler 就会发挥作用，自动增加节点来承载更多的工作负载。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"horizontal-pod-autoscaler\"\u003eHorizontal Pod Autoscaler：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e作用于特定的 Deployment、ReplicaSet 或 StatefulSet 中的 Pod 副本数量。它根据 Pod 的资源使用情况（如 CPU 使用率、内存使用率等）自动调整 Pod 的副本数量。例如，如果一个 Deployment 中的 Pod 的平均 CPU 使用率超过了预设的阈值，HPA 会自动增加 Pod 的副本数量，以分担负载。\u003c/li\u003e\n\u003cli\u003e当你的应用面临不同的负载变化时，HPA 可以动态地调整 Pod 的数量，确保应用始终有足够的资源来处理请求，同时避免资源浪费。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二调整方式\"\u003e\u003cstrong\u003e二、调整方式\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"cluster-autoscaler-1\"\u003eCluster Autoscaler：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e通过添加或删除节点来调整集群的资源容量。这通常涉及到云服务提供商的 API 调用，以启动新的虚拟机实例作为节点加入集群，或者删除不再需要的节点以节省成本。例如，在 AWS 上使用 Kubernetes，Cluster Autoscaler 可以调用 AWS EC2 API 来启动或终止 EC2 实例作为 Kubernetes 节点。\u003c/li\u003e\n\u003cli\u003e调整过程相对较慢，因为涉及到节点的创建和初始化等操作。但是，它可以从根本上解决集群资源不足的问题，适用于大规模的资源需求变化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"horizontal-pod-autoscaler-1\"\u003eHorizontal Pod Autoscaler：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e直接调整 Pod 的副本数量。当需要增加资源时，它会创建更多的 Pod 副本；当资源需求减少时，它会减少 Pod 的副本数量。这个过程相对较快，因为 Pod 的创建和销毁通常比节点的创建和删除要快得多。\u003c/li\u003e\n\u003cli\u003e调整的粒度相对较细，可以根据具体的应用负载变化进行快速响应。但是，它只能在现有节点的资源范围内进行调整，如果整个集群的资源都不足，就需要 Cluster Autoscaler 来添加新的节点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三应用场景\"\u003e\u003cstrong\u003e三、应用场景\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"cluster-autoscaler-2\"\u003eCluster Autoscaler：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e适用于大规模的资源需求变化，尤其是当现有节点无法满足应用的资源需求时。例如，在处理突发的高流量事件、大规模数据处理任务等情况下，Cluster Autoscaler 可以快速增加节点数量，以确保应用的可用性和性能。\u003c/li\u003e\n\u003cli\u003e对于长期运行的大规模分布式系统，Cluster Autoscaler 可以根据负载的变化自动调整节点数量，以实现资源的优化配置和成本控制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"horizontal-pod-autoscaler-2\"\u003eHorizontal Pod Autoscaler：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e适用于应用负载变化较为频繁，但资源需求变化相对较小的情况。例如，Web 应用、API 服务等，这些应用的负载可能会随着用户请求的数量而变化，但通常不需要大规模的资源扩展。\u003c/li\u003e\n\u003cli\u003e可以帮助优化资源使用，确保应用在不同负载下都能高效运行，同时避免资源浪费。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e综上所述，Cluster Autoscaler 和 Horizontal Pod Autoscaler 在 Kubernetes 中分别从不同的层面调整资源，以满足应用的需求。它们可以结合使用，共同实现 Kubernetes 集群的自动扩缩容，提高资源利用率和和应用的可靠性。\u003c/p\u003e","title":"Cluster Autoscaler和Horizontal Pod Autoscaler的区别"},{"content":"一、Nacos 配置中心 配置管理深度： 提供细粒度的配置管理，可以针对不同的服务、不同的环境进行独立的配置设置。例如，一个微服务架构中的多个服务可以各自拥有独特的配置项，同时在不同的开发、测试、生产环境下又可以有不同的配置值。 支持配置的版本控制，能够方便地回滚到特定版本的配置。这对于在配置变更出现问题时进行快速恢复非常有用。 动态更新机制： 当配置发生变化时，Nacos 能够实时地将更新推送给订阅了该配置的服务实例。这种主动推送的方式可以确保服务快速响应配置变化，无需等待服务的定期拉取或手动触发更新。 支持配置的监听机制，服务可以在运行时持续监听配置的变化，一旦有更新立即应用新配置，保证服务的灵活性和适应性。 服务发现集成： 与服务发现功能紧密集成，不仅可以管理配置，还能帮助服务之间进行高效的发现和通信。例如，服务在启动时可以从 Nacos 中获取所需的配置信息，同时注册自己的服务实例，方便其他服务发现和调用。 对于动态扩缩容的场景，新加入的服务实例可以自动注册到 Nacos，并获取最新的配置，实现无缝的服务扩展。 二、ConfigMap Kubernetes 内集成度： 作为 Kubernetes 的原生资源对象，与 Kubernetes 的其他组件（如 Pod、Deployment 等）紧密集成。可以通过 Kubernetes 的声明式配置文件轻松定义和管理 ConfigMap，并将其挂载到容器中。 与 Kubernetes 的命名空间概念结合，方便在不同的命名空间中管理不同的配置集，实现一定程度的环境隔离。 配置简单性： 主要适用于存储相对简单的键值对形式的配置数据。对于不太复杂的应用配置场景，ConfigMap 提供了一种简洁的方式来传递配置信息给容器。 不具备复杂的配置版本管理和动态推送功能，但可以通过更新 Kubernetes 资源来实现配置的变更，不过这种方式相对较为繁琐。 资源管理角度： ConfigMap 的管理与 Kubernetes 的资源管理体系一致，可以利用 Kubernetes 的工具和命令进行查看、修改和删除等操作。同时，Kubernetes 的控制器可以自动管理依赖于 ConfigMap 的资源，确保配置的一致性。 三、Helm 应用打包与部署： 专注于将整个应用打包为可重复使用的 Chart。一个 Chart 可以包含多个 Kubernetes 资源对象（如 Deployment、Service、ConfigMap 等），以及应用的特定配置和依赖关系。 通过 Helm，可以方便地将复杂的应用部署到不同的 Kubernetes 环境中，实现一键式部署和升级。例如，一个包含多个微服务的应用可以通过一个 Helm Chart 进行统一管理和部署。 版本管理与回滚： 对应用的版本管理非常强大。每次安装或升级应用时，Helm 会记录版本信息，方便在需要时进行回滚到特定版本。这对于在生产环境中进行应用的迭代更新非常重要，可以降低更新风险。 可以轻松比较不同版本的 Chart 之间的差异，帮助用户了解应用的变更历史。 社区与可扩展性： Helm 拥有活跃的社区，有大量的开源 Chart 可供使用。用户可以从 Helm 仓库中获取各种常见应用的 Chart，并根据自己的需求进行定制。 支持自定义插件和扩展，可以根据特定的需求开发自己的 Helm 插件，增强 Helm 的功能。同时，也可以将自己开发的 Chart 分享到社区，供其他用户使用。 总之： 一、功能特点 Nacos 配置中心： 集中管理配置，支持多环境、多项目配置。 强大的动态配置更新和推送机制，实时生效。 集成服务发现功能，适用于复杂微服务架构。 支持多种配置格式，配置管理细粒度高，有版本控制。 ConfigMap： Kubernetes 原生资源，与集群紧密集成。 存储简单键值对配置，适用于不太复杂的场景。 配置变更需更新资源或重启容器，动态性较弱。 遵循 Kubernetes 资源管理体系，方便与其他资源协同管理。 Helm： 应用包管理工具，将多个资源打包为 Chart。 方便应用的一键部署、升级和回滚，版本管理强大。 可从社区获取大量 Chart，也支持自定义扩展。 二、适用场景 Nacos 配置中心： 复杂微服务架构，对配置动态更新和服务发现有高要求。 跨多个环境、项目的统一配置管理。 ConfigMap： Kubernetes 集群内简单应用的配置分发。 对配置管理要求不高的小型应用场景。 Helm： 复杂应用在不同环境的快速部署和管理。 需要频繁更新、升级的应用。 技术选型建议： 如果你的应用是一个简单的 Kubernetes 应用，对配置管理要求不高，且不需要复杂的动态更新和服务发现功能，那么可以优先选择 ConfigMap。它与 Kubernetes 紧密集成，使用方便，对于小型项目或不太复杂的场景足够满足需求。 对于复杂的微服务架构，特别是需要集中管理配置、实现动态配置更新和服务发现的情况，Nacos 配置中心是一个不错的选择。它能够提供更强大的配置管理和服务协调能力，有助于提高微服务系统的灵活性和可维护性。 当你需要快速部署和管理复杂的 Kubernetes 应用，尤其是在不同环境中频繁进行应用的更新和升级时，Helm 是一个很好的工具。它可以将应用打包为可重复使用的 Chart，方便进行版本管理和部署，提高部署效率和可维护性。 ","permalink":"https://gopherding.github.io/posts/tech/k8s%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B/","summary":"\u003ch3 id=\"一nacos-配置中心\"\u003e\u003cstrong\u003e一、Nacos 配置中心\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"配置管理深度\"\u003e\u003cstrong\u003e配置管理深度\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e提供细粒度的配置管理，可以针对不同的服务、不同的环境进行独立的配置设置。例如，一个微服务架构中的多个服务可以各自拥有独特的配置项，同时在不同的开发、测试、生产环境下又可以有不同的配置值。\u003c/li\u003e\n\u003cli\u003e支持配置的版本控制，能够方便地回滚到特定版本的配置。这对于在配置变更出现问题时进行快速恢复非常有用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"动态更新机制\"\u003e\u003cstrong\u003e动态更新机制\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e当配置发生变化时，Nacos 能够实时地将更新推送给订阅了该配置的服务实例。这种主动推送的方式可以确保服务快速响应配置变化，无需等待服务的定期拉取或手动触发更新。\u003c/li\u003e\n\u003cli\u003e支持配置的监听机制，服务可以在运行时持续监听配置的变化，一旦有更新立即应用新配置，保证服务的灵活性和适应性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"服务发现集成\"\u003e\u003cstrong\u003e服务发现集成\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e与服务发现功能紧密集成，不仅可以管理配置，还能帮助服务之间进行高效的发现和通信。例如，服务在启动时可以从 Nacos 中获取所需的配置信息，同时注册自己的服务实例，方便其他服务发现和调用。\u003c/li\u003e\n\u003cli\u003e对于动态扩缩容的场景，新加入的服务实例可以自动注册到 Nacos，并获取最新的配置，实现无缝的服务扩展。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二configmap\"\u003e\u003cstrong\u003e二、ConfigMap\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"kubernetes-内集成度\"\u003e\u003cstrong\u003eKubernetes 内集成度\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e作为 Kubernetes 的原生资源对象，与 Kubernetes 的其他组件（如 Pod、Deployment 等）紧密集成。可以通过 Kubernetes 的声明式配置文件轻松定义和管理 ConfigMap，并将其挂载到容器中。\u003c/li\u003e\n\u003cli\u003e与 Kubernetes 的命名空间概念结合，方便在不同的命名空间中管理不同的配置集，实现一定程度的环境隔离。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"配置简单性\"\u003e\u003cstrong\u003e配置简单性\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e主要适用于存储相对简单的键值对形式的配置数据。对于不太复杂的应用配置场景，ConfigMap 提供了一种简洁的方式来传递配置信息给容器。\u003c/li\u003e\n\u003cli\u003e不具备复杂的配置版本管理和动态推送功能，但可以通过更新 Kubernetes 资源来实现配置的变更，不过这种方式相对较为繁琐。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"资源管理角度\"\u003e\u003cstrong\u003e资源管理角度\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eConfigMap 的管理与 Kubernetes 的资源管理体系一致，可以利用 Kubernetes 的工具和命令进行查看、修改和删除等操作。同时，Kubernetes 的控制器可以自动管理依赖于 ConfigMap 的资源，确保配置的一致性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三helm\"\u003e\u003cstrong\u003e三、Helm\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"应用打包与部署\"\u003e\u003cstrong\u003e应用打包与部署\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e专注于将整个应用打包为可重复使用的 Chart。一个 Chart 可以包含多个 Kubernetes 资源对象（如 Deployment、Service、ConfigMap 等），以及应用的特定配置和依赖关系。\u003c/li\u003e\n\u003cli\u003e通过 Helm，可以方便地将复杂的应用部署到不同的 Kubernetes 环境中，实现一键式部署和升级。例如，一个包含多个微服务的应用可以通过一个 Helm Chart 进行统一管理和部署。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"版本管理与回滚\"\u003e\u003cstrong\u003e版本管理与回滚\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e对应用的版本管理非常强大。每次安装或升级应用时，Helm 会记录版本信息，方便在需要时进行回滚到特定版本。这对于在生产环境中进行应用的迭代更新非常重要，可以降低更新风险。\u003c/li\u003e\n\u003cli\u003e可以轻松比较不同版本的 Chart 之间的差异，帮助用户了解应用的变更历史。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"社区与可扩展性\"\u003e\u003cstrong\u003e社区与可扩展性\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eHelm 拥有活跃的社区，有大量的开源 Chart 可供使用。用户可以从 Helm 仓库中获取各种常见应用的 Chart，并根据自己的需求进行定制。\u003c/li\u003e\n\u003cli\u003e支持自定义插件和扩展，可以根据特定的需求开发自己的 Helm 插件，增强 Helm 的功能。同时，也可以将自己开发的 Chart 分享到社区，供其他用户使用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"总之\"\u003e总之：\u003c/h3\u003e\n\u003ch4 id=\"一功能特点\"\u003e一、功能特点\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch5 id=\"nacos-配置中心\"\u003eNacos 配置中心：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e集中管理配置，支持多环境、多项目配置。\u003c/li\u003e\n\u003cli\u003e强大的动态配置更新和推送机制，实时生效。\u003c/li\u003e\n\u003cli\u003e集成服务发现功能，适用于复杂微服务架构。\u003c/li\u003e\n\u003cli\u003e支持多种配置格式，配置管理细粒度高，有版本控制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"configmap\"\u003eConfigMap：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003eKubernetes 原生资源，与集群紧密集成。\u003c/li\u003e\n\u003cli\u003e存储简单键值对配置，适用于不太复杂的场景。\u003c/li\u003e\n\u003cli\u003e配置变更需更新资源或重启容器，动态性较弱。\u003c/li\u003e\n\u003cli\u003e遵循 Kubernetes 资源管理体系，方便与其他资源协同管理。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"helm\"\u003eHelm：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e应用包管理工具，将多个资源打包为 Chart。\u003c/li\u003e\n\u003cli\u003e方便应用的一键部署、升级和回滚，版本管理强大。\u003c/li\u003e\n\u003cli\u003e可从社区获取大量 Chart，也支持自定义扩展。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"二适用场景\"\u003e二、适用场景\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch5 id=\"nacos-配置中心-1\"\u003eNacos 配置中心：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e复杂微服务架构，对配置动态更新和服务发现有高要求。\u003c/li\u003e\n\u003cli\u003e跨多个环境、项目的统一配置管理。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"configmap-1\"\u003eConfigMap：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003eKubernetes 集群内简单应用的配置分发。\u003c/li\u003e\n\u003cli\u003e对配置管理要求不高的小型应用场景。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"helm-1\"\u003eHelm：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e复杂应用在不同环境的快速部署和管理。\u003c/li\u003e\n\u003cli\u003e需要频繁更新、升级的应用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"技术选型建议\"\u003e\u003cstrong\u003e技术选型建议：\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e如果你的应用是一个简单的 Kubernetes 应用，对配置管理要求不高，且不需要复杂的动态更新和服务发现功能，那么可以优先选择 ConfigMap。它与 Kubernetes 紧密集成，使用方便，对于小型项目或不太复杂的场景足够满足需求。\u003c/li\u003e\n\u003cli\u003e对于复杂的微服务架构，特别是需要集中管理配置、实现动态配置更新和服务发现的情况，Nacos 配置中心是一个不错的选择。它能够提供更强大的配置管理和服务协调能力，有助于提高微服务系统的灵活性和可维护性。\u003c/li\u003e\n\u003cli\u003e当你需要快速部署和管理复杂的 Kubernetes 应用，尤其是在不同环境中频繁进行应用的更新和升级时，Helm 是一个很好的工具。它可以将应用打包为可重复使用的 Chart，方便进行版本管理和部署，提高部署效率和可维护性。\u003c/li\u003e\n\u003c/ol\u003e","title":"K8s的配置中心选型"},{"content":"无头服务（Headless Service）在 Kubernetes 中是一种特殊类型的服务，它没有 Cluster IP，直接通过 DNS 解析到后端的 Pod。以下是使用无头服务的步骤：\n一、创建无头服务的 YAML 文件 以下是一个简单的无头服务的 YAML 配置示例：\napiVersion: v1 kind: Service metadata: name: my-headless-service spec: clusterIP: None selector: app: my-app 在这个配置中：\nclusterIP: None表示这是一个无头服务。 selector指定了这个服务应该将流量路由到具有app: my-app标签的 Pod。 二、应用无头服务 使用kubectl apply -f命令来应用这个 YAML 文件：\nkubectl apply -f headless-service.yaml 三、使用无头服务 直接通过 DNS 访问后端 Pod： Kubernetes 会为无头服务创建一个 DNS 条目，格式为\u0026lt;service-name\u0026gt;.\u0026lt;namespace\u0026gt;.svc.cluster.local。这个 DNS 条目会解析到后端的 Pod IP 地址。 例如，如果你的无头服务名为my-headless-service，在同一命名空间中，可以通过my-headless-service.\u0026lt;namespace\u0026gt;.svc.cluster.local来访问后端的 Pod。 在应用程序中使用： 如果你的应用程序在 Kubernetes 集群内部运行，可以直接使用这个 DNS 条目来访问无头服务后端的 Pod。 例如，在一个 Java 应用程序中，可以使用java.net.InetAddress类来解析这个 DNS 条目，并建立连接到后端的 Pod。 四、无头服务的常见用途 有状态应用： 对于有状态应用，如数据库集群或分布式存储系统，无头服务可以用于确保每个实例都有一个唯一的 DNS 名称，方便应用程序进行发现和连接。 自定义负载均衡： 通过直接访问后端 Pod，应用程序可以实现自己的负载均衡策略，而不是依赖 Kubernetes 的默认负载均衡。 ","permalink":"https://gopherding.github.io/posts/tech/%E6%97%A0%E5%A4%B4%E6%9C%8D%E5%8A%A1headless-service/","summary":"\u003cp\u003e无头服务（Headless Service）在 Kubernetes 中是一种特殊类型的服务，它没有 Cluster IP，直接通过 DNS 解析到后端的 Pod。以下是使用无头服务的步骤：\u003c/p\u003e\n\u003ch3 id=\"一创建无头服务的-yaml-文件\"\u003e\u003cstrong\u003e一、创建无头服务的 YAML 文件\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e以下是一个简单的无头服务的 YAML 配置示例：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ev1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eService\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-headless-service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003eclusterIP\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003eselector\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在这个配置中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eclusterIP: None\u003c/code\u003e表示这是一个无头服务。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eselector\u003c/code\u003e指定了这个服务应该将流量路由到具有\u003ccode\u003eapp: my-app\u003c/code\u003e标签的 Pod。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"二应用无头服务\"\u003e\u003cstrong\u003e二、应用无头服务\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e使用\u003ccode\u003ekubectl apply -f\u003c/code\u003e命令来应用这个 YAML 文件：\u003c/p\u003e","title":"无头服务(Headless Service)"},{"content":"一、区别 ClusterIP： 访问范围：仅在集群内部可访问。 特点：分配的虚拟 IP 地址稳定，适合集群内部服务之间的通信。不需要暴露服务到外部网络，安全性相对较高。 负载均衡方式：由 Kubernetes 内部机制实现，通常是通过 iptables 规则或 IPVS 规则。 NodePort： 访问范围：可以通过集群中任何节点的 IP 地址和特定的端口从外部访问。 特点：相对简单直接地将服务暴露到外部，但需要管理节点上的端口范围，可能会与其他服务的端口冲突。 负载均衡方式：Kubernetes 将外部请求分发到各个节点，节点再转发到内部服务，最终由内部负载均衡机制将请求路由到后端 Pod。 LoadBalancer： 访问范围：通过云提供商的外部负载均衡器从外部访问，通常具有高可用性和高性能。 特点：在云环境中方便使用，但依赖于特定的云提供商，可能会产生额外的费用。 负载均衡方式：云提供商的负载均衡器将流量分发到各个节点，Kubernetes 内部机制处理节点到服务的路由。 Ingress： 访问范围：通过定义的域名和路径从外部访问，可以根据不同的规则将请求路由到不同的服务。 特点：提供了更灵活的路由和负载均衡功能，可以整合多种服务到一个入口点。需要部署和配置 Ingress 控制器。 负载均衡方式：Ingress 控制器根据配置的规则进行反向代理，将请求转发到相应的服务。 二、技术选型要点 考虑访问需求： 如果服务仅需要在集群内部被访问，ClusterIP 是一个合适的选择。例如，数据库服务通常只需要被集群内的其他应用访问。 如果需要从外部访问服务，并且对高可用性和性能要求不高，可以考虑 NodePort。比如，在开发和测试环境中，可能会使用 NodePort 来临时暴露服务。 如果在云环境中，并且需要高可用性和高性能的外部访问，可以选择 LoadBalancer。对于面向公众的关键业务应用，LoadBalancer 可能是更好的选择。 如果有多个服务需要统一的入口点，并且需要灵活的路由规则，Ingress 是一个很好的选择。例如，一个微服务架构的应用，可以使用 Ingress 来管理不同服务的访问。 考虑安全性： ClusterIP 由于仅在集群内部可访问，相对来说安全性较高。如果服务包含敏感信息，不希望被外部直接访问，可以选择 ClusterIP，并通过其他安全机制（如 VPN）来实现外部的有限访问。 NodePort 和 LoadBalancer 将服务直接暴露到外部网络，需要采取额外的安全措施，如使用身份验证、授权和加密等。 Ingress 可以通过配置 SSL/TLS 证书来实现加密通信，并可以结合其他安全策略来保护服务。 考虑资源和成本： ClusterIP 不需要额外的资源和成本，仅依赖于 Kubernetes 集群的内部网络。 NodePort 需要管理节点上的端口资源，并且可能会与其他服务冲突。在大规模集群中，端口管理可能会变得复杂。 LoadBalancer 通常会产生额外的费用，具体费用取决于云提供商。在选择 LoadBalancer 时，需要考虑成本效益。 Ingress 控制器的资源消耗取决于具体的实现和配置。一些 Ingress 控制器可能需要较多的资源，特别是在处理大量并发请求时。 考虑可维护性和灵活性： ClusterIP 和 NodePort 相对简单，易于理解和维护。但它们的灵活性有限，不太适合复杂的访问场景。 LoadBalancer 由云提供商管理，通常具有高可用性和可维护性。但在跨云或混合云环境中，可能会受到限制。 Ingress 提供了丰富的功能和灵活性，可以根据不同的需求进行定制。但需要部署和配置 Ingress 控制器，增加了一定的复杂性。 ","permalink":"https://gopherding.github.io/posts/tech/k8s%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/","summary":"\u003ch3 id=\"一区别\"\u003e\u003cstrong\u003e一、区别\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"clusterip\"\u003e\u003cstrong\u003eClusterIP\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e访问范围\u003c/strong\u003e：仅在集群内部可访问。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e特点\u003c/strong\u003e：分配的虚拟 IP 地址稳定，适合集群内部服务之间的通信。不需要暴露服务到外部网络，安全性相对较高。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e负载均衡方式\u003c/strong\u003e：由 Kubernetes 内部机制实现，通常是通过 iptables 规则或 IPVS 规则。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"nodeport\"\u003e\u003cstrong\u003eNodePort\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e访问范围\u003c/strong\u003e：可以通过集群中任何节点的 IP 地址和特定的端口从外部访问。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e特点\u003c/strong\u003e：相对简单直接地将服务暴露到外部，但需要管理节点上的端口范围，可能会与其他服务的端口冲突。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e负载均衡方式\u003c/strong\u003e：Kubernetes 将外部请求分发到各个节点，节点再转发到内部服务，最终由内部负载均衡机制将请求路由到后端 Pod。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"loadbalancer\"\u003e\u003cstrong\u003eLoadBalancer\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e访问范围\u003c/strong\u003e：通过云提供商的外部负载均衡器从外部访问，通常具有高可用性和高性能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e特点\u003c/strong\u003e：在云环境中方便使用，但依赖于特定的云提供商，可能会产生额外的费用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e负载均衡方式\u003c/strong\u003e：云提供商的负载均衡器将流量分发到各个节点，Kubernetes 内部机制处理节点到服务的路由。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"ingress\"\u003e\u003cstrong\u003eIngress\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e访问范围\u003c/strong\u003e：通过定义的域名和路径从外部访问，可以根据不同的规则将请求路由到不同的服务。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e特点\u003c/strong\u003e：提供了更灵活的路由和负载均衡功能，可以整合多种服务到一个入口点。需要部署和配置 Ingress 控制器。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e负载均衡方式\u003c/strong\u003e：Ingress 控制器根据配置的规则进行反向代理，将请求转发到相应的服务。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二技术选型要点\"\u003e\u003cstrong\u003e二、技术选型要点\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"考虑访问需求\"\u003e\u003cstrong\u003e考虑访问需求\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e如果服务仅需要在集群内部被访问，ClusterIP 是一个合适的选择。例如，数据库服务通常只需要被集群内的其他应用访问。\u003c/li\u003e\n\u003cli\u003e如果需要从外部访问服务，并且对高可用性和性能要求不高，可以考虑 NodePort。比如，在开发和测试环境中，可能会使用 NodePort 来临时暴露服务。\u003c/li\u003e\n\u003cli\u003e如果在云环境中，并且需要高可用性和高性能的外部访问，可以选择 LoadBalancer。对于面向公众的关键业务应用，LoadBalancer 可能是更好的选择。\u003c/li\u003e\n\u003cli\u003e如果有多个服务需要统一的入口点，并且需要灵活的路由规则，Ingress 是一个很好的选择。例如，一个微服务架构的应用，可以使用 Ingress 来管理不同服务的访问。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"考虑安全性\"\u003e\u003cstrong\u003e考虑安全性\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eClusterIP 由于仅在集群内部可访问，相对来说安全性较高。如果服务包含敏感信息，不希望被外部直接访问，可以选择 ClusterIP，并通过其他安全机制（如 VPN）来实现外部的有限访问。\u003c/li\u003e\n\u003cli\u003eNodePort 和 LoadBalancer 将服务直接暴露到外部网络，需要采取额外的安全措施，如使用身份验证、授权和加密等。\u003c/li\u003e\n\u003cli\u003eIngress 可以通过配置 SSL/TLS 证书来实现加密通信，并可以结合其他安全策略来保护服务。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"考虑资源和成本\"\u003e\u003cstrong\u003e考虑资源和成本\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eClusterIP 不需要额外的资源和成本，仅依赖于 Kubernetes 集群的内部网络。\u003c/li\u003e\n\u003cli\u003eNodePort 需要管理节点上的端口资源，并且可能会与其他服务冲突。在大规模集群中，端口管理可能会变得复杂。\u003c/li\u003e\n\u003cli\u003eLoadBalancer 通常会产生额外的费用，具体费用取决于云提供商。在选择 LoadBalancer 时，需要考虑成本效益。\u003c/li\u003e\n\u003cli\u003eIngress 控制器的资源消耗取决于具体的实现和配置。一些 Ingress 控制器可能需要较多的资源，特别是在处理大量并发请求时。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"考虑可维护性和灵活性\"\u003e\u003cstrong\u003e考虑可维护性和灵活性\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eClusterIP 和 NodePort 相对简单，易于理解和维护。但它们的灵活性有限，不太适合复杂的访问场景。\u003c/li\u003e\n\u003cli\u003eLoadBalancer 由云提供商管理，通常具有高可用性和可维护性。但在跨云或混合云环境中，可能会受到限制。\u003c/li\u003e\n\u003cli\u003eIngress 提供了丰富的功能和灵活性，可以根据不同的需求进行定制。但需要部署和配置 Ingress 控制器，增加了一定的复杂性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"K8s的几种服务访问的技术选型"},{"content":" 环境搭建 安装 Prometheus 下载安装包：从 Prometheus 官方网站（https://prometheus.io/download/）下载适合你操作系统的二进制文件。例如，在 Linux 系统下： wget https://github.com/prometheus/prometheus/releases/download/v2.34.0/prometheus - 2.34.0.linux - amd64.tar.gz 解压并配置： tar -zxvf prometheus - 2.34.0.linux - amd64.tar.gz cd prometheus - 2.34.0.linux - amd64 编辑prometheus.yml配置文件，这是 Prometheus 的核心配置文件。可以在其中定义要监控的目标，例如监控本地主机的节点信息（Node Exporter）和应用程序暴露的自定义指标。以下是一个简单的示例：\nglobal: scrape_interval: 15s # 抓取间隔 scrape_configs: - job_name: \u0026#39;node\u0026#39; static_configs: - targets: [\u0026#39;localhost:9100\u0026#39;] # 假设Node Exporter在9100端口暴露指标 - job_name: \u0026#39;my_app\u0026#39; static_configs: - targets: [\u0026#39;localhost:8080/metrics\u0026#39;] # 假设应用在8080端口的/metrics路径暴露指标 启动 Prometheus： ./prometheus --config.file=prometheus.yml 安装 Grafana 下载安装包：从 Grafana 官方网站（https://grafana.com/grafana/download）下载适合你操作系统的安装包。例如，对于 Linux 系统下的安装包： wget https://dl.grafana.com/oss/release/grafana - 8.3.0 - 1.x86_64.rpm 安装并启动： sudo yum -y install grafana - 8.3.0 - 1.x86_64.rpm sudo systemctl start grafana - server Prometheus 数据采集与存储 指标采集：Prometheus 按照prometheus.yml配置文件中定义的scrape_interval，定期从目标（如localhost:9100的 Node Exporter 和localhost:8080/metrics的应用自定义指标）抓取指标数据。这些指标数据是基于 Prometheus 的指标格式定义的，例如node_cpu_usage（节点 CPU 使用率）、my_app_request_count（应用请求计数）等。 数据存储：Prometheus 将采集到的指标数据存储在本地的时间序列数据库中。存储的数据结构基于时间戳和指标名称，以及对应的标签（用于区分不同维度的数据）。例如，node_cpu_usage{instance=\u0026quot;localhost:9100\u0026quot;, cpu=\u0026quot;cpu0\u0026quot;}表示在localhost:9100这个实例上，CPU0 的使用率指标。 Grafana 数据可视化 添加数据源： 登录 Grafana Web 界面（默认地址是http://localhost:3000，初始用户名和密码是admin）。 在Configuration - Data Sources中添加 Prometheus 数据源。填写 Prometheus 服务器的地址（如http://localhost:9090），然后点击Save \u0026amp; Test确保连接成功。 创建仪表盘（Dashboard）： 在 Grafana 中，可以通过导入已有的仪表盘模板或者自己创建仪表盘。例如，要创建一个简单的节点 CPU 使用率监控仪表盘，点击+ - Dashboard - Add new panel。 在面板编辑中，选择数据源为之前添加的 Prometheus，在查询编辑器（Query Editor）中输入 PromQL（Prometheus Query Language）查询，如node_cpu_usage来获取节点 CPU 使用率指标。 根据需要设置图表的类型（如折线图、柱状图等）、时间范围、坐标轴标签等可视化参数，然后保存仪表盘。 实现自动监控报警 配置 Prometheus Alertmanager 下载安装 Alertmanager：从 Prometheus 官方网站（https://prometheus.io/download/）下载 Alertmanager 二进制文件。例如，在 Linux 系统下： wget https://github.com/prometheus/alertmanager/releases/download/v0.23.0/alertmanager - 0.23.0.linux - amd64.tar.gz 解压并配置： tar -zxvf alertmanager - 0.23.0.linux - amd64.tar.gz cd alertmanager - 0.23.0.linux - amd64 编辑alertmanager.yml配置文件，这是 Alertmanager 的核心配置文件。以下是一个简单的配置示例，用于发送邮件报警：\nglobal: smtp_smarthost: \u0026#39;smtp.example.com:587\u0026#39; # 邮件服务器地址和端口 smtp_from: \u0026#39;alerts@example.com\u0026#39; # 发件人邮箱 smtp_auth_username: \u0026#39;alerts@example.com\u0026#39; # 用于认证的用户名 smtp_auth_password: \u0026#39;password\u0026#39; # 认证密码 route: receiver: \u0026#39;email - receiver\u0026#39; group_by: [\u0026#39;alertname\u0026#39;] group_wait: 30s group_interval: 5m repeat_interval: 1h receivers: - name: \u0026#39;email - receiver\u0026#39; email_configs: - to: \u0026#39;admin@example.com\u0026#39; # 收件人邮箱 subject: \u0026#39;Prometheus Alert\u0026#39; 启动 Alertmanager： ./alertmanager --config.file=alertmanager.yml 在 Prometheus 中配置报警规则： 编辑 Prometheus 的prometheus.yml配置文件，添加报警规则文件的路径，例如： rule_files: - \u0026#34;alert.rules.yml\u0026#34; 创建alert.rules.yml文件，定义报警规则。例如，当节点 CPU 使用率超过 80% 时触发报警： groups: - name: cpu - usage - alerts rules: - alert: HighCPUUsage expr: node_cpu_usage \u0026gt; 0.8 for: 2m # 持续时间达到2分钟才触发报警 labels: severity: critical annotations: summary: \u0026#34;High CPU Usage Detected\u0026#34; description: \u0026#34;CPU usage on the node has exceeded 80% for more than 2 minutes.\u0026#34; 默认端口：9090\n文档：https://prometheus.ac.cn/docs/prometheus/latest/getting_started/#using-the-expression-browser\n使用说明：https://blog.csdn.net/qq_31725371/article/details/114697770\n","permalink":"https://gopherding.github.io/posts/tech/%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"环境搭建\"\u003e\u003cstrong\u003e环境搭建\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"安装-prometheus\"\u003e\u003cstrong\u003e安装 Prometheus\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e下载安装包\u003c/strong\u003e：从 Prometheus 官方网站（https://prometheus.io/download/）下载适合你操作系统的二进制文件。例如，在 Linux 系统下：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       wget https://github.com/prometheus/prometheus/releases/download/v2.34.0/prometheus - 2.34.0.linux - amd64.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"解压并配置\"\u003e\u003cstrong\u003e解压并配置\u003c/strong\u003e：\u003c/h4\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       tar -zxvf prometheus - 2.34.0.linux - amd64.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       cd prometheus - 2.34.0.linux - amd64\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e编辑\u003ccode\u003eprometheus.yml\u003c/code\u003e配置文件，这是 Prometheus 的核心配置文件。可以在其中定义要监控的目标，例如监控本地主机的节点信息（Node Exporter）和应用程序暴露的自定义指标。以下是一个简单的示例：\u003c/p\u003e","title":"自动监控报警的实现"},{"content":"在 Kubernetes 中使用自定义的应用程序指标（通过 Prometheus 等监控系统暴露的指标）结合 Horizontal Pod Autoscaler（HPA）进行自动扩容，可以按照以下步骤进行操作：\n一、准备工作 安装 Prometheus 和相关组件： 在 Kubernetes 集群中安装 Prometheus 服务器、服务发现组件（如 Prometheus Operator）等，以便收集和存储应用程序的指标数据。 确保 Prometheus 能够正确地发现和监控目标应用程序的指标。 应用程序暴露指标： 在应用程序中集成指标暴露功能，例如使用 Prometheus client libraries 来暴露自定义的应用程序指标。 确保应用程序能够正确地将指标数据暴露给 Prometheus。 二、配置 Prometheus 和 HPA 创建 ServiceMonitor： 如果使用 Prometheus Operator，创建一个 ServiceMonitor 对象来定义 Prometheus 应该监控的目标服务。 ServiceMonitor 通常指定要监控的服务的标签选择器、端口和指标路径等信息。 例如： apiVersion: monitoring.coreos.com/v1 # 声明此资源对象的 API 版本来自 CoreOS 的监控组件 kind: ServiceMonitor # 表明这是一个 ServiceMonitor（服务监控器）资源对象 metadata: name: my-app-monitor # 此服务监控器的名称为 my-app-monitor spec: selector: # 用于选择要监控的服务的标签选择器 matchLabels: app: my-app # 选择具有标签 app: my-app 的服务进行监控 endpoints: # 定义要监控的服务的端点信息 - port: web # 要监控的服务的端口名为 web path: /metrics # 指标数据的路径为 /metrics，即 Prometheus 从这里获取指标数据 创建 HPA： 使用自定义指标创建一个 HPA 对象，指定要监控的指标名称、目标值和扩缩容规则。 例如： apiVersion: autoscaling/v2beta2 # 声明此资源对象的 API 版本为 autoscaling/v2beta2 kind: HorizontalPodAutoscaler # 表明这是一个 HorizontalPodAutoscaler（水平 Pod 自动扩缩器）资源对象 metadata: name: my-app-hpa # 此自动扩缩器的名称为 my-app-hpa spec: scaleTargetRef: # 指定要进行自动扩缩的目标资源 apiVersion: apps/v1 # 目标资源的 API 版本为 apps/v1 kind: Deployment # 目标资源的种类是 Deployment（部署） name: my-app # 目标 Deployment 的名称为 my-app metrics: - type: Pods # 指标类型为 Pods，表示基于 Pod 的指标进行扩缩容 pods: metric: name: my_custom_metric # 要使用的自定义指标名称为 my_custom_metric target: type: AverageValue # 目标值的类型为平均值 averageValue: 100 # 目标平均值为 100，即当自定义指标的平均值达到 100 时触发扩缩容操作 三、验证和调整 验证指标收集： 通过 Prometheus 的 Web UI 或查询接口验证 Prometheus 是否正确地收集了应用程序的自定义指标。 可以使用 PromQL 查询语言来检查指标的可用性和值。 观察自动扩容： 模拟应用程序的负载变化，观察 HPA 是否根据自定义指标自动调整 Pod 的数量。 可以通过增加负载生成工具（如ab、hey等）的并发请求数量来模拟高负载情况，观察 Pod 数量是否自动增加。 调整参数： 根据实际应用的需求和性能测试结果，调整 HPA 的参数，如目标值、最大和最小副本数等。 同时，也可以调整应用程序的指标暴露方式和阈值，以确保自动扩容机制能够有效地响应负载变化。 总之，使用自定义的应用程序指标结合 Prometheus 和 HPA 可以实现更加灵活和精确的自动扩容机制。通过正确地配置 Prometheus 和 HPA，并验证指标的收集和自动扩容的效果，可以提高应用程序的可用性和资源利用率。\n","permalink":"https://gopherding.github.io/posts/tech/hpa%E5%92%8Cprometheus%E8%81%94%E5%8A%A8/","summary":"\u003cp\u003e在 Kubernetes 中使用自定义的应用程序指标（通过 Prometheus 等监控系统暴露的指标）结合 Horizontal Pod Autoscaler（HPA）进行自动扩容，可以按照以下步骤进行操作：\u003c/p\u003e\n\u003ch3 id=\"一准备工作\"\u003e\u003cstrong\u003e一、准备工作\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"安装-prometheus-和相关组件\"\u003e安装 Prometheus 和相关组件：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在 Kubernetes 集群中安装 Prometheus 服务器、服务发现组件（如 Prometheus Operator）等，以便收集和存储应用程序的指标数据。\u003c/li\u003e\n\u003cli\u003e确保 Prometheus 能够正确地发现和监控目标应用程序的指标。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"应用程序暴露指标\"\u003e应用程序暴露指标：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在应用程序中集成指标暴露功能，例如使用 Prometheus client libraries 来暴露自定义的应用程序指标。\u003c/li\u003e\n\u003cli\u003e确保应用程序能够正确地将指标数据暴露给 Prometheus。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二配置-prometheus-和-hpa\"\u003e\u003cstrong\u003e二、配置 Prometheus 和 HPA\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"创建-servicemonitor\"\u003e创建 ServiceMonitor：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e如果使用 Prometheus Operator，创建一个 ServiceMonitor 对象来定义 Prometheus 应该监控的目标服务。\u003c/li\u003e\n\u003cli\u003eServiceMonitor 通常指定要监控的服务的标签选择器、端口和指标路径等信息。\u003c/li\u003e\n\u003cli\u003e例如：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emonitoring.coreos.com/v1 \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 声明此资源对象的 API 版本来自 CoreOS 的监控组件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eServiceMonitor \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 表明这是一个 ServiceMonitor（服务监控器）资源对象\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app-monitor \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 此服务监控器的名称为 my-app-monitor\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003eselector\u003c/span\u003e:  \u003cspan style=\"color:#75715e\"\u003e# 用于选择要监控的服务的标签选择器\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003ematchLabels\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003eapp: my-app  # 选择具有标签 app\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app 的服务进行监控\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003eendpoints\u003c/span\u003e:  \u003cspan style=\"color:#75715e\"\u003e# 定义要监控的服务的端点信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  - \u003cspan style=\"color:#f92672\"\u003eport\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eweb \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 要监控的服务的端口名为 web\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003epath\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e/metrics \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 指标数据的路径为 /metrics，即 Prometheus 从这里获取指标数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003ch4 id=\"创建-hpa\"\u003e创建 HPA：\u003c/h4\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e使用自定义指标创建一个 HPA 对象，指定要监控的指标名称、目标值和扩缩容规则。\u003c/li\u003e\n\u003cli\u003e例如：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eautoscaling/v2beta2 \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 声明此资源对象的 API 版本为 autoscaling/v2beta2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eHorizontalPodAutoscaler \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 表明这是一个 HorizontalPodAutoscaler（水平 Pod 自动扩缩器）资源对象\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app-hpa \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 此自动扩缩器的名称为 my-app-hpa\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003escaleTargetRef\u003c/span\u003e:  \u003cspan style=\"color:#75715e\"\u003e# 指定要进行自动扩缩的目标资源\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eapps/v1 \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 目标资源的 API 版本为 apps/v1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eDeployment \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 目标资源的种类是 Deployment（部署）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 目标 Deployment 的名称为 my-app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003emetrics\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  - \u003cspan style=\"color:#f92672\"\u003etype\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ePods \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 指标类型为 Pods，表示基于 Pod 的指标进行扩缩容\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003epods\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003emetric\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy_custom_metric \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 要使用的自定义指标名称为 my_custom_metric\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003etarget\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003etype\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eAverageValue \u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e# 目标值的类型为平均值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003eaverageValue\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e# 目标平均值为 100，即当自定义指标的平均值达到 100 时触发扩缩容操作\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"三验证和调整\"\u003e\u003cstrong\u003e三、验证和调整\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"验证指标收集\"\u003e验证指标收集：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e通过 Prometheus 的 Web UI 或查询接口验证 Prometheus 是否正确地收集了应用程序的自定义指标。\u003c/li\u003e\n\u003cli\u003e可以使用 PromQL 查询语言来检查指标的可用性和值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"观察自动扩容\"\u003e观察自动扩容：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e模拟应用程序的负载变化，观察 HPA 是否根据自定义指标自动调整 Pod 的数量。\u003c/li\u003e\n\u003cli\u003e可以通过增加负载生成工具（如\u003ccode\u003eab\u003c/code\u003e、\u003ccode\u003ehey\u003c/code\u003e等）的并发请求数量来模拟高负载情况，观察 Pod 数量是否自动增加。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"调整参数\"\u003e调整参数：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e根据实际应用的需求和性能测试结果，调整 HPA 的参数，如目标值、最大和最小副本数等。\u003c/li\u003e\n\u003cli\u003e同时，也可以调整应用程序的指标暴露方式和阈值，以确保自动扩容机制能够有效地响应负载变化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e总之，使用自定义的应用程序指标结合 Prometheus 和 HPA 可以实现更加灵活和精确的自动扩容机制。通过正确地配置 Prometheus 和 HPA，并验证指标的收集和自动扩容的效果，可以提高应用程序的可用性和资源利用率。\u003c/p\u003e","title":"HPA和Prometheus联动自动扩容"},{"content":"","permalink":"https://gopherding.github.io/posts/tech/%E6%A8%A1%E6%9D%BF---%E5%89%AF%E6%9C%AC/","summary":"","title":"XXXXXXXXXXXXXX"},{"content":"","permalink":"https://gopherding.github.io/posts/tech/%E6%A8%A1%E6%9D%BF/","summary":"","title":"XXXXXXXXXXXXXX"},{"content":"一、蓝绿部署（Blue-Green Deployment） 概念： 准备两套完全相同的生产环境，分别称为蓝色环境和绿色环境。其中一个环境（比如蓝色）处于当前的生产状态，为用户提供服务；另一个环境（绿色）则用于部署新版本的应用。 过程： 首先在绿色环境中部署新版本应用，并进行充分的测试。 当准备好切换时，通过更改负载均衡器或路由规则，将所有流量从蓝色环境切换到绿色环境，此时绿色环境成为生产环境，而蓝色环境可以用于下一次的版本部署或回滚操作。 优点： 可以实现零停机时间发布，用户在切换过程中基本无感知。 方便回滚，如果新版本出现问题，可以快速将流量切换回蓝色环境。 缺点： 需要双倍的硬件资源来维持两套环境。 二、金丝雀发布（Canary Release） 概念： 先将一小部分用户流量导向新版本的应用（通常称为金丝雀版本），同时大部分用户流量仍然指向旧版本应用。通过观察金丝雀版本的性能和稳定性，来决定是否逐步扩大新版本的部署范围。 过程： 选择一小部分用户（可以通过 IP 地址、用户 ID 等方式），将他们的流量导向金丝雀版本。 监控金丝雀版本的关键指标，如响应时间、错误率、吞吐量等。 如果金丝雀版本表现良好，则逐步增加金丝雀版本的流量比例，直到全部用户都使用新版本。如果出现问题，则可以快速回滚到旧版本。 优点： 降低了发布风险，因为只有一小部分用户受到影响。 可以早期发现新版本中的问题，避免大规模故障。 缺点： 需要有良好的流量控制机制和监控系统来支持。 三、滚动发布（Rolling Deployment） 概念： 逐步更新生产环境中的应用实例，而不是一次性全部更新。通常是一个实例一个实例地进行更新，确保在任何时候都有部分旧版本的实例在运行，以保证服务的连续性。 过程： 首先更新一个或几个应用实例，然后对这些实例进行测试和观察。 如果更新后的实例运行正常，则继续更新下一批实例，直到所有实例都更新到新版本。 优点： 可以实现相对平滑的发布过程，对用户的影响较小。 不需要额外的硬件资源。 缺点： 发布过程相对较长，如果新版本存在严重问题，可能需要较长时间才能发现和回滚。 四、A/B 测试发布（A/B Testing Deployment） 概念： 将用户随机分为两组或多组，分别让他们访问不同版本的应用，通过比较不同版本的性能和用户反馈，来决定哪个版本更优。 过程： 确定要测试的变量，比如不同的界面设计、功能特性等。 将用户随机分配到不同的版本组中。 收集和分析用户行为数据、性能指标等，以评估不同版本的效果。 根据测试结果，选择最优版本进行全面发布。 优点： 可以帮助确定最优的版本，提高用户体验和业务效果。 可以同时测试多个变量，寻找最佳组合。 缺点： 需要有完善的用户分组和数据收集分析机制。 测试过程可能会比较复杂和耗时。 ","permalink":"https://gopherding.github.io/posts/tech/%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5/","summary":"\u003ch3 id=\"一蓝绿部署blue-green-deployment\"\u003e\u003cstrong\u003e一、蓝绿部署（Blue-Green Deployment）\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"概念\"\u003e概念：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e准备两套完全相同的生产环境，分别称为蓝色环境和绿色环境。其中一个环境（比如蓝色）处于当前的生产状态，为用户提供服务；另一个环境（绿色）则用于部署新版本的应用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"过程\"\u003e过程：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e首先在绿色环境中部署新版本应用，并进行充分的测试。\u003c/li\u003e\n\u003cli\u003e当准备好切换时，通过更改负载均衡器或路由规则，将所有流量从蓝色环境切换到绿色环境，此时绿色环境成为生产环境，而蓝色环境可以用于下一次的版本部署或回滚操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"优点\"\u003e优点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e可以实现零停机时间发布，用户在切换过程中基本无感知。\u003c/li\u003e\n\u003cli\u003e方便回滚，如果新版本出现问题，可以快速将流量切换回蓝色环境。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"缺点\"\u003e缺点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e需要双倍的硬件资源来维持两套环境。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二金丝雀发布canary-release\"\u003e\u003cstrong\u003e二、金丝雀发布（Canary Release）\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"概念-1\"\u003e概念：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e先将一小部分用户流量导向新版本的应用（通常称为金丝雀版本），同时大部分用户流量仍然指向旧版本应用。通过观察金丝雀版本的性能和稳定性，来决定是否逐步扩大新版本的部署范围。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"过程-1\"\u003e过程：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e选择一小部分用户（可以通过 IP 地址、用户 ID 等方式），将他们的流量导向金丝雀版本。\u003c/li\u003e\n\u003cli\u003e监控金丝雀版本的关键指标，如响应时间、错误率、吞吐量等。\u003c/li\u003e\n\u003cli\u003e如果金丝雀版本表现良好，则逐步增加金丝雀版本的流量比例，直到全部用户都使用新版本。如果出现问题，则可以快速回滚到旧版本。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"优点-1\"\u003e优点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e降低了发布风险，因为只有一小部分用户受到影响。\u003c/li\u003e\n\u003cli\u003e可以早期发现新版本中的问题，避免大规模故障。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"缺点-1\"\u003e缺点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e需要有良好的流量控制机制和监控系统来支持。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三滚动发布rolling-deployment\"\u003e\u003cstrong\u003e三、滚动发布（Rolling Deployment）\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"概念-2\"\u003e概念：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e逐步更新生产环境中的应用实例，而不是一次性全部更新。通常是一个实例一个实例地进行更新，确保在任何时候都有部分旧版本的实例在运行，以保证服务的连续性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"过程-2\"\u003e过程：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e首先更新一个或几个应用实例，然后对这些实例进行测试和观察。\u003c/li\u003e\n\u003cli\u003e如果更新后的实例运行正常，则继续更新下一批实例，直到所有实例都更新到新版本。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"优点-2\"\u003e优点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e可以实现相对平滑的发布过程，对用户的影响较小。\u003c/li\u003e\n\u003cli\u003e不需要额外的硬件资源。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"缺点-2\"\u003e缺点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e发布过程相对较长，如果新版本存在严重问题，可能需要较长时间才能发现和回滚。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"四ab-测试发布ab-testing-deployment\"\u003e\u003cstrong\u003e四、A/B 测试发布（A/B Testing Deployment）\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"概念-3\"\u003e概念：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e将用户随机分为两组或多组，分别让他们访问不同版本的应用，通过比较不同版本的性能和用户反馈，来决定哪个版本更优。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"过程-3\"\u003e过程：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e确定要测试的变量，比如不同的界面设计、功能特性等。\u003c/li\u003e\n\u003cli\u003e将用户随机分配到不同的版本组中。\u003c/li\u003e\n\u003cli\u003e收集和分析用户行为数据、性能指标等，以评估不同版本的效果。\u003c/li\u003e\n\u003cli\u003e根据测试结果，选择最优版本进行全面发布。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"优点-3\"\u003e优点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e可以帮助确定最优的版本，提高用户体验和业务效果。\u003c/li\u003e\n\u003cli\u003e可以同时测试多个变量，寻找最佳组合。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"缺点-3\"\u003e缺点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e需要有完善的用户分组和数据收集分析机制。\u003c/li\u003e\n\u003cli\u003e测试过程可能会比较复杂和耗时。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"版本更新发布策略"},{"content":" 创建初始 Deployment 和 Service： 首先，创建一个基本的 Deployment，它包含旧版本的应用容器。同时创建一个对应的 Service，将流量路由到这个 Deployment。 例如： apiVersion: apps/v1 kind: Deployment metadata: name: my-app spec: replicas: 3 selector: matchLabels: app: my-app template: metadata: labels: app: my-app spec: containers: - name: my-app-container image: old-version-image --- apiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 创建新的 Deployment 进行金丝雀发布： 创建一个新的 Deployment，其中包含新版本的应用容器。可以设置较少的副本数，比如 1 个副本，作为金丝雀版本。 例如： apiVersion: apps/v1 kind: Deployment metadata: name: my-app-canary spec: replicas: 1 selector: matchLabels: app: my-app-canary template: metadata: labels: app: my-app-canary spec: containers: - name: my-app-container image: new-version-image 修改 Service 以包含金丝雀 Deployment： 修改 Service 的 selector，使其同时选择旧版本和金丝雀版本的 Pod。这样，一部分流量会被路由到金丝雀版本的 Pod。 例如： apiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 修改为：\napiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app | app: my-app-canary ports: - protocol: TCP port: 80 targetPort: 8080 监控和评估： 通过监控工具观察金丝雀版本的性能、错误率等指标。如果金丝雀版本表现良好，可以逐渐增加金丝雀版本的副本数，同时减少旧版本的副本数，直到完全切换到新版本。 ","permalink":"https://gopherding.github.io/posts/tech/%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","summary":"\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"创建初始-deployment-和-service\"\u003e创建初始 Deployment 和 Service：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e首先，创建一个基本的 Deployment，它包含旧版本的应用容器。同时创建一个对应的 Service，将流量路由到这个 Deployment。\u003c/li\u003e\n\u003cli\u003e例如：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eapps/v1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eDeployment\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003ereplicas\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003eselector\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003ematchLabels\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003etemplate\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003elabels\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003econtainers\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app-container\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#f92672\"\u003eimage\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eold-version-image\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   ---\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ev1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eService\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app-service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003eselector\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003eports\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     - \u003cspan style=\"color:#f92672\"\u003eprotocol\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eTCP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003eport\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e80\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003etargetPort\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e8080\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003ch3 id=\"创建新的-deployment-进行金丝雀发布\"\u003e创建新的 Deployment 进行金丝雀发布：\u003c/h3\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e创建一个新的 Deployment，其中包含新版本的应用容器。可以设置较少的副本数，比如 1 个副本，作为金丝雀版本。\u003c/li\u003e\n\u003cli\u003e例如：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eapps/v1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eDeployment\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app-canary\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003ereplicas\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003eselector\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003ematchLabels\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app-canary\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003etemplate\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003elabels\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app-canary\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003econtainers\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app-container\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           \u003cspan style=\"color:#f92672\"\u003eimage\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003enew-version-image\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003ch3 id=\"修改-service-以包含金丝雀-deployment\"\u003e修改 Service 以包含金丝雀 Deployment：\u003c/h3\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e修改 Service 的 selector，使其同时选择旧版本和金丝雀版本的 Pod。这样，一部分流量会被路由到金丝雀版本的 Pod。\u003c/li\u003e\n\u003cli\u003e例如：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ev1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eService\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app-service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003eselector\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#f92672\"\u003eports\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     - \u003cspan style=\"color:#f92672\"\u003eprotocol\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eTCP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003eport\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e80\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#f92672\"\u003etargetPort\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e8080\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改为：\u003c/p\u003e","title":"金丝雀发布的使用方法"},{"content":"一、Pod 定义 apiVersion: v1 kind: Pod metadata: name: my-pod labels: app: my-app spec: containers: - name: my-container image: my-image ports: - containerPort: 8080 apiVersion：指定 Kubernetes API 的版本，对于 Pod 通常是 v1。\nkind：表明资源的类型，这里是 Pod。\nmetadata：包含 Pod 的元数据信息。 name：Pod 的名称，在集群中必须是唯一的。 labels：用于标识 Pod 的标签，可以用于选择器和分组。 spec：定义 Pod 的具体规格。 containers：列出 Pod 中的容器。 name：容器的名称。\nimage：容器使用的镜像名称。\nports：容器暴露的端口列表。 containerPort：容器内部监听的端口号。 二、Deployment 定义 apiVersion: apps/v1 kind: Deployment metadata: name: my-deployment spec: replicas: 3 selector: matchLabels: app: my-app template: metadata: labels: app: my-app spec: containers: - name: my-container image: my-image ports: - containerPort: 8080 apiVersion：对于 Deployment，通常是 apps/v1。\nkind：资源类型为 Deployment。\nmetadata： name：Deployment 的名称。 spec： replicas：指定要创建的 Pod 副本数量。 selector：用于选择要管理的 Pod 的标签选择器。 template：定义 Pod 的模板，与 Pod 的定义类似。 三、Service 定义 apiVersion: v1 kind: Service metadata: name: my-service spec: selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 type: ClusterIP apiVersion：通常是 v1。\nkind：资源类型为 Service。\nmetadata： name：Service 的名称。 spec： selector：选择要关联的 Pod 的标签。\nports ：定义服务的端口。\nprotocol：协议类型，通常是 TCP 或 UDP。 port：服务对外暴露的端口。 targetPort：后端 Pod 上的端口。 type：服务的类型，可以是 ClusterIP、NodePort、LoadBalancer 等。\n","permalink":"https://gopherding.github.io/posts/tech/k8s%E7%9A%84yaml%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%A7%A3%E6%9E%90/","summary":"\u003ch3 id=\"一pod-定义\"\u003e\u003cstrong\u003e一、Pod 定义\u003c/strong\u003e\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eapiVersion\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ev1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003ekind\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ePod\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003emetadata\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-pod\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003elabels\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003eapp\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003espec\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003econtainers\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-container\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003eimage\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003emy-image\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003eports\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    - \u003cspan style=\"color:#f92672\"\u003econtainerPort\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e8080\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eapiVersion\u003c/code\u003e：指定 Kubernetes API 的版本，对于 Pod 通常是 \u003ccode\u003ev1\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ekind\u003c/code\u003e：表明资源的类型，这里是 \u003ccode\u003ePod\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emetadata：包含 Pod 的元数据信息。\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ename\u003c/code\u003e：Pod 的名称，在集群中必须是唯一的。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elabels\u003c/code\u003e：用于标识 Pod 的标签，可以用于选择器和分组。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003espec：定义 Pod 的具体规格。\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econtainers：列出 Pod 中的容器。\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ename\u003c/code\u003e：容器的名称。\u003c/p\u003e","title":"K8s的Yaml文件内容解析"},{"content":" 命令 用途 示例 kubectl get 获取 Kubernetes 资源的信息。 kubectl get pods（列出所有 Pod）；kubectl get services（列出所有 Service）。 kubectl describe 提供特定 Kubernetes 资源的详细信息。 kubectl describe pod \u0026lt;pod-name\u0026gt;（描述特定 Pod）；kubectl describe service \u0026lt;service-name\u0026gt;（描述特定 Service）。 kubectl create 创建 Kubernetes 资源。 kubectl create -f deployment.yaml（从 YAML 文件创建 Deployment）；kubectl create service clusterip my-service --tcp=80:8080（创建 ClusterIP 类型 Service）。 kubectl delete 删除 Kubernetes 资源。 kubectl delete pod \u0026lt;pod-name\u0026gt;（删除特定 Pod）；kubectl delete -f deployment.yaml（根据 YAML 文件删除相应资源）。 kubectl logs 查看 Pod 中容器的日志。 kubectl logs \u0026lt;pod-name\u0026gt;。 kubectl exec 在 Pod 中的容器中执行命令。 kubectl exec -it \u0026lt;pod-name\u0026gt; -- /bin/bash（在特定 Pod 的容器中启动交互式 Bash shell）。 kubectl rollout status 查看 Deployment 的滚动更新状态。 kubectl rollout status deployment/\u0026lt;deployment-name\u0026gt;。 kubectl rollout undo 回滚 Deployment 到上一个版本。 kubectl rollout undo deployment/\u0026lt;deployment-name\u0026gt;。 kubectl get namespaces 列出所有的命名空间。 kubectl create namespace \u0026lt;namespace-name\u0026gt; 创建一个新的命名空间。 kubectl -n \u0026lt;namespace-name\u0026gt; \u0026lt;command\u0026gt; 在特定的命名空间中执行命令。 kubectl -n my-namespace get pods（在 “my-namespace” 命名空间中列出 Pod）。 kubectl get nodes 列出所有的 Kubernetes 节点。 kubectl describe node \u0026lt;node-name\u0026gt; 描述特定的节点，包括其状态、资源使用情况等信息。 ","permalink":"https://gopherding.github.io/posts/tech/kuberctl%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/","summary":"\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e命令\u003c/th\u003e\n          \u003cth\u003e用途\u003c/th\u003e\n          \u003cth\u003e示例\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl get\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e获取 Kubernetes 资源的信息。\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl get pods\u003c/code\u003e（列出所有 Pod）；\u003ccode\u003ekubectl get services\u003c/code\u003e（列出所有 Service）。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl describe\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e提供特定 Kubernetes 资源的详细信息。\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl describe pod \u0026lt;pod-name\u0026gt;\u003c/code\u003e（描述特定 Pod）；\u003ccode\u003ekubectl describe service \u0026lt;service-name\u0026gt;\u003c/code\u003e（描述特定 Service）。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl create\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e创建 Kubernetes 资源。\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl create -f deployment.yaml\u003c/code\u003e（从 YAML 文件创建 Deployment）；\u003ccode\u003ekubectl create service clusterip my-service --tcp=80:8080\u003c/code\u003e（创建 ClusterIP 类型 Service）。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl delete\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e删除 Kubernetes 资源。\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl delete pod \u0026lt;pod-name\u0026gt;\u003c/code\u003e（删除特定 Pod）；\u003ccode\u003ekubectl delete -f deployment.yaml\u003c/code\u003e（根据 YAML 文件删除相应资源）。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl logs\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看 Pod 中容器的日志。\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl logs \u0026lt;pod-name\u0026gt;\u003c/code\u003e。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl exec\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e在 Pod 中的容器中执行命令。\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl exec -it \u0026lt;pod-name\u0026gt; -- /bin/bash\u003c/code\u003e（在特定 Pod 的容器中启动交互式 Bash shell）。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl rollout status\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e查看 Deployment 的滚动更新状态。\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl rollout status deployment/\u0026lt;deployment-name\u0026gt;\u003c/code\u003e。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl rollout undo\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e回滚 Deployment 到上一个版本。\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl rollout undo deployment/\u0026lt;deployment-name\u0026gt;\u003c/code\u003e。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl get namespaces\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e列出所有的命名空间。\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl create namespace \u0026lt;namespace-name\u0026gt;\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e创建一个新的命名空间。\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl -n \u0026lt;namespace-name\u0026gt; \u0026lt;command\u0026gt;\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e在特定的命名空间中执行命令。\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl -n my-namespace get pods\u003c/code\u003e（在 “my-namespace” 命名空间中列出 Pod）。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl get nodes\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e列出所有的 Kubernetes 节点。\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003ekubectl describe node \u0026lt;node-name\u0026gt;\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e描述特定的节点，包括其状态、资源使用情况等信息。\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"kuberctl命令速查表"},{"content":"k8s主要由master节点和node节点构成。\nmaster节点负责管理集群，node节点是容器应用真正运行的地方。\nmaster节点包含的组件有：kube-api-server、kube-controller-manager、kube-scheduler、etcd。\nnode节点包含的组件有：kubelet、kube-proxy、container-runtime。\nkube-api-server： 以下简称api-server，api-server是k8s最重要的核心组件之一，它是k8s集群管理的统一访问入口，提供了RESTful API接口, 实现了认证、授权和准入控制等安全功能；api-server还是其他组件之间的数据交互和通信的枢纽，其他组件彼此之间并不会直接通信，其他组件对资源对象的增、删、改、查和监听操作都是交由api-server处理后，api-server再提交给etcd数据库做持久化存储，只有api-server才能直接操作etcd数据库，其他组件都不能直接操作etcd数据库，其他组件都是通过api-server间接的读取，写入数据到etcd。\nkube-controller-manager： 以下简称controller-manager，controller-manager是k8s中各种控制器的的管理者，是k8s集群内部的管理控制中心，也是k8s自动化功能的核心；controller-manager内部包含replication controller、node controller、deployment controller、endpoint controller等各种资源对象的控制器，每种控制器都负责一种特定资源的控制流程，而controller-manager正是这些controller的核心管理者。\nkube-scheduler： 以下简称scheduler，scheduler负责集群资源调度，其作用是将待调度的pod通过一系列复杂的调度算法计算出最合适的node节点，然后将pod绑定到目标节点上。shceduler会根据pod的信息，全部节点信息列表，过滤掉不符合要求的节点，过滤出一批候选节点，然后给候选节点打分，选分最高的就是最佳节点，scheduler就会把目标pod安置到该节点。\nEtcd： etcd是一个分布式的键值对存储数据库，主要是用于保存k8s集群状态数据，比如，pod，service等资源对象的信息；etcd可以是单个也可以有多个，多个就是etcd数据库集群，etcd通常部署奇数个实例，在大规模集群中，etcd有5个或7个节点就足够了；另外说明一点，etcd本质上可以不与master节点部署在一起，只要master节点能通过网络连接etcd数据库即可。\nkubelet： 每个node节点上都有一个kubelet服务进程，kubelet作为连接master和各node之间的桥梁，负责维护pod和容器的生命周期，当监听到master下发到本节点的任务时，比如创建、更新、终止pod等任务，kubelet 即通过控制docker来创建、更新、销毁容器； 每个kubelet进程都会在api-server上注册本节点自身的信息，用于定期向master汇报本节点资源的使用情况。\nkube-proxy： kube-proxy运行在node节点上，在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作，kube-proxy会监听api-server中从而获取service和endpoint的变化情况，创建并维护路由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上。\ncontainer-runtime： 容器运行时环境，即运行容器所需要的一系列程序，目前k8s支持的容器运行时有很多，如docker、rkt或其他，比较受欢迎的是docker，但是新版的k8s已经宣布弃用docker。\n","permalink":"https://gopherding.github.io/posts/tech/k8s%E7%9A%84%E7%BB%84%E4%BB%B6%E6%9E%84%E6%88%90/","summary":"\u003cp\u003ek8s主要由master节点和node节点构成。\u003c/p\u003e\n\u003cp\u003emaster节点负责管理集群，node节点是容器应用真正运行的地方。\u003c/p\u003e\n\u003cp\u003emaster节点包含的组件有：kube-api-server、kube-controller-manager、kube-scheduler、etcd。\u003c/p\u003e\n\u003cp\u003enode节点包含的组件有：kubelet、kube-proxy、container-runtime。\u003c/p\u003e","title":"K8s的组件构成"},{"content":"三阶段提交（3PC - Three - Phase Commit） 定义和工作原理 3PC 是在 2PC 的基础上进行改进的分布式事务协议，主要是为了减少 2PC 中的阻塞问题和单点故障风险。它分为三个阶段： CanCommit 阶段：事务协调者向所有参与者发送一个 CanCommit 请求，询问参与者是否可以提交事务。参与者接收到请求后，根据自身的状态（如资源是否充足、本地事务是否能够执行等）返回 Yes 或 No 响应。这个阶段主要是初步检查参与者是否有能力执行事务，并不涉及事务的实际执行和资源预留。 PreCommit 阶段：如果协调者收到所有参与者的 Yes 响应，就会进入 PreCommit 阶段。协调者向参与者发送 PreCommit 请求，要求参与者执行事务操作，但与 2PC 不同的是，此时参与者并不立即提交事务，而是和 2PC 的准备阶段一样，执行事务操作并记录 Redo 和 Undo 信息，然后向协调者返回 ACK 响应。如果协调者收到任何一个参与者的 No 响应，就会向所有参与者发送 abort 请求，要求参与者回滚事务，整个事务流程结束。 DoCommit 阶段：当协调者收到所有参与者在 PreCommit 阶段返回的 ACK 响应后，就会向参与者发送 DoCommit 请求，要求参与者提交事务。参与者收到请求后正式提交事务，释放资源。如果协调者在规定时间内没有收到所有参与者的 ACK 响应，或者在发送 DoCommit 请求后没有收到参与者的提交成功反馈，协调者会重新发送 DoCommit 请求或者判定事务失败并要求参与者回滚事务。 与 2PC 的区别 在协调者和参与者中都引入了超时机制（2PC只有协调者才有超时机制），并且把2PC的第一个阶段拆分成了两步（询问 \u0026amp; 执行事务操作并记录 Redo 和 Undo 信息）\n解决阻塞问题 2PC：在准备阶段后，如果协调者出现故障，参与者会一直等待协调者的指令，导致事务阻塞。 3PC：引入了 CanCommit 阶段进行初步询问，并且在 PreCommit 阶段参与者在未收到 DoCommit 请求时可以自动回滚事务，减少了等待协调者指令导致的阻塞情况。例如，在 PreCommit 阶段，如果参与者长时间未收到 DoCommit 请求，它可以基于超时机制自行决定回滚事务，避免了长时间的资源占用。 降低单点故障影响 2PC：协调者在事务过程中扮演着至关重要的角色，一旦协调者故障，可能会导致整个事务处理陷入混乱。 3PC：虽然协调者仍然很重要，但由于有更多的阶段和更灵活的回滚机制，即使协调者在某个阶段出现故障，参与者可以基于当前阶段的状态进行一定程度的自我处理，降低了对协调者的依赖。例如，在 CanCommit 阶段，如果协调者故障，参与者可以简单地结束事务流程而不会产生像 2PC 中那样的阻塞。 提高可靠性 2PC：因为同步阻塞和单点故障问题，在出现网络故障或节点故障时，数据不一致的风险相对较高。 3PC：通过三次阶段的通信和更灵活的处理机制，在一定程度上提高了事务处理的可靠性，减少了数据不一致的可能性。例如，在 DoCommit 阶段，如果部分参与者未收到提交请求，3PC 可以通过重新发送请求或者回滚机制来尽量保证事务的一致性。 ","permalink":"https://gopherding.github.io/posts/tech/3-pc%E5%92%8C2-pc%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"\u003ch3 id=\"三阶段提交3pc---three---phase-commit\"\u003e\u003cstrong\u003e三阶段提交（3PC - Three - Phase Commit）\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"定义和工作原理\"\u003e\u003cstrong\u003e定义和工作原理\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e3PC 是在 2PC 的基础上进行改进的分布式事务协议，主要是为了减少 2PC 中的阻塞问题和单点故障风险。它分为三个阶段：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCanCommit 阶段\u003c/strong\u003e：事务协调者向所有参与者发送一个 CanCommit 请求，询问参与者是否可以提交事务。参与者接收到请求后，根据自身的状态（如资源是否充足、本地事务是否能够执行等）返回 Yes 或 No 响应。这个阶段主要是初步检查参与者是否有能力执行事务，并不涉及事务的实际执行和资源预留。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePreCommit 阶段\u003c/strong\u003e：如果协调者收到所有参与者的 Yes 响应，就会进入 PreCommit 阶段。协调者向参与者发送 PreCommit 请求，要求参与者执行事务操作，但与 2PC 不同的是，此时参与者并不立即提交事务，而是和 2PC 的准备阶段一样，执行事务操作并记录 Redo 和 Undo 信息，然后向协调者返回 ACK 响应。如果协调者收到任何一个参与者的 No 响应，就会向所有参与者发送 abort 请求，要求参与者回滚事务，整个事务流程结束。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDoCommit 阶段\u003c/strong\u003e：当协调者收到所有参与者在 PreCommit 阶段返回的 ACK 响应后，就会向参与者发送 DoCommit 请求，要求参与者提交事务。参与者收到请求后正式提交事务，释放资源。如果协调者在规定时间内没有收到所有参与者的 ACK 响应，或者在发送 DoCommit 请求后没有收到参与者的提交成功反馈，协调者会重新发送 DoCommit 请求或者判定事务失败并要求参与者回滚事务。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"与-2pc-的区别\"\u003e\u003cstrong\u003e与 2PC 的区别\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e在协调者和参与者中都引入了超时机制（2PC只有协调者才有超时机制），并且把2PC的第一个阶段拆分成了两步（询问 \u0026amp; 执行事务操作并记录 Redo 和 Undo 信息）\u003c/p\u003e","title":"3-PC和2-PC的区别"},{"content":"详见6.8小节 柔性事务主要分为补偿型和通知型，\n补偿型事务又分：TCC、Saga；\n通知型事务分：MQ事务消息、最大努力通知型。\nTCC其实本质和3 PC是差不多的： T就是Try，两个C分别是Confirm和Cancel。 Try就是尝试，请求链路中每个参与者依次执行Try逻辑，如果都成功，就再执行Confirm逻辑，如果有失败，就执行Cancel逻辑。 柔性事务概述 柔性事务是相对于传统的刚性事务而言的一种事务处理机制。刚性事务遵循 ACID（原子性、一致性、隔离性、持久性）原则，适用于单数据库系统等场景，能严格保证事务的正确性和数据的一致性。而柔性事务主要用于分布式系统环境，在这种环境下，严格遵循 ACID 原则会带来性能下降、可用性降低等问题。柔性事务通过放宽对 ACID 某些特性的要求，同时采用补偿机制等手段来确保分布式系统在高并发、高可用等复杂场景下数据的最终一致性。\n柔性事务的常见模式 补偿事务（Compensating Transaction） 定义：补偿事务是一种事后补偿的机制。当一个分布式事务中的某个操作（或一组操作）失败时，通过执行一个与之相对应的补偿操作来撤销之前已经执行成功的部分操作，从而达到最终的一致性。例如，在一个电商系统中，当订单创建成功后需要调用库存系统扣减库存，如果库存扣减失败，就需要执行一个补偿操作，如将已经创建的订单状态修改为无效，以保证系统数据的一致性。 工作流程：首先，事务开始执行各个子事务（可以是不同服务或数据库中的操作），每个子事务在执行过程中记录必要的业务信息（如操作日志、上下文信息等）。当某个子事务失败时，系统根据之前记录的信息触发补偿事务。补偿事务会按照预定的规则和业务逻辑，对已经成功执行的子事务进行反向操作。 TCC 事务（Try - Confirm - Cancel） 《Life beyond Distributed Transactions:an Apostate’s Opinion》 定义：TCC 是一种更细粒度的柔性事务模式。它将事务分为三个阶段：Try（尝试）、Confirm（确认）和 Cancel（取消）。在 Try 阶段，业务系统进行资源的预留（如冻结资金、锁定库存等），但不进行实际的业务操作。如果 Try 阶段所有操作都成功，就进入 Confirm 阶段，此时对之前预留的资源进行真正的业务处理（如扣除资金、扣减库存等）。如果在 Try 阶段有任何操作失败，就进入 Cancel 阶段，释放之前预留的资源。 工作流程：以一个在线支付场景为例，在 Try 阶段，支付系统会冻结用户账户中的相应金额，同时订单系统会锁定商品库存。如果这些操作都成功，就进入 Confirm 阶段，支付系统扣除冻结的金额，订单系统扣减锁定的库存，完成订单交易。如果在 Try 阶段，例如库存锁定失败，就进入 Cancel 阶段，支付系统解冻之前冻结的金额，取消本次交易。 基于消息的最终一致性（Message - Based Eventually Consistent）（即通知型） 定义：这种模式利用消息中间件来实现分布式事务的最终一致性。在分布式系统中，当一个业务操作完成后，通过发送消息到消息中间件来通知其他相关的业务系统进行后续操作。消息的发送和接收是异步的，接收消息的系统可能会因为网络延迟、系统故障等原因不能立即处理消息，但最终会在系统恢复正常后处理消息，从而达到数据的最终一致性。 工作流程：例如，在一个电商系统中，当用户下单成功后，订单系统会发送一个消息到消息中间件，通知库存系统和物流系统。库存系统收到消息后进行库存扣减，物流系统收到消息后安排发货。如果库存系统或物流系统在收到消息时出现故障，消息中间件会保留消息，直到系统恢复正常后重新发送消息，确保各个业务系统的数据最终达到一致。 柔性事务的应用场景和优势 应用场景 微服务架构：在微服务架构中，不同的微服务可能使用不同的数据库，并且服务之间的调用通过网络进行。柔性事务能够适应这种分布式、异构的环境，保证跨微服务的业务操作最终达到数据一致性。 高并发系统：对于高并发的电商、金融等系统，严格的刚性事务可能会因为锁机制等导致性能瓶颈。柔性事务通过异步操作、补偿机制等方式，可以在保证数据最终一致性的前提下，提高系统的并发处理能力。 优势 提高系统可用性：与刚性事务相比，柔性事务不会因为某个子事务的短暂故障（如网络抖动、某个服务的临时不可用）而导致整个事务失败，通过补偿机制或异步处理可以继续完成事务，从而提高了系统的可用性。 提升性能：避免了刚性事务中大量的同步等待和锁竞争，例如在 TCC 事务的 Try 阶段只是进行资源预留，不像刚性事务那样直接进行资源的占有和操作，减少了对系统资源的占用，提升了系统的性能。 ","permalink":"https://gopherding.github.io/posts/tech/%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1/","summary":"\u003ch3 id=\"详见68小节\"\u003e\u003cstrong\u003e\u003ca href=\"https://mp.weixin.qq.com/s/W-1a5linbSk7W-zqs6-osw\"\u003e详见6.8小节\u003c/a\u003e\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e柔性事务主要分为\u003cstrong\u003e补偿型\u003c/strong\u003e和\u003cstrong\u003e通知型\u003c/strong\u003e，\u003c/p\u003e\n\u003cp\u003e补偿型事务又分：TCC、Saga；\u003c/p\u003e\n\u003cp\u003e通知型事务分：MQ事务消息、最大努力通知型。\u003c/p\u003e\n\u003ch3 id=\"tcc其实本质和3-pc是差不多的\"\u003e\u003cstrong\u003eTCC其实本质和3 PC是差不多的：\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eT就是Try，两个C分别是Confirm和Cancel。\u003c/li\u003e\n\u003cli\u003eTry就是尝试，请求链路中每个参与者依次执行Try逻辑，如果都成功，就再执行Confirm逻辑，如果有失败，就执行Cancel逻辑。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"柔性事务概述\"\u003e\u003cstrong\u003e柔性事务概述\u003c/strong\u003e\u003c/h3\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e柔性事务是相对于传统的刚性事务而言的一种事务处理机制。刚性事务遵循 ACID（原子性、一致性、隔离性、持久性）原则，适用于单数据库系统等场景，能严格保证事务的正确性和数据的一致性。而柔性事务主要用于分布式系统环境，在这种环境下，严格遵循 ACID 原则会带来性能下降、可用性降低等问题。柔性事务通过放宽对 ACID 某些特性的要求，同时采用补偿机制等手段来确保分布式系统在高并发、高可用等复杂场景下数据的最终一致性。\u003c/p\u003e","title":"柔性事务"},{"content":"两阶段提交（Two-Phase Commit，2PC）是一种用于保证分布式系统中多个节点上的事务一致性的协议。（强一致、中心化的原子提交协议）\n一、协议流程 准备阶段（Prepare Phase）： 协调者向所有参与者节点发送一个准备请求，询问它们是否能够提交事务。 参与者接收到准备请求后，执行事务中的所有操作，但不提交事务。此时，参与者会将事务的执行结果记录下来，并锁定资源，防止其他事务对这些资源进行修改。 参与者根据事务的执行情况，向协调者回复一个响应，表明它是否能够提交事务。如果参与者能够提交事务，它会回复 “同意”；否则，它会回复 “不同意”。 提交阶段（Commit Phase）： 如果协调者接收到所有参与者的 “同意” 回复，它会向所有参与者发送一个提交请求，要求它们提交事务。 参与者接收到提交请求后，正式提交事务，并释放锁定的资源。 如果协调者接收到任何一个参与者的 “不同意” 回复，或者在一定时间内没有接收到所有参与者的回复，它会向所有参与者发送一个回滚请求，要求它们回滚事务。 参与者接收到回滚请求后，回滚事务，并释放锁定的资源。 二、特点和作用 保证事务的原子性和一致性：通过两阶段提交协议，分布式系统中的多个节点可以在一个事务中同时进行操作，并保证这些操作要么全部成功提交，要么全部回滚，从而保证了事务的原子性和一致性。 协调者的关键作用：协调者在两阶段提交协议中起着关键的作用，它负责发起事务、收集参与者的回复、决定事务的提交或回滚，并向参与者发送相应的请求。如果协调者出现故障，整个事务可能会处于不确定状态，需要采取一些恢复措施来保证事务的一致性。 参与者的独立性：参与者在两阶段提交协议中相对独立，它们只需要根据协调者的请求进行相应的操作，并向协调者回复自己的状态。参与者之间不需要直接通信，这降低了系统的复杂性。 三、应用场景和局限性 应用场景：两阶段提交协议通常用于分布式数据库系统、分布式事务处理系统等需要保证事务一致性的场景。例如，在银行转账系统中，从一个账户向另一个账户转账可能涉及多个数据库节点的操作，需要使用两阶段提交协议来保证事务的一致性。 局限性：两阶段提交协议也存在一些局限性，例如： 性能问题：两阶段提交协议需要在多个节点之间进行多次通信，这会导致较高的延迟和较低的性能。特别是在网络延迟较大或参与者节点较多的情况下，性能问题可能会更加严重。 单点故障：协调者在两阶段提交协议中起着关键的作用，如果协调者出现故障，整个事务可能会处于不确定状态。为了解决这个问题，需要采用一些高可用的协调者实现，如使用主备协调者、分布式协调者等。 阻塞问题：在两阶段提交协议中，如果参与者在准备阶段回复了 “同意”，但在提交阶段出现故障，协调者可能会一直等待参与者的回复，从而导致整个事务被阻塞。为了解决这个问题，需要采用一些超时机制和重试机制来保证事务的顺利进行。 ","permalink":"https://gopherding.github.io/posts/tech/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/","summary":"\u003cp\u003e两阶段提交（Two-Phase Commit，2PC）是一种用于保证分布式系统中多个节点上的事务一致性的协议。（强一致、中心化的原子提交协议）\u003c/p\u003e\n\u003ch3 id=\"一协议流程\"\u003e\u003cstrong\u003e一、协议流程\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"准备阶段prepare-phase\"\u003e\u003cstrong\u003e准备阶段（Prepare Phase）\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e协调者向所有参与者节点发送一个准备请求，询问它们是否能够提交事务。\u003c/li\u003e\n\u003cli\u003e参与者接收到准备请求后，执行事务中的所有操作，但不提交事务。此时，参与者会将事务的执行结果记录下来，并锁定资源，防止其他事务对这些资源进行修改。\u003c/li\u003e\n\u003cli\u003e参与者根据事务的执行情况，向协调者回复一个响应，表明它是否能够提交事务。如果参与者能够提交事务，它会回复 “同意”；否则，它会回复 “不同意”。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"提交阶段commit-phase\"\u003e\u003cstrong\u003e提交阶段（Commit Phase）\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e如果协调者接收到所有参与者的 “同意” 回复，它会向所有参与者发送一个提交请求，要求它们提交事务。\u003c/li\u003e\n\u003cli\u003e参与者接收到提交请求后，正式提交事务，并释放锁定的资源。\u003c/li\u003e\n\u003cli\u003e如果协调者接收到任何一个参与者的 “不同意” 回复，或者在一定时间内没有接收到所有参与者的回复，它会向所有参与者发送一个回滚请求，要求它们回滚事务。\u003c/li\u003e\n\u003cli\u003e参与者接收到回滚请求后，回滚事务，并释放锁定的资源。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二特点和作用\"\u003e\u003cstrong\u003e二、特点和作用\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e保证事务的原子性和一致性：通过两阶段提交协议，分布式系统中的多个节点可以在一个事务中同时进行操作，并保证这些操作要么全部成功提交，要么全部回滚，从而保证了事务的原子性和一致性。\u003c/li\u003e\n\u003cli\u003e协调者的关键作用：协调者在两阶段提交协议中起着关键的作用，它负责发起事务、收集参与者的回复、决定事务的提交或回滚，并向参与者发送相应的请求。如果协调者出现故障，整个事务可能会处于不确定状态，需要采取一些恢复措施来保证事务的一致性。\u003c/li\u003e\n\u003cli\u003e参与者的独立性：参与者在两阶段提交协议中相对独立，它们只需要根据协调者的请求进行相应的操作，并向协调者回复自己的状态。参与者之间不需要直接通信，这降低了系统的复杂性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三应用场景和局限性\"\u003e\u003cstrong\u003e三、应用场景和局限性\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e应用场景：两阶段提交协议通常用于分布式数据库系统、分布式事务处理系统等需要保证事务一致性的场景。例如，在银行转账系统中，从一个账户向另一个账户转账可能涉及多个数据库节点的操作，需要使用两阶段提交协议来保证事务的一致性。\u003c/li\u003e\n\u003cli\u003e局限性：两阶段提交协议也存在一些局限性，例如：\n\u003cul\u003e\n\u003cli\u003e性能问题：两阶段提交协议需要在多个节点之间进行多次通信，这会导致较高的延迟和较低的性能。特别是在网络延迟较大或参与者节点较多的情况下，性能问题可能会更加严重。\u003c/li\u003e\n\u003cli\u003e单点故障：协调者在两阶段提交协议中起着关键的作用，如果协调者出现故障，整个事务可能会处于不确定状态。为了解决这个问题，需要采用一些高可用的协调者实现，如使用主备协调者、分布式协调者等。\u003c/li\u003e\n\u003cli\u003e阻塞问题：在两阶段提交协议中，如果参与者在准备阶段回复了 “同意”，但在提交阶段出现故障，协调者可能会一直等待参与者的回复，从而导致整个事务被阻塞。为了解决这个问题，需要采用一些超时机制和重试机制来保证事务的顺利进行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"两阶段提交"},{"content":"荷塘月色 这几天心里颇不宁静。今晚在院子里坐着乘凉，忽然想起日日走过的荷塘，在这满月的光里，总该另有一番样子吧。月亮渐渐地升高了，墙外马路上孩子们的欢笑，已经听不见了；妻在屋里拍着闰儿，迷迷糊糊地哼着眠歌。我悄悄地披了大衫，带上门出去。\n沿着荷塘，是一条曲折的小煤屑路。这是一条幽僻的路；白天也少人走，夜晚更加寂寞。荷塘四面，长着许多树，蓊蓊郁郁的。路的一旁，是些杨柳，和一些不知道名字的树。没有月光的晚上，这路上阴森森的，有些怕人。今晚却很好，虽然月光也还是淡淡的。\n路上只我一个人，背着手踱着。这一片天地好像是我的；我也像超出了平常的自己，到了另一个世界里。我爱热闹，也爱冷静；爱群居，也爱独处。像今晚上，一个人在这苍茫的月下，什么都可以想，什么都可以不想，便觉是个自由的人。白天里一定要做的事，一定要说的话，现在都可不理。这是独处的妙处；我且受用这无边的荷香月色好了。\n曲曲折折的荷塘上面，弥望的是田田的叶子。叶子出水很高，像亭亭的舞女的裙。层层的叶子中间，零星地点缀着些白花，有袅娜地开着的，有羞涩地打着朵儿的；正如一粒粒的明珠，又如碧天里的星星，又如刚出浴的美人。微风过处，送来缕缕清香，仿佛远处高楼上渺茫的歌声似的。这时候叶子与花也有一丝的颤动，像闪电般，霎时传过荷塘的那边去了。叶子本是肩并肩密密地挨着，这便宛然有了一道凝碧的波痕。叶子底下是脉脉的流水，遮住了，不能见一些颜色；而叶子却更见风致了。\n月光如流水一般，静静地泻在这一片叶子和花上。薄薄的青雾浮起在荷塘里。叶子和花仿佛在牛乳中洗过一样；又像笼着轻纱的梦。虽然是满月，天上却有一层淡淡的云，所以不能朗照；但我以为这恰是到了好处 —— 酣畅淋漓的月光，反倒有些俗气了。月光是隔了树照过来的，高处丛生的灌木，落下参差的斑驳的黑影，峭楞楞如鬼一般；弯弯的杨柳的稀疏的倩影，却又像是画在荷叶上。塘中的月色并不均匀；但光与影有着和谐的旋律，如梵婀玲上奏着的名曲。\n荷塘的四面，远远近近，高高低低都是树，而杨柳最多。这些树将一片荷塘重重围住；只在小路一旁，漏着几段空隙，像是特为月光留下的。树色一例是阴阴的，乍看像一团烟雾；但细细看去，却又分明。树梢上隐隐约约的是一带远山，只有些大意罢了。树缝里也有几点路灯光，没精打采的，是渴睡人的眼。这时候最热闹的，要数树上的蝉声与水里的蛙声；但热闹是它们的，我什么也没有。\n忽然想起采莲的事情来了。采莲是江南的旧俗，似乎很早就有，而六朝时为盛；从诗歌里可以约略知道。采莲的是少年男女，他们划着小船，唱着艳歌：\n于是妖童媛女，荡舟心许；鹢首徐回，兼传羽杯；棹将移而藻挂，船欲动而萍开。尔其纤腰束素，迁延顾步；夏始春余，叶嫩花初，恐沾裳而浅笑，畏倾舟而敛裾。\n可见当时嬉游的光景了。这真是有趣的事，可惜我们现在早已无福消受了。\n于是又记起《西洲曲》里的句子：\n采莲南塘秋，莲花过人头。低头弄莲子，莲子清如水。\n今晚若有采莲人，定会从荷塘的这边，荡舟到那边，满船盛着采莲的收获，也许是莲子，也许是莲藕。只是不知他们是否也会像我一样，被这荷塘月色所陶醉？\n我且受用这无边的荷香月色好了。\n但热闹是它们的，我什么也没有。\n忽然想起回家，我的妻还等着我呢。我悄悄地披了大衫，带上门出去。\n","permalink":"https://gopherding.github.io/posts/read/%E8%8D%B7%E5%A1%98%E6%9C%88%E8%89%B2/","summary":"\u003ch3 id=\"荷塘月色\"\u003e荷塘月色\u003c/h3\u003e\n\u003cp\u003e这几天心里颇不宁静。今晚在院子里坐着乘凉，忽然想起日日走过的荷塘，在这满月的光里，总该另有一番样子吧。月亮渐渐地升高了，墙外马路上孩子们的欢笑，已经听不见了；妻在屋里拍着闰儿，迷迷糊糊地哼着眠歌。我悄悄地披了大衫，带上门出去。\u003c/p\u003e\n\u003cp\u003e沿着荷塘，是一条曲折的小煤屑路。这是一条幽僻的路；白天也少人走，夜晚更加寂寞。荷塘四面，长着许多树，蓊蓊郁郁的。路的一旁，是些杨柳，和一些不知道名字的树。没有月光的晚上，这路上阴森森的，有些怕人。今晚却很好，虽然月光也还是淡淡的。\u003c/p\u003e","title":"荷塘月色"},{"content":"服务网格（Service Mesh）是用于处理服务间通信的基础设施层，它在微服务架构中扮演着重要的角色，为微服务之间的通信提供了可靠、高效、安全且易于管理的解决方案。以下是关于服务网格的详细介绍：\n概念和架构 概念：服务网格是一种专用的基础设施层，它在微服务架构中实现了服务间通信的标准化、可靠性和安全性。它将服务间通信的逻辑从微服务代码中分离出来，以独立的组件形式（称为边车代理，Sidecar Proxy）部署在每个微服务的旁边，负责处理服务之间的流量路由、负载均衡、熔断限流、安全认证等通信相关的功能，使得微服务开发者可以专注于业务逻辑的实现，而无需过多关注底层的通信细节。\n架构组成： 边车代理（Sidecar Proxy）：这是服务网格的核心组件，与每个微服务实例紧密绑定，形成一个边车模式。边车代理负责拦截微服务实例的所有入站和出站流量，对流量进行处理和控制，如根据配置的路由规则将请求转发到目标服务实例、对请求进行负载均衡、监控流量指标等。常见的边车代理有 Istio 中的 Envoy、Linkerd 中的 Linkerd-proxy 等。 控制平面（Control Plane）：控制平面负责管理和配置整个服务网格中的边车代理。它提供了一系列的 API 和配置接口，用于定义服务间的路由策略、负载均衡策略、安全策略等，并将这些配置信息下发到各个边车代理中。控制平面还负责收集边车代理上报的监控数据、流量指标等信息，以便进行集中的管理和分析。例如，Istio 的控制平面包含了 Pilot（负责服务发现和流量管理）、Citadel（负责安全认证和密钥管理）、Galley（负责配置验证和分发）等组件。 主要功能 流量管理： 路由规则配置：服务网格允许管理员通过控制平面定义灵活的路由规则，根据请求的不同特征（如请求路径、请求头、源 IP 等）将流量路由到不同版本的服务实例上。这使得在进行服务升级、A/B 测试、灰度发布等操作时更加方便和可控。例如，可以将 10% 的流量路由到新开发的服务版本上进行测试，而将其余 90% 的流量保持在旧版本上，根据测试结果逐步调整流量分配比例。 负载均衡：边车代理可以对多个服务实例进行负载均衡，根据不同的负载均衡算法（如轮询、随机、加权轮询等）将请求均匀地分配到各个实例上，确保每个实例的负载相对均衡，提高系统的整体性能和可靠性。同时，服务网格还可以根据实例的实时状态（如 CPU 利用率、内存使用情况等）动态调整负载均衡策略，将请求优先分配到负载较轻的实例上。 熔断限流：当某个服务实例出现故障或响应延迟过高时，服务网格可以自动触发熔断机制，暂时停止将请求路由到该故障实例，避免故障扩散影响整个系统。同时，通过限流策略可以限制对某个服务的并发请求数量，防止因大量请求导致服务过载。例如，当一个服务每秒能够处理的最大请求数量为 100 时，可以设置限流规则，当并发请求超过 100 时，直接拒绝多余的请求，保护服务的稳定性。 安全通信： 身份认证和授权：服务网格可以为微服务之间的通信提供身份认证机制，确保只有经过授权的服务才能相互通信。常见的认证方式包括基于 TLS 证书的双向认证、基于令牌（如 JWT）的认证等。在认证通过后，还可以根据预定义的授权策略（如基于角色的访问控制，RBAC）限制服务对其他服务资源的访问权限，增强系统的安全性。 加密通信：所有微服务之间的通信流量都可以通过服务网格进行加密，防止数据在传输过程中被窃取或篡改。边车代理可以自动处理 TLS 加密和解密的过程，对开发者透明，无需在微服务代码中显式实现加密逻辑。这在处理敏感数据（如用户信息、财务数据等）的传输时尤为重要。 监控和可观测性： 流量指标收集：服务网格能够收集详细的流量指标，如请求数量、响应时间、错误率等，不仅可以针对整个服务进行统计，还可以细分到每个服务实例、每个接口甚至每个请求路径。这些指标数据对于了解系统的运行状态、发现性能瓶颈和故障排查非常有帮助。 分布式链路追踪：通过与分布式链路追踪系统集成，服务网格可以跟踪每个请求在微服务之间的传播路径，记录请求经过的各个服务实例、处理时间等信息，形成完整的调用链路。这使得开发者可以清晰地了解一个请求从发起端到最终响应的整个过程，便于快速定位问题所在，尤其是在复杂的微服务架构中，当出现性能问题或故障时，分布式链路追踪能够大大缩短排查问题的时间。 日志管理：服务网格可以统一管理微服务的日志输出，将分散在各个服务实例中的日志信息进行集中收集和存储。同时，还可以根据请求的上下文信息（如请求 ID）将相关的日志关联起来，方便进行综合分析。例如，当一个请求在多个服务中流转时，通过服务网格可以将这些服务产生的与该请求相关的日志整合在一起，更好地理解请求的处理过程和可能出现的问题。 优势 解耦微服务通信逻辑：将服务间通信的复杂逻辑从微服务代码中分离出来，使得微服务可以更加专注于业务逻辑的实现，降低了微服务之间的耦合度。当需要修改通信相关的功能（如路由策略、安全策略等）时，无需修改微服务代码，只需要在控制平面进行配置更新即可，提高了系统的可维护性和灵活性。 增强系统的可靠性和弹性：通过熔断限流、负载均衡等功能，服务网格可以有效地应对服务故障、网络波动和流量高峰等情况，提高系统的整体可靠性和弹性。即使某个服务实例出现问题，也不会导致整个系统崩溃，能够自动进行故障隔离和流量转移，确保系统的持续稳定运行。 统一的安全管理：提供了统一的安全机制，包括身份认证、授权和加密通信等，使得在微服务架构中实现全面的安全防护变得更加容易。可以集中管理安全策略，确保所有微服务之间的通信都符合安全要求，降低了安全漏洞的风险，保护了系统和用户数据的安全。 强大的监控和可观测性：丰富的监控和可观测性功能有助于深入了解系统的运行状况，及时发现性能问题和潜在故障。开发者可以根据收集到的流量指标、链路追踪信息和日志数据进行性能优化、故障排查和容量规划，提高系统的整体质量和可管理性。 挑战和限制 性能开销：由于引入了边车代理，服务网格会在一定程度上增加系统的性能开销。边车代理需要处理所有的流量拦截、转发和其他相关操作，这可能会导致额外的延迟和资源消耗。在对性能要求极高的场景下（如高频交易系统、实时通信系统等），需要仔细评估服务网格带来的性能影响，并进行优化。 复杂性增加：服务网格本身的架构和功能相对复杂，引入了新的概念、组件和配置方式。这需要团队具备一定的技术能力和学习成本来理解、部署和管理服务网格。同时，在多团队协作开发微服务的环境中，需要统一的管理和协调机制，确保各个团队正确使用和配置服务网格，避免因配置错误或不一致导致的问题。 资源占用：除了性能开销外，服务网格的边车代理和控制平面组件还会占用一定的系统资源（如 CPU、内存、网络带宽等）。在大规模部署微服务的情况下，需要合理规划资源分配，确保服务网格组件不会过度占用资源，影响其他业务应用的正常运行。 与现有系统的集成难度：如果企业已经有一套成熟的微服务架构和相关的技术栈，将服务网格集成到现有系统中可能会面临一些挑战。可能需要对现有系统进行一定的改造和适配，以确保服务网格能够与现有组件（如注册中心、配置中心、负载均衡器等）协同工作。此外，在与一些不兼容的技术或框架集成时，可能需要额外的开发工作来解决兼容性问题。 应用场景 微服务架构的演进和扩展：在微服务架构不断发展和规模不断扩大的过程中，服务网格可以帮助企业更好地管理日益复杂的服务间通信。随着微服务数量的增加、服务之间的依赖关系变得更加复杂，服务网格提供的流量管理、安全保障和监控能力能够确保系统的稳定性和可扩展性，使得企业可以更加灵活地演进和扩展其微服务架构。 多云和混合云环境部署：当企业的微服务部署在多云或混合云环境中时，服务网格可以提供统一的通信管理和安全策略。它可以跨越不同的云平台和数据中心，确保微服务之间的通信顺畅和安全，屏蔽底层基础设施的差异，使得企业在多云环境下的应用部署和管理更加便捷。 对服务通信质量和安全性要求较高的行业：如金融、医疗、电商等行业，对服务间通信的可靠性、安全性和性能要求非常严格。服务网格可以满足这些行业的需求，通过提供强大的流量管理、加密通信和身份认证等功能，保障关键业务系统的稳定运行，保护用户敏感信息的安全，提高客户满意度和企业信誉。 ","permalink":"https://gopherding.github.io/posts/tech/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/","summary":"\u003cp\u003e服务网格（Service Mesh）是用于处理服务间通信的基础设施层，它在微服务架构中扮演着重要的角色，为微服务之间的通信提供了可靠、高效、安全且易于管理的解决方案。以下是关于服务网格的详细介绍：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"概念和架构\"\u003e概念和架构\u003c/h3\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e概念\u003c/strong\u003e：服务网格是一种专用的基础设施层，它在微服务架构中实现了服务间通信的标准化、可靠性和安全性。它将服务间通信的逻辑从微服务代码中分离出来，以独立的组件形式（称为边车代理，Sidecar Proxy）部署在每个微服务的旁边，负责处理服务之间的流量路由、负载均衡、熔断限流、安全认证等通信相关的功能，使得微服务开发者可以专注于业务逻辑的实现，而无需过多关注底层的通信细节。\u003c/p\u003e","title":"服务网格"},{"content":"一、UUID（通用唯一识别码） 原理 UUID 是一种由数字和字母组成的 128 位标识符。它通过一定的算法生成，通常基于时间戳、MAC 地址（网卡物理地址）等信息。最常用的 UUID 版本是基于随机数生成的版本 4，其生成的 ID 具有全球唯一性。 优点 唯一性高：在全球范围内几乎不可能出现重复的 ID，适合用于分布式系统中不同节点产生的标识。 简单易用：生成算法相对简单，大多数编程语言都有现成的库来生成 UUID。 缺点 不具备顺序性：生成的 ID 是随机的，没有时间顺序或者其他有意义的顺序。这在一些需要根据 ID 排序的场景下，如数据库索引优化，会带来不便。 占用空间较大：128 位的长度在存储和传输时相对占用较多的空间，可能会增加系统的存储成本和网络开销。 二、数据库自增 ID 原理 利用数据库（如 MySQL）的自增主键特性。在数据库中创建一个包含自增主键的表，每次需要生成 ID 时，插入一条记录，数据库会自动为其分配一个唯一的自增 ID。这个 ID 可以作为分布式 ID 使用，多个应用节点可以共享这个数据库来获取 ID。 优点 简单高效：对于小型分布式系统或者对 ID 顺序性有严格要求的场景，数据库自增 ID 是一种简单直接的解决方案。生成的 ID 是顺序递增的，有利于数据库索引和查询性能。 缺点 单点瓶颈：所有 ID 生成请求都依赖于数据库，当系统并发量高时，数据库可能会成为性能瓶颈。因为数据库的写入操作需要加锁来保证自增 ID 的唯一性，大量并发请求可能会导致锁竞争，影响性能。 扩展性差：在分布式环境下，随着系统规模的扩大，单个数据库可能无法满足 ID 生成的需求，需要考虑数据库的高可用和横向扩展问题。 三、雪花算法（Snowflake） 原理 雪花算法是一种分布式 ID 生成算法，它生成的 ID 是一个 64 位的长整型数字。其结构主要包括以下几个部分： 符号位（1 位）：最高位是符号位，通常为 0，表示正数。 时间戳（41 位）：记录了从一个固定的起始时间（如 2016 年 1 月 1 日）到 ID 生成时刻的毫秒数。这部分保证了 ID 的时间顺序性。 工作机器 ID（10 位）：用于区分不同的工作机器，最多可以支持 1024 台机器。 序列号（12 位）：在同一毫秒内，同一机器可以生成的不同 ID，最多可以生成 4096 个不同的 ID。 优点 高并发支持：可以在分布式系统中高并发地生成唯一 ID。在同一毫秒内，不同机器和同一机器都可以生成多个不同的 ID，满足高并发场景的需求。 有序性好：生成的 ID 按照时间顺序递增，这对于数据库索引、日志排序等场景非常有利，可以提高系统的查询和处理效率。 缺点 依赖时间戳：如果系统的时钟出现回拨（如服务器时间被手动调整或者时钟同步出现问题），可能会导致生成的 ID 出现重复或者不符合预期的顺序。需要采取一定的措施来应对时钟回拨问题，如使用备用时间源或者拒绝生成 ID 直到时钟恢复正常。 机器 ID 分配复杂：在大规模分布式系统中，需要合理地分配工作机器 ID，否则可能会出现机器 ID 冲突或者浪费的情况。 四、Redis 自增 ID 原理 利用 Redis 的原子性自增命令（如INCR）来生成 ID。在 Redis 中设置一个键（Key），每次需要生成 ID 时，通过INCR命令对这个键的值进行自增操作。多个应用节点可以共享这个 Redis 实例来获取 ID。 优点 性能高：Redis 是基于内存的高性能数据库，INCR命令是原子操作，能够在高并发环境下快速生成 ID，避免了数据库自增 ID 的锁竞争问题。 简单易用：和数据库自增 ID 类似，实现相对简单，只需要调用 Redis 的自增命令即可。 缺点 单点故障风险：如果 Redis 实例出现故障，可能会导致 ID 生成服务中断。虽然可以通过 Redis 的主从复制和哨兵模式来提高可用性，但仍然存在一定的风险。 数据持久化问题：如果 Redis 没有正确地进行持久化设置，在重启或者故障恢复后，可能会出现 ID 重复或者丢失的情况。 看个大佬\n","permalink":"https://gopherding.github.io/posts/tech/%E5%88%86%E5%B8%83%E5%BC%8Fid%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%86/","summary":"\u003ch3 id=\"一uuid通用唯一识别码\"\u003e一、UUID（通用唯一识别码）\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"原理\"\u003e原理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUUID 是一种由数字和字母组成的 128 位标识符。它通过一定的算法生成，通常基于时间戳、MAC 地址（网卡物理地址）等信息。最常用的 UUID 版本是基于随机数生成的版本 4，其生成的 ID 具有全球唯一性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"优点\"\u003e优点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e唯一性高\u003c/strong\u003e：在全球范围内几乎不可能出现重复的 ID，适合用于分布式系统中不同节点产生的标识。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e简单易用\u003c/strong\u003e：生成算法相对简单，大多数编程语言都有现成的库来生成 UUID。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"缺点\"\u003e缺点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e不具备顺序性\u003c/strong\u003e：生成的 ID 是随机的，没有时间顺序或者其他有意义的顺序。这在一些需要根据 ID 排序的场景下，如数据库索引优化，会带来不便。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e占用空间较大\u003c/strong\u003e：128 位的长度在存储和传输时相对占用较多的空间，可能会增加系统的存储成本和网络开销。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二数据库自增-id\"\u003e二、数据库自增 ID\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"原理-1\"\u003e原理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e利用数据库（如 MySQL）的自增主键特性。在数据库中创建一个包含自增主键的表，每次需要生成 ID 时，插入一条记录，数据库会自动为其分配一个唯一的自增 ID。这个 ID 可以作为分布式 ID 使用，多个应用节点可以共享这个数据库来获取 ID。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"优点-1\"\u003e优点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e简单高效\u003c/strong\u003e：对于小型分布式系统或者对 ID 顺序性有严格要求的场景，数据库自增 ID 是一种简单直接的解决方案。生成的 ID 是顺序递增的，有利于数据库索引和查询性能。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"缺点-1\"\u003e缺点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e单点瓶颈\u003c/strong\u003e：所有 ID 生成请求都依赖于数据库，当系统并发量高时，数据库可能会成为性能瓶颈。因为数据库的写入操作需要加锁来保证自增 ID 的唯一性，大量并发请求可能会导致锁竞争，影响性能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e扩展性差\u003c/strong\u003e：在分布式环境下，随着系统规模的扩大，单个数据库可能无法满足 ID 生成的需求，需要考虑数据库的高可用和横向扩展问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三雪花算法snowflake\"\u003e三、雪花算法（Snowflake）\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"原理-2\"\u003e原理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e雪花算法是一种分布式 ID 生成算法，它生成的 ID 是一个 64 位的长整型数字。其结构主要包括以下几个部分：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e符号位（1 位）\u003c/strong\u003e：最高位是符号位，通常为 0，表示正数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e时间戳（41 位）\u003c/strong\u003e：记录了从一个固定的起始时间（如 2016 年 1 月 1 日）到 ID 生成时刻的毫秒数。这部分保证了 ID 的时间顺序性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工作机器 ID（10 位）\u003c/strong\u003e：用于区分不同的工作机器，最多可以支持 1024 台机器。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e序列号（12 位）\u003c/strong\u003e：在同一毫秒内，同一机器可以生成的不同 ID，最多可以生成 4096 个不同的 ID。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"优点-2\"\u003e优点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e高并发支持\u003c/strong\u003e：可以在分布式系统中高并发地生成唯一 ID。在同一毫秒内，不同机器和同一机器都可以生成多个不同的 ID，满足高并发场景的需求。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e有序性好\u003c/strong\u003e：生成的 ID 按照时间顺序递增，这对于数据库索引、日志排序等场景非常有利，可以提高系统的查询和处理效率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"缺点-2\"\u003e缺点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e依赖时间戳\u003c/strong\u003e：如果系统的时钟出现回拨（如服务器时间被手动调整或者时钟同步出现问题），可能会导致生成的 ID 出现重复或者不符合预期的顺序。需要采取一定的措施来应对时钟回拨问题，如使用备用时间源或者拒绝生成 ID 直到时钟恢复正常。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e机器 ID 分配复杂\u003c/strong\u003e：在大规模分布式系统中，需要合理地分配工作机器 ID，否则可能会出现机器 ID 冲突或者浪费的情况。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"四redis-自增-id\"\u003e四、Redis 自增 ID\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"原理-3\"\u003e原理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e利用 Redis 的原子性自增命令（如\u003ccode\u003eINCR\u003c/code\u003e）来生成 ID。在 Redis 中设置一个键（Key），每次需要生成 ID 时，通过\u003ccode\u003eINCR\u003c/code\u003e命令对这个键的值进行自增操作。多个应用节点可以共享这个 Redis 实例来获取 ID。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"优点-3\"\u003e优点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e性能高\u003c/strong\u003e：Redis 是基于内存的高性能数据库，\u003ccode\u003eINCR\u003c/code\u003e命令是原子操作，能够在高并发环境下快速生成 ID，避免了数据库自增 ID 的锁竞争问题。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e简单易用\u003c/strong\u003e：和数据库自增 ID 类似，实现相对简单，只需要调用 Redis 的自增命令即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"缺点-3\"\u003e缺点\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e单点故障风险\u003c/strong\u003e：如果 Redis 实例出现故障，可能会导致 ID 生成服务中断。虽然可以通过 Redis 的主从复制和哨兵模式来提高可用性，但仍然存在一定的风险。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据持久化问题\u003c/strong\u003e：如果 Redis 没有正确地进行持久化设置，在重启或者故障恢复后，可能会出现 ID 重复或者丢失的情况。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"https://segmentfault.com/a/1190000022717820\"\u003e看个大佬\u003c/a\u003e\u003c/p\u003e","title":"分布式ID业务需求的区分"},{"content":"一、简介 Raft 是一种用于管理复制日志的分布式一致性算法。它的设计目的是在分布式系统中，让一组机器（通常称为节点）能够在面对诸如网络分区、节点故障等各种问题时，就一系列操作达成一致，从而保证数据的一致性。Raft 通过选举一个领导者（Leader）来协调复制日志的工作，并且以简单易懂的原则确保系统的可靠性和容错性。\n二、核心角色 领导者（Leader） 主要职责是接收客户端请求，将请求作为日志条目（Log Entry）添加到自己的日志中，然后并行地将这些日志条目发送给其他节点（追随者）进行复制。 领导者还会发送心跳（Heartbeat）消息给追随者，以维持自己的领导地位。心跳消息可以看作是一种特殊的、没有日志条目的消息，用于告知追随者领导者仍然存活。 追随者（Follower） 接收并保存领导者发送的日志条目。当收到日志条目后，会按照顺序将其追加到自己的日志中。 响应领导者的心跳消息。如果在一定时间内没有收到心跳消息，追随者会认为领导者可能出现故障，从而触发新的领导者选举。 候选人（Candidate） 当追随者在一段时间内没有收到领导者的心跳消息时，它会转变为候选人状态。候选人会发起选举，请求其他节点为自己投票，以争取成为新的领导者。 在选举过程中，候选人会增加自己的任期号（Term），并且向其他节点发送包含自己任期号的请求投票（Request Vote）消息。 三、选举过程 触发选举 当追随者在选举超时（Election Timeout）时间内没有收到领导者的心跳消息时，会触发选举。选举超时是一个随机的时间间隔，这样设计是为了避免多个追随者同时触发选举，造成冲突。 请求投票阶段 成为候选人后，节点会向其他节点发送请求投票消息。消息中包含候选人的任期号和最后一条日志条目的索引（Index）及任期号。 其他节点在收到请求投票消息后，会根据一定的规则来决定是否投票给候选人。规则主要包括：候选人的任期号必须不小于自己当前的任期号；如果自己已经投票给其他候选人，就不会再投票；如果候选人的最后一条日志条目的任期号和索引不小于自己的，就会投票给候选人。 选举获胜 当候选人获得多数（超过半数）节点的投票时，就会成为新的领导者。然后，新领导者会开始向追随者发送心跳消息，以确立自己的领导地位，同时开始接收客户端请求并复制日志。 四、日志复制 日志条目组成 日志条目由索引（Index）、任期号（Term）和命令（Command）组成。索引用于标识日志条目的位置，任期号用于标记该条目所属的领导者任期，命令则是客户端请求对应的操作，如写入一个数据值。 复制流程 领导者接收到客户端请求后，会将日志条目添加到自己的日志中，然后将该条目发送给所有追随者。 追随者收到日志条目后，会检查其合法性。如果日志条目与自己的日志匹配（例如，索引和任期号符合要求），就会将其追加到自己的日志中，并向领导者返回成功确认。如果不匹配，就会拒绝接收。 只有当多数追随者成功复制了该日志条目后，领导者才会将这个日志条目应用到本地状态机（即真正执行命令），并向客户端返回成功响应。这一步确保了在大多数节点都同意的情况下才执行操作，保证了数据的一致性。 五、安全性保证 选举限制 Raft 通过限制选举来保证安全性。在选举过程中，只有拥有最新日志的节点才能成为领导者。这是因为新的领导者必须能够将自己的日志复制到其他节点，而拥有最新日志的节点更有可能保证数据的完整性和一致性。 日志一致性原则 如果两个节点的日志中有相同索引和任期号的条目，那么这些条目之前的所有日志条目都是相同的。这一原则通过领导者在复制日志时的严格检查和追随者的配合来保证。当领导者发现追随者的日志与自己不一致时，会尝试通过发送前序日志条目来使追随者的日志与自己同步。 状态机安全 一旦一个日志条目被应用到状态机，它在所有节点上的相同索引位置的日志条目最终都会被应用。这是通过日志复制的多数原则和严格的一致性检查来实现的，确保了所有节点在相同的操作序列下更新状态机，从而保证了数据的一致性。 六、应用场景 分布式存储系统 如分布式文件系统、分布式数据库等，Raft 可以用于保证数据在多个存储节点之间的一致性。例如，在一个分布式数据库中，当客户端执行写入操作时，通过 Raft 算法确保所有副本节点都按照相同的顺序执行相同的写入命令，避免数据不一致的情况。 分布式配置管理系统 用于管理分布式系统中的配置文件。当配置文件发生更新时，Raft 算法可以确保所有节点都能正确地更新配置，避免因配置不一致导致的系统故障。 集群管理系统 在集群中，用于协调各个节点的状态和任务分配。例如，在一个容器编排系统中，通过 Raft 来保证节点对集群状态的共识，如节点的加入、退出以及任务的调度等操作的一致性。 ","permalink":"https://gopherding.github.io/posts/tech/raft/","summary":"\u003ch3 id=\"一简介\"\u003e一、简介\u003c/h3\u003e\n\u003cp\u003eRaft 是一种用于管理复制日志的分布式一致性算法。它的设计目的是在分布式系统中，让一组机器（通常称为节点）能够在面对诸如网络分区、节点故障等各种问题时，就一系列操作达成一致，从而保证数据的一致性。Raft 通过选举一个领导者（Leader）来协调复制日志的工作，并且以简单易懂的原则确保系统的可靠性和容错性。\u003c/p\u003e","title":"Raft"},{"content":"ZAB（Zookeeper Atomic Broadcast）协议概述 ZAB 协议是为分布式协调服务 ZooKeeper 专门设计的一种原子广播协议，用于保证分布式系统中数据的一致性和主从节点数据的同步。ZooKeeper 在分布式系统中扮演着重要角色，如配置管理、命名服务、分布式锁等，而 ZAB 协议是 ZooKeeper 实现这些功能的核心保障。\nZAB 协议的主要阶段和工作机制 消息广播阶段（Broadcast Phase） 工作原理：在 ZooKeeper 集群中，当客户端发送一个写请求（如创建节点、更新节点数据等）到主节点（Leader）时，主节点会将这个写请求转化为一个事务 Proposal（提议），并为这个提议分配一个全局唯一的递增的事务 ID（zxid）。然后，主节点通过一个 FIFO（先进先出）的队列将提议广播给所有的从节点（Follower）。从节点接收到提议后，会将其写入本地的磁盘事务日志中，然后向主节点发送一个 ACK（确认）消息。当主节点收到超过半数（Quorum）的从节点的 ACK 消息后，就会向所有从节点发送一个提交（Commit）消息，通知它们可以将这个事务应用到内存数据库中，从而完成整个消息广播过程。 示例：假设一个 ZooKeeper 集群有一个主节点和三个从节点，客户端发送一个写请求 “创建节点 /node1”。主节点将这个请求转换为一个带有 zxid 的提议，如 zxid = 100，然后广播给三个从节点。从节点收到提议后记录到事务日志，再发送 ACK 给主节点。当主节点收到至少两个从节点的 ACK 后，发送 Commit 消息，此时所有节点将这个事务应用到内存数据库，完成节点 /node1 的创建。 崩溃恢复阶段（Recovery Phase） 工作原理：当主节点出现故障（如宕机）时，ZAB 协议会进入崩溃恢复阶段。在这个阶段，ZooKeeper 集群会选举出一个新的主节点。选举的依据主要是节点的 zxid 和数据完整程度。拥有最大 zxid 的节点通常有更大的优势成为新的主节点，因为它的数据是最新的。新主节点选举出来后，它需要和其他从节点进行数据同步。新主节点会检查从节点的 zxid，对于从节点中已经提交（Commit）但新主节点还没有的事务，新主节点会将这些事务重新广播给其他从节点，以保证所有节点的数据一致性。对于从节点中未提交的事务（处于 Proposal 阶段），新主节点会根据事务的 zxid 决定是丢弃还是重新广播这些事务。 示例：如果主节点在广播一个事务（zxid = 200）但还没发送 Commit 消息时崩溃，集群开始选举新主节点。假设一个从节点已经收到并记录了这个事务，另一个从节点还没收到。新主节点选举出来后，会根据自己的事务日志和从节点的情况，决定是否重新广播这个事务，确保所有节点的数据最终一致。 ZAB 协议与其他分布式一致性协议的比较 与 Paxos 协议比较 相似点：ZAB 协议和 Paxos 协议都用于解决分布式系统中的一致性问题。它们都通过多轮消息传递和投票机制来达成共识。例如，在节点选举和事务提交过程中，都需要多数节点的同意。 不同点：ZAB 协议相对 Paxos 协议在设计上更偏向于支持 ZooKeeper 的功能特点。ZAB 协议是一个主从模式的协议，有明确的主节点来主导事务的广播，而 Paxos 协议没有这样明确的主从之分，其角色在选举过程中是动态变化的。另外，ZAB 协议在消息广播阶段的流程相对 Paxos 协议更加简洁明了，更适合 ZooKeeper 这种对写操作有一定顺序要求的场景。 与 Raft 协议比较 相似点：Raft 和 ZAB 都有领导者（Leader）的概念，并且在领导者选举和数据复制方面有相似的机制。例如，两者都需要多数节点的支持来选举领导者，并且领导者在数据复制过程中起到关键作用。 不同点：Raft 协议在选举过程中有明确的任期（Term）概念，通过任期来保证选举的顺序和合法性。ZAB 协议则通过 zxid 来保证事务的顺序和节点的更新程度。在数据复制方面，ZAB 协议的消息广播和提交过程与 Raft 协议的日志复制和提交过程在细节上有所不同，ZAB 协议的重点在于保证 ZooKeeper 事务的原子广播和顺序性。 ","permalink":"https://gopherding.github.io/posts/tech/zab/","summary":"\u003ch3 id=\"zabzookeeper-atomic-broadcast协议概述\"\u003e\u003cstrong\u003eZAB（Zookeeper Atomic Broadcast）协议概述\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eZAB 协议是为分布式协调服务 ZooKeeper 专门设计的一种原子广播协议，用于保证分布式系统中数据的一致性和主从节点数据的同步。ZooKeeper 在分布式系统中扮演着重要角色，如配置管理、命名服务、分布式锁等，而 ZAB 协议是 ZooKeeper 实现这些功能的核心保障。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"zab-协议的主要阶段和工作机制\"\u003e\u003cstrong\u003eZAB 协议的主要阶段和工作机制\u003c/strong\u003e\u003c/h4\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch5 id=\"消息广播阶段broadcast-phase\"\u003e\u003cstrong\u003e消息广播阶段（Broadcast Phase）\u003c/strong\u003e\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e工作原理\u003c/strong\u003e：在 ZooKeeper 集群中，当客户端发送一个写请求（如创建节点、更新节点数据等）到主节点（Leader）时，主节点会将这个写请求转化为一个事务 Proposal（提议），并为这个提议分配一个全局唯一的递增的事务 ID（zxid）。然后，主节点通过一个 FIFO（先进先出）的队列将提议广播给所有的从节点（Follower）。从节点接收到提议后，会将其写入本地的磁盘事务日志中，然后向主节点发送一个 ACK（确认）消息。当主节点收到超过半数（Quorum）的从节点的 ACK 消息后，就会向所有从节点发送一个提交（Commit）消息，通知它们可以将这个事务应用到内存数据库中，从而完成整个消息广播过程。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e示例\u003c/strong\u003e：假设一个 ZooKeeper 集群有一个主节点和三个从节点，客户端发送一个写请求 “创建节点 /node1”。主节点将这个请求转换为一个带有 zxid 的提议，如 zxid = 100，然后广播给三个从节点。从节点收到提议后记录到事务日志，再发送 ACK 给主节点。当主节点收到至少两个从节点的 ACK 后，发送 Commit 消息，此时所有节点将这个事务应用到内存数据库，完成节点 /node1 的创建。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"崩溃恢复阶段recovery-phase\"\u003e\u003cstrong\u003e崩溃恢复阶段（Recovery Phase）\u003c/strong\u003e\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e工作原理\u003c/strong\u003e：当主节点出现故障（如宕机）时，ZAB 协议会进入崩溃恢复阶段。在这个阶段，ZooKeeper 集群会选举出一个新的主节点。选举的依据主要是节点的 zxid 和数据完整程度。拥有最大 zxid 的节点通常有更大的优势成为新的主节点，因为它的数据是最新的。新主节点选举出来后，它需要和其他从节点进行数据同步。新主节点会检查从节点的 zxid，对于从节点中已经提交（Commit）但新主节点还没有的事务，新主节点会将这些事务重新广播给其他从节点，以保证所有节点的数据一致性。对于从节点中未提交的事务（处于 Proposal 阶段），新主节点会根据事务的 zxid 决定是丢弃还是重新广播这些事务。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e示例\u003c/strong\u003e：如果主节点在广播一个事务（zxid = 200）但还没发送 Commit 消息时崩溃，集群开始选举新主节点。假设一个从节点已经收到并记录了这个事务，另一个从节点还没收到。新主节点选举出来后，会根据自己的事务日志和从节点的情况，决定是否重新广播这个事务，确保所有节点的数据最终一致。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003ch4 id=\"zab-协议与其他分布式一致性协议的比较\"\u003e\u003cstrong\u003eZAB 协议与其他分布式一致性协议的比较\u003c/strong\u003e\u003c/h4\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch5 id=\"与-paxos-协议比较\"\u003e\u003cstrong\u003e与 Paxos 协议比较\u003c/strong\u003e\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e相似点\u003c/strong\u003e：ZAB 协议和 Paxos 协议都用于解决分布式系统中的一致性问题。它们都通过多轮消息传递和投票机制来达成共识。例如，在节点选举和事务提交过程中，都需要多数节点的同意。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不同点\u003c/strong\u003e：ZAB 协议相对 Paxos 协议在设计上更偏向于支持 ZooKeeper 的功能特点。ZAB 协议是一个主从模式的协议，有明确的主节点来主导事务的广播，而 Paxos 协议没有这样明确的主从之分，其角色在选举过程中是动态变化的。另外，ZAB 协议在消息广播阶段的流程相对 Paxos 协议更加简洁明了，更适合 ZooKeeper 这种对写操作有一定顺序要求的场景。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"与-raft-协议比较\"\u003e\u003cstrong\u003e与 Raft 协议比较\u003c/strong\u003e\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e相似点\u003c/strong\u003e：Raft 和 ZAB 都有领导者（Leader）的概念，并且在领导者选举和数据复制方面有相似的机制。例如，两者都需要多数节点的支持来选举领导者，并且领导者在数据复制过程中起到关键作用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不同点\u003c/strong\u003e：Raft 协议在选举过程中有明确的任期（Term）概念，通过任期来保证选举的顺序和合法性。ZAB 协议则通过 zxid 来保证事务的顺序和节点的更新程度。在数据复制方面，ZAB 协议的消息广播和提交过程与 Raft 协议的日志复制和提交过程在细节上有所不同，ZAB 协议的重点在于保证 ZooKeeper 事务的原子广播和顺序性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"ZAB"},{"content":" Gossip 协议概述 Gossip 协议是一种去中心化的、基于消息传播的分布式协议。它模拟了人类社会中流言蜚语（gossip）的传播方式，通过节点之间不断地随机交换信息来达到在分布式系统中传播信息、更新状态和达成共识的目的。这种协议常用于分布式数据库、分布式存储系统和集群管理等场景，以实现数据的一致性、故障检测和成员管理等功能。\n工作原理 信息传播机制 节点交互方式：在一个分布式系统中，每个节点会定期（按照一定的时间间隔）或者在某些事件触发（如自身状态发生变化）时，随机选择系统中的其他节点进行通信。这些节点之间的通信是异步的，它们会互相交换自己所知道的信息。例如，在一个分布式存储系统中，节点 A 可能会随机选择节点 B，并将自己存储的数据版本号、节点的健康状态等信息告诉节点 B。 信息传播内容：传播的信息可以包括系统状态信息（如节点的存活状态、资源利用情况）、数据更新信息（如数据库的写操作记录）等。每个节点都维护一个自己的信息表，记录从其他节点获取到的信息。例如，节点可能会记录集群中有多少个活跃节点、哪些节点存储了特定的数据副本等。 收敛性和最终一致性 收敛过程：随着节点之间不断地进行信息交换，系统中的信息会逐渐在所有节点中扩散。假设最初只有少数节点知道某个新的数据更新，通过 Gossip 协议的反复传播，越来越多的节点会了解到这个更新。例如，在一个分布式缓存系统中，当一个缓存节点更新了某个缓存项的值后，通过 Gossip 协议，其他缓存节点最终也会更新这个缓存项的值。 最终一致性实现：虽然信息传播是随机的，但是从宏观上看，系统会逐渐趋向于一种一致的状态。在足够长的时间和足够多的信息交换次数后，所有节点对于系统的某些关键信息（如数据的最新版本、成员列表等）会达成一致，这就是所谓的最终一致性。不过，这种一致性并不是即时的，可能会存在一定的延迟。 Gossip 协议的应用场景 分布式数据库中的数据同步 在分布式数据库系统（如 Cassandra）中，Gossip 协议用于在节点之间传播数据的更新信息和节点的状态信息。每个节点通过与其他节点的随机通信，了解到数据库的最新写操作记录，从而更新自己的数据副本。例如，当一个节点接收到一个新的插入或更新操作后，它会通过 Gossip 协议将这个信息传播给其他节点，使得整个数据库集群的数据保持最终一致性。 集群成员管理和故障检测 对于集群管理系统（如 Consul），Gossip 协议可以用于维护集群的成员列表和检测节点故障。每个节点定期向其他节点发送自己的存活信息，同时接收其他节点的信息。如果一个节点在一段时间内没有收到某个节点的存活信息，就可以推断该节点可能出现故障。而且，新加入的节点也可以通过 Gossip 协议快速了解集群的现有成员，融入到集群中。例如，当一个新节点加入一个分布式文件存储集群时，它可以通过 Gossip 协议与其他节点交换信息，获取集群的存储架构、数据分布等信息，从而更好地参与集群的工作。 优点和缺点 优点 去中心化和高容错性：由于没有中心控制节点，系统不会因为某个中心节点的故障而瘫痪。即使部分节点出现故障或者网络分区，信息仍然可以通过其他正常节点之间的通信在系统中传播。例如，在一个大规模的分布式传感器网络中，即使部分传感器节点损坏，数据仍然可以在其他节点之间传播和汇总。 简单易实现：Gossip 协议的实现相对简单，不需要复杂的选举机制或者集中式的协调器。节点之间的通信规则比较直观，主要是随机选择和信息交换，降低了系统的实现难度和维护成本。 缺点 消息冗余和网络开销：由于信息传播是随机的，可能会导致相同的信息在节点之间多次传播，产生消息冗余。这会增加网络带宽的占用和系统的资源消耗。例如，在一个网络带宽有限的分布式系统中，过多的 Gossip 消息可能会影响系统的正常通信。 收敛速度慢和一致性延迟：达到最终一致性的时间可能较长，尤其是在大型分布式系统或者网络不稳定的情况下。因为信息传播是基于随机的节点选择，不能保证信息能够快速地在所有节点中传播，可能会导致系统在一段时间内处于不一致的状态。 ","permalink":"https://gopherding.github.io/posts/tech/gossip/","summary":"\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"gossip-协议概述\"\u003e\u003cstrong\u003eGossip 协议概述\u003c/strong\u003e\u003c/h3\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eGossip 协议是一种去中心化的、基于消息传播的分布式协议。它模拟了人类社会中流言蜚语（gossip）的传播方式，通过节点之间不断地随机交换信息来达到在分布式系统中传播信息、更新状态和达成共识的目的。这种协议常用于分布式数据库、分布式存储系统和集群管理等场景，以实现数据的一致性、故障检测和成员管理等功能。\u003c/p\u003e","title":"Gossip"},{"content":"文章一号\n文章二号\n","permalink":"https://gopherding.github.io/posts/tech/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B/","summary":"\u003cp\u003e\u003ca href=\"https://developer.aliyun.com/article/942292\"\u003e文章一号\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://juejin.cn/post/7068065361312088095#heading-4\"\u003e文章二号\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/registry.png\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"注册中心选型"},{"content":"I. Debout les damnés de la terre ! Debout les forçats de la faim ! La raison tonne en son cratère, C\u0026rsquo;est l\u0026rsquo;éruption de la fin. Du passé, faisons table rase, Foule esclave debout ! debout ! Le monde va changer de base : Nous ne sommes rien, soyons tout !|\nC\u0026rsquo;est la lutte finale, Groupons-nous, et demain L\u0026rsquo;Internationale, Sera le genre humain. C\u0026rsquo;est la lutte finale, Groupons-nous, et demain L\u0026rsquo;Internationale, Sera le genre humain.\nII. Il n\u0026rsquo;est pas de sauveurs suprêmes, Ni dieu, ni César, ni tribun, Producteurs, sauvons-nous nous-mêmes ! Décrétons le salut commun ! Pour que le voleur rende gorge, Pour tirer l\u0026rsquo;esprit du cachot, Soufflons nous-mêmes notre forge, Battons le fer quand il est chaud !\nVI. Ouvriers, paysans, nous sommes Le grand parti des travailleurs ; La terre n\u0026rsquo;appartient qu\u0026rsquo;aux hommes, L\u0026rsquo;oisif ira loger ailleurs. Combien de nos chairs se repaissent ! Mais si les corbeaux, les vautours, Un de ces matins disparaissent, Le soleil brillera toujours !\n（一） 起来，饥寒交迫的奴隶！ 起来，全世界受苦的人！ 满腔的热血已经沸腾， 要为真理而斗争！ 旧世界打个落花流水， 奴隶们起来，起来！ 不要说我们一无所有， 我们要做天下的主人！\n这是最后的斗争， 团结起来到明天， 英特纳雄耐尔 就一定要实现！ 这是最后的斗争， 团结起来到明天， 英特纳雄耐尔 就一定要实现！\n（二） 从来就没有什么救世主， 也不靠神仙皇帝！ 要创造人类的幸福， 全靠我们自己！ 我们要夺回劳动果实， 让思想冲破牢笼！ 快把那炉火烧得通红， 趁热打铁才能成功！\n（六） 是谁创造了人类世界？ 是我们劳动群众！ 一切归劳动者所有， 哪能容得寄生虫？！ 最可恨那些毒蛇猛兽， 吃尽了我们的血肉！ 一旦把它们消灭干净， 鲜红的太阳照遍全球！\n","permalink":"https://gopherding.github.io/posts/read/linternationale/","summary":"\u003cp\u003e\u003cstrong\u003eI.\u003c/strong\u003e\nDebout les damnés de la terre !\nDebout les forçats de la faim !\nLa raison tonne en son cratère,\nC\u0026rsquo;est l\u0026rsquo;éruption de la fin.\nDu passé, faisons table rase,\nFoule esclave debout ! debout !\nLe monde va changer de base :\nNous ne sommes rien, soyons tout !|\u003c/p\u003e\n\u003cp\u003eC\u0026rsquo;est la lutte finale,\nGroupons-nous, et demain\nL\u0026rsquo;Internationale,\nSera le genre humain.\nC\u0026rsquo;est la lutte finale,\nGroupons-nous, et demain\nL\u0026rsquo;Internationale,\nSera le genre humain.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eII.\u003c/strong\u003e\nIl n\u0026rsquo;est pas de sauveurs suprêmes,\nNi dieu, ni César, ni tribun,\nProducteurs, sauvons-nous nous-mêmes !\nDécrétons le salut commun !\nPour que le voleur rende gorge,\nPour tirer l\u0026rsquo;esprit du cachot,\nSoufflons nous-mêmes notre forge,\nBattons le fer quand il est chaud !\u003c/p\u003e","title":"L'Internationale"},{"content":"一、数据模型 RDS： 是一种关系型数据库服务，支持常见的关系型数据库引擎如 MySQL、PostgreSQL、Oracle、SQL Server 等。 使用传统的表格结构来存储数据，通过 SQL 语言进行数据查询和操作。 遵循关系型数据库的 ACID（原子性、一致性、隔离性、持久性）特性，适用于对数据一致性要求较高的应用场景。 DynamoDB： 是一种完全托管的 NoSQL 数据库服务，支持键值对和文档数据模型。 可以存储和检索任意类型的数据，无需预先定义模式，具有很高的灵活性。 提供最终一致性和强一致性两种一致性级别，适用于对可扩展性和性能要求较高的应用场景。 二、可扩展性 RDS： 可以通过垂直扩展（增加实例的资源配置）和水平扩展（增加只读副本或使用数据库集群）来提高性能和容量。 水平扩展相对复杂，需要进行一些额外的配置和管理。 DynamoDB： 具有高度可扩展性，可以自动处理大规模的数据和流量。 可以根据实际需求动态调整存储容量和吞吐量，无需进行复杂的扩展操作。 适用于处理高并发、大规模数据的应用场景。 三、性能 RDS： 性能取决于所选择的数据库引擎、实例类型和配置。 对于复杂的查询和事务处理，关系型数据库通常具有较好的性能表现。 但在处理大规模数据和高并发访问时，可能需要进行优化和扩展。 DynamoDB： 设计用于提供低延迟的读写操作，具有很高的性能和吞吐量。 可以快速响应大量的并发请求，适用于对响应时间要求较高的应用场景。 但对于复杂的查询和分析操作，可能不如关系型数据库灵活。 四、成本 RDS： 成本主要取决于实例类型、存储容量、备份和恢复选项等。 关系型数据库通常需要进行较多的管理和维护工作，可能会增加成本。 DynamoDB： 采用按需付费的模式，根据实际使用的存储容量和吞吐量进行计费。 无需进行复杂的管理和维护工作，成本相对较低。 但对于长期存储大量数据的应用场景，成本可能会较高。 五、适用场景 RDS： 适用于传统的企业级应用、事务处理系统、数据分析等场景。 对于需要复杂查询、事务支持和数据一致性的应用，关系型数据库是一个可靠的选择。 DynamoDB： 适用于互联网应用、移动应用、游戏等对可扩展性和性能要求较高的场景。 对于需要快速响应、灵活数据模型和自动扩展的应用，DynamoDB 是一个理想的选择。 ","permalink":"https://gopherding.github.io/posts/tech/rds-dynamodb%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"\u003ch3 id=\"一数据模型\"\u003e\u003cstrong\u003e一、数据模型\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"rds\"\u003e\u003cstrong\u003eRDS\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e是一种关系型数据库服务，支持常见的关系型数据库引擎如 MySQL、PostgreSQL、Oracle、SQL Server 等。\u003c/li\u003e\n\u003cli\u003e使用传统的表格结构来存储数据，通过 SQL 语言进行数据查询和操作。\u003c/li\u003e\n\u003cli\u003e遵循关系型数据库的 ACID（原子性、一致性、隔离性、持久性）特性，适用于对数据一致性要求较高的应用场景。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"dynamodb\"\u003e\u003cstrong\u003eDynamoDB\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e是一种完全托管的 NoSQL 数据库服务，支持键值对和文档数据模型。\u003c/li\u003e\n\u003cli\u003e可以存储和检索任意类型的数据，无需预先定义模式，具有很高的灵活性。\u003c/li\u003e\n\u003cli\u003e提供最终一致性和强一致性两种一致性级别，适用于对可扩展性和性能要求较高的应用场景。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二可扩展性\"\u003e\u003cstrong\u003e二、可扩展性\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"rds-1\"\u003e\u003cstrong\u003eRDS\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e可以通过垂直扩展（增加实例的资源配置）和水平扩展（增加只读副本或使用数据库集群）来提高性能和容量。\u003c/li\u003e\n\u003cli\u003e水平扩展相对复杂，需要进行一些额外的配置和管理。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"dynamodb-1\"\u003e\u003cstrong\u003eDynamoDB\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e具有高度可扩展性，可以自动处理大规模的数据和流量。\u003c/li\u003e\n\u003cli\u003e可以根据实际需求动态调整存储容量和吞吐量，无需进行复杂的扩展操作。\u003c/li\u003e\n\u003cli\u003e适用于处理高并发、大规模数据的应用场景。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"三性能\"\u003e\u003cstrong\u003e三、性能\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"rds-2\"\u003e\u003cstrong\u003eRDS\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e性能取决于所选择的数据库引擎、实例类型和配置。\u003c/li\u003e\n\u003cli\u003e对于复杂的查询和事务处理，关系型数据库通常具有较好的性能表现。\u003c/li\u003e\n\u003cli\u003e但在处理大规模数据和高并发访问时，可能需要进行优化和扩展。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"dynamodb-2\"\u003e\u003cstrong\u003eDynamoDB\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e设计用于提供低延迟的读写操作，具有很高的性能和吞吐量。\u003c/li\u003e\n\u003cli\u003e可以快速响应大量的并发请求，适用于对响应时间要求较高的应用场景。\u003c/li\u003e\n\u003cli\u003e但对于复杂的查询和分析操作，可能不如关系型数据库灵活。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"四成本\"\u003e\u003cstrong\u003e四、成本\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"rds-3\"\u003e\u003cstrong\u003eRDS\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e成本主要取决于实例类型、存储容量、备份和恢复选项等。\u003c/li\u003e\n\u003cli\u003e关系型数据库通常需要进行较多的管理和维护工作，可能会增加成本。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"dynamodb-3\"\u003e\u003cstrong\u003eDynamoDB\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e采用按需付费的模式，根据实际使用的存储容量和吞吐量进行计费。\u003c/li\u003e\n\u003cli\u003e无需进行复杂的管理和维护工作，成本相对较低。\u003c/li\u003e\n\u003cli\u003e但对于长期存储大量数据的应用场景，成本可能会较高。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"五适用场景\"\u003e\u003cstrong\u003e五、适用场景\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"rds-4\"\u003e\u003cstrong\u003eRDS\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e适用于传统的企业级应用、事务处理系统、数据分析等场景。\u003c/li\u003e\n\u003cli\u003e对于需要复杂查询、事务支持和数据一致性的应用，关系型数据库是一个可靠的选择。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"dynamodb-4\"\u003e\u003cstrong\u003eDynamoDB\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e适用于互联网应用、移动应用、游戏等对可扩展性和性能要求较高的场景。\u003c/li\u003e\n\u003cli\u003e对于需要快速响应、灵活数据模型和自动扩展的应用，DynamoDB 是一个理想的选择。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"RDS 、DynamoDB的区别"},{"content":"She Walks in Beauty By George Gordon Byron\nShe walks in beauty, like the night\nOf cloudless climes and starry skies;\nAnd all that’s best of dark and bright\nMeet in her aspect and her eyes;\nThus mellowed to that tender light\nWhich heaven to gaudy day denies.\nOne shade the more, one ray the less,\nHad half impaired the nameless grace\nWhich waves in every raven tress,\nOr softly lightens o’er her face;\nWhere thoughts serenely sweet express,\nHow pure, how dear their dwelling - place.\nAnd on that cheek, and o’er that brow,\nSo soft, so calm, yet eloquent,\nThe smiles that win, the tints that glow,\nBut tell of days in goodness spent,\nA mind at peace with all below,\nA heart whose love is innocent!\n","permalink":"https://gopherding.github.io/posts/read/she-walks-in-beauty/","summary":"\u003ch3 id=\"she-walks-in-beauty\"\u003eShe Walks in Beauty\u003c/h3\u003e\n\u003cp\u003eBy George Gordon Byron\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eShe walks in beauty, like the night\u003c/p\u003e\n\u003cp\u003eOf cloudless climes and starry skies;\u003c/p\u003e\n\u003cp\u003eAnd all that’s best of dark and bright\u003c/p\u003e\n\u003cp\u003eMeet in her aspect and her eyes;\u003c/p\u003e\n\u003cp\u003eThus mellowed to that tender light\u003c/p\u003e\n\u003cp\u003eWhich heaven to gaudy day denies.\u003c/p\u003e\n\u003cp\u003eOne shade the more, one ray the less,\u003c/p\u003e\n\u003cp\u003eHad half impaired the nameless grace\u003c/p\u003e\n\u003cp\u003eWhich waves in every raven tress,\u003c/p\u003e\n\u003cp\u003eOr softly lightens o’er her face;\u003c/p\u003e\n\u003cp\u003eWhere thoughts serenely sweet express,\u003c/p\u003e\n\u003cp\u003eHow pure, how dear their dwelling - place.\u003c/p\u003e\n\u003cp\u003eAnd on that cheek, and o’er that brow,\u003c/p\u003e\n\u003cp\u003eSo soft, so calm, yet eloquent,\u003c/p\u003e\n\u003cp\u003eThe smiles that win, the tints that glow,\u003c/p\u003e\n\u003cp\u003eBut tell of days in goodness spent,\u003c/p\u003e\n\u003cp\u003eA mind at peace with all below,\u003c/p\u003e\n\u003cp\u003eA heart whose love is innocent!\u003c/p\u003e","title":"She Walks in Beauty"},{"content":"一、本地操作流程 1. 查看文件变更状态 git status 作用：查看哪些文件被修改、新增或删除，确认更新内容 2. 添加变更到暂存区 git add . 说明：.表示添加所有变更文件，也可指定单个文件如git add content/posts/new-article.md 3. 提交变更到本地仓库 git commit -m \u0026#34;更新博文：《Hugo博客部署指南》\u0026#34; 建议：提交信息明确说明更新内容，便于后续追溯 4. 拉取远程仓库最新代码 git pull origin main 注意：main为默认主分支，若使用其他分支请替换，避免推送时出现冲突 5. 生成静态文件 hugo -D 参数说明：\n-D：包含草稿状态的文章（draft: true） \u0026ndash;minify：压缩 HTML、CSS 和 JS 文件（可选） -b https://yourdomain.com：设置基准 URL（多环境部署时使用） 二、远程部署操作 1. 推送到 GitHub 主分支 git push origin main 效果：触发 GitHub Actions 工作流（若已配置）自动部署到 GitHub Pages 2. 验证部署状态 查看 GitHub Actions 运行情况： 进入 GitHub 仓库 → Actions标签\n查看Deploy to GitHub Pages工作流是否成功\n点击具体任务查看日志，排查错误（如有）\n确认博客更新： # 本地预览（部署前可选） hugo server -D 访问http://localhost:1313确认新博文已显示\n部署后访问线上地址，可能需要清除浏览器缓存\n三、特殊场景补充命令 1. 更新博客主题 # 拉取主题子模块最新代码 git submodule update --remote --merge # 提交主题变更 git add themes/your-theme/ git commit -m \u0026#34;更新主题到v1.2.0\u0026#34; git push origin main 2. 修复部署错误 # 修改本地代码后重新提交 git add . git commit -m \u0026#34;修复部署问题：修正配置文件\u0026#34; git push origin main 3. 手动部署到自定义服务器 # 生成静态文件到指定目录 hugo -D -d /path/to/deploy/folder # 通过SCP上传到服务器 scp -r /path/to/deploy/folder/* user@server:/var/www/your-blog/ # 远程重启服务（如Nginx） ssh user@server \u0026#34;systemctl restart nginx\u0026#34; 四、自动化部署脚本 创建deploy.sh脚本简化流程：\n#!/bin/bash # 博客部署脚本 echo \u0026#34;开始部署Hugo博客...\u0026#34; # 1. 检查状态并添加变更 git status git add . # 2. 提交变更 DATE=$(date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) git commit -m \u0026#34;自动部署：$DATE\u0026#34; || exit 0 # 3. 拉取并推送 git pull origin main git push origin main # 4. 提示完成 echo \u0026#34;部署已触发，等待GitHub Actions完成...\u0026#34; 赋予执行权限并运行：\nchmod +x deploy.sh ./deploy.sh 五、部署流程示意图 本地修改博文 → git add . → git commit → git pull → hugo -D → git push → GitHub Actions触发 ↓ Hugo生成静态文件 → 推送到gh-pages分支 → 博客自动更新（约1-3分钟） 六、注意事项 分支设置：确保 GitHub Actions 配置文件（.github/workflows/gh-pages.yml）正确监听main分支\n主题依赖：若使用主题，需在 Actions 中配置submodules: true拉取主题代码\n草稿处理：线上环境如需显示草稿，需在 Hugo 命令或 Actions 中添加-D参数\n缓存问题：部署后若未显示更新，尝试强制刷新浏览器（Ctrl+Shift+R）或清除 CDN 缓存\n","permalink":"https://gopherding.github.io/posts/blog/hugo%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8-%E4%BB%8E%E9%83%A8%E7%BD%B2%E8%AE%B2%E8%B5%B7/","summary":"\u003ch3 id=\"一本地操作流程\"\u003e一、本地操作流程\u003c/h3\u003e\n\u003ch4 id=\"1-查看文件变更状态\"\u003e1. 查看文件变更状态\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit status\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e作用：查看哪些文件被修改、新增或删除，确认更新内容\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-添加变更到暂存区\"\u003e2. 添加变更到暂存区\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit add .\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e说明：.表示添加所有变更文件，也可指定单个文件如git add content/posts/\u003ca href=\"http://new-article.md\"\u003enew-article.md\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"3-提交变更到本地仓库\"\u003e3. 提交变更到本地仓库\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit commit -m \u0026#34;更新博文：《Hugo博客部署指南》\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e建议：提交信息明确说明更新内容，便于后续追溯\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"4-拉取远程仓库最新代码\"\u003e4. 拉取远程仓库最新代码\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit pull origin main\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e注意：main为默认主分支，若使用其他分支请替换，避免推送时出现冲突\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"5-生成静态文件\"\u003e5. 生成静态文件\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehugo -D\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e参数说明：\u003c/p\u003e","title":"Hugo简单入门-从部署讲起"},{"content":"But why, some say, the moon?\n但有人问，为什么选择登月？\nWhy choose this as our goal?\n为什么选择登月作为我们的目标？\nAnd they may well ask why climb the highest mountain?\n那他们也许会问为什么我们要登上最高的山峰？\nWhy, 35 years ago, fly the Atlantic?\n为什么，要在35年前，飞越大西洋？\nWhy does Rice play Texas?\n为什么赖斯大学要与德克萨斯大学竞赛？\nWe choose to go to the moon.\n我们决定登月。\nWe choose to go to the moon.\n我们决定登月。\nWe choose to go to the moon in this decade and do the other things, not because they are easy, but because they are hard, because that goal will serve to organize and measure the best of our energies and skills, because that challenge is one that we are willing to accept, one we are unwilling to postpone, and one which we intend to win, and the others, too.\n我们决定在这十年间登上月球并实现更多梦想，并非它们轻而易举，而正是因为它们困难重重。因为这个目标将促进我们实现最佳的组织并测试我们顶尖的技术和力量，因为这个挑战我们乐于接受，因为这个挑战我们不愿推迟，因为这个挑战我们志在必得，其他的挑战也是如此。\n","permalink":"https://gopherding.github.io/posts/read/we-choose-to-go-to-the-moonextract/","summary":"\u003cp\u003eBut why, some say, the moon?\u003c/p\u003e\n\u003cp\u003e但有人问，为什么选择登月？\u003c/p\u003e\n\u003cp\u003eWhy choose this as our goal?\u003c/p\u003e\n\u003cp\u003e为什么选择登月作为我们的目标？\u003c/p\u003e\n\u003cp\u003eAnd they may well ask why climb the highest mountain?\u003c/p\u003e\n\u003cp\u003e那他们也许会问为什么我们要登上最高的山峰？\u003c/p\u003e\n\u003cp\u003eWhy, 35 years ago, fly the Atlantic?\u003c/p\u003e\n\u003cp\u003e为什么，要在35年前，飞越大西洋？\u003c/p\u003e\n\u003cp\u003eWhy does Rice play Texas?\u003c/p\u003e\n\u003cp\u003e为什么赖斯大学要与德克萨斯大学竞赛？\u003c/p\u003e\n\u003cp\u003eWe choose to go to the moon.\u003c/p\u003e\n\u003cp\u003e我们决定登月。\u003c/p\u003e\n\u003cp\u003eWe choose to go to the moon.\u003c/p\u003e\n\u003cp\u003e我们决定登月。\u003c/p\u003e\n\u003cp\u003eWe choose to go to the moon in this decade and do the other things, not because they are easy, but because they are hard, because that goal will serve to organize and measure the best of our energies and skills, because that challenge is one that we are willing to accept, one we are unwilling to postpone, and one which we intend to win, and the others, too.\u003c/p\u003e","title":"We choose to go to the moon(Extract)"},{"content":"Hadoop 的 EditLog 和 FsImage 与 Redis 的 AOF（Append Only File）和 RDB（Redis Database）在某些方面有相似的设计思想。\n一、Redis 的 AOF 和 RDB RDB（Redis Database） 功能与特点： RDB 是 Redis 用来进行数据持久化的一种方式，它是在某个时间点将 Redis 内存中的数据以快照的形式写入到磁盘文件中。这个过程类似于对 Redis 数据的一个完整备份。 例如，当执行 SAVE 或 BGSAVE 命令时，Redis 会将当前内存中的所有数据序列化并写入到一个.rdb 文件中。下次 Redis 启动时，可以通过加载这个.rdb 文件来恢复数据。 存储与恢复： RDB 文件通常存储在磁盘上指定的目录中。在 Redis 启动时，如果配置了使用 RDB 进行数据恢复，它会首先尝试加载这个文件，将其中的数据恢复到内存中，从而快速恢复到上次保存的状态。 例如，如果 Redis 因为某些原因崩溃了，在重新启动时，它可以通过加载最新的.rdb 文件来恢复数据，使得数据的丢失最小化。 AOF（Append Only File） 功能与特点： AOF 则是以日志的形式记录 Redis 服务器所执行的所有写命令。每当 Redis 执行一个写命令时，这个命令就会被追加到 AOF 文件的末尾。这样，即使 Redis 发生故障，也可以通过重新执行 AOF 文件中的命令来恢复数据。 例如，当执行 SET key value 命令时，这个命令会被立即记录到 AOF 文件中。如果 Redis 服务器在后续的运行过程中出现故障，重新启动后，Redis 会读取 AOF 文件，并重新执行其中的所有写命令，以恢复数据到故障发生前的状态。 存储与恢复： AOF 文件也是存储在磁盘上，并且以追加的方式不断增长。为了防止 AOF 文件过大，Redis 提供了一些机制来对 AOF 文件进行重写和压缩，例如可以使用 BGREWRITEAOF 命令来启动 AOF 文件的重写过程。 在 Redis 启动时，如果同时配置了 AOF 和 RDB 进行数据恢复，通常会优先使用 AOF 文件进行恢复，因为 AOF 文件记录了更完整的写命令历史，可以更准确地恢复数据到故障发生前的状态。 二、相似的设计思想 数据持久化与恢复： 共同目标： EditLog + FsImage 和 AOF + RDB 组合的主要目的都是为了实现数据的持久化和故障恢复。在 Hadoop 的 HDFS 中，EditLog 记录元数据的变更操作，FsImage 提供元数据的快照，通过它们可以在 NameNode 故障后恢复文件系统的状态。同样，在 Redis 中，AOF 记录写命令历史，RDB 提供数据的快照，用于在 Redis 服务器故障后恢复数据。 恢复过程相似： 在恢复过程中，两者都需要读取存储在磁盘上的文件来重建数据状态。对于 HDFS，NameNode 读取 FsImage 和 EditLog 来恢复文件系统的元数据；对于 Redis，服务器读取 RDB 文件或重放 AOF 文件中的命令来恢复数据。 例如，如果 HDFS 的 NameNode 或 Redis 服务器发生故障，在重新启动时，它们都可以依靠存储在磁盘上的持久化文件来恢复到故障发生前的状态，确保数据的可用性和完整性。\n动态更新与静态快照结合： 设计理念相似： EditLog 和 AOF 都是用于记录动态的变更操作，而 FsImage 和 RDB 则是提供静态的快照。这种设计思想是将动态的变更记录与静态的快照相结合，既可以快速获取某个时间点的状态（通过快照），又可以通过记录变更操作来实现对数据的逐步更新和恢复。 性能与可靠性平衡： 通过这种方式，可以在一定程度上平衡性能和可靠性。例如，在 HDFS 中，频繁地更新 FsImage 可能会影响性能，而通过 EditLog 记录变更操作并定期合并到 FsImage 中，可以减少对 FsImage 的直接更新，提高性能。在 Redis 中，RDB 可以快速进行数据恢复，但可能会丢失一些最近的写操作，而 AOF 可以记录所有的写命令，保证数据的完整性，但可能会导致 AOF 文件过大。通过合理配置两者的使用，可以在性能和可靠性之间找到平衡。 定期合并与重写： 优化机制类似： HDFS 中的 EditLog 会定期合并到 FsImage 中，以生成新的 FsImage 文件并清空 EditLog，从而减少 EditLog 的大小和提高系统性能。同样，Redis 的 AOF 文件也可以通过重写机制来压缩文件大小，去除重复的和无效的命令，提高数据恢复的效率。 触发条件相似： 两者的合并和重写操作通常都是基于一定的条件触发的。例如，在 HDFS 中，NameNode 可能会定期触发检查点操作来合并 EditLog 和 FsImage；在 Redis 中，可以通过配置自动触发 AOF 重写的条件，如当 AOF 文件大小超过一定阈值或经过一定时间没有重写时。 ","permalink":"https://gopherding.github.io/posts/tech/editlog-+-fsimage-%E5%92%8C-aof-+-rdb-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/","summary":"\u003cp\u003eHadoop 的 EditLog 和 FsImage 与 Redis 的 AOF（Append Only File）和 RDB（Redis Database）在某些方面有相似的设计思想。\u003c/p\u003e\n\u003ch3 id=\"一redis-的-aof-和-rdb\"\u003e\u003cstrong\u003e一、Redis 的 AOF 和 RDB\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"rdbredis-database\"\u003e\u003cstrong\u003eRDB（Redis Database）\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch5 id=\"功能与特点\"\u003e功能与特点：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003eRDB 是 Redis 用来进行数据持久化的一种方式，它是在某个时间点将 Redis 内存中的数据以快照的形式写入到磁盘文件中。这个过程类似于对 Redis 数据的一个完整备份。\u003c/li\u003e\n\u003cli\u003e例如，当执行 \u003ccode\u003eSAVE\u003c/code\u003e 或 \u003ccode\u003eBGSAVE\u003c/code\u003e 命令时，Redis 会将当前内存中的所有数据序列化并写入到一个.rdb 文件中。下次 Redis 启动时，可以通过加载这个.rdb 文件来恢复数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"存储与恢复\"\u003e存储与恢复：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003eRDB 文件通常存储在磁盘上指定的目录中。在 Redis 启动时，如果配置了使用 RDB 进行数据恢复，它会首先尝试加载这个文件，将其中的数据恢复到内存中，从而快速恢复到上次保存的状态。\u003c/li\u003e\n\u003cli\u003e例如，如果 Redis 因为某些原因崩溃了，在重新启动时，它可以通过加载最新的.rdb 文件来恢复数据，使得数据的丢失最小化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"aofappend-only-file\"\u003e\u003cstrong\u003eAOF（Append Only File）\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch5 id=\"功能与特点-1\"\u003e功能与特点：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003eAOF 则是以日志的形式记录 Redis 服务器所执行的所有写命令。每当 Redis 执行一个写命令时，这个命令就会被追加到 AOF 文件的末尾。这样，即使 Redis 发生故障，也可以通过重新执行 AOF 文件中的命令来恢复数据。\u003c/li\u003e\n\u003cli\u003e例如，当执行 \u003ccode\u003eSET key value\u003c/code\u003e 命令时，这个命令会被立即记录到 AOF 文件中。如果 Redis 服务器在后续的运行过程中出现故障，重新启动后，Redis 会读取 AOF 文件，并重新执行其中的所有写命令，以恢复数据到故障发生前的状态。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"存储与恢复-1\"\u003e存储与恢复：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003eAOF 文件也是存储在磁盘上，并且以追加的方式不断增长。为了防止 AOF 文件过大，Redis 提供了一些机制来对 AOF 文件进行重写和压缩，例如可以使用 \u003ccode\u003eBGREWRITEAOF\u003c/code\u003e 命令来启动 AOF 文件的重写过程。\u003c/li\u003e\n\u003cli\u003e在 Redis 启动时，如果同时配置了 AOF 和 RDB 进行数据恢复，通常会优先使用 AOF 文件进行恢复，因为 AOF 文件记录了更完整的写命令历史，可以更准确地恢复数据到故障发生前的状态。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"二相似的设计思想\"\u003e\u003cstrong\u003e二、相似的设计思想\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"数据持久化与恢复\"\u003e\u003cstrong\u003e数据持久化与恢复\u003c/strong\u003e：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch5 id=\"共同目标\"\u003e共同目标：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003eEditLog + FsImage 和 AOF + RDB 组合的主要目的都是为了实现数据的持久化和故障恢复。在 Hadoop 的 HDFS 中，EditLog 记录元数据的变更操作，FsImage 提供元数据的快照，通过它们可以在 NameNode 故障后恢复文件系统的状态。同样，在 Redis 中，AOF 记录写命令历史，RDB 提供数据的快照，用于在 Redis 服务器故障后恢复数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch5 id=\"恢复过程相似\"\u003e恢复过程相似：\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e在恢复过程中，两者都需要读取存储在磁盘上的文件来重建数据状态。对于 HDFS，NameNode 读取 FsImage 和 EditLog 来恢复文件系统的元数据；对于 Redis，服务器读取 RDB 文件或重放 AOF 文件中的命令来恢复数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e例如，如果 HDFS 的 NameNode 或 Redis 服务器发生故障，在重新启动时，它们都可以依靠存储在磁盘上的持久化文件来恢复到故障发生前的状态，确保数据的可用性和完整性。\u003c/p\u003e","title":"EditLog+FsImage和AOF+RDB设计哲学"},{"content":"再论雷峰塔的倒掉 从崇轩先生的通信（二月份《京报副刊》）里，知道他在轮船上听到两个旅客谈话，说是杭州雷峰塔之所以倒掉，是因为乡下人迷信那塔砖放在自己的家中，凡事都必平安，如意，逢凶化吉，于是这个也挖，那个也挖，挖之久久，便倒了。一个旅客并且再三叹息道：西湖十景这可缺了呵！\n这消息，可又使我有点畅快了，虽然明知道幸灾乐祸，不像一个绅士，但本来不是绅士的，也没有法子来装潢。\n我们中国的许多人，—— 我在此特别郑重声明：并不包括四万万同胞全部！—— 大抵患有一种 “十景病”，至少是 “八景病”，沉重起来的时候大概在清朝。凡看一部县志，这一县往往有十景或八景，如 “远村明月”“萧寺清钟”“古池好水” 之类。而且，“十” 字形的病菌，似乎已经侵入血管，流布全身，其势力早不在 “！” 形惊叹亡国病菌之下了。点心有十样锦，菜有十碗，音乐有十番，阎罗有十殿，药有十全大补，猜拳有全福手福手全，连人的劣迹或罪状，宣布起来也大抵是十条，仿佛犯了九条的时候总不肯歇手。\n现在西湖十景可缺了呵！“凡为天下国家有九经”，九经固古已有之，而九景却颇不习见，所以正是对于十景病的一个针砭，至少也可以使患者感到一种不平常，知道自己的可爱的老病，忽而跑掉了十分之一了。\n但仍有悲哀在里面。其实，这一种势所必至的破坏，也还是徒然的，畅快不过是无聊的自欺。雅人和信士和传统大家，定要苦心孤诣巧语花言地再来补足了十景而后已。\n无破坏即无新建设，大致是的；但有破坏却未必即有新建设。卢梭，斯谛纳尔，尼采，托尔斯泰，伊孛生等辈，若用勃兰兑斯的话来说，乃是 “轨道破坏者”。其实他们不单是破坏，而且是扫除，是大呼猛进，将碍脚的旧轨道不论整条或碎片，一扫而空，并非想挖一块废铁古砖挟回家去，预备卖给旧货店。中国很少这一类人，即使有之，也会被大众的唾沫淹死。\n孔丘先生确是伟大，生在巫鬼势力如此旺盛的时代，偏不肯随俗谈鬼神；但可惜太聪明了，“祭如在祭神如神在”，只用他修《春秋》的照例手段以两个 “如” 字略寓 “俏皮刻薄” 之意，使人一时莫名其妙，看不出他肚皮里的反对来。他肯对子路赌咒，却不肯对鬼神宣战，因为一宣战就不和平，易犯骂人 —— 虽然不过骂鬼 —— 之罪，即不免有《衡论》（见一月份《晨报副镌》）作家 ty 先生似的好人，会替鬼神来奚落他道：为名乎？骂人不能得名。为利乎？骂人不能得利。想引诱女人乎？又不能将蚩尤的脸子印在文章上。何乐而为之也欤？孔丘先生是深通世故的老先生，大约除脸子付印问题以外，还有深心，犯不上来做明目张胆的破坏者，所以只是不谈，而决不骂，于是乎俨然成为中国的圣人，道大，无所不包故也。否则，现在供在圣庙里的，也许不姓孔。\n不过在戏台上罢了，悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。讥讽又不过是喜剧的变简的一支流。但悲壮滑稽，却都是十景病的仇敌，因为都有破坏性，虽然所破坏的方面各不同。中国如十景病尚存，则不但卢梭他们似的疯子决不产生，并且也决不产生一个悲剧作家或喜剧作家或讽刺诗人。所有的，只是喜剧底人物或非喜剧非悲剧底人物，在互相模造的十景中生存，一面各各带了十景病。\n然而十全停滞的生活，世界上是很不多见的事，于是破坏者到了，但并非自己的先觉的破坏者，却是狂暴的强盗，或外来的蛮夷。猃狁早到过中原，五胡来过了，蒙古也来过了；同胞张献忠杀人如草，而满洲兵的一箭，就钻进树丛中死掉了。有人论中国说，倘使没有带着新鲜的血液的野蛮的侵入，真不知自身会腐败到如何！这当然是极刻毒的恶谑，但我们一翻历史，怕不免要有汗流浃背的时候罢。\n外寇来了，暂一震动，终于请他作主子，在他的刀斧下修补老例；内寇来了，也暂一震动，终于请他做主子，或者别拜一个主子，在自己的瓦砾中修补老例。再来翻县志，就看见每一次兵燹之后，所添上的是许多烈妇烈女的氏名。看近来的兵祸，怕又要大举表扬节烈了罢。许多男人们都那里去了？\n凡这一种寇盗式的破坏，结果只能留下一片瓦砾，与建设无关。但当太平时候，就是正在修补老例，并无寇盗时候，即国中暂时没有破坏么？也不然的，其时有奴才式的破坏作用常川活动着。雷峰塔砖的挖去，不过是极近的一条小小的例。龙门的石佛，大半肢体不全，图书馆中的书籍，插图须谨防撕去，凡公物或无主的东西，倘难于移动，能够完全的即很不多。但其毁坏的原因，则非如革除者的志在扫除，也非如寇盗的志在掠夺或单是破坏，仅因目前极小的自利，也肯对于完整的大物暗暗的加一个创伤。人数既多，创伤自然极大，而倒败之后，却难于知道加害的究竟是谁。正如雷峰塔倒掉以后，我们单知道由于乡下人的迷信。共有的塔失去了，乡下人的所得，却不过一块砖，这砖，将来又将为别一自利者所藏，终究至于灭尽。\n倘在民康物阜时候，因为十景病的发作，新的雷峰塔也会再造的罢。但将来的运命，不也就可以推想而知么？如果乡下人还是这样的乡下人，老例还是这样的老例。\n这一种奴才式的破坏，结果也只能留下一片瓦砾，与建设无关。岂但乡下人之于雷峰塔，日日偷挖中华民国的柱石的奴才们，现在正不知有多少！\n瓦砾场上还不足悲，在瓦砾场上修补老例是可悲的。我们要革新的破坏者，因为他内心有理想的光。我们应该知道他和寇盗奴才的分别；应该留心自己堕入后两种。这区别并不烦难，只要观人，省己，凡言动中，思想中，含有借此据为己有的朕兆者是寇盗，含有借此占些目前的小便宜的朕兆者是奴才，无论在前面打着的是怎样鲜明好看的旗子 。\n","permalink":"https://gopherding.github.io/posts/read/%E5%86%8D%E8%AE%BA%E9%9B%B7%E5%B3%B0%E5%A1%94%E7%9A%84%E5%80%92%E6%8E%89/","summary":"\u003ch3 id=\"再论雷峰塔的倒掉\"\u003e再论雷峰塔的倒掉\u003c/h3\u003e\n\u003cp\u003e从崇轩先生的通信（二月份《京报副刊》）里，知道他在轮船上听到两个旅客谈话，说是杭州雷峰塔之所以倒掉，是因为乡下人迷信那塔砖放在自己的家中，凡事都必平安，如意，逢凶化吉，于是这个也挖，那个也挖，挖之久久，便倒了。一个旅客并且再三叹息道：西湖十景这可缺了呵！\u003c/p\u003e\n\u003cp\u003e这消息，可又使我有点畅快了，虽然明知道幸灾乐祸，不像一个绅士，但本来不是绅士的，也没有法子来装潢。\u003c/p\u003e","title":"再论雷峰塔的倒掉"},{"content":"战士和苍蝇 Schopenhauer 说过这样的话：要估定人的伟大，则精神上的大和体格上的大，那法则完全相反。后者距离愈远即愈小，前者却见得愈大。正因为近则愈小，而且愈看见缺点和创伤，所以他就和我们一样，不是神道，不是妖怪，不是异兽。他仍然是人，不过如此。但也惟其如此，所以他是伟大的人。\n战士战死了的时候，苍蝇们所首先发见的是他的缺点和伤痕，嘬着，营营地叫着，以为得意，以为比死了的战士更英雄。但是战士已经战死了，不再来挥去他们。于是乎苍蝇们即更其营营地叫，自以为倒是不朽的声音，因为它们的安全，远在战士之上。\n的确的，谁也没有发见过苍蝇们的缺点和创伤。\n然而，有缺点的战士终竟是战士，完美的苍蝇也终竟不过是苍蝇。\n去罢，苍蝇们！虽然生着翅子，还能营营，总不会超过战士的。你们这些虫豸们！\n","permalink":"https://gopherding.github.io/posts/read/%E6%88%98%E5%A3%AB%E5%92%8C%E8%8B%8D%E8%9D%87/","summary":"\u003ch3 id=\"战士和苍蝇\"\u003e战士和苍蝇\u003c/h3\u003e\n\u003cp\u003eSchopenhauer 说过这样的话：要估定人的伟大，则精神上的大和体格上的大，那法则完全相反。后者距离愈远即愈小，前者却见得愈大。正因为近则愈小，而且愈看见缺点和创伤，所以他就和我们一样，不是神道，不是妖怪，不是异兽。他仍然是人，不过如此。但也惟其如此，所以他是伟大的人。\u003c/p\u003e\n\u003cp\u003e战士战死了的时候，苍蝇们所首先发见的是他的缺点和伤痕，嘬着，营营地叫着，以为得意，以为比死了的战士更英雄。但是战士已经战死了，不再来挥去他们。于是乎苍蝇们即更其营营地叫，自以为倒是不朽的声音，因为它们的安全，远在战士之上。\u003c/p\u003e","title":"战士和苍蝇"},{"content":"dockerfile 的命令摘要 FROM- 镜像从那里来\nMAINTAINER- 镜像维护者信息\nRUN- 构建镜像执行的命令，每一次RUN都会构建一层\nCMD- 容器启动的命令，如果有多个则以最后一个为准，也可以为ENTRYPOINT提供参数\nVOLUME- 定义数据卷，如果没有定义则使用默认\nUSER- 指定后续执行的用户组和用户\nWORKDIR- 切换当前执行的工作目录\nHEALTHCHECH- 健康检测指令\nARG- 变量属性值，但不在容器内部起作用\nEXPOSE- 暴露端口\nENV- 变量属性值，容器内部也会起作用\nADD- 添加文件，如果是压缩文件也解压\nCOPY- 添加文件，以复制的形式\nENTRYPOINT- 容器进入时执行的命令，追加到后面\n","permalink":"https://gopherding.github.io/posts/tech/dockerfile-%E7%9A%84%E5%91%BD%E4%BB%A4%E6%91%98%E8%A6%81/","summary":"\u003ch3 id=\"dockerfile-的命令摘要\"\u003edockerfile 的命令摘要\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eFROM- 镜像从那里来\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMAINTAINER- 镜像维护者信息\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRUN- 构建镜像执行的命令，每一次RUN都会构建一层\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCMD- 容器启动的命令，如果有多个则以最后一个为准，也可以为ENTRYPOINT提供参数\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVOLUME- 定义数据卷，如果没有定义则使用默认\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUSER- 指定后续执行的用户组和用户\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWORKDIR- 切换当前执行的工作目录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHEALTHCHECH- 健康检测指令\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eARG- 变量属性值，但不在容器内部起作用\u003c/p\u003e","title":"dockerfile 的命令摘要"},{"content":" 命令分类 命令 功能描述 示例 镜像操作 docker pull 从镜像仓库下载镜像 docker pull ubuntu:latest docker images 列出本地镜像 docker images docker rmi 删除本地镜像 docker rmi ubuntu:latest docker build 根据 Dockerfile 构建镜像 docker build -t my - app:1.0. 容器操作 docker run 创建并运行容器 docker run -it ubuntu:latest /bin/bash docker run -d nginx docker run -p 8080:80 nginx docker run -v /host - dir:/container - dir ubuntu docker ps 列出正在运行的容器 docker ps docker stop 停止正在运行的容器 docker stop 1234567890ab docker start 启动已停止的容器 docker start 1234567890ab docker restart 重启容器 docker restart 1234567890ab docker rm 删除容器 docker rm 1234567890ab或docker rm -f（强制删除运行中的容器） docker exec 在运行容器内执行命令 docker exec -it 1234567890ab /bin/bash 容器网络操作 docker network create 创建新的 Docker 网络 docker network create my - network docker network ls 列出所有 Docker 网络 docker network ls docker network connect 将容器连接到网络 docker network connect my - network 1234567890ab docker network disconnect 将容器从网络断开连接 docker network disconnect my - network 1234567890ab 其他操作 docker login 登录到 Docker Hub 或其他镜像仓库 docker login docker logout 从 Docker Hub 或其他镜像仓库注销 docker logout docker info 显示 Docker 系统信息 docker info ","permalink":"https://gopherding.github.io/posts/tech/docker%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/","summary":"\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e命令分类\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e命令\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e功能描述\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e示例\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e镜像操作\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker pull\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e从镜像仓库下载镜像\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker pull ubuntu:latest\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker images\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e列出本地镜像\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker images\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker rmi\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e删除本地镜像\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker rmi ubuntu:latest\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker build\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e根据 Dockerfile 构建镜像\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker build -t my - app:1.0.\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e容器操作\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker run\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e创建并运行容器\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker run -it ubuntu:latest /bin/bash\u003c/code\u003e \u003ccode\u003edocker run -d nginx\u003c/code\u003e \u003ccode\u003edocker run -p 8080:80 nginx\u003c/code\u003e \u003ccode\u003edocker run -v /host - dir:/container - dir ubuntu\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker ps\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e列出正在运行的容器\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker ps\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker stop\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e停止正在运行的容器\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker stop 1234567890ab\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker start\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e启动已停止的容器\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker start 1234567890ab\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker restart\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e重启容器\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker restart 1234567890ab\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker rm\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e删除容器\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker rm 1234567890ab\u003c/code\u003e或\u003ccode\u003edocker rm -f\u003c/code\u003e（强制删除运行中的容器）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker exec\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e在运行容器内执行命令\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker exec -it 1234567890ab /bin/bash\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e容器网络操作\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker network create\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e创建新的 Docker 网络\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker network create my - network\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker network ls\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e列出所有 Docker 网络\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker network ls\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker network connect\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将容器连接到网络\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker network connect my - network 1234567890ab\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker network disconnect\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将容器从网络断开连接\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker network disconnect my - network 1234567890ab\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e其他操作\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker login\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e登录到 Docker Hub 或其他镜像仓库\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker login\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker logout\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e从 Docker Hub 或其他镜像仓库注销\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker logout\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker info\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e显示 Docker 系统信息\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003edocker info\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Docker命令速查表"},{"content":"娜拉走后怎样 —— 一九二三年十二月二十六日在北京女子高等师范学校文艺会讲\n我今天要讲的是 “娜拉走后怎样？”\n易卜生是十九世纪后半的挪威的一个文人。他的著作，除了几十首诗之外，其余都是剧本。这些剧本里面，有一时期是大抵含有社会问题的，世间也称作 “社会剧”，其中有一篇就是《娜拉》。《娜拉》一名 Ein Puppenheim，中国译作《傀儡家庭》（即《玩偶之家》）。但 Puppe 不单是牵线的傀儡，孩子抱着玩的人形也是；引申开去，别人怎么指挥，他便怎么做的人也是。娜拉当初是满足地生活在所谓幸福的家庭里的，但是她竟觉悟了：自己是丈夫的傀儡，孩子们又是她的傀儡。她于是走了，只听得关门声，接着就是闭幕。这想来大家都知道，不必细说了。\n娜拉要怎样才不走呢？或者说易卜生自己有解答，就是 Die Frau vom Meer，《海的夫人》的。这女人是已经结婚的了，然而先前有一个爱人在海的彼岸，一日突然寻来，叫她一同去。她便告知她的丈夫，要和那外来人会面。临末，她的丈夫说，“现在放你完全自由。（走与不走）你能够自己选择，并且还要自己负责任。” 于是什么事全都改变，她就不走了。这样看来，娜拉倘也得到这样的自由，或者也便可以安住。\n但娜拉毕竟是走了的。走了以后怎样？易卜生并无解答；而且他已经死了。即使不死，他也不负解答的责任。因为易卜生是在做诗，不是为社会提出问题来而且代为解答。就如黄莺一样，因为他自己要歌唱，所以他歌唱，不是要唱给人们听得有趣，有益。\n娜拉走后怎样？—— 别人可是也发表过意见的。一个英国人曾作一篇戏剧，说一个新式的女子走出家庭，再也没有路走，终于堕落，进了妓院了。还有一个中国人，—— 我称他什么呢？上海的文学家罢，—— 说他所见的《娜拉》是和现译本不同，娜拉终于回来了。这样的本子可惜没有第二人看见，除非是易卜生自己寄给他的。但从事理上推想起来，娜拉或者也实在只有两条路：不是堕落，就是回来。因为如果是一匹小鸟，则笼子里固然不自由，而一出笼门，外面便又有鹰，有猫，以及别的什么东西之类；倘使已经关得麻痹了翅子，忘却了飞翔，也诚然是无路可以走。还有一条，就是饿死了，但饿死已经离开了生活，更无所谓问题，所以也不是什么路。\n人生最苦痛的是梦醒了无路可以走。做梦的人是幸福的；倘没有看出可走的路，最要紧的是不要去惊醒他。你看，唐朝的诗人李贺，不是困顿了一世的么？而他临死的时候，却对他的母亲说，“阿妈，上帝造成了白玉楼，叫我做文章落成去了。” 这岂非明明是一个诳，一个梦？然而一个小的和一个老的，一个死的和一个活的，死的高兴地死去，活的放心地活着。说诳和做梦，在这些时候便见得伟大。所以我想，假使寻不出路，我们所要的倒是梦。但是，万不可做将来的梦。阿尔志跋绥夫曾经借了他所做的小说，质问过梦想将来的黄金世界的理想家，因为要造那世界，先唤起许多人们来受苦。他说，“你们将黄金世界预约给他们的子孙了，可是有什么给他们自己呢？” 有是有的，就是将来的希望。但代价也太大了，为了这希望，要使人练敏了感觉来更深切地感到自己的苦痛，叫起灵魂来目睹他自己的腐烂的尸骸。惟有说诳和做梦，这些时候便见得伟大。所以我想，假使寻不出路，我们所要的就是梦；但不要将来的梦，只要目前的梦。\n然而娜拉既然醒了，是很不容易回到梦境的，因此只得走；可是走了以后，有时却也免不掉堕落或回来。否则，就得问：她除了觉醒的心以外，还带了什么去？倘只有一条像诸君一样的紫红的绒绳的围巾，那可是无论宽到二尺或三尺，也完全是不中用。她还须更富有，提包里有准备，直白地说，就是要有钱。\n梦是好的；否则，钱是要紧的。钱这个字很难听，或者要被高尚的君子们所非笑，但我总觉得人们的议论是不但昨天和今天，即使饭前和饭后，也往往有些差别。凡承认饭需钱买，而以说钱为卑鄙者，倘能按一按他的胃，那里面怕总还有鱼肉没有消化完，须得饿他一天之后，再来听他发议论。所以为娜拉计，钱，—— 高雅的说罢，就是经济，是最要紧的了。自由固不是钱所能买到的，但能够为钱而卖掉。人类有一个大缺点，就是常常要饥饿。为补救这缺点起见，为准备不做傀儡起见，在目下的社会里，经济权就见得最要紧了。第一，在家应该先获得男女平均的分配；第二，在社会应该获得男女相等的势力。可惜我不知道这权柄如何取得，单知道仍然要战斗；或者也许比要求参政权更要用剧烈的战斗。\n要求经济权固然是很平凡的事，然而也许比要求高尚的参政权以及博大的女子解放之类更烦难。天下事尽有小作为比大作为更烦难的。譬如现在似的冬天，我们只有这一件棉袄，然而必须救助一个将要冻死的苦人，否则便须坐在菩提树下冥想普度一切人类的方法去。普度一切人类和救活一人，大小实在相去太远了，然而倘叫我挑选，我就立刻到菩提树下去坐着，因为免得脱下唯一的棉袄来冻杀自己。所以在家里说要参政权，是不至于大遭反对的，一说到经济的平匀分配，或不免面前就遇见敌人，这就当然要有剧烈的战斗。\n战斗不算好事情，我们也不能责成人人都是战士，那么，平和的方法也就可贵了，这就是将来利用了亲权来解放自己的子女。中国的亲权是无上的，那时候，就可以将财产平匀地分配子女们，使他们平和而没有冲突地都得到相等的经济权，此后或者去读书，或者去生发，或者为自己去享用，或者为社会去做事，或者去花完，都请便，自己负责任。这虽然也是颇远的梦，可是比黄金世界的梦近得不少了。但第一需要记性。记性不佳，是有益于己而有害于子孙的。人们因为能忘却，所以自己能渐渐地脱离了受过的苦痛，也因为能忘却，所以往往照样地再犯前人的错误。被虐待的儿媳做了婆婆，仍然虐待儿媳；嫌恶学生的官吏，每是先前痛骂官吏的学生；现在压迫子女的，有时也就是十年前的家庭革命者。这也许与年龄和地位都有关系罢，但记性不佳也是一个很大的原因。救济法就是各人去买一本 Note-book 来，将自己现在的思想举动都记上，作为将来年龄和地位都改变了之后的参考。假如憎恶孩子要到公园去的时候，取来一翻，看见上面有一条道，“我想到中央公园去”，那就即刻心平气和了。别的事也一样。\n世间有一种无赖精神，那要义就是韧性。听说拳匪乱后，天津的青皮，就是所谓无赖者很跋扈，譬如给人搬一件行李，他就要两元，对他说这行李小，他说要两元，对他说道路近，他说要两元，对他说不要搬了，他说也仍然要两元。青皮固然是不足为法的，而那韧性却大可以佩服。要求经济权也一样，有人说这事情太陈腐了，就答道要经济权；说是太卑鄙了，就答道要经济权；说是经济制度就要改变了，用不着再操心，也仍然答道要经济权。其实，在现在，一个娜拉的出走，或者也许不至于感到困难的，因为这人物很特别，举动也新鲜，能得到若干人们的同情，帮助着生活。生活在人们的同情之下，已经是不自由了，然而倘有一百个娜拉出走，便连同情也减少，有一千一万个出走，就得到厌恶了，断不如自己握着经济权之为可靠。\n在经济方面得到自由，就不是傀儡了么？也还是傀儡。无非被人所牵的事可以减少，而自己能牵的傀儡可以增多罢了。因为在现在的社会里，不但女人常作男人的傀儡，就是男人和男人，女人和女人，也相互地作傀儡，男人也常作女人的傀儡，这决不是几个女人取得经济权所能救的。但人不能饿着静候理想世界的到来，至少也得留一点残喘，正如涸辙之鲋，急谋升斗之水一样，就要这较为切近的经济权，一面再想别的法。如果经济制度竟改革了，那上文当然完全是废话。然而上文，是又将娜拉当作一个普通的人物而说的，假使她很特别，自己情愿闯出去做牺牲，那就又另是一回事。我们无权去劝诱人做牺牲，也无权去阻止人做牺牲。况且世上也尽有乐于牺牲，乐于受苦的人物。欧洲有一个传说，耶稣去钉十字架时，休息在 Ahasvar 的檐下，Ahasvar 不准他，于是被了咒诅，使他永世不得休息，直到末日裁判的时候。Ahasvar 从此就歇不下，只是走，现在还在走。走是苦的，安息是乐的，他何以不安息呢？虽说背着咒诅，可是大约总该是觉得走比安息还适意，所以始终狂走的罢。只是这牺牲的适意是属于自己的，与志士们之所谓为社会者无涉。\n群众，—— 尤其是中国的，—— 永远是戏剧的看客。牺牲上场，如果显得慷慨，他们就看了悲壮剧；如果显得觳觫，他们就看了滑稽剧。北京的羊肉铺前常有几个人张着嘴看剥羊，仿佛颇愉快，人的牺牲能给与他们的益处，也不过如此。而况事后走不几步，他们并这一点愉快也就忘却了。对于这样的群众没有法，只好使他们无戏可看倒是疗救，正无需乎震骇一时的牺牲，不如深沉的韧性的战斗。\n可惜中国太难改变了，即使搬动一张桌子，改装一个火炉，几乎也要血；而且即使有了血，也未必一定能搬动，能改装。不是很大的鞭子打在背上，中国自己是不肯动弹的。我想这鞭子总要来，好坏是别一问题，然而总要打到的。但是从那里来，怎么地来，我也是不能确切地知道。\n我这讲演也就此完结了。\n","permalink":"https://gopherding.github.io/posts/read/%E5%A8%9C%E6%8B%89%E8%B5%B0%E5%90%8E%E6%80%8E%E6%A0%B7/","summary":"\u003ch3 id=\"娜拉走后怎样\"\u003e娜拉走后怎样\u003c/h3\u003e\n\u003cp\u003e—— 一九二三年十二月二十六日在北京女子高等师范学校文艺会讲\u003c/p\u003e\n\u003cp\u003e我今天要讲的是 “娜拉走后怎样？”\u003c/p\u003e\n\u003cp\u003e易卜生是十九世纪后半的挪威的一个文人。他的著作，除了几十首诗之外，其余都是剧本。这些剧本里面，有一时期是大抵含有社会问题的，世间也称作 “社会剧”，其中有一篇就是《娜拉》。《娜拉》一名 Ein Puppenheim，中国译作《傀儡家庭》（即《玩偶之家》）。但 Puppe 不单是牵线的傀儡，孩子抱着玩的人形也是；引申开去，别人怎么指挥，他便怎么做的人也是。娜拉当初是满足地生活在所谓幸福的家庭里的，但是她竟觉悟了：自己是丈夫的傀儡，孩子们又是她的傀儡。她于是走了，只听得关门声，接着就是闭幕。这想来大家都知道，不必细说了。\u003c/p\u003e","title":"娜拉走后怎样"},{"content":"《希望》 我的心分外地寂寞。\n然而我的心很平安：没有爱憎，没有哀乐，也没有颜色和声音。\n我大概老了。我的头发已经苍白，不是很明白的事么?我的手颤抖着，不是很明白的事么?那么，我的魂灵的手一定也颤抖着，头发也一定苍白了。\n然而这是许多年前的事了。\n这以前，我的心也曾充满过血腥的歌声：血和铁，火焰和毒，恢复和报仇。而忽而这些都空虚了，但有时故意地填以没奈何的自欺的希望。希望，希望，用这希望的盾，抗拒那空虚中的暗夜的袭来，虽然盾后面也依然是空虚中的暗夜。然而就是如此，陆续地耗尽了我的青春。\n我早先岂不知我的青春已经逝去了?但以为身外的青春固在：星，月光，僵坠的胡蝶，暗中的花，猫头鹰的不祥之言，杜鹃的啼血，笑的渺茫，爱的翔舞……虽然是悲凉漂渺的青春罢，然而究竟是青春。\n然而现在何以如此寂寞? 难道连身外的青春也都逝去，世上的青年也多衰老了么?\n我只得由我来肉薄这空虚中的暗夜了。我放下了希望之盾，我听到 Petofi Sándor (1823—49)的“希望”之歌：\n希望是甚么?是娼妓：\n她对谁都蛊惑，将一切都献给;\n待你牺牲了极多的宝贝……\n你的青春——她就弃掉你。\n这伟大的抒情诗人，匈牙利的爱国者，为了祖国而死在可萨克兵的矛尖上，已经七十五年了。悲哉死也，然而更可悲的是他的诗至今没有死。\n但是，可惨的人生! 桀骜英勇如 Petofi ，也终于对了暗夜止步，回顾着茫茫的东方了。他说：\n绝望之为虚妄，正与希望相同。\n倘使我还得偷生在不明不暗的这“虚妄”中，我就还要寻求那逝去的悲凉漂渺的青春，但不妨在我的身外。因为身外的青春倘一消灭，我身中的迟暮也即凋零了。\n然而现在没有星和月光，没有僵坠的胡蝶以至笑的渺茫，爱的翔舞。然而青年们很平安。\n我只得由我来肉薄这空虚中的暗夜了，纵使寻不到身外的青春，也总得自己来一掷我身中的迟暮。但暗夜又在那里呢?现在没有星，没有月光以至笑的渺茫和爱的翔舞;青年们很平安，而我的面前又竟至于并且没有真的暗夜。\n绝望之为虚妄，正与希望相同!\n一九二五年一月一日。\n","permalink":"https://gopherding.github.io/posts/read/%E5%B8%8C%E6%9C%9B/","summary":"\u003ch3 id=\"希望\"\u003e《希望》\u003c/h3\u003e\n\u003cp\u003e我的心分外地寂寞。\u003c/p\u003e\n\u003cp\u003e然而我的心很平安：没有爱憎，没有哀乐，也没有颜色和声音。\u003c/p\u003e\n\u003cp\u003e我大概老了。我的头发已经苍白，不是很明白的事么?我的手颤抖着，不是很明白的事么?那么，我的魂灵的手一定也颤抖着，头发也一定苍白了。\u003c/p\u003e\n\u003cp\u003e然而这是许多年前的事了。\u003c/p\u003e\n\u003cp\u003e这以前，我的心也曾充满过血腥的歌声：血和铁，火焰和毒，恢复和报仇。而忽而这些都空虚了，但有时故意地填以没奈何的自欺的希望。希望，希望，用这希望的盾，抗拒那空虚中的暗夜的袭来，虽然盾后面也依然是空虚中的暗夜。然而就是如此，陆续地耗尽了我的青春。\u003c/p\u003e","title":"希望"},{"content":"关于知识阶级 我到上海约二十多天，这回来上海并无什么意义，只是跑来跑去偶然到上海就是了。我没有什么学问和思想，可以贡献给诸君。但这次易先生要我来讲几句话；因为我去年亲见易先生在北京和军阀官僚怎样奋斗，而且我也参与其间，所以他要我来，我是不得不来的。\n我不会讲演，也想不出什么可讲的，讲演近于做八股，是极难的，要有讲演的天才才好，在我是不会的。终于想不出什么，只能随便一谈；刚才谈起中国情形，说到 “知识阶级” 四字，我想对于知识阶级发表一点个人的意见，只是我并不是站在引导者的地位，要诸君都相信我的话，我自己走路都走不清楚，如何能引导诸君？\n“知识阶级” 一辞是爱罗先珂七八年前讲演 “知识阶级及其使命” 时提出的，他骂俄国的知识阶级，也骂中国的知识阶级，中国人于是也骂起知识阶级来了；后来便要打倒知识阶级，要利害一点，甚至于要杀知识阶级了。知识就仿佛是罪恶，但是一方面虽有人骂知识阶级；一方面却又有人以此自豪：这种情形是中国所特有的。\n所谓俄国的知识阶级，其实与中国的不同，俄国当革命以前，社会上还欢迎知识阶级。为什么要欢迎呢？因为他确能替平民抱不平，把平民的苦痛告诉大众。他为什么能把平民的苦痛说出来？因为他与平民接近，或自身就是平民。几年前有一位中国大学教授，他很奇怪，为什么有人要描写一个车夫的事情，这就因为大学教授一向住在高大的洋房里，不明白平民的生活。欧洲的著作家往往是平民出身，所以也同样的感受到平民的苦痛，当然能痛痛快快写出来为平民说话，因此平民以为知识阶级对于自身是有益的；于是赞成他，到处都欢迎他，但是他们既受此荣誉，地位就增高了，而同时却把平民忘记了，变成一种特别的阶级。那时他们自以为了不得，到阔人家里去宴会，钱也多了，房子东西都要好的，终于与平民远远的离开了。他享受了高贵的生活，就记不起从前一切的贫苦生活了。—— 所以请诸位不要拍手，拍了手把我的地位一提高，我就要忘记了说话的。他不但不同情于平民或许还要压迫平民，以致变成了平民的敌人，现在贵族阶级不能存在；贵族的知识阶级当然也不能站住了，这是知识阶级缺点之一。\n还有知识阶级不可免避的运命，在革命时代是注重实行的，动的；思想还在其次，直白地说：或者倒有害。至少我个人的意见如此的。唐朝奸臣李林甫有一次看兵操练很勇敢，就有人对着他称赞。他说：“兵好是好，可是无思想，” 这话很不差。因为兵之所以勇敢，就在没有思想，要是有了思想，就会没有勇气了。现在倘叫我去当兵，要我去革命，我一定不去，因为明白了利害是非，就难于实行了。有知识的人，讲讲柏拉图讲讲苏格拉底是不会有危险的。讲柏拉图可以讲一年，讲苏格拉底可以讲三年，他很可以安安稳稳地活下去，但要他去干危险的事情，那就很费踟踌。譬如中国人，凡是做文章，总说 “有利然而又有弊”，这最足以代表知识阶级的思想。其实无论什么都是有弊的，就是吃饭也是有弊的，它能滋养我们这方面是有利的；但是一方面使我们消化器官疲乏，那就不好而有弊了。假使做事要面面顾到，那就什么事都不能做了。\n还有，知识阶级对于别人的行动，往往以为这样也不好，那样也不好。先前俄国皇帝杀革命党，他们反对皇帝；后来革命党杀皇族，他们也起来反对。问他怎么才好呢？他们也没办法。所以在皇帝时代他们吃苦，在革命时代他们也吃苦，这实在是他们本身的缺点。所以我想，知识阶级能否存在还是个问题。\n知识和强有力是冲突的，不能并立的；强有力不许人民有自由思想，因为这能使能力分散，在动物界有很显的例；猴子的社会是最专制的，猴王说一声走，猴子都走了。在原始时代酋长的命令是不能反对的，无怀疑的，在那时酋长带领着群众并吞衰小的部落；于是部落渐渐的大了，团体也大了。一个人就不能支配了。因为各个人思想发达了，各人的思想不一，民族的思想就不能统一，于是命令不行，团体的力量减小，而渐趋灭亡。在古时野蛮民族常侵略文明很发达的民族，在历史上常见的。现在知识阶级在国内的弊病，正与古时一样。\n英国罗素法国罗曼罗兰反对欧战，大家以为他们了不起，其实幸而他们的话没有实行，否则，德国早已打进英国和法国了；因为德国如不能同时实行非战，是没有办法的。俄国托尔斯泰的无抵抗主义之所以不能实行，也是这个原因。他不主张以恶报恶的，他的意思是皇帝叫我们去当兵，我们不去当兵。叫警察去捉；他不去；叫刽子手去杀，他不去杀，大家都不听皇帝的命令，他也没有兴趣；那末做皇帝也无聊起来，天下也就太平了。然而如果一部分的人偏听皇帝的话，那就不行。我从前也很想做皇帝，后来在北京去看到宫殿的房子都是一个刻板的格式，觉得无聊极了。所以我皇帝也不想做了。做人的趣味在和许多朋友有趣的谈天，热烈的讨论。做了皇帝，口出一声，臣民都下跪，只有不绝声的 yes，yes，那有什么趣味？但是还有人做皇帝，因为他和外界隔绝，不知外面还有世界！总之，思想一自由，能力要减少，民族就站不住，他的自身也站不住了！现在思想自由和生存还有冲突，这是知识阶级本身的缺点。\n然而知识阶级将怎么样呢？还是在指挥刀下听令行动，还是发表倾向民众的思想呢？要是发表意见，就要想到什么就说什么。真的知识阶级是不顾利害的，如想到种种利害，就是假的，冒充的知识阶级；只是假知识阶级的寿命倒比较长一点。像今天发表这个主张，明天发表那个意见的人，思想似乎天天在进步；只是真的知识阶级的进步，决不能如此快的。不过他们对于社会永不会满意的，所感受的永远是痛苦，所看到的永远是缺点，他们预备着将来的牺牲，社会也因为有了他们而热闹，不过他的本身 —— 心身方面总是苦痛的；因为这也是旧式社会传下来的遗物。\n至于诸君，是与旧的不同，是二十世纪初叶青年，如在劳动大学一方读书，一方做工，这是新的境遇；或许可以造成新的局面，但是环境是老样子，着着逼人堕落，倘不与这老社会奋斗，还是要回到老路上去的。譬如从前我在学生时代不吸烟，不吃酒，不打牌，没有一点嗜好；后来当了教员，有人发传单说我抽鸦片。我很气，但并不辩明，为要报复他们，前年我在陕西就真的抽一回鸦片，看他们怎样？此次来上海有人在报纸上说我来开书店；又有人说我每年版税有一万多元。但是我也并不辩明；但曾经自己想，与其负空名，倒不如真的去赚这许多进款。\n还有一层，最可怕的情形，就是比较新的思想运动起来时，如与社会无关，作为空谈，那是不要紧的，这也是专制时代所以能容知识阶级存在的原故。因为痛哭流泪与实际是没有关系的，只是思想运动变成实际的社会运动时，那就危险了。往往反为旧势力所扑灭。中国现在也是如此，这现象，革新的人称之为 “反动”。我在文艺史上，却找到一个好名辞，就是 renaissance，在意大利文艺复兴的意义，是把古时好的东西复活，将现存的坏的东西压倒，因为那时候思想太专制腐败了，在古时代确实有些比较好的；因此后来得到了社会上的信仰。现在中国顽固派的复古，把孔子礼教都拉出来了，但是他们拉出来的是好的么？如果是不好的，就是反动，倒退，以后恐怕是倒退的时代了。\n还有，中国人现在胆子格外小了，这是受了共产党的影响。人一听到俄罗斯，一看见红色，就吓得一跳；一听到新思想，一看到俄国的小说，更其害怕，对于较特别的思想，较新思想尤其丧心发抖，总要仔仔细细底想，这有没有变成共产党思想的可能性？！这样的害怕，一动也不敢动，怎样能够有进步呢？这实在是没有力量的表示，比如我们吃东西，吃就吃，若是左思右想，吃牛肉怕不消化，喝茶时又要怀疑，那就不行了，—— 老年人才是如此；有力量，有自信力的人是不至于此的。虽是西洋文明罢，我们能吸收时，就是西洋文明也变成我们自己的了。好像吃牛肉一样，决不会吃了牛肉自己也即变成牛肉的，要是如此胆小，那真是衰弱的知识阶级了，不衰弱的知识阶级，尚且对于将来的存在不能确定；而衰弱的知识阶级是必定要灭亡的。从前或许有，将来一定不能存在的。\n现在比较安全一点的，还有一条路，是不做时评而做艺术家。要为艺术而艺术。住在 “象牙之塔” 里，目下自然要比别处平安。就我自己来说罢，—— 有人说我只会讲自己，这是真的。我先前独自住在厦门大学的一所静寂的大洋房里；到了晚上，我总是孤思默想，想到一切，想到世界怎样，人类怎样，我静静地思想时，自己以为很了不得的样子；但是给蚊子一咬，跳了一跳，把世界人类的大问题全然忘了，离不开的还是我本身。就我自己说起来，是早就有人劝我不要发议论，不要做杂感，你还是创作去吧！因为做了创作在世界史上有名字，做杂感是没有名字的。其实就是我不做杂感，世界史上，还是没有名字的，这得声明一句，是：这些劝我做创作，不要写杂感的人们之中，有几个是别有用意，是被我骂过的。所以要我不再做杂感。但是我不听他，因此在北京终于站不住了，不得不躲到厦门的图书馆上去了。艺术家住在象牙塔中，固然比较地安全，但可惜还是安全不到底。秦始皇，汉武帝想成仙，终于没有成功而死了。危险的临头虽然可怕，但别的运命说不定，“人生必死” 的运命却无法逃避，所以危险也仿佛用不着害怕似的。但我并不想劝青年得到危险，也不劝他人去做牺牲，说为社会死了名望好，高巍巍的镌起铜像来。自己活着的人没有劝别人去死的权利，假使你自己以为死是好的，那末请你自己先去死吧。诸君中恐有钱人不多罢。那末，我们穷人唯一的资本就是生命。以生命来投资，为社会做一点事，总得多赚一点利才好；以生命来做利息小的牺牲，是不值得的。所以我从来不叫人去牺牲，但也不要再爬进象牙之塔和知识阶级里去了，我以为是最稳当的一条路。\n至于有一班从外国留学回来，自称知识阶级，以为中国没有他们就要灭亡的，却不在我所论之内，像这样的知识阶级，我还不知道是些什么东西？！\n今天的说话很没有伦次，望诸君原谅！\n","permalink":"https://gopherding.github.io/posts/read/%E5%85%B3%E4%BA%8E%E7%9F%A5%E8%AF%86%E9%98%B6%E7%BA%A7/","summary":"\u003ch3 id=\"关于知识阶级\"\u003e关于知识阶级\u003c/h3\u003e\n\u003cp\u003e我到上海约二十多天，这回来上海并无什么意义，只是跑来跑去偶然到上海就是了。我没有什么学问和思想，可以贡献给诸君。但这次易先生要我来讲几句话；因为我去年亲见易先生在北京和军阀官僚怎样奋斗，而且我也参与其间，所以他要我来，我是不得不来的。\u003c/p\u003e\n\u003cp\u003e我不会讲演，也想不出什么可讲的，讲演近于做八股，是极难的，要有讲演的天才才好，在我是不会的。终于想不出什么，只能随便一谈；刚才谈起中国情形，说到 “知识阶级” 四字，我想对于知识阶级发表一点个人的意见，只是我并不是站在引导者的地位，要诸君都相信我的话，我自己走路都走不清楚，如何能引导诸君？\u003c/p\u003e","title":"关于知识阶级"},{"content":"记念刘和珍君 一 中华民国十五年三月二十五日，就是国立北京女子师范大学为十八日在段祺瑞执政府前遇害的刘和珍杨德群两君开追悼会的那一天，我独在礼堂外徘徊，遇见程君，前来问我道，“先生可曾为刘和珍写了一点什么没有？” 我说 “没有”。她就正告我，“先生还是写一点罢；刘和珍生前就很爱看先生的文章。”\n这是我知道的，凡我所编辑的期刊，大概是因为往往有始无终之故罢，销行一向就甚为寥落，然而在这样的生活艰难中，毅然预定了《莽原》全年的就有她。我也早觉得有写一点东西的必要了，这虽然于死者毫不相干，但在生者，却大抵只能如此而已。\n倘使我能够相信真有所谓 “在天之灵”，那自然可以得到更大的安慰，—— 但是，现在，却只能如此而已。\n可是我实在无话可说。我只觉得所住的并非人间。四十多个青年的血，洋溢在我的周围，使我艰于呼吸视听，那里还能有什么言语？长歌当哭，是必须在痛定之后的。而此后几个所谓学者文人的阴险的论调，尤使我觉得悲哀。我已经出离愤怒了。我将深味这非人间的浓黑的悲凉；以我的最大哀痛显示于非人间，使它们快意于我的苦痛，就将这作为后死者的菲薄的祭品，奉献于逝者的灵前。\n二 真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。这是怎样的哀痛者和幸福者？然而造化又常常为庸人设计，以时间的流驶，来洗涤旧迹，仅使留下淡红的血色和微漠的悲哀。在这淡红的血色和微漠的悲哀中，又给人暂得偷生，维持着这似人非人的世界。我不知道这样的世界何时是一个尽头！\n我们还在这样的世上活着；我也早觉得有写一点东西的必要了。离三月十八日也已有两星期，忘却的救主快要降临了罢，我正有写一点东西的必要了。\n三 在四十余被害的青年之中，刘和珍君是我的学生。学生云者，我向来这样想，这样说，现在却觉得有些踌躇了，我应该对她奉献我的悲哀与尊敬。她不是 “苟活到现在的我” 的学生，是为了中国而死的中国的青年。\n她的姓名第一次为我所见，是在去年夏初杨荫榆女士做女子师范大学校长，开除校中六个学生自治会职员的时候。其中的一个就是她；但是我不认识。直到后来，也许已经是刘百昭率领男女武将，强拖出校之后了，才有人指着一个学生告诉我，说：这就是刘和珍。其时我才能将姓名和实体联合起来，心中却暗自诧异。我平素想，能够不为势利所屈，反抗一广有羽翼的校长的学生，无论如何，总该是有些桀骜锋利的，但她却常常微笑着，态度很温和。\n待到偏安于宗帽胡同，赁屋授课之后，她才始来听我的讲义，于是见面的回数就较多了，也还是始终微笑着，态度很温和。待到学校恢复旧观，往日的教职员以为责任已尽，准备陆续引退的时候，我才见她虑及母校前途，黯然至于泣下。此后似乎就不相见。总之，在我的记忆上，那一次就是永别了。\n四 我在十八日早晨，才知道上午有群众向执政府请愿的事；下午便得到噩耗，说卫队居然开枪，死伤至数百人，而刘和珍君即在遇害者之列。但我对于这些传说，竟至于颇为怀疑。我向来是不惮以最坏的恶意，来推测中国人的，然而我还不料，也不信竟会下劣凶残到这地步。况且始终微笑着的和蔼的刘和珍君，更何至于无端在府门前喋血呢？\n然而即日证明是事实了，作证的便是她自己的尸骸。还有一具，是杨德群君的。而且又证明着这不但是杀害，简直是虐杀，因为身体上还有棍棒的伤痕。\n但段政府就有令，说她们是 “暴徒”！但接着就有流言，说她们是受人利用的。惨象，已使我目不忍视了；流言，尤使我耳不忍闻。我还有什么话可说呢？我懂得衰亡民族之所以默无声息的缘由了。沉默呵，沉默呵！不在沉默中爆发，就在沉默中灭亡。\n五 但是，我还有要说的话。我没有亲见；听说，她，刘和珍君，那时是欣然前往的。自然，请愿而已，稍有人心者，谁也不会料到有这样的罗网。但竟在执政府前中弹了，从背部入，斜穿心肺，已是致命的创伤，只是没有便死。同去的张静淑君想扶起她，中了四弹，其一是手枪，立仆；同去的杨德群君又想去扶起她，也被击，弹从左肩入，穿胸偏右出，也立仆。但她还能坐起来，一个兵在她头部及胸部猛击两棍，于是死掉了。\n始终微笑的和蔼的刘和珍君确是死掉了，这是真的，有她自己的尸骸为证；沉勇而友爱的杨德群君也死掉了，有她自己的尸骸为证；只有一样沉勇而友爱的张静淑君还在医院里呻吟。当三个女子从容地转辗于文明人所发明的枪弹的攒射中的时候，这是怎样的一个惊心动魄的伟大呵！中国军人的屠戮妇婴的伟绩，八国联军的惩创学生的武功，不幸全被这几缕血痕抹杀了。\n但是中外的杀人者却居然昂起头来，不知道个个脸上有着血污。\n六 时间永是流驶，街市依旧太平，有限的几个生命，在中国是不算什么的，至多，不过供无恶意的闲人以饭后的谈资，或者给有恶意的闲人作 “流言” 的种子。至于此外的深的意义，我总觉得很寥寥，因为这实在不过是徒手的请愿。人类的血战前行的历史，正如煤的形成，当时用大量的木材，结果却只是一小块，但请愿是不在其中的，更何况是徒手。\n然而既然有了血痕了，当然不觉要扩大。至少，也当浸渍了亲族；师友，爱人的心，纵使时光流驶，洗成绯红，也会在微漠的悲哀中永存微笑的和蔼的旧影。陶潜说过，“亲戚或余悲，他人亦已歌，死去何所道，托体同山阿。” 倘能如此，这也就够了。\n七 我已经说过：我向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是当局者竟会这样地凶残，一是流言家竟至如此之下劣，一是中国的女性临难竟能如是之从容。\n我目睹中国女子的办事，是始于去年的，虽然是少数，但看那干练坚决，百折不回的气概，曾经屡次为之感叹。至于这一回在弹雨中互相救助，虽殒身不恤的事实，则更足为中国女子的勇毅，虽遭阴谋秘计，压抑至数千年，而终于没有消亡的明证了。倘要寻求这一次死伤者对于将来的意义，意义就在此罢。\n苟活者在淡红的血色中，会依稀看见微茫的希望；真的猛士，将更奋然而前行。\n呜呼，我说不出话，但以此记念刘和珍君！\n四月一日\n","permalink":"https://gopherding.github.io/posts/read/%E8%AE%B0%E5%BF%B5%E5%88%98%E5%92%8C%E7%8F%8D%E5%90%9B/","summary":"\u003ch3 id=\"记念刘和珍君\"\u003e记念刘和珍君\u003c/h3\u003e\n\u003ch3 id=\"一\"\u003e一\u003c/h3\u003e\n\u003cp\u003e中华民国十五年三月二十五日，就是国立北京女子师范大学为十八日在段祺瑞执政府前遇害的刘和珍杨德群两君开追悼会的那一天，我独在礼堂外徘徊，遇见程君，前来问我道，“先生可曾为刘和珍写了一点什么没有？” 我说 “没有”。她就正告我，“先生还是写一点罢；刘和珍生前就很爱看先生的文章。”\u003c/p\u003e\n\u003cp\u003e这是我知道的，凡我所编辑的期刊，大概是因为往往有始无终之故罢，销行一向就甚为寥落，然而在这样的生活艰难中，毅然预定了《莽原》全年的就有她。我也早觉得有写一点东西的必要了，这虽然于死者毫不相干，但在生者，却大抵只能如此而已。\u003c/p\u003e","title":"记念刘和珍君"},{"content":"论睁了眼看 虚生先生所做的时事短评中，曾有一个这样的题目：《我们应该有正眼看东西的勇气》（《猛进》十九期）。诚然，必须敢于正视，这才可望敢想，敢说，敢作，敢当。倘使并正视都不敢，此外还能成什么气候。然而，不幸这一种勇气，是我们中国人最所缺乏的东西。\n但现在我所想到的是别一方面 ——\n中国的文人，对于人生，—— 至少是对于社会现象，向来就多没有正视的勇气。我们的圣贤，本来早已教人 “非礼勿视” 的了；而这 “礼” 又非常之严，不但 “正视”，连 “平视”“斜视” 也不许。现在青年的精神未可知，在体质，却大半还是弯腰曲背，低眉顺眼，表示着老牌的老成的子弟，驯良的百姓。\n至于说对外却有大力量，乃是近一月来的新说，还不知道究竟是如何。\n再回到 “正视” 问题去：先既不敢，后便不能，再后，就自然不视，不见了。一辆汽车坏了，停在马路上，一群人围着呆看，所得的结果是一团乌油油的东西。然而由本身的矛盾或社会的别的原因，使文人学者没有勇气正视社会现象，或是不敢正视，或不愿正视，于是就闭眼胡说一通。所以中国的文人学者，对于人生，对于社会现象，也便往往闭了眼睛。\n中国文人的不敢正视人生，大半因为中国人的怯懦。但也有别的原因，例如：怕看真理，怕看人生的真相。因为人生的真相，往往是残酷的，丑恶的，与文人所想象的大不相同。文人想象中的人生，是美妙的，光明的，充满着诗意的。所以他们害怕看到现实的人生，怕看到丑恶的东西。\n像这样的闭着眼睛，中国文人是很不少的。他们写文章，作诗，画画，都是为了逃避现实，或是美化现实。他们把丑恶的东西，写成美好的；把残酷的东西，写成温柔的；把黑暗的东西，写成光明的。他们用这样的方法，来安慰自己，也安慰别人。\n更有一种坏脾气，是相传所谓 “文人相轻”。文人之间，互相看不起，互相攻击。他们不看别人的优点，只看别人的缺点。他们把别人的作品，说得一文不值。他们这样做，并不是因为别人的作品真的不好，而是因为他们自己的嫉妒心。他们嫉妒别人的才华，嫉妒别人的成就。所以他们用攻击别人的方法，来抬高自己。\n中国的文人，还有一种坏脾气，是所谓 “党同伐异”。他们结成党派，互相支持，互相攻击。他们只看党派的利益，不看真理。他们把自己的党派，说得无比正确；把别人的党派，说得无比错误。他们这样做，并不是因为自己的党派真的正确，而是因为他们自己的偏见。他们偏见别人的观点，偏见别人的主张。所以他们用攻击别人的方法，来维护自己的党派。\n但是，闭着眼睛，胡说一通，是没有用的。社会现象，是客观存在的，不管你看与不看，它都在那里。而且，社会现象，是不断变化的，你不看，就会落后，就会被淘汰。所以，文人学者，必须敢于正视社会现象，必须敢于正视人生。\n敢于正视社会现象，敢于正视人生，是一种勇气，也是一种智慧。只有敢于正视，才能了解社会现象的本质，才能了解人生的真相。只有了解了本质和真相，才能找到解决问题的方法，才能找到前进的方向。\n中国的文人学者，要想有所作为，要想为社会做出贡献，就必须睁了眼看。他们必须抛弃怯懦，抛弃嫉妒，抛弃偏见，他们必须正视社会现象，正视人生。只有这样，他们才能写出有价值的文章，画出有价值的画，做出有价值的学问。\n现在，中国的社会，正处在一个大变革的时代。各种社会现象，层出不穷。文人学者，应该睁了眼看，应该勇敢地面对现实，应该积极地参与变革。他们应该用自己的笔，用自己的画，用自己的学问，为社会的变革，为人民的幸福，做出自己的贡献。\n这就是我所要说的 “论睁了眼看”。\n","permalink":"https://gopherding.github.io/posts/read/%E8%AE%BA%E7%9D%81%E4%BA%86%E7%9C%BC%E7%9C%8B/","summary":"\u003ch3 id=\"论睁了眼看\"\u003e论睁了眼看\u003c/h3\u003e\n\u003cp\u003e虚生先生所做的时事短评中，曾有一个这样的题目：《我们应该有正眼看东西的勇气》（《猛进》十九期）。诚然，必须敢于正视，这才可望敢想，敢说，敢作，敢当。倘使并正视都不敢，此外还能成什么气候。然而，不幸这一种勇气，是我们中国人最所缺乏的东西。\u003c/p\u003e\n\u003cp\u003e但现在我所想到的是别一方面 ——\u003c/p\u003e\n\u003cp\u003e中国的文人，对于人生，—— 至少是对于社会现象，向来就多没有正视的勇气。我们的圣贤，本来早已教人 “非礼勿视” 的了；而这 “礼” 又非常之严，不但 “正视”，连 “平视”“斜视” 也不许。现在青年的精神未可知，在体质，却大半还是弯腰曲背，低眉顺眼，表示着老牌的老成的子弟，驯良的百姓。\u003c/p\u003e","title":"论睁了眼看"},{"content":"本文摘自：https://www.cnblogs.com/you-men/p/13884645.html\n同时参考了：https://zhuanlan.zhihu.com/p/37081073\nnsqd: 是一个进程监听了http,tcp两种协议, 用来创建topic,channel, 分发消息给消费者,向nsqlooup 注册自己的元数据信息(topic、channel、consumer)，自己的服务信息，最核心模块。\nnsqd 是一个守护进程，负责接收，排队，投递消息给客户端。也就是说这个服务是干活的。它可以独立运行，不过通常它是由 nsqlookupd 实例所在集群配置的。\n/* 特性: 1. 对订阅了同一个topic，同一个channel的消费者使用负载均衡策略（不是轮询） 2. 只要channel存在，即使没有该channel的消费者，也会将生产者的message缓存到队列中（注意消息的过期处理） 3. 保证队列中的message至少会被消费一次，即使nsqd退出，也会将队列中的消息暂存磁盘上(结束进程等意外情况除外) 4. 限定内存占用，能够配置nsqd中每个channel队列在内存中缓存的message数量，一旦超出，message将被缓存到磁盘中 5. topic，channel一旦建立，将会一直存在，要及时在管理台或者用代码清除无效的topic和channel，避免资源的浪费 */ nsqlookup: 存储了nsqd的元数据和服务信息(endpoind),向消费者提供服务发现功能, 向nsqadmin提供数据查询功能.\nnsqlookupd 是守护进程负责管理拓扑信息。客户端通过查询 nsqlookupd 来发现指定话题（topic）的生产者，并且 nsqd 节点广播话题（topic）和通道（channel）信息。也就是说nsqlookupd是管理者。\n/* 特性: 1. 唯一性，在一个Nsq服务中只有一个nsqlookupd服务。当然也可以在集群中部署多个nsqlookupd，但它们之间是没有关联的. 2. 去中心化，即使nsqlookupd崩溃，也会不影响正在运行的nsqd服务 3. 充当nsqd和naqadmin信息交互的中间件 4. 提供一个http查询服务，给客户端定时更新nsqd的地址目录. */ nsqadmin: 简单的管理界面,展示了topic, channel以及channel上的消费者,也可以创建topic,channel\n/* 特性: 1. 提供一个对topic和channel统一管理的操作界面以及各种实时监控数据的展示，界面设计的很简洁，操作也很简单 2. 展示所有message的数量 3. 能够在后台创建topic和channel 4. nsqadmin的所有功能都必须依赖于nsqlookupd，nsqadmin只是向nsqlookupd传递用户操作并展示来自nsqlookupd的数据 */ Topic和Channel：\n每个nsqd实例旨在一次处理多个数据流。这些数据流称为“topics”，一个topic具有1个或多个“channels”。每个channel都会收到topic所有消息的副本，实际上下游的服务是通过对应的channel来消费topic消息。\ntopic和channel不是预先配置的。topic在首次使用时创建，方法是将其发布到指定topic，或者订阅指定topic上的channel。channel是通过订阅指定的channel在第一次使用时创建的。\ntopic和channel都相互独立地缓冲数据，防止缓慢的消费者导致其他chennel的积压（同样适用于topic级别）。\nchannel可以并且通常会连接多个客户端。假设所有连接的客户端都处于准备接收消息的状态，则每条消息将被传递到随机客户端。\n生产者向某个topic中发送消息，如果topic有一个或者多个channel，那么该消息会被复制多分发送到每一个channel中。类似 rabbitmq中的fanout类型，channel类似队列。 官方说 nsq 是分布式的消息队列服务，但是在我看来只有channel到消费者这部分提现出来分布式的感觉，nsqd 这个模块其实就是单点的，nsqd 将 topic、channel、以及消息都存储在了本地磁盘，官方还建议一个生产者使用一个 nsqd，这样不仅浪费资源还没有数据备份的保障。一旦 nsqd 所在的主机磁损坏，数据都将丢失。 总而言之,消息是从topic--\u0026gt; channel (每个channel接受该topic的所有消息的副本)多播的,但是从channel --\u0026gt; consumers均匀分布 (每个消费者接受该channel的一部分消息) ","permalink":"https://gopherding.github.io/posts/tech/nsq%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/","summary":"\u003cp\u003e本文摘自：\u003ca href=\"https://www.cnblogs.com/you-men/p/13884645.html\"\u003ehttps://www.cnblogs.com/you-men/p/13884645.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e同时参考了：\u003ca href=\"https://zhuanlan.zhihu.com/p/37081073\"\u003ehttps://zhuanlan.zhihu.com/p/37081073\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ensqd:\u003c/code\u003e 是一个进程监听了http,tcp两种协议, 用来创建topic,channel, 分发消息给消费者,向nsqlooup 注册自己的元数据信息(topic、channel、consumer)，自己的服务信息，最核心模块。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ensqd 是一个守护进程，负责接收，排队，投递消息给客户端。也就是说这个服务是干活的。它可以独立运行，不过通常它是由 nsqlookupd 实例所在集群配置的。\u003c/p\u003e","title":"NSQ组件介绍"},{"content":" 架构设计 Kafka 分布式架构的分层结构：Kafka 具有高度分布式的架构，包含生产者（Producer）、消费者（Consumer）、Broker（服务器节点）和 Zookeeper（用于管理集群配置、选举等元数据）。生产者将消息发送到 Broker，消费者从 Broker 获取消息。其中，Broker 采用分区（Partition）机制，每个主题（Topic）可以被划分为多个分区，消息被均匀地分配到这些分区中进行存储和处理。 集群协调机制：依赖 Zookeeper 进行集群协调，如 Broker 的状态管理、领导者选举等。例如，当一个 Broker 出现故障时，Zookeeper 能够协助重新选举领导者，以确保集群的正常运行。 NSQ 简单的分布式消息传递组件：NSQ 主要由生产者、消费者和 NSQ 守护进程（nsqd）组成。生产者将消息发送到 nsqd，nsqd 负责存储和转发消息给消费者。它没有像 Kafka 那样依赖额外的组件进行集群协调。 基于内存和磁盘的存储方式：nsqd 将消息先存储在内存队列中，然后定期将消息刷写到磁盘上进行持久化。这种方式相对 Kafka 分区存储的概念更为简单直接。 消息传递语义 Kafka 支持多种消息传递语义： 最多一次（At - Most - Once）：消息可能会丢失，适用于对数据准确性要求不高的场景，如日志收集的某些情况，因为即使部分日志消息丢失，对整体日志分析影响不大。 最少一次（At - Least - Once）：消息不会丢失，但可能会被重复处理。例如，在一些数据采集场景中，即使消息被重复处理，只要最终数据完整即可。 精确一次（Exactly - Once）：通过事务机制和幂等性消费等手段，确保消息既不丢失也不重复处理，在金融交易数据传输等对准确性要求极高的场景中有重要意义。 消息顺序保证：在每个分区内，消息是有序的。如果要保证消息在整个主题上的顺序，需要将主题设置为单分区，但这会影响可扩展性。 NSQ 以最少一次（At - Least - Once）为主：通过重传机制确保消息不会丢失，但可能会导致消息重复处理，在消息处理失败（如消费者崩溃）时会将消息重新放入队列等待重新处理。 消息顺序保证：在 NSQ 守护进程中的每个分区（Topic 中的分区）内消息是按顺序存储的，消费者通过有序消费和确认机制来保证消息顺序，但在分布式环境下整体顺序保证相对复杂。 性能和扩展性 Kafka 高吞吐量和低延迟：Kafka 设计用于处理大规模数据的高效传输。其分区机制和批量处理的特性使得它能够在高并发场景下实现高吞吐量，例如在大数据分析场景中，可以处理海量的日志数据传输。同时，它也能保持较低的延迟，满足实时性要求较高的应用场景。 水平扩展性强：通过增加 Broker 节点和分区数量，可以轻松扩展集群的处理能力。新的 Broker 可以加入集群分担负载，并且可以动态调整分区数量来适应数据增长。 NSQ 中等吞吐量和延迟特性：NSQ 的性能适用于一般规模的消息处理场景。它的内存队列和磁盘持久化机制在处理消息时相对简单，性能上不如 Kafka 在大规模数据传输时那么高效，但在中小规模场景下能够满足需求。 扩展性相对有限：虽然可以增加 nsqd 的数量来扩展，但在集群协调和整体架构的复杂性方面，不如 Kafka 那样易于大规模扩展。 数据持久化和可靠性 Kafka 可靠的持久化机制：消息被持久化到磁盘上的日志文件中，并且通过多副本（Replica）机制来确保数据的可靠性。每个分区可以有多个副本分布在不同的 Broker 上，当一个 Broker 故障时，其他副本可以继续提供服务，保证数据不丢失。 数据保留策略：可以根据时间或者消息大小等设置数据保留策略，例如可以设置只保留最近 7 天的消息或者当消息总量达到一定大小后开始删除旧消息。 NSQ 内存与磁盘结合的持久化：如前面所述，先将消息存储在内存队列中，再定期刷写到磁盘。这种方式在一定程度上确保了数据的持久性，但相对 Kafka 的多副本磁盘持久化，在可靠性方面可能稍逊一筹。 重传机制保障数据不丢失：通过重传机制确保消息在处理过程中不会因为消费者故障等原因丢失，但在磁盘故障等极端情况下，数据的恢复能力可能不如 Kafka。 应用场景 Kafka 大数据处理和日志系统：由于其高吞吐量、可扩展性和多种消息传递语义，非常适合大数据分析中的数据采集、日志收集与传输等场景。例如在大型互联网公司中收集服务器的日志数据，然后进行分布式处理和分析。 实时流处理：也适用于实时流处理场景，如实时监控数据的传输和分析，能够在保证低延迟的同时处理大量的实时数据。 NSQ 中小规模消息处理：适用于对吞吐量要求不是特别高的中小规模消息处理场景，如一些内部业务系统中的简单消息通知、任务队列等。例如在一个小型电商公司内部，用于订单状态更新通知等场景。 ","permalink":"https://gopherding.github.io/posts/tech/nsq%E5%92%8Ckafka%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/","summary":"\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"架构设计\"\u003e架构设计\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"kafka\"\u003eKafka\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e分布式架构的分层结构\u003c/strong\u003e：Kafka 具有高度分布式的架构，包含生产者（Producer）、消费者（Consumer）、Broker（服务器节点）和 Zookeeper（用于管理集群配置、选举等元数据）。生产者将消息发送到 Broker，消费者从 Broker 获取消息。其中，Broker 采用分区（Partition）机制，每个主题（Topic）可以被划分为多个分区，消息被均匀地分配到这些分区中进行存储和处理。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e集群协调机制\u003c/strong\u003e：依赖 Zookeeper 进行集群协调，如 Broker 的状态管理、领导者选举等。例如，当一个 Broker 出现故障时，Zookeeper 能够协助重新选举领导者，以确保集群的正常运行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"nsq\"\u003eNSQ\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e简单的分布式消息传递组件\u003c/strong\u003e：NSQ 主要由生产者、消费者和 NSQ 守护进程（nsqd）组成。生产者将消息发送到 nsqd，nsqd 负责存储和转发消息给消费者。它没有像 Kafka 那样依赖额外的组件进行集群协调。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e基于内存和磁盘的存储方式\u003c/strong\u003e：nsqd 将消息先存储在内存队列中，然后定期将消息刷写到磁盘上进行持久化。这种方式相对 Kafka 分区存储的概念更为简单直接。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"消息传递语义\"\u003e消息传递语义\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"kafka-1\"\u003eKafka\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e支持多种消息传递语义：\n\u003cul\u003e\n\u003cli\u003e最多一次（At - Most - Once）：消息可能会丢失，适用于对数据准确性要求不高的场景，如日志收集的某些情况，因为即使部分日志消息丢失，对整体日志分析影响不大。\u003c/li\u003e\n\u003cli\u003e最少一次（At - Least - Once）：消息不会丢失，但可能会被重复处理。例如，在一些数据采集场景中，即使消息被重复处理，只要最终数据完整即可。\u003c/li\u003e\n\u003cli\u003e精确一次（Exactly - Once）：通过事务机制和幂等性消费等手段，确保消息既不丢失也不重复处理，在金融交易数据传输等对准确性要求极高的场景中有重要意义。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e消息顺序保证\u003c/strong\u003e：在每个分区内，消息是有序的。如果要保证消息在整个主题上的顺序，需要将主题设置为单分区，但这会影响可扩展性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"nsq-1\"\u003eNSQ\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e以最少一次（At - Least - Once）为主\u003c/strong\u003e：通过重传机制确保消息不会丢失，但可能会导致消息重复处理，在消息处理失败（如消费者崩溃）时会将消息重新放入队列等待重新处理。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e消息顺序保证\u003c/strong\u003e：在 NSQ 守护进程中的每个分区（Topic 中的分区）内消息是按顺序存储的，消费者通过有序消费和确认机制来保证消息顺序，但在分布式环境下整体顺序保证相对复杂。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"性能和扩展性\"\u003e性能和扩展性\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"kafka-2\"\u003eKafka\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e高吞吐量和低延迟\u003c/strong\u003e：Kafka 设计用于处理大规模数据的高效传输。其分区机制和批量处理的特性使得它能够在高并发场景下实现高吞吐量，例如在大数据分析场景中，可以处理海量的日志数据传输。同时，它也能保持较低的延迟，满足实时性要求较高的应用场景。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e水平扩展性强\u003c/strong\u003e：通过增加 Broker 节点和分区数量，可以轻松扩展集群的处理能力。新的 Broker 可以加入集群分担负载，并且可以动态调整分区数量来适应数据增长。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"nsq-2\"\u003eNSQ\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e中等吞吐量和延迟特性\u003c/strong\u003e：NSQ 的性能适用于一般规模的消息处理场景。它的内存队列和磁盘持久化机制在处理消息时相对简单，性能上不如 Kafka 在大规模数据传输时那么高效，但在中小规模场景下能够满足需求。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e扩展性相对有限\u003c/strong\u003e：虽然可以增加 nsqd 的数量来扩展，但在集群协调和整体架构的复杂性方面，不如 Kafka 那样易于大规模扩展。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"数据持久化和可靠性\"\u003e数据持久化和可靠性\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"kafka-3\"\u003eKafka\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e可靠的持久化机制\u003c/strong\u003e：消息被持久化到磁盘上的日志文件中，并且通过多副本（Replica）机制来确保数据的可靠性。每个分区可以有多个副本分布在不同的 Broker 上，当一个 Broker 故障时，其他副本可以继续提供服务，保证数据不丢失。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据保留策略\u003c/strong\u003e：可以根据时间或者消息大小等设置数据保留策略，例如可以设置只保留最近 7 天的消息或者当消息总量达到一定大小后开始删除旧消息。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"nsq-3\"\u003eNSQ\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e内存与磁盘结合的持久化\u003c/strong\u003e：如前面所述，先将消息存储在内存队列中，再定期刷写到磁盘。这种方式在一定程度上确保了数据的持久性，但相对 Kafka 的多副本磁盘持久化，在可靠性方面可能稍逊一筹。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e重传机制保障数据不丢失\u003c/strong\u003e：通过重传机制确保消息在处理过程中不会因为消费者故障等原因丢失，但在磁盘故障等极端情况下，数据的恢复能力可能不如 Kafka。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"应用场景\"\u003e应用场景\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"kafka-4\"\u003eKafka\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e大数据处理和日志系统\u003c/strong\u003e：由于其高吞吐量、可扩展性和多种消息传递语义，非常适合大数据分析中的数据采集、日志收集与传输等场景。例如在大型互联网公司中收集服务器的日志数据，然后进行分布式处理和分析。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实时流处理\u003c/strong\u003e：也适用于实时流处理场景，如实时监控数据的传输和分析，能够在保证低延迟的同时处理大量的实时数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"nsq-4\"\u003eNSQ\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e中小规模消息处理\u003c/strong\u003e：适用于对吞吐量要求不是特别高的中小规模消息处理场景，如一些内部业务系统中的简单消息通知、任务队列等。例如在一个小型电商公司内部，用于订单状态更新通知等场景。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"NSQ和kafka的技术选型"},{"content":"City of stars\nAre you shining just for me\nCity of stars\nThere’s so much that I can’t see\nWho knows\nI felt it from the first embrace I shared with you\nThat now our dreams\nThey’ve finally come true\nCity of stars\nJust one thing everybody wants\nThere in the bars\nAnd through the smokescreen of the crowded restaurants\nIt’s love\nYes all we’re looking for is love from someone else\nA rush\nA glance\nA touch\nA dance\nA look in somebody’s eyes\nTo light up the skies\nTo open the world and send it reeling\nA voice that says “I’ll be here”\nAnd “you’ll be alright”\nI don’t care if I know\nJust where I will go\n‘Cause all that I need is this crazy feeling\nA rat-tat-tat on my heart\nThink I want it to stay\nCity of stars\nAre you shining just for me\nCity of stars\nYou never shined so brightly\n","permalink":"https://gopherding.github.io/posts/read/city-of-stars_la-la-land/","summary":"\u003cp\u003eCity of stars\u003c/p\u003e\n\u003cp\u003eAre you shining just for me\u003c/p\u003e\n\u003cp\u003eCity of stars\u003c/p\u003e\n\u003cp\u003eThere’s so much that I can’t see\u003c/p\u003e\n\u003cp\u003eWho knows\u003c/p\u003e\n\u003cp\u003eI felt it from the first embrace I shared with you\u003c/p\u003e\n\u003cp\u003eThat now our dreams\u003c/p\u003e\n\u003cp\u003eThey’ve finally come true\u003c/p\u003e\n\u003cp\u003eCity of stars\u003c/p\u003e\n\u003cp\u003eJust one thing everybody wants\u003c/p\u003e\n\u003cp\u003eThere in the bars\u003c/p\u003e\n\u003cp\u003eAnd through the smokescreen of the crowded restaurants\u003c/p\u003e\n\u003cp\u003eIt’s love\u003c/p\u003e\n\u003cp\u003eYes all we’re looking for is love from someone else\u003c/p\u003e\n\u003cp\u003eA rush\u003c/p\u003e\n\u003cp\u003eA glance\u003c/p\u003e\n\u003cp\u003eA touch\u003c/p\u003e\n\u003cp\u003eA dance\u003c/p\u003e\n\u003cp\u003eA look in somebody’s eyes\u003c/p\u003e\n\u003cp\u003eTo light up the skies\u003c/p\u003e\n\u003cp\u003eTo open the world and send it reeling\u003c/p\u003e\n\u003cp\u003eA voice that says “I’ll be here”\u003c/p\u003e","title":"City of Stars_La La Land"},{"content":"矛盾论 （一九三七年八月）\n这篇哲学论文，是毛泽东继《实践论》之后，为了同一的目的，即为了克服存在于中国共产党内的严重的教条主义思想而写的，曾在延安的抗日军事政治大学作过讲演。在收入本书第一版的时候，作者作了部分的补充、删节和修改。\n事物的矛盾法则，即对立统一的法则，是唯物辩证法的最根本的法则。列宁说：“就本来的意义讲，辩证法是研究对象的本质自身中的矛盾。”[1]列宁常称这个法则为辩证法的本质，又称之为辩证法的核心[2]。因此，我们在研究这个法则时，不得不涉及广泛的方面，不得不涉及许多的哲学问题。如果我们将这些问题都弄清楚了，我们就在根本上懂得了唯物辩证法。这些问题是：两种宇宙观；矛盾的普遍性；矛盾的特殊性；主要的矛盾和主要的矛盾方面；矛盾诸方面的同一性和斗争性；对抗在矛盾中的地位。 苏联哲学界在最近数年中批判了德波林学派[3]的唯心论，这件事引起了我们的极大的兴趣。德波林的唯心论在中国共产党内发生了极坏的影响，我们党内的教条主义思想不能说和这个学派的作风没有关系。因此，我们现在的哲学研究工作，应当以扫除教条主义思想为主要的目标。\n一　两种宇宙观 在人类的认识史中，从来就有关于宇宙发展法则的两种见解，一种是形而上学的见解，一种是辩证法的见解，形成了互相对立的两种宇宙观。列宁说：“对于发展（进化）所持的两种基本的（或两种可能的？或两种在历史上常见的？）观点是：（一）认为发展是减少和增加，是重复；（二）认为发展是对立的统一（统一物分成为两个互相排斥的对立，而两个对立又互相关联着）。”[4]列宁说的就是这两种不同的宇宙观。 形而上学，亦称玄学。这种思想，无论在中国，在欧洲，在一个很长的历史时间内，是属于唯心论的宇宙观，并在人们的思想中占了统治的地位。在欧洲，资产阶级初期的唯物论，也是形而上学的。由于欧洲许多国家的社会经济情况进到了资本主义高度发展的阶段，生产力、阶级斗争和科学均发展到了历史上未有过的水平，工业无产阶级成为历史发展的最伟大的动力，因而产生了马克思主义的唯物辩证法的宇宙观。于是，在资产阶级那里，除了公开的极端露骨的反动的唯心论之外，还出现了庸俗的进化论，出来对抗唯物辩证法。 所谓形而上学的或庸俗进化论的宇宙观，就是用孤立的、静止的和片面的观点去看世界。这种宇宙观把世界一切事物，一切事物的形态和种类，都看成是永远彼此孤立和永远不变化的。如果说有变化，也只是数量的增减和场所的变更。而这种增减和变更的原因，不在事物的内部而在事物的外部，即是由于外力的推动。形而上学家认为，世界上各种不同事物和事物的特性，从它们一开始存在的时候就是如此。后来的变化，不过是数量上的扩大或缩小。他们认为一种事物永远只能反复地产生为同样的事物，而不能变化为另一种不同的事物。在形而上学家看来，资本主义的剥削，资本主义的竞争，资本主义社会的个人主义思想等，就是在古代的奴隶社会里，甚至在原始社会里，都可以找得出来，而且会要永远不变地存在下去。说到社会发展的原因，他们就用社会外部的地理、气候等条件去说明。他们简单地从事物外部去找发展的原因，否认唯物辩证法所主张的事物因内部矛盾引起发展的学说。因此，他们不能解释事物的质的多样性，不能解释一种质变为他种质的现象。这种思想，在欧洲，在十七世纪和十八世纪是机械唯物论，在十九世纪末和二十世纪初则有庸俗进化论。在中国，则有所谓“天不变，道亦不变”[5]的形而上学的思想，曾经长期地为腐朽了的封建统治阶级所拥护。近百年来输入了欧洲的机械唯物论和庸俗进化论，则为资产阶级所拥护。 和形而上学的宇宙观相反，唯物辩证法的宇宙观主张从事物的内部、从一事物对他事物的关系去研究事物的发展，即把事物的发展看做是事物内部的必然的自己的运动，而每一事物的运动都和它的周围其它事物互相联系着和互相影响着。事物发展的根本原因，不是在事物的外部而是在事物的内部，在于事物内部的矛盾性。任何事物内部都有这种矛盾性，因此引起了事物的运动和发展。事物内部的这种矛盾性是事物发展的根本原因，一事物和他事物的互相联系和互相影响则是事物发展的第二位的原因。这样，唯物辩证法就有力地反对了形而上学的机械唯物论和庸俗进化论的外因论或被动论。这是清楚的，单纯的外部原因只能引起事物的机械的运动，即范围的大小，数量的增减，不能说明事物何以有性质上的千差万别及其互相变化。事实上，即使是外力推动的机械运动，也要通过事物内部的矛盾性。植物和动物的单纯的增长，数量的发展，主要地也是由于内部矛盾所引起的。同样，社会的发展，主要地不是由于外因而是由于内因。许多国家在差不多一样的地理和气候的条件下，它们发展的差异性和不平衡性，非常之大。同一个国家吧，在地理和气候并没有变化的情形下，社会的变化却是很大的。帝国主义的俄国变为社会主义的苏联，封建的闭关锁国的日本变为帝国主义的日本，这些国家的地理和气候并没有变化。长期地被封建制度统治的中国，近百年来发生了很大的变化，现在正在变化到一个自由解放的新中国的方向去，中国的地理和气候并没有变化。整个地球及地球各部分的地理和气候也是变化着的，但以它们的变化和社会的变化相比较，则显得很微小，前者是以若干万年为单位而显现其变化的，后者则在几千年、几百年、几十年、甚至几年或几个月（在革命时期）内就显现其变化了。按照唯物辩证法的观点，自然界的变化，主要地是由于自然界内部矛盾的发展。社会的变化，主要地是由于社会内部矛盾的发展，即生产力和生产关系的矛盾，阶级之间的矛盾，新旧之间的矛盾，由于这些矛盾的发展，推动了社会的前进，推动了新旧社会的代谢。唯物辩证法是否排除外部的原因呢？并不排除。唯物辩证法认为外因是变化的条件，内因是变化的根据，外因通过内因而起作用。鸡蛋因得适当的温度而变化为鸡子，但温度不能使石头变为鸡子，因为二者的根据是不同的。各国人民之间的互相影响是时常存在的。在资本主义时代，特别是在帝国主义和无产阶级革命的时代，各国在政治上、经济上和文化上的互相影响和互相激动，是极其巨大的。十月社会主义革命不只是开创了俄国历史的新纪元，而且开创了世界历史的新纪元，影响到世界各国内部的变化，同样地而且还特别深刻地影响到中国内部的变化，但是这种变化是通过了各国内部和中国内部自己的规律性而起的。两军相争，一胜一败，所以胜败，皆决于内因。胜者或因其强，或因其指挥无误，败者或因其弱，或因其指挥失宜，外因通过内因而引起作用。一九二七年中国大资产阶级战败了无产阶级，是通过中国无产阶级内部的（中国共产党内部的）机会主义而起作用的。当着我们清算了这种机会主义的时候，中国革命就重新发展了。后来，中国革命又受了敌人的严重的打击，是因为我们党内产生了冒险主义。当着我们清算了这种冒险主义的时候，我们的事业就又重新发展了。由此看来，一个政党要引导革命到胜利，必须依靠自己政治路线的正确和组织上的巩固。 辩证法的宇宙观，不论在中国，在欧洲，在古代就产生了。但是古代的辩证法带着自发的朴素的性质，根据当时的社会历史条件，还不可能有完备的理论，因而不能完全解释宇宙，后来就被形而上学所代替。生活在十八世纪末和十九世纪初期的德国著名哲学家黑格尔，对于辩证法曾经给了很重要的贡献，但是他的辩证法却是唯心的辩证法。直到无产阶级运动的伟大的活动家马克思和恩格斯综合了人类认识史的积极的成果，特别是批判地吸取了黑格尔的辩证法的合理的部分，创造了辩证唯物论和历史唯物论这个伟大的理论，才在人类认识史上起了一个空前的大革命。后来，经过列宁和斯大林，又发展了这个伟大的理论。这个理论一经传到中国来，就在中国思想界引起了极大的变化。 这个辩证法的宇宙观，主要地就是教导人们要善于去观察和分析各种事物的矛盾的运动，并根据这种分析，指出解决矛盾的方法。因此，具体地了解事物矛盾这一个法则，对于我们是非常重要的。\n二　矛盾的普遍性 为了叙述的便利起见，我在这里先说矛盾的普遍性，再说矛盾的特殊性。这是因为马克思主义的伟大的创造者和继承者马克思、恩格斯、列宁、斯大林他们发现了唯物辩证法的宇宙观，已经把唯物辩证法应用在人类历史的分析和自然历史的分析的许多方面，应用在社会的变革和自然的变革（例如在苏联）的许多方面，获得了极其伟大的成功，矛盾的普遍性已经被很多人所承认，因此，关于这个问题只需要很少的话就可以说明白；而关于矛盾的特殊性的问题，则还有很多的同志，特别是教条主义者，弄不清楚。他们不了解矛盾的普遍性即寓于矛盾的特殊性之中。他们也不了解研究当前具体事物的矛盾的特殊性，对于我们指导革命实践的发展有何等重要的意义。因此，关于矛盾的特殊性的问题应当着重地加以研究，并用足够的篇幅加以说明。为了这个缘故，当着我们分析事物矛盾的法则的时候，我们就先来分析矛盾的普遍性的问题，然后再着重地分析矛盾的特殊性的问题，最后仍归到矛盾的普遍性的问题。 矛盾的普遍性或绝对性这个问题有两方面的意义。其一是说，矛盾存在于一切事物的发展过程中；其二是说，每一事物的发展过程中存在着自始至终的矛盾运动。 恩格斯说：“运动本身就是矛盾。”[6]列宁对于对立统一法则所下的定义，说它就是“承认（发现）自然界（精神和社会两者也在内）的一切现象和过程都含有互相矛盾、互相排斥、互相对立的趋向”[7]。这些意见是对的吗？是对的。一切事物中包含的矛盾方面的相互依赖和相互斗争，决定一切事物的生命，推动一切事物的发展。没有什么事物是不包含矛盾的，没有矛盾就没有世界。 矛盾是简单的运动形式（例如机械性的运动）的基础，更是复杂的运动形式的基础。 恩格斯这样说明过矛盾的普遍性：“如果简单的机械的移动本身包含着矛盾，那末，物质的更高的运动形式，特别是有机生命及其发展，就更加包含着矛盾。……生命首先就在于：生物在每一个瞬间是它自身，但却又是别的什么。所以，生命也是存在于物体和过程本身中的不断地自行产生并自行解决的矛盾；这一矛盾一停止，生命亦即停止，于是死就来到。同样，我们看到了，在思维的范围以内我们也不能避免矛盾，并且我们看到了，例如，人的内部无限的认识能力与此种认识能力仅在外部被局限的而且认识上也被局限的个别人们身上的实际的实现二者之间的矛盾，是在人类世代的无穷的——至少对于我们，实际上是无穷的——连续系列之中，是在无穷的前进运动之中解决的。” “高等数学的主要基础之一，就是矛盾……” “就是初等数学，也充满着矛盾。……”[8] 列宁也这样说明过矛盾的普遍性：“在数学中，正和负，微分和积分。 在力学中，作用和反作用。 在物理学中，阳电和阴电。 在化学中，原子的化合和分解。 在社会科学中，阶级斗争。”[9] 战争中的攻守，进退，胜败，都是矛盾着的现象。失去一方，他方就不存在。双方斗争而又联结，组成了战争的总体，推动了战争的发展，解决了战争的问题。 人的概念的每一差异，都应把它看作是客观矛盾的反映。客观矛盾反映入主观的思想，组成了概念的矛盾运动，推动了思想的发展，不断地解决了人们的思想问题。 党内不同思想的对立和斗争是经常发生的，这是社会的阶级矛盾和新旧事物的矛盾在党内的反映。党内如果没有矛盾和解决矛盾的思想斗争，党的生命也就停止了。 由此看来，不论是简单的运动形式，或复杂的运动形式，不论是客观现象，或思想现象，矛盾是普遍地存在着，矛盾存在于一切过程中，这一点已经弄清楚了。但是每一过程的开始阶段，是否也有矛盾存在呢？是否每一事物的发展过程具有自始至终的矛盾运动呢？ 从苏联哲学界批判德波林学派的文章中看出，德波林学派有这样一种见解，他们认为矛盾不是一开始就在过程中出现，须待过程发展到一定的阶段才出现。那末，在那一时间以前，过程发展的原因不是由于内部的原因，而是由于外部的原因了。这样，德波林回到形而上学的外因论和机械论去了。拿这种见解去分析具体的问题，他们就看见在苏联条件下富农和一般农民之间只有差异，并无矛盾，完全同意了布哈林的意见。在分析法国革命时，他们就认为在革命前，工农资产阶级合组的第三等级中，也只有差异，并无矛盾。德波林学派这类见解是反马克思主义的。他们不知道世界上的每一差异中就已经包含着矛盾，差异就是矛盾。劳资之间，从两阶级发生的时候起，就是互相矛盾的，仅仅还没有激化而已。工农之间，即使在苏联的社会条件下，也有差异，它们的差异就是矛盾，仅仅不会激化成为对抗，不取阶级斗争的形态，不同于劳资间的矛盾；它们在社会主义建设中形成巩固的联盟，并在由社会主义走向共产主义的发展过程中逐渐地解决这个矛盾。这是矛盾的差别性的问题，不是矛盾的有无的问题。矛盾是普遍的、绝对的，存在于事物发展的一切过程中，又贯串于一切过程的始终。 新过程的发生是什么呢？这是旧的统一和组成此统一的对立成分让位于新的统一和组成此统一的对立成分，于是新过程就代替旧过程而发生。旧过程完结了，新过程发生了。新过程又包含着新矛盾，开始它自己的矛盾发展史。 事物发展过程的自始至终的矛盾运动，列宁指出马克思在《资本论》中模范地作了这样的分析。这是研究任何事物发展过程所必须应用的方法。列宁自己也正确地应用了它，贯彻于他的全部著作中。 “马克思在《资本论》中，首先分析的是资产阶级社会（商品社会）里最简单的、最普通的、最基本的、最常见的、最平常的、碰到亿万次的关系——商品交换。这一分析在这个最简单的现象之中（资产阶级社会的这个‘细胞’之中）暴露了现代社会的一切矛盾（以及一切矛盾的胚芽）。往后的叙述又向我们表明了这些矛盾和这个社会各个部分总和的自始至终的发展（增长与运动两者）。” 列宁说了上面的话之后，接着说道：“这应该是一般辩证法的……叙述（以及研究）方法。”[10] 中国共产党人必须学会这个方法，才能正确地分析中国革命的历史和现状，并推断革命的将来。\n三　矛盾的特殊性 矛盾存在于一切事物发展的过程中，矛盾贯串于每一事物发展过程的始终，这是矛盾的普遍性和绝对性，前面已经说过了。现在来说矛盾的特殊性和相对性。 这个问题，应从几种情形中去研究。 首先是各种物质运动形式中的矛盾，都带特殊性。人的认识物质，就是认识物质的运动形式，因为除了运动的物质以外，世界上什么也没有，而物质的运动则必取一定的形式。对于物质的每一种运动形式，必须注意它和其它各种运动形式的共同点。但是，尤其重要的，成为我们认识事物的基础的东西，则是必须注意它的特殊点，就是说，注意它和其它运动形式的质的区别。只有注意了这一点，才有可能区别事物。任何运动形式，其内部都包含着本身特殊的矛盾。这种特殊的矛盾，就构成一事物区别于他事物的特殊的本质。这就是世界上诸种事物所以有千差万别的内在的原因，或者叫做根据。自然界存在着许多的运动形式，机械运动、发声、发光、发热、电流、化分、化合等等都是。所有这些物质的运动形式，都是互相依存的，又是本质上互相区别的。每一物质的运动形式所具有的特殊的本质，为它自己的特殊的矛盾所规定。这种情形，不但在自然界中存在着，在社会现象和思想现象中也是同样地存在着。每一种社会形式和思想形式，都有它的特殊的矛盾和特殊的本质。 科学研究的区分，就是根据科学对象所具有的特殊的矛盾性。因此，对于某一现象的领域所特有的某一种矛盾的研究，就构成某一门科学的对象。例如，数学中的正数和负数，机械学中的作用和反作用，物理学中的阴电和阳电，化学中的化分和化合，社会科学中的生产力和生产关系、阶级和阶级的互相斗争，军事学中的攻击和防御，哲学中的唯心论和唯物论、形而上学观和辩证法观等等，都是因为具有特殊的矛盾和特殊的本质，才构成了不同的科学研究的对象。固然，如果不认识矛盾的普遍性，就无从发现事物运动发展的普遍的原因或普遍的根据；但是，如果不研究矛盾的特殊性，就无从确定一事物不同于他事物的特殊的本质，就无从发现事物运动发展的特殊的原因，或特殊的根据，也就无从辨别事物，无从区分科学研究的领域。 就人类认识运动的秩序说来，总是由认识个别的和特殊的事物，逐步地扩大到认识一般的事物。人们总是首先认识了许多不同事物的特殊的本质，然后才有可能更进一步地进行概括工作，认识诸种事物的共同的本质。当着人们已经认识了这种共同的本质以后，就以这种共同的认识为指导，继续地向着尚未研究过的或者尚未深入地研究过的各种具体的事物进行研究，找出其特殊的本质，这样才可以补充、丰富和发展这种共同的本质的认识，而使这种共同的本质的认识不致变成枯槁的和僵死的东西。这是两个认识的过程：一个是由特殊到一般，一个是由一般到特殊。人类的认识总是这样循环往复地进行的，而每一次的循环（只要是严格地按照科学的方法）都可能使人类的认识提高一步，使人类的认识不断地深化。我们的教条主义者在这个问题上的错误，就是，一方面，不懂得必须研究矛盾的特殊性，认识各别事物的特殊的本质，才有可能充分地认识矛盾的普遍性，充分地认识诸种事物的共同的本质；另一方面，不懂得在我们认识了事物的共同的本质以后，还必须继续研究那些尚未深入地研究过的或者新冒出来的具体的事物。我们的教条主义者是懒汉，他们拒绝对于具体事物做任何艰苦的研究工作，他们把一般真理看成是凭空出现的东西，把它变成为人们所不能够捉摸的纯粹抽象的公式，完全否认了并且颠倒了这个人类认识真理的正常秩序。他们也不懂得人类认识的两个过程的互相联结——由特殊到一般，又由一般到特殊，他们完全不懂得马克思主义的认识论。 不但要研究每一个大系统的物质运动形式的特殊的矛盾性及其所规定的本质，而且要研究每一个物质运动形式在其发展长途中的每一个过程的特殊的矛盾及其本质。一切运动形式的每一个实在的非臆造的发展过程内，都是不同质的。我们的研究工作必须着重这一点，而且必须从这一点开始。 不同质的矛盾，只有用不同质的方法才能解决。例如，无产阶级和资产阶级的矛盾，用社会主义革命的方法去解决；人民大众和封建制度的矛盾，用民主革命的方法去解决；殖民地和帝国主义的矛盾，用民族革命战争的方法去解决；在社会主义社会中工人阶级和农民阶级的矛盾，用农业集体化和农业机械化的方法去解决；共产党内的矛盾，用批评和自我批评的方法去解决；社会和自然的矛盾，用发展生产力的方法去解决。过程变化，旧过程和旧矛盾消灭，新过程和新矛盾发生，解决矛盾的方法也因之而不同。俄国的二月革命和十月革命所解决的矛盾及其所用以解决矛盾的方法是根本上不相同的。用不同的方法去解决不同的矛盾，这是马克思列宁主义者必须严格地遵守的一个原则。教条主义者不遵守这个原则，他们不了解诸种革命情况的区别，因而也不了解应当用不同的方法去解决不同的矛盾，而只是千篇一律地使用一种自以为不可改变的公式到处硬套，这就只能使革命遭受挫折，或者将本来做得好的事情弄得很坏。 为要暴露事物发展过程中的矛盾在其总体上、在其相互联结上的特殊性，就是说暴露事物发展过程的本质，就必须暴露过程中矛盾各方面的特殊性，否则暴露过程的本质成为不可能，这也是我们作研究工作时必须十分注意的。 一个大的事物，在其发展过程中，包含着许多的矛盾。例如，在中国资产阶级民主革命过程中，有中国社会各被压迫阶级和帝国主义的矛盾，有人民大众和封建制度的矛盾，有无产阶级和资产阶级的矛盾，有农民及城市小资产阶级和资产阶级的矛盾，有各个反动的统治集团之间的矛盾等等，情形是非常复杂的。这些矛盾，不但各各有其特殊性，不能一律看待，而且每一矛盾的两方面，又各各有其特点，也是不能一律看待的。我们从事中国革命的人，不但要在各个矛盾的总体上，即矛盾的相互联结上，了解其特殊性，而且只有从矛盾的各个方面着手研究，才有可能了解其总体。所谓了解矛盾的各个方面，就是了解它们每一方面各占何等特定的地位，各用何种具体形式和对方发生互相依存又互相矛盾的关系，在互相依存又互相矛盾中，以及依存破裂后，又各用何种具体的方法和对方作斗争。研究这些问题，是十分重要的事情。列宁说：马克思主义的最本质的东西，马克思主义的活的灵魂，就在于具体地分析具体的情况[11]。就是说的这个意思。我们的教条主义者违背列宁的指示，从来不用脑筋具体地分析任何事物，做起文章或演说来，总是空洞无物的八股调，在我们党内造成了一种极坏的作风。 研究问题，忌带主观性、片面性和表面性。所谓主观性，就是不知道客观地看问题，也就是不知道用唯物的观点去看问题。这一点，我在《实践论》一文中已经说过了。所谓片面性，就是不知道全面地看问题。例如：只了解中国一方、不了解日本一方，只了解共产党一方、不了解国民党一方，只了解无产阶级一方、不了解资产阶级一方，只了解农民一方、不了解地主一方，只了解顺利情形一方、不了解困难情形一方，只了解过去一方、不了解将来一方，只了解个体一方、不了解总体一方，只了解缺点一方、不了解成绩一方，只了解原告一方、不了解被告一方，只了解革命的秘密工作一方、不了解革命的公开工作一方，如此等等。一句话，不了解矛盾各方的特点。这就叫做片面地看问题。或者叫做只看见局部，不看见全体，只看见树木，不看见森林。这样，是不能找出解决矛盾的方法的，是不能完成革命任务的，是不能做好所任工作的，是不能正确地发展党内的思想斗争的。孙子论军事说：“知彼知己，百战不殆。”[12]他说的是作战的双方。唐朝人魏征说过：“兼听则明，偏信则暗。”[13]也懂得片面性不对。可是我们的同志看问题，往往带片面性，这样的人就往往碰钉子。《水浒传》上宋江三打祝家庄[14]，两次都因情况不明，方法不对，打了败仗。后来改变方法，从调查情形入手，于是熟悉了盘陀路，拆散了李家庄、扈家庄和祝家庄的联盟，并且布置了藏在敌人营盘里的伏兵，用了和外国故事中所说木马计[15]相像的方法，第三次就打了胜仗。《水浒传》上有很多唯物辩证法的事例，这个三打祝家庄，算是最好的一个。列宁说：“要真正地认识对象，就必须把握和研究它的一切方面、一切联系和‘媒介’。我们决不会完全地作到这一点，可是要求全面性，将使我们防止错误，防止僵化。”[16]我们应该记得他的话。表面性，是对矛盾总体和矛盾各方的特点都不去看，否认深入事物里面精细地研究矛盾特点的必要，仅仅站在那里远远地望一望，粗枝大叶地看到一点矛盾的形相，就想动手去解决矛盾（答复问题、解决纠纷、处理工作、指挥战争）。这样的做法，没有不出乱子的。中国的教条主义和经验主义的同志们所以犯错误，就是因为他们看事物的方法是主观的、片面的和表面的。片面性、表面性也是主观性，因为一切客观事物本来是互相联系的和具有内部规律的，人们不去如实地反映这些情况，而只是片面地或表面地去看它们，不认识事物的互相联系，不认识事物的内部规律，所以这种方法是主观主义的。 不但事物发展的全过程中的矛盾运动，在其相互联结上，在其各方情况上，我们必须注意其特点，而且在过程发展的各个阶段中，也有其特点，也必须注意。 事物发展过程的根本矛盾及为此根本矛盾所规定的过程的本质，非到过程完结之日，是不会消灭的；但是事物发展的长过程中的各个发展的阶段，情形又往往互相区别。这是因为事物发展过程的根本矛盾的性质和过程的本质虽然没有变化，但是根本矛盾在长过程中的各个发展阶段上采取了逐渐激化的形式。并且，被根本矛盾所规定或影响的许多大小矛盾中，有些是激化了，有些是暂时地或局部地解决了，或者缓和了，又有些是发生了，因此，过程就显出阶段性来。如果人们不去注意事物发展过程中的阶段性，人们就不能适当地处理事物的矛盾。 例如，自由竞争时代的资本主义发展为帝国主义，这时，无产阶级和资产阶级这两个根本矛盾着的阶级的性质和这个社会的资本主义的本质，并没有变化；但是，两阶级的矛盾激化了，独占资本和自由资本之间的矛盾发生了，宗主国和殖民地的矛盾激化了，各资本主义国家间的矛盾即由各国发展不平衡的状态而引起的矛盾特别尖锐地表现出来了，因此形成了资本主义的特殊阶段，形成了帝国主义阶段。列宁主义之所以成为帝国主义和无产阶级革命时代的马克思主义，就是因为列宁和斯大林正确地说明了这些矛盾，并正确地作出了解决这些矛盾的无产阶级革命的理论和策略。 拿从辛亥革命[17]开始的中国资产阶级民主革命过程的情形来看，也有了若干特殊阶段。特别是在资产阶级领导时期的革命和在无产阶级领导时期的革命，区别为两个很大不同的历史阶段。这就是：由于无产阶级的领导，根本地改变了革命的面貌，引出了阶级关系的新调度，农民革命的大发动，反帝国主义和反封建主义的革命彻底性，由民主革命转变到社会主义革命的可能性，等等。所有这些，都是在资产阶级领导革命时期不可能出现的。虽然整个过程中根本矛盾的性质，过程之反帝反封建的民主革命的性质（其反面是半殖民地半封建的性质），并没有变化，但是，在这长时间中，经过了辛亥革命失败和北洋军阀统治，第一次民族统一战线的建立和一九二四年至一九二七年的革命，统一战线破裂和资产阶级转入反革命，新的军阀战争，土地革命战争，第二次民族统一战线建立和抗日战争等等大事变，二十多年间经过了几个发展阶段。在这些阶段中，包含着有些矛盾激化了（例如土地革命战争和日本侵入东北四省[18]），有些矛盾部分地或暂时地解决了（例如北洋军阀的被消灭，我们没收了地主的土地），有些矛盾重新发生了（例如新军阀之间的斗争，南方各革命根据地丧失后地主又重新收回土地）等等特殊的情形。 研究事物发展过程中的各个发展阶段上的矛盾的特殊性，不但必须在其联结上、在其总体上去看，而且必须从各个阶段中矛盾的各个方面去看。 例如国共两党。国民党方面，在第一次统一战线时期，因为它实行了孙中山的联俄、联共、援助工农的三大政策，所以它是革命的、有朝气的，它是各阶级的民主革命的联盟。一九二七年以后，国民党变到了与此相反的方面，成了地主和大资产阶级的反动集团。一九三六年十二月西安事变[19]后又开始向停止内战、联合共产党共同反对日本帝国主义这个方面转变。这就是国民党在三个阶段上的特点。形成这些特点，当然有种种的原因。中国共产党方面，在第一次统一战线时期，它是幼年的党，它英勇地领导了一九二四年至一九二七年的革命；但在对于革命的性质、任务和方法的认识方面，却表现了它的幼年性，因此在这次革命的后期所发生的陈独秀主义[20]能够起作用，使这次革命遭受了失败。一九二七年以后，它又英勇地领导了土地革命战争，创立了革命的军队和革命的根据地，但是它也犯过冒险主义的错误，使军队和根据地都受了很大的损失。一九三五年以后，它又纠正了冒险主义的错误，领导了新的抗日的统一战线，这个伟大的斗争现在正在发展。在这个阶段上，共产党是一个经过了两次革命的考验、有了丰富的经验的党。这些就是中国共产党在三个阶段上的特点。形成这些特点也有种种的原因。不研究这些特点，就不能了解两党在各个发展阶段上的特殊的相互关系：统一战线的建立，统一战线的破裂，再一个统一战线的建立。而要研究两党的种种特点，更根本的就必须研究这两党的阶级基础以及因此在各个时期所形成的它们和其它方面的矛盾的对立。例如，国民党在它第一次联合共产党的时期，一方面有和国外帝国主义的矛盾，因而它反对帝国主义；另一方面有和国内人民大众的矛盾，它在口头上虽然允许给予劳动人民以许多的利益，但在实际上则只给予很少的利益，或者简直什么也不给。在它进行反共战争的时期，则和帝国主义、封建主义合作反对人民大众，一笔勾销了人民大众原来在革命中所争得的一切利益，激化了它和人民大众的矛盾。现在抗日时期，国民党和日本帝国主义有矛盾，它一面要联合共产党，同时它对共产党和国内人民并不放松其斗争和压迫。共产党则无论在哪一时期，均和人民大众站在一道，反对帝国主义和封建主义；但在现在的抗日时期，由于国民党表示抗日，它对国民党和国内封建势力，也就采取了缓和的政策。由于这些情况，所以或者造成了两党的联合，或者造成了两党的斗争，而且即使在两党联合的时期也有又联合又斗争的复杂的情况。如果我们不去研究这些矛盾方面的特点，我们就不但不能了解这两个党各各和其它方面的关系，也不能了解两党之间的相互关系。 由此看来，不论研究何种矛盾的特性——各个物质运动形式的矛盾，各个运动形式在各个发展过程中的矛盾，各个发展过程的矛盾的各方面，各个发展过程在其各个发展阶段上的矛盾以及各个发展阶段上的矛盾的各方面，研究所有这些矛盾的特性，都不能带主观随意性，必须对它们实行具体的分析。离开具体的分析，就不能认识任何矛盾的特性。我们必须时刻记得列宁的话：对于具体的事物作具体的分析。 这种具体的分析，马克思、恩格斯首先给了我们以很好的模范。 当马克思、恩格斯把这事物矛盾的法则应用到社会历史过程的研究的时候，他们看出生产力和生产关系之间的矛盾，看出剥削阶级和被剥削阶级之间的矛盾以及由于这些矛盾所产生的经济基础和政治及思想等上层建筑之间的矛盾，而这些矛盾如何不可避免地会在各种不同的阶级社会中，引出各种不同的社会革命。 马克思把这一法则应用到资本主义社会经济结构的研究的时候，他看出这一社会的基本矛盾在于生产的社会性和占有制的私人性之间的矛盾。这个矛盾表现于在各别企业中的生产的有组织性和在全社会中的生产的无组织性之间的矛盾。这个矛盾的阶级表现则是资产阶级和无产阶级之间的矛盾。 由于事物范围的极其广大，发展的无限性，所以，在一定场合为普遍性的东西，而在另一一定场合则变为特殊性。反之，在一定场合为特殊性的东西，而在另一一定场合则变为普遍性。资本主义制度所包含的生产社会化和生产资料私人占有制的矛盾，是所有有资本主义的存在和发展的各国所共有的东西，对于资本主义说来，这是矛盾的普遍性。但是资本主义的这种矛盾，乃是一般阶级社会发展在一定历史阶段上的东西，对于一般阶级社会中的生产力和生产关系的矛盾说来，这是矛盾的特殊性。然而，当着马克思把资本主义社会这一切矛盾的特殊性解剖出来之后，同时也就更进一步地、更充分地、更完全地把一般阶级社会中这个生产力和生产关系的矛盾的普遍性阐发出来了。 由于特殊的事物是和普遍的事物联结的，由于每一个事物内部不但包含了矛盾的特殊性，而且包含了矛盾的普遍性，普遍性即存在于特殊性之中，所以，当着我们研究一定事物的时候，就应当去发现这两方面及其互相联结，发现一事物内部的特殊性和普遍性的两方面及其互相联结，发现一事物和它以外的许多事物的互相联结。斯大林在他的名著《论列宁主义基础》一书中说明列宁主义的历史根源的时候，他分析了列宁主义所由产生的国际环境，分析了在帝国主义条件下已经发展到极点的资本主义的诸矛盾，以及这些矛盾使无产阶级革命成为直接实践的问题，并造成了直接冲击资本主义的良好的条件。不但如此，他又分析了为什么俄国成为列宁主义的策源地，分析了沙皇俄国当时是帝国主义一切矛盾的集合点以及俄国无产阶级所以能够成为国际的革命无产阶级的先锋队的原因。这样，斯大林分析了帝国主义的矛盾的普遍性，说明列宁主义是帝国主义和无产阶级革命时代的马克思主义；又分析了沙俄帝国主义在这一般矛盾中所具有的特殊性，说明俄国成了无产阶级革命理论和策略的故乡，而在这种特殊性中间就包含了矛盾的普遍性。斯大林的这种分析，给我们提供了认识矛盾的特殊性和普遍性及其互相联结的模范。 马克思和恩格斯，同样地列宁和斯大林，他们对于应用辩证法到客观现象的研究的时候，总是指导人们不要带上任何的主观随意性，而必须从客观的实际运动所包含的具体的条件，去看出这些现象中的具体的矛盾、矛盾各方面的具体的地位以及矛盾的具体的相互关系。我们的教条主义者因为没有这种研究态度，所以弄得一无是处。我们必须以教条主义的失败为鉴戒，学会这种研究态度，舍此没有第二种研究法。 矛盾的普遍性和矛盾的特殊性的关系，就是矛盾的共性和个性的关系。其共性是矛盾存在于一切过程中，并贯串于一切过程的始终，矛盾即是运动，即是事物，即是过程，也即是思想。否认事物的矛盾就是否认了一切。这是共通的道理，古今中外，概莫能外。所以它是共性，是绝对性。然而这种共性，即包含于一切个性之中，无个性即无共性。假如除去一切个性，还有什么共性呢？因为矛盾的各各特殊，所以造成了个性。一切个性都是有条件地暂时地存在的，所以是相对的。 这一共性个性、绝对相对的道理，是关于事物矛盾的问题的精髓，不懂得它，就等于抛弃了辩证法。\n四　主要的矛盾和主要的矛盾方面 在矛盾特殊性的问题中，还有两种情形必须特别地提出来加以分析，这就是主要的矛盾和主要的矛盾方面。 在复杂的事物的发展过程中，有许多的矛盾存在，其中必有一种是主要的矛盾，由于它的存在和发展规定或影响着其它矛盾的存在和发展。 例如在资本主义社会中，无产阶级和资产阶级这两个矛盾着的力量是主要的矛盾；其它的矛盾力量，例如，残存的封建阶级和资产阶级的矛盾，农民小资产者和资产阶级的矛盾，无产阶级和农民小资产者的矛盾，自由资产阶级和垄断资产阶级的矛盾，资产阶级的民主主义和资产阶级的法西斯主义的矛盾，资本主义国家相互间的矛盾，帝国主义和殖民地的矛盾，以及其它的矛盾，都为这个主要的矛盾力量所规定、所影响。 半殖民地的国家如中国，其主要矛盾和非主要矛盾的关系呈现着复杂的情况。 当着帝国主义向这种国家举行侵略战争的时候，这种国家的内部各阶级，除开一些叛国分子以外，能够暂时地团结起来举行民族战争去反对帝国主义。这时，帝国主义和这种国家之间的矛盾成为主要的矛盾，而这种国家内部各阶级的一切矛盾（包括封建制度和人民大众之间这个主要矛盾在内），便都暂时地降到次要和服从的地位。中国一八四○年的鸦片战争[21]，一八九四年的中日战争[22]，一九○○年的义和团战争[23]和目前的中日战争，都有这种情形。 然而在另一种情形之下，则矛盾的地位起了变化。当着帝国主义不是用战争压迫而是用政治、经济、文化等比较温和的形式进行压迫的时候，半殖民地国家的统治阶级就会向帝国主义投降，二者结成同盟，共同压迫人民大众。这种时候，人民大众往往采取国内战争的形式，去反对帝国主义和封建阶级的同盟，而帝国主义则往往采取间接的方式去援助半殖民地国家的反动派压迫人民，而不采取直接行动，显出了内部矛盾的特别尖锐性。中国的辛亥革命战争，一九二四年至一九二七年的革命战争，一九二七年以后的十年土地革命战争，都有这种情形。还有半殖民地国家各个反动的统治集团之间的内战，例如在中国的军阀战争，也属于这一类。 当着国内革命战争发展到从根本上威胁帝国主义及其走狗国内反动派的存在的时候，帝国主义就往往采取上述方法以外的方法，企图维持其统治：或者分化革命阵线的内部，或者直接出兵援助国内反动派。这时，外国帝国主义和国内反动派完全公开地站在一个极端，人民大众则站在另一极端，成为一个主要矛盾，而规定或影响其它矛盾的发展状态。十月革命后各资本主义国家援助俄国反动派，是武装干涉的例子。一九二七年的蒋介石的叛变，是分化革命阵线的例子。 然而不管怎样，过程发展的各个阶段中，只有一种主要的矛盾起着领导的作用，是完全没有疑义的。 由此可知，任何过程如果有多数矛盾存在的话，其中必定有一种是主要的，起着领导的、决定的作用，其它则处于次要和服从的地位。因此，研究任何过程，如果是存在着两个以上矛盾的复杂过程的话，就要用全力找出它的主要矛盾。捉住了这个主要矛盾，一切问题就迎刃而解了。这是马克思研究资本主义社会告诉我们的方法。列宁和斯大林研究帝国主义和资本主义总危机的时候，列宁和斯大林研究苏联经济的时候，也告诉了这种方法。万千的学问家和实行家，不懂得这种方法，结果如堕烟海，找不到中心，也就找不到解决矛盾的方法。 不能把过程中所有的矛盾平均看待，必须把它们区别为主要的和次要的两类，着重于捉住主要的矛盾，已如上述。但是在各种矛盾之中，不论是主要的或次要的，矛盾着的两个方面，又是否可以平均看待呢？也是不可以的。无论什么矛盾，矛盾的诸方面，其发展是不平衡的。有时候似乎势均力敌，然而这只是暂时的和相对的情形，基本的形态则是不平衡。矛盾着的两方面中，必有一方面是主要的，他方面是次要的。其主要的方面，即所谓矛盾起主导作用的方面。事物的性质，主要地是由取得支配地位的矛盾的主要方面所规定的。 然而这种情形不是固定的，矛盾的主要和非主要的方面互相转化着，事物的性质也就随着起变化。在矛盾发展的一定过程或一定阶段上，主要方面属于甲方，非主要方面属于乙方；到了另一发展阶段或另一发展过程时，就互易其位置，这是依靠事物发展中矛盾双方斗争的力量的增减程度来决定的。 我们常常说“新陈代谢”这句话。新陈代谢是宇宙间普遍的永远不可抵抗的规律。依事物本身的性质和条件，经过不同的飞跃形式，一事物转化为他事物，就是新陈代谢的过程。任何事物的内部都有其新旧两个方面的矛盾，形成为一系列的曲折的斗争。斗争的结果，新的方面由小变大，上升为支配的东西；旧的方面则由大变小，变成逐步归于灭亡的东西。而一当新的方面对于旧的方面取得支配地位的时候，旧事物的性质就变化为新事物的性质。由此可见，事物的性质主要地是由取得支配地位的矛盾的主要方面所规定的。取得支配地位的矛盾的主要方面起了变化，事物的性质也就随着起变化。 在资本主义社会中，资本主义已从旧的封建主义社会时代的附庸地位，转化成了取得支配地位的力量，社会的性质也就由封建主义的变为资本主义的。在新的资本主义社会时代，封建势力则由原来处在支配地位的力量转化为附庸的力量，随着也就逐步地归于消灭了，例如英法诸国就是如此。随着生产力的发展，资产阶级由新的起进步作用的阶级，转化为旧的起反动作用的阶级，以至于最后被无产阶级所推翻，而转化为私有的生产资料被剥夺和失去权力的阶级，这个阶级也就要逐步归于消灭了。人数比资产阶级多得多、并和资产阶级同时生长、但被资产阶级统治着的无产阶级，是一个新的力量，它由初期的附属于资产阶级的地位，逐步地壮大起来，成为独立的和在历史上起主导作用的阶级，以至最后夺取政权成为统治阶级。这时，社会的性质，就由旧的资本主义的社会转化成了新的社会主义的社会。这就是苏联已经走过和一切其它国家必然要走的道路。 就中国的情形来说，帝国主义处在形成半殖民地这种矛盾的主要地位，压迫中国人民，中国则由独立国变为半殖民地。然而事情必然会变化，在双方斗争的局势中，中国人民在无产阶级领导之下所生长起来的力量必然会把中国由半殖民地变为独立国，而帝国主义则将被打倒，旧中国必然要变为新中国。 旧中国变为新中国，还包含着国内旧的封建势力和新的人民势力之间的情况的变化。旧的封建地主阶级将被打倒，由统治者变为被统治者，这个阶级也就会要逐步归于消灭。人民则将在无产阶级领导之下，由被统治者变为统治者。这时，中国社会的性质就会起变化，由旧的半殖民地和半封建的社会变为新的民主的社会。 这种互相转化的事情，过去已有经验。统治中国将近三百年的清朝帝国，曾在辛亥革命时期被打倒；而孙中山领导的革命同盟会，则曾经一度取得了胜利。在一九二四年至一九二七年的革命战争中，共产党和国民党联合的南方革命势力，曾经由弱小的力量变得强大起来，取得了北伐的胜利；而称雄一时的北洋军阀则被打倒了。一九二七年，共产党领导的人民力量，受了国民党反动势力的打击，变得很小了；但因肃清了自己内部的机会主义，就又逐步地壮大起来。在共产党领导的革命根据地内，农民由被统治者转化为统治者，地主则作了相反的转化。世界上总是这样以新的代替旧的，总是这样新陈代谢、除旧布新或推陈出新的。 革命斗争中的某些时候，困难条件超过顺利条件，在这种时候，困难是矛盾的主要方面，顺利是其次要方面。然而由于革命党人的努力，能够逐步地克服困难，开展顺利的新局面，困难的局面让位于顺利的局面。一九二七年中国革命失败后的情形，中国红军在长征[24]中的情形，都是如此。现在的中日战争，中国又处在困难地位，但是我们能够改变这种情况，使中日双方的情况发生根本的变化。在相反的情形之下，顺利也能转化为困难，如果是革命党人犯了错误的话。一九二四年至一九二七年的革命的胜利，变为失败了。一九二七年以后在南方各省发展起来的革命根据地，至一九三四年都失败了。 研究学问的时候，由不知到知的矛盾也是如此。当着我们刚才开始研究马克思主义的时候，对于马克思主义的无知或知之不多的情况，和马克思主义的知识之间，互相矛盾着。然而由于努力学习，可以由无知转化为有知，由知之不多转化为知之甚多，由对于马克思主义的盲目性改变为能够自由运用马克思主义。 有人觉得有些矛盾并不是这样。例如，生产力和生产关系的矛盾，生产力是主要的；理论和实践的矛盾，实践是主要的；经济基础和上层建筑的矛盾，经济基础是主要的：它们的地位并不互相转化。这是机械唯物论的见解，不是辩证唯物论的见解。诚然，生产力、实践、经济基础，一般地表现为主要的决定的作用，谁不承认这一点，谁就不是唯物论者。然而，生产关系、理论、上层建筑这些方面，在一定条件之下，又转过来表现其为主要的决定的作用，这也是必须承认的。当着不变更生产关系，生产力就不能发展的时候，生产关系的变更就起了主要的决定的作用。当着如同列宁所说“没有革命的理论，就不会有革命的运动”[25]的时候，革命理论的创立和提倡就起了主要的决定的作用。当着某一件事情（任何事情都是一样）要做，但是还没有方针、方法、计划或政策的时候，确定方针、方法、计划或政策，也就是主要的决定的东西。当着政治文化等等上层建筑阻碍着经济基础的发展的时候，对于政治上和文化上的革新就成为主要的决定的东西了。我们这样说，是否违反了唯物论呢？没有。因为我们承认总的历史发展中是物质的东西决定精神的东西，是社会的存在决定社会的意识；但是同时又承认而且必须承认精神的东西的反作用，社会意识对于社会存在的反作用，上层建筑对于经济基础的反作用。这不是违反唯物论，正是避免了机械唯物论，坚持了辩证唯物论。 在研究矛盾特殊性的问题中，如果不研究过程中主要的矛盾和非主要的矛盾以及矛盾之主要的方面和非主要的方面这两种情形，也就是说不研究这两种矛盾情况的差别性，那就将陷入抽象的研究，不能具体地懂得矛盾的情况，因而也就不能找出解决矛盾的正确的方法。这两种矛盾情况的差别性或特殊性，都是矛盾力量的不平衡性。世界上没有绝对地平衡发展的东西，我们必须反对平衡论，或均衡论。同时，这种具体的矛盾状况，以及矛盾的主要方面和非主要方面在发展过程中的变化，正是表现出新事物代替旧事物的力量。对于矛盾的各种不平衡情况的研究，对于主要的矛盾和非主要的矛盾、主要的矛盾方面和非主要的矛盾方面的研究，成为革命政党正确地决定其政治上和军事上的战略战术方针的重要方法之一，是一切共产党人都应当注意的。\n五　矛盾诸方面的同一性和斗争性 在懂得了矛盾的普遍性和特殊性的问题之后，我们必须进而研究矛盾诸方面的同一性和斗争性的问题。 同一性、统一性、一致性、互相渗透、互相贯通、互相依赖（或依存）、互相联结或互相合作，这些不同的名词都是一个意思，说的是如下两种情形：第一、事物发展过程中的每一种矛盾的两个方面，各以和它对立着的方面为自己存在的前提，双方共处于一个统一体中；第二、矛盾着的双方，依据一定的条件，各向着其相反的方面转化。这些就是所谓同一性。 列宁说：“辩证法是这样的一种学说：它研究对立怎样能够是同一的，又怎样成为同一的（怎样变成同一的），——在怎样的条件之下它们互相转化，成为同一的，——为什么人的头脑不应当把这些对立看作死的、凝固的东西，而应当看作生动的、有条件的、可变动的、互相转化的东西。”[26] 列宁这段话是什么意思呢？ 一切过程中矛盾着的各方面，本来是互相排斥、互相斗争、互相对立的。世界上一切事物的过程里和人们的思想里，都包含着这样带矛盾性的方面，无一例外。单纯的过程只有一对矛盾，复杂的过程则有一对以上的矛盾。各对矛盾之间，又互相成为矛盾。这样地组成客观世界的一切事物和人们的思想，并推使它们发生运动。 如此说来，只是极不同一，极不统一，怎样又说是同一或统一呢？ 原来矛盾着的各方面，不能孤立地存在。假如没有和它作对的矛盾的一方，它自己这一方就失去了存在的条件。试想一切矛盾着的事物或人们心中矛盾着的概念，任何一方面能够独立地存在吗？没有生，死就不见；没有死，生也不见。没有上，无所谓下；没有下，也无所谓上。没有祸，无所谓福；没有福，也无所谓祸。没有顺利，无所谓困难；没有困难，也无所谓顺利。没有地主，就没有佃农；没有佃农，也就没有地主。没有资产阶级，就没有无产阶级；没有无产阶级，也就没有资产阶级。没有帝国主义的民族压迫，就没有殖民地和半殖民地；没有殖民地和半殖民地，也就没有帝国主义的民族压迫。一切对立的成分都是这样，因一定的条件，一面互相对立，一面又互相联结、互相贯通、互相渗透、互相依赖，这种性质，叫做同一性。一切矛盾着的方面都因一定条件具备着不同一性，所以称为矛盾。然而又具备着同一性，所以互相联结。列宁所谓辩证法研究“对立怎样能够是同一的”，就是说的这种情形。怎样能够呢？因为互为存在的条件。这是同一性的第一种意义。 然而单说了矛盾双方互为存在的条件，双方之间有同一性，因而能够共处于一个统一体中，这样就够了吗？还不够。事情不是矛盾双方互相依存就完了，更重要的，还在于矛盾着的事物的互相转化。这就是说，事物内部矛盾着的两方面，因为一定的条件而各向着和自己相反的方面转化了去，向着它的对立方面所处的地位转化了去。这就是矛盾的同一性的第二种意义。 为什么这里也有同一性呢？你们看，被统治的无产阶级经过革命转化为统治者，原来是统治者的资产阶级却转化为被统治者，转化到对方原来所占的地位。苏联已经是这样做了，全世界也将要这样做。试问其间没有在一定条件之下的联系和同一性，如何能够发生这样的变化呢？ 曾在中国近代历史的一定阶段上起过某种积极作用的国民党，因为它的固有的阶级性和帝国主义的引诱（这些就是条件），在一九二七年以后转化为反革命，又由于中日矛盾的尖锐化和共产党的统一战线政策（这些就是条件），而被迫着赞成抗日。矛盾着的东西这一个变到那一个，其间包含了一定的同一性。 我们实行过的土地革命，已经是并且还将是这样的过程，拥有土地的地主阶级转化为失掉土地的阶级，而曾经是失掉土地的农民却转化为取得土地的小私有者。有无、得失之间，因一定条件而互相联结，二者具有同一性。在社会主义条件之下，农民的私有制又将转化为社会主义农业的公有制，苏联已经这样做了，全世界将来也会这样做。私产和公产之间有一条由此达彼的桥梁，哲学上名之曰同一性，或互相转化、互相渗透。 巩固无产阶级的专政或人民的专政，正是准备着取消这种专政，走到消灭任何国家制度的更高阶段去的条件。建立和发展共产党，正是准备着消灭共产党和一切政党制度的条件。建立共产党领导的革命军，进行革命战争，正是准备着永远消灭战争的条件。这许多相反的东西，同时却是相成的东西。 大家知道，战争与和平是互相转化的。战争转化为和平，例如第一次世界大战转化为战后的和平，中国的内战现在也停止了，出现了国内的和平。和平转化为战争，例如一九二七年的国共合作转化为战争，现在的世界和平局面也可能转化为第二次世界大战。为什么是这样？因为在阶级社会中战争与和平这样矛盾着的事物，在一定条件下具备着同一性。 一切矛盾着的东西，互相联系着，不但在一定条件之下共处于一个统一体中，而且在一定条件之下互相转化，这就是矛盾的同一性的全部意义。列宁所谓“怎样成为同一的（怎样变成同一的），——在怎样的条件之下它们互相转化，成为同一的”，就是这个意思。 “为什么人的头脑不应当把这些对立看作死的、凝固的东西，而应当看作生动的、有条件的、可变动的、互相转化的东西”呢？因为客观事物本来是如此的。客观事物中矛盾着的诸方面的统一或同一性，本来不是死的、凝固的，而是生动的、有条件的、可变动的、暂时的、相对的东西，一切矛盾都依一定条件向它们的反面转化着。这种情况，反映在人们的思想里，就成了马克思主义的唯物辩证法的宇宙观。只有现在的和历史上的反动的统治阶级以及为他们服务的形而上学，不是把对立的事物当作生动的、有条件的、可变动的、互相转化的东西去看，而是当作死的、凝固的东西去看，并且把这种错误的看法到处宣传，迷惑人民群众，以达其继续统治的目的。共产党人的任务就在于揭露反动派和形而上学的错误思想，宣传事物的本来的辩证法，促成事物的转化，达到革命的目的。 所谓矛盾在一定条件下的同一性，就是说，我们所说的矛盾乃是现实的矛盾，具体的矛盾，而矛盾的互相转化也是现实的、具体的。神话中的许多变化，例如《山海经》中所说的“夸父追日”[27]，《淮南子》中所说的“羿射九日”[28]，《西游记》中所说的孙悟空七十二变[29]和《聊斋志异》[30]中的许多鬼狐变人的故事等等，这种神话中所说的矛盾的互相变化，乃是无数复杂的现实矛盾的互相变化对于人们所引起的一种幼稚的、想象的、主观幻想的变化，并不是具体的矛盾所表现出来的具体的变化。马克思说：“任何神话都是用想象和借助想象以征服自然力，支配自然力，把自然力加以形象化；因而，随着这些自然力之实际上被支配，神话也就消失了。”[31]这种神话中的（还有童话中的）千变万化的故事，虽然因为它们想象出人们征服自然力等等，而能够吸引人们的喜欢，并且最好的神话具有“永久的魅力”[32]（马克思），但神话并不是根据具体的矛盾之一定的条件而构成的，所以它们并不是现实之科学的反映。这就是说，神话或童话中矛盾构成的诸方面，并不是具体的同一性，只是幻想的同一性。科学地反映现实变化的同一性的，就是马克思主义的辩证法。 为什么鸡蛋能够转化为鸡子，而石头不能够转化为鸡子呢？为什么战争与和平有同一性，而战争与石头却没有同一性呢？为什么人能生人不能生出其它的东西呢？没有别的，就是因为矛盾的同一性要在一定的必要的条件之下。缺乏一定的必要的条件，就没有任何的同一性。 为什么俄国在一九一七年二月的资产阶级民主革命和同年十月的无产阶级社会主义革命直接地联系着，而法国资产阶级革命没有直接地联系于社会主义的革命，一八七一年的巴黎公社终于失败了呢？为什么蒙古和中亚细亚的游牧制度又直接地和社会主义联系了呢？为什么中国的革命可以避免资本主义的前途，可以和社会主义直接联系起来，不要再走西方国家的历史老路，不要经过一个资产阶级专政的时期呢？没有别的，都是由于当时的具体条件。一定的必要的条件具备了，事物发展的过程就发生一定的矛盾，而且这种或这些矛盾互相依存，又互相转化，否则，一切都不可能。 同一性的问题如此。那末，什么是斗争性呢？同一性和斗争性的关系是怎样的呢？ 列宁说：“对立的统一（一致、同一、合一），是有条件的、一时的、暂存的、相对的。互相排斥的对立的斗争则是绝对的，正如发展、运动是绝对的一样。”[33] 列宁这段话是什么意思呢？ 一切过程都有始有终，一切过程都转化为它们的对立物。一切过程的常住性是相对的，但是一种过程转化为他种过程的这种变动性则是绝对的。 无论什么事物的运动都采取两种状态，相对地静止的状态和显着地变动的状态。两种状态的运动都是由事物内部包含的两个矛盾着的因素互相斗争所引起的。当着事物的运动在第一种状态的时候，它只有数量的变化，没有性质的变化，所以显出好似静止的面貌。当着事物的运动在第二种状态的时候，它已由第一种状态中的数量的变化达到了某一个最高点，引起了统一物的分解，发生了性质的变化，所以显出显着地变化的面貌。我们在日常生活中所看见的统一、团结、联合、调和、均势、相持、僵局、静止、有常、平衡、凝聚、吸引等等，都是事物处在量变状态中所显现的面貌。而统一物的分解，团结、联合、调和、均势、相持、僵局、静止、有常、平衡、凝聚、吸引等等状态的破坏，变到相反的状态，便都是事物在质变状态中、在一种过程过渡到他种过程的变化中所显现的面貌。事物总是不断地由第一种状态转化为第二种状态，而矛盾的斗争则存在于两种状态中，并经过第二种状态而达到矛盾的解决。所以说，对立的统一是有条件的、暂时的、相对的，而对立的互相排除的斗争则是绝对的。 前面我们曾经说，两个相反的东西中间有同一性，所以二者能够共处于一个统一体中，又能够互相转化，这是说的条件性，即是说在一定条件之下，矛盾的东西能够统一起来，又能够互相转化；无此一定条件，就不能成为矛盾，不能共居，也不能转化。由于一定的条件才构成了矛盾的同一性，所以说同一性是有条件的、相对的。这里我们又说，矛盾的斗争贯串于过程的始终，并使一过程向着他过程转化，矛盾的斗争无所不在，所以说矛盾的斗争性是无条件的、绝对的。 有条件的相对的同一性和无条件的绝对的斗争性相结合，构成了一切事物的矛盾运动。 我们中国人常说：“相反相成。”[34]就是说相反的东西有同一性。这句话是辩证法的，是违反形而上学的。“相反”就是说两个矛盾方面的互相排斥，或互相斗争。“相成”就是说在一定条件之下两个矛盾方面互相联结起来，获得了同一性。而斗争性即寓于同一性之中，没有斗争性就没有同一性。 在同一性中存在着斗争性，在特殊性中存在着普遍性，在个性中存在着共性。拿列宁的话来说，叫做“在相对的东西里面有着绝对的东西”[35]。\n六　对抗在矛盾中的地位 在矛盾的斗争性的问题中，包含着对抗是什么的问题。我们回答道：对抗是矛盾斗争的一种形式，而不是矛盾斗争的一切形式。 在人类历史中，存在着阶级的对抗，这是矛盾斗争的一种特殊的表现。剥削阶级和被剥削阶级之间的矛盾，无论在奴隶社会也好，封建社会也好，资本主义社会也好，互相矛盾着的两阶级，长期地并存于一个社会中，它们互相斗争着，但要待两阶级的矛盾发展到了一定的阶段的时候，双方才取外部对抗的形式，发展为革命。阶级社会中，由和平向战争的转化，也是如此。 炸弹在未爆炸的时候，是矛盾物因一定条件共居于一个统一体中的时候。待至新的条件（发火）出现，才发生了爆炸。自然界中一切到了最后要采取外部冲突形式去解决旧矛盾产生新事物的现象，都有与此相仿佛的情形。 认识这种情形，极为重要。它使我们懂得，在阶级社会中，革命和革命战争是不可避免的，舍此不能完成社会发展的飞跃，不能推翻反动的统治阶级，而使人民获得政权。共产党人必须揭露反动派所谓社会革命是不必要的和不可能的等等欺骗的宣传，坚持马克思列宁主义的社会革命论，使人民懂得，这不但是完全必要的，而且是完全可能的，整个人类的历史和苏联的胜利，都证明了这个科学的真理。 但是我们必须具体地研究各种矛盾斗争的情况，不应当将上面所说的公式不适当地套在一切事物的身上。矛盾和斗争是普遍的、绝对的，但是解决矛盾的方法，即斗争的形式，则因矛盾的性质不同而不相同。有些矛盾具有公开的对抗性，有些矛盾则不是这样。根据事物的具体发展，有些矛盾是由原来还非对抗性的，而发展成为对抗性的；也有些矛盾则由原来是对抗性的，而发展成为非对抗性的。 共产党内正确思想和错误思想的矛盾，如前所说，在阶级存在的时候，这是阶级矛盾对于党内的反映。这种矛盾，在开始的时候，或在个别的问题上，并不一定马上表现为对抗性的。但随着阶级斗争的发展，这种矛盾也就可能发展为对抗性的。苏联共产党的历史告诉我们：列宁、斯大林的正确思想和托洛茨基、布哈林等人的错误思想的矛盾，在开始的时候还没有表现为对抗的形式，但随后就发展为对抗的了。中国共产党的历史也有过这样的情形。我们党内许多同志的正确思想和陈独秀、张国焘[36]等人的错误思想的矛盾，在开始的时候也没有表现为对抗的形式，但随后就发展为对抗的了。目前我们党内的正确思想和错误思想的矛盾，没有表现为对抗的形式，如果犯错误的同志能够改正自己的错误，那就不会发展为对抗性的东西。因此，党一方面必须对于错误思想进行严肃的斗争，另方面又必须充分地给犯错误的同志留有自己觉悟的机会。在这样的情况下，过火的斗争，显然是不适当的。但如果犯错误的人坚持错误，并扩大下去，这种矛盾也就存在着发展为对抗性的东西的可能性。 经济上城市和乡村的矛盾，在资本主义社会里面（那里资产阶级统治的城市残酷地掠夺乡村），在中国的国民党统治区域里面（那里外国帝国主义和本国买办大资产阶级所统治的城市极野蛮地掠夺乡村），那是极其对抗的矛盾。但在社会主义国家里面，在我们的革命根据地里面，这种对抗的矛盾就变为非对抗的矛盾，而当到达共产主义社会的时候，这种矛盾就会消灭。 列宁说：“对抗和矛盾断然不同。在社会主义下，对抗消灭了，矛盾存在着。”[37]这就是说，对抗只是矛盾斗争的一种形式，而不是它的一切形式，不能到处套用这个公式。\n七　结　论 说到这里，我们可以总起来说几句。事物矛盾的法则，即对立统一的法则，是自然和社会的根本法则，因而也是思维的根本法则。它是和形而上学的宇宙观相反的。它对于人类的认识史是一个大革命。按照辩证唯物论的观点看来，矛盾存在于一切客观事物和主观思维的过程中，矛盾贯串于一切过程的始终，这是矛盾的普遍性和绝对性。矛盾着的事物及其每一个侧面各有其特点，这是矛盾的特殊性和相对性。矛盾着的事物依一定的条件有同一性，因此能够共居于一个统一体中，又能够互相转化到相反的方面去，这又是矛盾的特殊性和相对性。然而矛盾的斗争则是不断的，不管在它们共居的时候，或者在它们互相转化的时候，都有斗争的存在，尤其是在它们互相转化的时候，斗争的表现更为显着，这又是矛盾的普遍性和绝对性。当着我们研究矛盾的特殊性和相对性的时候，要注意矛盾和矛盾方面的主要的和非主要的区别；当着我们研究矛盾的普遍性和斗争性的时候，要注意矛盾的各种不同的斗争形式的区别。否则就要犯错误。如果我们经过研究真正懂得了上述这些要点，我们就能够击破违反马克思列宁主义基本原则的不利于我们的革命事业的那些教条主义的思想；也能够使有经验的同志们整理自己的经验，使之带上原则性，而避免重复经验主义的错误。这些，就是我们研究矛盾法则的一些简单的结论。\n注释 [1] 见列宁《黑格尔〈哲学史讲演录〉一书摘要》（《列宁全集》第55卷，人民出版社1990年版，第213页）。\n[2] 参见列宁《谈谈辩证法问题》：“统一物之分为两个部分以及对它的矛盾着的部分的认识……，是辩证法的实质（是辩证法的‘本质’之一，是它的基本的特点或特征之一，甚至可说是它的最基本的特点或特征）。”并参见《黑格尔〈逻辑学〉一书摘要》中关于“辩证法的要素”部分：“可以把辩证法简要地规定为关于对立面的统一的学说。这样就会抓住辩证法的核心，可是这需要说明和发挥。”（《列宁全集》第55卷，人民出版社1990年版，第305、192页）\n[3] 德波林（一八八一——一九六三），苏联哲学家。一九二九年当选为苏联科学院院士。三十年代初，苏联哲学界发动对德波林学派的批判，认为他们犯了理论脱离实践、哲学脱离政治等唯心主义性质的错误。\n[4] 见列宁《谈谈辩证法问题》。新的译文是：“有两种基本的（或两种可能的？或两种在历史上常见的？）发展（进化）观点：认为发展是减少和增加，是重复；以及认为发展是对立面的统一（统一物之分为两个互相排斥的对立面以及它们之间的相互关系）。”（《列宁全集》第55卷，人民出版社1990年版，第306页）\n[5] 见《汉书•董仲舒传》。董仲舒（公元前一七九——前一○四）是孔子学派在西汉的主要代表，他曾经对汉武帝说：“道之大原出于天，天不变，道亦不变。”“道”是中国古代哲学家的通用语，它的意义是“道路”或“道理”，可作“法则”或“规律”解说。\n[6] 见恩格斯《反杜林论》第一编第十二节《辩证法。量和质》（《马克思恩格斯选集》第3卷，人民出版社1972年版，第160页）。\n[7] 见列宁《谈谈辩证法问题》。新的译文是：“承认（发现）自然界的（也包括精神的和社会的）一切现象和过程具有矛盾着的、相互排斥的、对立的倾向。”（《列宁全集》第55卷，人民出版社1990年版，第306页）\n[8] 以上所引恩格斯的三段话，均见恩格斯《反杜林论》第一编第十二节《辩证法。量和质》。其中第二段“高等数学的主要基础之一，就是矛盾……”，《反杜林论》中的原文是：“我们已经提到，高等数学的主要基础之一是这样一个矛盾：在一定条件下直线和曲线应当是一回事。高等数学还有另一个矛盾：在我们眼前相交的线，只要离开交点五六厘米，就应当认为是平行的、即使无限延长也不会相交的线。可是，高等数学利用这些和其它一些更加尖锐的矛盾获得了不仅是正确的、而且是初等数学所完全不能达到的成果。”（《马克思恩格斯选集》第3卷，人民出版社1972年版，第160—161页）\n[9] 见列宁《谈谈辩证法问题》（《列宁全集》第55卷，人民出版社1990年版，第305—306页）。\n[10] 见列宁《谈谈辩证法问题》（《列宁全集》第55卷，人民出版社1990年版，第307页）。\n[11] 参见本卷《中国革命战争的战略问题》注〔11〕。\n[12] 见《孙子•谋攻》。\n[13] 魏征（五八○——六四三），唐代初期的政治活动家和历史学家。本文引语见《资治通鉴》卷一百九十二。\n[14] 《水浒传》是中国描写农民战争的著名小说。宋江是这部小说中农民武装的主要领袖。祝家庄在农民武装根据地梁山泊的附近，这个庄的统治者祝朝奉，是一个大恶霸地主。\n[15] 木马计是希腊神话中的一个著名故事。据传说，古希腊人攻打特洛伊城，很久打不下来。后来，他们伪装撤退，在城下营房中留下了一匹腹内藏有一批勇士的大木马。特洛伊人不知道这是敌人的计策，把木马作为战利品拉进城去。深夜，勇士们走出木马，利用特洛伊人毫无戒备的时机，配合城外的军队，迅速地夺取了特洛伊城。\n[16] 见列宁《再论工会、目前局势及托洛茨基同志和布哈林同志的错误》。新的译文是：“要真正地认识事物，就必须把握住、研究清楚它的一切方面、一切联系和‘中介’。我们永远也不会完全做到这一点，但是，全面性这一要求可以使我们防止犯错误和防止僵化。”（《列宁全集》第40卷，人民出版社1986年版，第291页）\n[17] 见本卷《湖南农民运动考察报告》注〔3〕。\n[18] 见本卷《论反对日本帝国主义的策略》注〔5〕。\n[19] 参见本卷《关于蒋介石声明的声明》注〔1〕。\n[20] 见本卷《中国革命战争的战略问题》注〔4〕。\n[21] 见本卷《论反对日本帝国主义的策略》注〔35〕。\n[22] 一八九四年（甲午年）发生的中日战争，也称甲午战争。这次战争是日本军国主义者蓄意挑起的。日本军队先向朝鲜发动侵略并对中国的陆海军进行挑衅，继即大举侵入中国的东北。在战争中，中国军队曾经英勇作战，但是由于清朝政府的腐败以及缺乏坚决反对侵略的准备，中国方面遭到了失败。一八九五年，清朝政府和日本订立了可耻的马关条约，这个条约的主要内容是：中国割让台湾全岛及所有附属各岛屿、澎湖列岛和辽东半岛（后来在俄、德、法三国干涉下，日本同意由清政府偿付白银三千万两“赎还”该半岛），赔偿军费银二万万两，允许日本人在中国通商口岸开设工厂，开辟沙市、重庆、苏州、杭州等地为商埠。\n[23] 见本卷《论反对日本帝国主义的策略》注〔37〕。\n[24] 参见本卷《论反对日本帝国主义的策略》注〔22〕。\n[25] 见列宁《俄国社会民主党人的任务》（《列宁全集》第2卷，人民出版社1984年版，第443页）；并见列宁《怎么办？》第一章第四节（《列宁全集》第6卷，人民出版社1986年版，第23页）。\n[26] 见列宁《黑格尔〈逻辑学〉一书摘要》。新的译文是：“辩证法是一种学说，它研究对立面怎样才能够同一，是怎样（怎样成为）同一的——在什么条件下它们是相互转化而同一的，——为什么人的头脑不应该把这些对立面看作僵死的、凝固的东西，而应该看作活生生的、有条件的、活动的、彼此转化的东西。”（《列宁全集》第55卷，人民出版社1990年版，第90页）\n[27] 《山海经》是一部中国古代地理著作，其中记载了不少远古的神话传说。夸父是《山海经•海外北经》上记载的一个神人。据说：“夸父与日逐走。入日，渴欲得饮，饮于河渭。河渭不足，北饮大泽。未至，道渴而死。弃其杖，化为邓林。”\n[28] 羿是中国古代传说中的英雄，“射日”是关于他善射的著名故事。据西汉淮南王刘安（公元前二世纪人）及其门客所著《淮南子》一书说：“尧之时，十日并出，焦禾稼，杀草木，而民无所食。猰豸、凿齿、九婴、大风、封狶、修蛇，皆为民害。尧乃使羿……上射十日而下杀猰豸。……万民皆喜。”东汉著作家王逸（公元二世纪人）关于屈原诗篇《天问》的注释说：“淮南言，尧时十日并出，草木焦枯。尧命羿仰射十日，中其九日……留其一日。”\n[29] 《西游记》是明代作家吴承恩着的一部神话小说。孙悟空是书中的主角。他是一个神猴，有七十二变的法术，能够随意变成各式各样的鸟兽虫鱼草木器物或者人形。\n[30] 《聊斋志异》是清代文学家蒲松龄着的短篇小说集，大部分是叙述神仙狐鬼的故事。\n[31] 见马克思《〈政治经济学批判〉导言》（《马克思恩格斯选集》第2卷，人民出版社1972年版，第113页）。\n[32] 见马克思《〈政治经济学批判〉导言》（《马克思恩格斯选集》第2卷，人民出版社1972年版，第114页）。\n[33] 见列宁《谈谈辩证法问题》。新的译文是：“对立面的统一（一致、同一、均势）是有条件的、暂时的、易逝的、相对的。相互排斥的对立面的斗争是绝对的，正如发展、运动是绝对的一样。”（《列宁全集》第55卷，人民出版社1990年版，第306页）\n[34] 见东汉著名史学家班固（三二——九二）所著《汉书•艺文志》，原文是：“诸子十家，其可观者，九家而已。皆起于王道既微，诸侯力政，时君世主，好恶殊方。是以九家之术，蜂出并作，各引一端，崇其所善，以此驰说，取合诸侯。其言虽殊，辟犹水火，相灭亦相生也。仁之与义，敬之与和，相反而皆相成也。”\n[35] 见列宁《谈谈辩证法问题》。新的译文是：“相对中有绝对。”（《列宁全集》第55卷，人民出版社1990年版，第307页）\n[36] 见本卷《论反对日本帝国主义的策略》注〔24〕。\n[37] 见列宁《在尼•布哈林〈过渡时期经济学〉一书上作的批注和评论》（《列宁全集》第60卷，人民出版社1990年版，第282页）。\n","permalink":"https://gopherding.github.io/posts/read/%E7%9F%9B%E7%9B%BE%E8%AE%BA/","summary":"\u003ch3 id=\"矛盾论\"\u003e矛盾论\u003c/h3\u003e\n\u003cp\u003e（一九三七年八月）\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这篇哲学论文，是毛泽东继《实践论》之后，为了同一的目的，即为了克服存在于中国共产党内的严重的教条主义思想而写的，曾在延安的抗日军事政治大学作过讲演。在收入本书第一版的时候，作者作了部分的补充、删节和修改。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e　　事物的矛盾法则，即对立统一的法则，是唯物辩证法的最根本的法则。列宁说：“就本来的意义讲，辩证法是研究对象的本质自身中的矛盾。”[1]列宁常称这个法则为辩证法的本质，又称之为辩证法的核心[2]。因此，我们在研究这个法则时，不得不涉及广泛的方面，不得不涉及许多的哲学问题。如果我们将这些问题都弄清楚了，我们就在根本上懂得了唯物辩证法。这些问题是：两种宇宙观；矛盾的普遍性；矛盾的特殊性；主要的矛盾和主要的矛盾方面；矛盾诸方面的同一性和斗争性；对抗在矛盾中的地位。\n　　苏联哲学界在最近数年中批判了德波林学派[3]的唯心论，这件事引起了我们的极大的兴趣。德波林的唯心论在中国共产党内发生了极坏的影响，我们党内的教条主义思想不能说和这个学派的作风没有关系。因此，我们现在的哲学研究工作，应当以扫除教条主义思想为主要的目标。\u003c/p\u003e","title":"矛盾论"},{"content":"实践论 论认识和实践的关系——知和行的关系\n（一九三七年七月）\n在中国共产党内，曾经有一部分教条主义的同志长期拒绝中国革命的经验，否认“马克思主义不是教条而是行动的指南”这个真理，而只生吞活剥马克思主义书籍中的只言片语，去吓唬人们。还有另一部分经验主义的同志长期拘守于自身的片断经验，不了解理论对于革命实践的重要性，看不见革命的全局，虽然也是辛苦地——但却是盲目地在工作。这两类同志的错误思想，特别是教条主义思想，曾经在一九三一年至一九三四年使得中国革命受了极大的损失，而教条主义者却是披着马克思主义的外衣迷惑了广大的同志。毛泽东的《实践论》，是为着用马克思主义的认识论观点去揭露党内的教条主义和经验主义——特别是教条主义这些主观主义的错误而写的。因为重点是揭露看轻实践的教条主义这种主观主义，故题为《实践论》。毛泽东曾以这篇论文的观点在延安的抗日军事政治大学作过讲演。\n马克思以前的唯物论，离开人的社会性，离开人的历史发展，去观察认识问题，因此不能了解认识对社会实践的依赖关系，即认识对生产和阶级斗争的依赖关系。 首先，马克思主义者认为人类的生产活动是最基本的实践活动，是决定其它一切活动的东西。人的认识，主要地依赖于物质的生产活动，逐渐地了解自然的现象、自然的性质、自然的规律性、人和自然的关系；而且经过生产活动，也在各种不同程度上逐渐地认识了人和人的一定的相互关系。一切这些知识，离开生产活动是不能得到的。在没有阶级的社会中，每个人以社会一员的资格，同其它社会成员协力，结成一定的生产关系，从事生产活动，以解决人类物质生活问题。在各种阶级的社会中，各阶级的社会成员，则又以各种不同的方式，结成一定的生产关系，从事生产活动，以解决人类物质生活问题。这是人的认识发展的基本来源。 人的社会实践，不限于生产活动一种形式，还有多种其它的形式，阶级斗争，政治生活，科学和艺术的活动，总之社会实际生活的一切领域都是社会的人所参加的。因此，人的认识，在物质生活以外，还从政治生活文化生活中（与物质生活密切联系），在各种不同程度上，知道人和人的各种关系。其中，尤以各种形式的阶级斗争，给予人的认识发展以深刻的影响。在阶级社会中，每一个人都在一定的阶级地位中生活，各种思想无不打上阶级的烙印。 马克思主义者认为人类社会的生产活动，是一步又一步地由低级向高级发展，因此，人们的认识，不论对于自然界方面，对于社会方面，也都是一步又一步地由低级向高级发展，即由浅入深，由片面到更多的方面。在很长的历史时期内，大家对于社会的历史只能限于片面的了解，这一方面是由于剥削阶级的偏见经常歪曲社会的历史，另方面，则由于生产规模的狭小，限制了人们的眼界。人们能够对于社会历史的发展作全面的历史的了解，把对于社会的认识变成了科学，这只是到了伴随巨大生产力——大工业而出现近代无产阶级的时候，这就是马克思主义的科学。 马克思主义者认为，只有人们的社会实践，才是人们对于外界认识的真理性的标准。实际的情形是这样的，只有在社会实践过程中（物质生产过程中，阶级斗争过程中，科学实验过程中），人们达到了思想中所预想的结果时，人们的认识才被证实了。人们要想得到工作的胜利即得到预想的结果，一定要使自己的思想合于客观外界的规律性，如果不合，就会在实践中失败。人们经过失败之后，也就从失败取得教训，改正自己的思想使之适合于外界的规律性，人们就能变失败为胜利，所谓“失败者成功之母”，“吃一堑长一智”，就是这个道理。辩证唯物论的认识论把实践提到第一的地位，认为人的认识一点也不能离开实践，排斥一切否认实践重要性、使认识离开实践的错误理论。列宁这样说过：“实践高于（理论的）认识，因为它不但有普遍性的品格，而且还有直接现实性的品格。”[1]马克思主义的哲学辩证唯物论有两个最显着的特点：一个是它的阶级性，公然申明辩证唯物论是为无产阶级服务的；再一个是它的实践性，强调理论对于实践的依赖关系，理论的基础是实践，又转过来为实践服务。判定认识或理论之是否真理，不是依主观上觉得如何而定，而是依客观上社会实践的结果如何而定。真理的标准只能是社会的实践。实践的观点是辩证唯物论的认识论之第一的和基本的观点[2]。 然而人的认识究竟怎样从实践发生，而又服务于实践呢？这只要看一看认识的发展过程就会明了的。 原来人在实践过程中，开始只是看到过程中各个事物的现象方面，看到各个事物的片面，看到各个事物之间的外部联系。例如有些外面的人们到延安来考察，头一二天，他们看到了延安的地形、街道、屋宇，接触了许多的人，参加了宴会、晚会和群众大会，听到了各种说话，看到了各种文件，这些就是事物的现象，事物的各个片面以及这些事物的外部联系。这叫做认识的感性阶段，就是感觉和印象的阶段。也就是延安这些各别的事物作用于考察团先生们的感官，引起了他们的感觉，在他们的脑子中生起了许多的印象，以及这些印象间的大概的外部的联系，这是认识的第一个阶段。在这个阶段中，人们还不能造成深刻的概念，作出合乎论理（即合乎逻辑）的结论。 社会实践的继续，使人们在实践中引起感觉和印象的东西反复了多次，于是在人们的脑子里生起了一个认识过程中的突变（即飞跃），产生了概念。概念这种东西已经不是事物的现象，不是事物的各个片面，不是它们的外部联系，而是抓着了事物的本质，事物的全体，事物的内部联系了。概念同感觉，不但是数量上的差别，而且有了性质上的差别。循此继进，使用判断和推理的方法，就可产生出合乎论理的结论来。《三国演义》上所谓“眉头一皱计上心来”，我们普通说话所谓“让我想一想”，就是人在脑子中运用概念以作判断和推理的工夫。这是认识的第二个阶段。外来的考察团先生们在他们集合了各种材料，加上他们“想了一想”之后，他们就能够作出“共产党的抗日民族统一战线的政策是彻底的、诚恳的和真实的”这样一个判断了。在他们作出这个判断之后，如果他们对于团结救国也是真实的的话，那末他们就能够进一步作出这样的结论：“抗日民族统一战线是能够成功的。”这个概念、判断和推理的阶段，在人们对于一个事物的整个认识过程中是更重要的阶段，也就是理性认识的阶段。认识的真正任务在于经过感觉而到达于思维，到达于逐步了解客观事物的内部矛盾，了解它的规律性，了解这一过程和那一过程间的内部联系，即到达于论理的认识。重复地说，论理的认识所以和感性的认识不同，是因为感性的认识是属于事物之片面的、现象的、外部联系的东西，论理的认识则推进了一大步，到达了事物的全体的、本质的、内部联系的东西，到达了暴露周围世界的内在的矛盾，因而能在周围世界的总体上，在周围世界一切方面的内部联系上去把握周围世界的发展。 这种基于实践的由浅入深的辩证唯物论的关于认识发展过程的理论，在马克思主义以前，是没有一个人这样解决过的。马克思主义的唯物论，第一次正确地解决了这个问题，唯物地而且辩证地指出了认识的深化的运动，指出了社会的人在他们的生产和阶级斗争的复杂的、经常反复的实践中，由感性认识到论理认识的推移的运动。列宁说过：“物质的抽象，自然规律的抽象，价值的抽象以及其它等等，一句话，一切科学的（正确的、郑重的、非瞎说的）抽象，都更深刻、更正确、更完全地反映着自然。”[3]马克思列宁主义认为：认识过程中两个阶段的特性，在低级阶段，认识表现为感性的，在高级阶段，认识表现为论理的，但任何阶段，都是统一的认识过程中的阶段。感性和理性二者的性质不同，但又不是互相分离的，它们在实践的基础上统一起来了。我们的实践证明：感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻地感觉它。感觉只解决现象问题，理论才解决本质问题。这些问题的解决，一点也不能离开实践。无论何人要认识什么事物，除了同那个事物接触，即生活于（实践于）那个事物的环境中，是没有法子解决的。不能在封建社会就预先认识资本主义社会的规律，因为资本主义还未出现，还无这种实践。马克思主义只能是资本主义社会的产物。马克思不能在自由资本主义时代就预先具体地认识帝国主义时代的某些特异的规律，因为帝国主义这个资本主义最后阶段还未到来，还无这种实践，只有列宁和斯大林才能担当此项任务。马克思、恩格斯、列宁、斯大林之所以能够作出他们的理论，除了他们的天才条件之外，主要地是他们亲自参加了当时的阶级斗争和科学实验的实践，没有这后一个条件，任何天才也是不能成功的。“秀才不出门，全知天下事”，在技术不发达的古代只是一句空话，在技术发达的现代虽然可以实现这句话，然而真正亲知的是天下实践着的人，那些人在他们的实践中间取得了“知”，经过文字和技术的传达而到达于“秀才”之手，秀才乃能间接地“知天下事”。如果要直接地认识某种或某些事物，便只有亲身参加于变革现实、变革某种或某些事物的实践的斗争中，才能触到那种或那些事物的现象，也只有在亲身参加变革现实的实践的斗争中，才能暴露那种或那些事物的本质而理解它们。这是任何人实际上走着的认识路程，不过有些人故意歪曲地说些反对的话罢了。世上最可笑的是那些“知识里手”[4]，有了道听途说的一知半解，便自封为“天下第一”，适足见其不自量而已。知识的问题是一个科学问题，来不得半点的虚伪和骄傲，决定地需要的倒是其反面——诚实和谦逊的态度。你要有知识，你就得参加变革现实的实践。你要知道梨子的滋味，你就得变革梨子，亲口吃一吃。你要知道原子的组织同性质，你就得实行物理学和化学的实验，变革原子的情况。你要知道革命的理论和方法，你就得参加革命。一切真知都是从直接经验发源的。但人不能事事直接经验，事实上多数的知识都是间接经验的东西，这就是一切古代的和外域的知识。这些知识在古人在外人是直接经验的东西，如果在古人外人直接经验时是符合于列宁所说的条件“科学的抽象”，是科学地反映了客观的事物，那末这些知识是可靠的，否则就是不可靠的。所以，一个人的知识，不外直接经验的和间接经验的两部分。而且在我为间接经验者，在人则仍为直接经验。因此，就知识的总体说来，无论何种知识都是不能离开直接经验的。任何知识的来源，在于人的肉体感官对客观外界的感觉，否认了这个感觉，否认了直接经验，否认亲自参加变革现实的实践，他就不是唯物论者。“知识里手”之所以可笑，原因就是在这个地方。中国人有一句老话：“不入虎穴，焉得虎子。”这句话对于人们的实践是真理，对于认识论也是真理。离开实践的认识是不可能的。 为了明了基于变革现实的实践而产生的辩证唯物论的认识运动——认识的逐渐深化的运动，下面再举出几个具体的例子。 无产阶级对于资本主义社会的认识，在其实践的初期——破坏机器和自发斗争时期，他们还只在感性认识的阶段，只认识资本主义各个现象的片面及其外部的联系。这时，他们还是一个所谓“自在的阶级”。但是到了他们实践的第二个时期——有意识有组织的经济斗争和政治斗争的时期，由于实践，由于长期斗争的经验，经过马克思、恩格斯用科学的方法把这种种经验总结起来，产生了马克思主义的理论，用以教育无产阶级，这样就使无产阶级理解了资本主义社会的本质，理解了社会阶级的剥削关系，理解了无产阶级的历史任务，这时他们就变成了一个“自为的阶级”。 中国人民对于帝国主义的认识也是这样。第一阶段是表面的感性的认识阶段，表现在太平天国运动和义和团运动等笼统的排外主义的斗争上[5]。第二阶段才进到理性的认识阶段，看出了帝国主义内部和外部的各种矛盾，并看出了帝国主义联合中国买办阶级和封建阶级以压榨中国人民大众的实质，这种认识是从一九一九年五四运动[6]前后才开始的。 我们再来看战争。战争的领导者，如果他们是一些没有战争经验的人，对于一个具体的战争（例如我们过去十年的土地革命战争）的深刻的指导规律，在开始阶段是不了解的。他们在开始阶段只是身历了许多作战的经验，而且败仗是打得很多的。然而由于这些经验（胜仗，特别是败仗的经验），使他们能够理解贯串整个战争的内部的东西，即那个具体战争的规律性，懂得了战略和战术，因而能够有把握地去指导战争。此时，如果改换一个无经验的人去指导，又会要在吃了一些败仗之后（有了经验之后）才能理会战争的正确的规律。 常常听到一些同志在不能勇敢接受工作任务时说出来的一句话：没有把握。为什么没有把握呢？因为他对于这项工作的内容和环境没有规律性的了解，或者他从来就没有接触过这类工作，或者接触得不多，因而无从谈到这类工作的规律性。及至把工作的情况和环境给以详细分析之后，他就觉得比较地有了把握，愿意去做这项工作。如果这个人在这项工作中经过了一个时期，他有了这项工作的经验了，而他又是一个肯虚心体察情况的人，不是一个主观地、片面地、表面地看问题的人，他就能够自己做出应该怎样进行工作的结论，他的工作勇气也就可以大大地提高了。只有那些主观地、片面地和表面地看问题的人，跑到一个地方，不问环境的情况，不看事情的全体（事情的历史和全部现状），也不触到事情的本质（事情的性质及此一事情和其它事情的内部联系），就自以为是地发号施令起来，这样的人是没有不跌交子的。 由此看来，认识的过程，第一步，是开始接触外界事情，属于感觉的阶段。第二步，是综合感觉的材料加以整理和改造，属于概念、判断和推理的阶段。只有感觉的材料十分丰富（不是零碎不全）和合于实际（不是错觉），才能根据这样的材料造出正确的概念和论理来。 这里有两个要点必须着重指明。第一个，在前面已经说过的，这里再重复说一说，就是理性认识依赖于感性认识的问题。如果以为理性认识可以不从感性认识得来，他就是一个唯心论者。哲学史上有所谓“唯理论”一派，就是只承认理性的实在性，不承认经验的实在性，以为只有理性靠得住，而感觉的经验是靠不住的，这一派的错误在于颠倒了事实。理性的东西所以靠得住，正是由于它来源于感性，否则理性的东西就成了无源之水，无本之木，而只是主观自生的靠不住的东西了。从认识过程的秩序说来，感觉经验是第一的东西，我们强调社会实践在认识过程中的意义，就在于只有社会实践才能使人的认识开始发生，开始从客观外界得到感觉经验。一个闭目塞听、同客观外界根本绝缘的人，是无所谓认识的。认识开始于经验——这就是认识论的唯物论。 第二是认识有待于深化，认识的感性阶段有待于发展到理性阶段——这就是认识论的辩证法[7]。如果以为认识可以停顿在低级的感性阶段，以为只有感性认识可靠，而理性认识是靠不住的，这便是重复了历史上的“经验论”的错误。这种理论的错误，在于不知道感觉材料固然是客观外界某些真实性的反映（我这里不来说经验只是所谓内省体验的那种唯心的经验论），但它们仅是片面的和表面的东西，这种反映是不完全的，是没有反映事物本质的。要完全地反映整个的事物，反映事物的本质，反映事物的内部规律性，就必须经过思考作用，将丰富的感觉材料加以去粗取精、去伪存真、由此及彼、由表及里的改造制作工夫，造成概念和理论的系统，就必须从感性认识跃进到理性认识。这种改造过的认识，不是更空虚了更不可靠了的认识，相反，只要是在认识过程中根据于实践基础而科学地改造过的东西，正如列宁所说乃是更深刻、更正确、更完全地反映客观事物的东西。庸俗的事务主义家不是这样，他们尊重经验而看轻理论，因而不能通观客观过程的全体，缺乏明确的方针，没有远大的前途，沾沾自喜于一得之功和一孔之见。这种人如果指导革命，就会引导革命走上碰壁的地步。 理性认识依赖于感性认识，感性认识有待于发展到理性认识，这就是辩证唯物论的认识论。哲学上的“唯理论”和“经验论”都不懂得认识的历史性或辩证性，虽然各有片面的真理（对于唯物的唯理论和经验论而言，非指唯心的唯理论和经验论），但在认识论的全体上则都是错误的。由感性到理性之辩证唯物论的认识运动，对于一个小的认识过程（例如对于一个事物或一件工作的认识）是如此，对于一个大的认识过程（例如对于一个社会或一个革命的认识）也是如此。 然而认识运动至此还没有完结。辩证唯物论的认识运动，如果只到理性认识为止，那末还只说到问题的一半。而且对于马克思主义的哲学说来，还只说到非十分重要的那一半。马克思主义的哲学认为十分重要的问题，不在于懂得了客观世界的规律性，因而能够解释世界，而在于拿了这种对于客观规律性的认识去能动地改造世界。在马克思主义看来，理论是重要的，它的重要性充分地表现在列宁说过的一句话：“没有革命的理论，就不会有革命的运动。”[8]然而马克思主义看重理论，正是，也仅仅是，因为它能够指导行动。如果有了正确的理论，只是把它空谈一阵，束之高阁，并不实行，那末，这种理论再好也是没有意义的。认识从实践始，经过实践得到了理论的认识，还须再回到实践去。认识的能动作用，不但表现于从感性的认识到理性的认识之能动的飞跃，更重要的还须表现于从理性的认识到革命的实践这一个飞跃。抓着了世界的规律性的认识，必须把它再回到改造世界的实践中去，再用到生产的实践、革命的阶级斗争和民族斗争的实践以及科学实验的实践中去。这就是检验理论和发展理论的过程，是整个认识过程的继续。理论的东西之是否符合于客观真理性这个问题，在前面说的由感性到理性之认识运动中是没有完全解决的，也不能完全解决的。要完全地解决这个问题，只有把理性的认识再回到社会实践中去，应用理论于实践，看它是否能够达到预想的目的。许多自然科学理论之所以被称为真理，不但在于自然科学家们创立这些学说的时候，而且在于为尔后的科学实践所证实的时候。马克思列宁主义之所以被称为真理，也不但在于马克思、恩格斯、列宁、斯大林等人科学地构成这些学说的时候，而且在于为尔后革命的阶级斗争和民族斗争的实践所证实的时候。辩证唯物论之所以为普遍真理，在于经过无论什么人的实践都不能逃出它的范围。人类认识的历史告诉我们，许多理论的真理性是不完全的，经过实践的检验而纠正了它们的不完全性。许多理论是错误的，经过实践的检验而纠正其错误。所谓实践是真理的标准，所谓“生活、实践底观点，应该是认识论底首先的和基本的观点”[9]，理由就在这个地方。斯大林说得好：“理论若不和革命实践联系起来，就会变成无对象的理论，同样，实践若不以革命理论为指南，就会变成盲目的实践。”[10] 说到这里，认识运动就算完成了吗？我们的答复是完成了，又没有完成。社会的人们投身于变革在某一发展阶段内的某一客观过程的实践中（不论是关于变革某一自然过程的实践，或变革某一社会过程的实践），由于客观过程的反映和主观能动性的作用，使得人们的认识由感性的推移到了理性的，造成了大体上相应于该客观过程的法则性的思想、理论、计划或方案，然后再应用这种思想、理论、计划或方案于该同一客观过程的实践，如果能够实现预想的目的，即将预定的思想、理论、计划、方案在该同一过程的实践中变为事实，或者大体上变为事实，那末，对于这一具体过程的认识运动算是完成了。例如，在变革自然的过程中，某一工程计划的实现，某一科学假想的证实，某一器物的制成，某一农产的收获，在变革社会过程中某一罢工的胜利，某一战争的胜利，某一教育计划的实现，都算实现了预想的目的。然而一般地说来，不论在变革自然或变革社会的实践中，人们原定的思想、理论、计划、方案，毫无改变地实现出来的事，是很少的。这是因为从事变革现实的人们，常常受着许多的限制，不但常常受着科学条件和技术条件的限制，而且也受着客观过程的发展及其表现程度的限制（客观过程的方面及本质尚未充分暴露）。在这种情形之下，由于实践中发现前所未料的情况，因而部分地改变思想、理论、计划、方案的事是常有的，全部地改变的事也是有的。即是说，原定的思想、理论、计划、方案，部分地或全部地不合于实际，部分错了或全部错了的事，都是有的。许多时候须反复失败过多次，才能纠正错误的认识，才能到达于和客观过程的规律性相符合，因而才能够变主观的东西为客观的东西，即在实践中得到预想的结果。但是不管怎样，到了这种时候，人们对于在某一发展阶段内的某一客观过程的认识运动，算是完成了。 然而对于过程的推移而言，人们的认识运动是没有完成的。任何过程，不论是属于自然界的和属于社会的，由于内部的矛盾和斗争，都是向前推移向前发展的，人们的认识运动也应跟着推移和发展。依社会运动来说，真正的革命的指导者，不但在于当自己的思想、理论、计划、方案有错误时须得善于改正，如同上面已经说到的，而且在于当某一客观过程已经从某一发展阶段向另一发展阶段推移转变的时候，须得善于使自己和参加革命的一切人员在主观认识上也跟着推移转变，即是要使新的革命任务和新的工作方案的提出，适合于新的情况的变化。革命时期情况的变化是很急速的，如果革命党人的认识不能随之而急速变化，就不能引导革命走向胜利。 然而思想落后于实际的事是常有的，这是因为人的认识受了许多社会条件的限制的缘故。我们反对革命队伍中的顽固派，他们的思想不能随变化了的客观情况而前进，在历史上表现为右倾机会主义。这些人看不出矛盾的斗争已将客观过程推向前进了，而他们的认识仍然停止在旧阶段。一切顽固党的思想都有这样的特征。他们的思想离开了社会的实践，他们不能站在社会车轮的前头充任向导的工作，他们只知跟在车子后面怨恨车子走得太快了，企图把它向后拉，开倒车。 我们也反对“左”翼空谈主义。他们的思想超过客观过程的一定发展阶段，有些把幻想看作真理，有些则把仅在将来有现实可能性的理想，勉强地放在现时来做，离开了当前大多数人的实践，离开了当前的现实性，在行动上表现为冒险主义。 唯心论和机械唯物论，机会主义和冒险主义，都是以主观和客观相分裂，以认识和实践相脱离为特征的。以科学的社会实践为特征的马克思列宁主义的认识论，不能不坚决反对这些错误思想。马克思主义者承认，在绝对的总的宇宙发展过程中，各个具体过程的发展都是相对的，因而在绝对真理的长河中，人们对于在各个一定发展阶段上的具体过程的认识只具有相对的真理性。无数相对的真理之总和，就是绝对的真理[11]。客观过程的发展是充满着矛盾和斗争的发展，人的认识运动的发展也是充满着矛盾和斗争的发展。一切客观世界的辩证法的运动，都或先或后地能够反映到人的认识中来。社会实践中的发生、发展和消灭的过程是无穷的，人的认识的发生、发展和消灭的过程也是无穷的。根据于一定的思想、理论、计划、方案以从事于变革客观现实的实践，一次又一次地向前，人们对于客观现实的认识也就一次又一次地深化。客观现实世界的变化运动永远没有完结，人们在实践中对于真理的认识也就永远没有完结。马克思列宁主义并没有结束真理，而是在实践中不断地开辟认识真理的道路。我们的结论是主观和客观、理论和实践、知和行的具体的历史的统一，反对一切离开具体历史的“左”的或右的错误思想。 社会的发展到了今天的时代，正确地认识世界和改造世界的责任，已经历史地落在无产阶级及其政党的肩上。这种根据科学认识而定下来的改造世界的实践过程，在世界、在中国均已到达了一个历史的时节——自有历史以来未曾有过的重大时节，这就是整个儿地推翻世界和中国的黑暗面，把它们转变过来成为前所未有的光明世界。无产阶级和革命人民改造世界的斗争，包括实现下述的任务：改造客观世界，也改造自己的主观世界——改造自己的认识能力，改造主观世界同客观世界的关系。地球上已经有一部分实行了这种改造，这就是苏联。他们还正在促进这种改造过程。中国人民和世界人民也都正在或将要通过这样的改造过程。所谓被改造的客观世界，其中包括了一切反对改造的人们，他们的被改造，须要通过强迫的阶段，然后才能进入自觉的阶段。世界到了全人类都自觉地改造自己和改造世界的时候，那就是世界的共产主义时代。 通过实践而发现真理，又通过实践而证实真理和发展真理。从感性认识而能动地发展到理性认识，又从理性认识而能动地指导革命实践，改造主观世界和客观世界。实践、认识、再实践、再认识，这种形式，循环往复以至无穷，而实践和认识之每一循环的内容，都比较地进到了高一级的程度。这就是辩证唯物论的全部认识论，这就是辩证唯物论的知行统一观。\n注释\n[1] 见列宁《黑格尔〈逻辑学〉一书摘要》。新的译文是：“实践高于（理论的）认识，因为它不仅具有普遍性的品格，而且还具有直接现实性的品格。”（《列宁全集》第55卷，人民出版社1990年版，第183页）\n[2] 参见马克思《关于费尔巴哈的提纲》（《马克思恩格斯选集》第1卷，人民出版社1972年版，第16—19页）和列宁《唯物主义和经验批判主义》第二章第六节（《列宁全集》第18卷，人民出版社1988年版，第144页）。\n[3] 见列宁《黑格尔〈逻辑学〉一书摘要》（《列宁全集》第55卷，人民出版社1990年版，第142页）。\n[4] 里手，湖南方言，内行的意思。\n[5] 一九五一年三月二十七日，毛泽东在致李达的信中说：“《实践论》中将太平天国放在排外主义一起说不妥，出选集时拟加修改，此处暂仍照原。”\n[6] 五四运动是一九一九年五月四日发生的反帝反封建的爱国运动。当时，第一次世界大战刚刚结束，英、美、法、日、意等战胜国在巴黎召开对德和会，决定由日本继承德国在中国山东的特权。中国是参加对德宣战的战胜国之一，但北洋军阀政府却准备接受这个决定。五月四日，北京学生游行示威，反对帝国主义的这一无理决定和北洋军阀政府的妥协。这次运动迅速地获得了全国人民的响应，到六月三日以后，发展成为有工人阶级、城市小资产阶级和民族资产阶级参加的广大群众性的反帝反封建的爱国运动。五四运动也是反对封建文化的新文化运动。以一九一五年《青年杂志》（后改名《新青年》）创刊为起点的新文化运动，竖起“民主”和“科学”的旗帜，反对旧道德，提倡新道德，反对旧文学，提倡新文学。五四运动中的先进分子接受了马克思主义，使新文化运动发展成为马克思主义思想运动，他们致力于马克思主义同中国工人运动相结合，在思想上和干部上准备了中国共产党的成立。\n[7] 参见列宁《黑格尔〈逻辑学〉一书摘要》：“要理解，就必须从经验开始理解、研究，从经验上升到一般。”（《列宁全集》第55卷，人民出版社1990年版，第175页）\n[8] 见列宁《俄国社会民主党人的任务》（《列宁全集》第2卷，人民出版社1984年版，第443页）；并见列宁《怎么办？》第一章第四节（《列宁全集》第6卷，人民出版社1986年版，第23页）。\n[9] 见列宁《唯物主义和经验批判主义》第二章第六节（《列宁全集》第18卷，人民出版社1988年版，第144页）。\n[10] 见斯大林《论列宁主义基础》第三部分《理论》。新的译文是：“离开革命实践的理论是空洞的理论，而不以革命理论为指南的实践是盲目的实践。”（《斯大林选集》上卷，人民出版社1979年版，第199—200页）\n[11] 参见列宁《唯物主义和经验批判主义》第二章第五节。原文是：“人类思维按其本性是能够给我们提供并且正在提供由相对真理的总和所构成的绝对真理的。”（《列宁全集》第18卷，人民出版社1988年版，第135页）\n","permalink":"https://gopherding.github.io/posts/read/%E5%AE%9E%E8%B7%B5%E8%AE%BA/","summary":"\u003ch3 id=\"实践论\"\u003e实践论\u003c/h3\u003e\n\u003cp\u003e论认识和实践的关系——知和行的关系\u003c/p\u003e\n\u003cp\u003e（一九三七年七月）\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在中国共产党内，曾经有一部分教条主义的同志长期拒绝中国革命的经验，否认“马克思主义不是教条而是行动的指南”这个真理，而只生吞活剥马克思主义书籍中的只言片语，去吓唬人们。还有另一部分经验主义的同志长期拘守于自身的片断经验，不了解理论对于革命实践的重要性，看不见革命的全局，虽然也是辛苦地——但却是盲目地在工作。这两类同志的错误思想，特别是教条主义思想，曾经在一九三一年至一九三四年使得中国革命受了极大的损失，而教条主义者却是披着马克思主义的外衣迷惑了广大的同志。毛泽东的《实践论》，是为着用马克思主义的认识论观点去揭露党内的教条主义和经验主义——特别是教条主义这些主观主义的错误而写的。因为重点是揭露看轻实践的教条主义这种主观主义，故题为《实践论》。毛泽东曾以这篇论文的观点在延安的抗日军事政治大学作过讲演。\u003c/p\u003e","title":"实践论"},{"content":"对于指针接收器和值接收器方法的一些拙见 本文主要解决了下文代码中\nm := inputType.Method(i) 在使用指针接收器（pointer receiver）\nfunc (this *User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } 定义方法时Method()无预期输出的问题😫😫😫，详见代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this *User) Call() { //改成func (this User) Call()即可被下文inputType.Method(i)实现 fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() //可寻址值变量（左值） 上调用指针接收器方法，Golang 会自动隐式的为变量取地址后调用方法，Golang 的语法糖让我们不用再啰嗦的显式取地址。同理，当指针类型调用值接收器方法时，Golang 也会通过指针找到值类型，在值类型上调用方法。此处如果写成 User{1, \u0026#34;Aceld\u0026#34;, 18}.Call() 会报错，因为 User{1, \u0026#34;Aceld\u0026#34;, 18} 不是左值。 DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) fmt.Println(\u0026#34;inputType is :\u0026#34;, inputType.Name()) //获取input的value inputValue := reflect.ValueOf(input) fmt.Println(\u0026#34;inputValue is:\u0026#34;, inputValue) //通过type 获取里面的字段 //1. 获取interface的reflect.Type，通过Type得到NumField ,进行遍历 //2. 得到每个field，数据类型 //3. 通过filed有一个Interface()方法等到 对应的value for i := 0; i \u0026lt; inputType.NumField(); i++ { field := inputType.Field(i) value := inputValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, field.Name, field.Type, value) } //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, m.Name, m.Type) } } 在Go语言中，方法是否可以被反射（通过reflect包）获取取决于它们是如何定义的。当使用指针接收器（pointer receiver）定义一个方法时，该方法仅在指针类型上存在，而不是在值类型上。相反，当使用值接收器（value receiver）定义方法时，该方法将在值类型和指针类型上均可用。\n让我们分析提供的两种情况：\n使用指针接收器的方法： func (this *User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } 在这种情况下，Call方法是一个指针方法。这意味着它只能被*User类型的变量调用，而不能被User类型的变量调用。当使用指针接收器定义方法时，Go语言会在运行时为该方法创建一个新的函数，该函数接受一个指向接收者类型的指针作为第一个参数。因此，当尝试通过值类型的变量调用这个方法时，它不会出现在方法的列表中。\n使用值接收器的方法： func (this User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } 在这种情况下，Call方法是一个值方法。它可以被User类型的变量直接调用。当使用值接收器定义方法时，Go语言会为该方法创建一个新的函数，该函数接受接收者类型的值作为第一个参数。因此，当通过值类型的变量调用方法时，这个方法会出现在方法的列表中。\n在DoFiledAndMethod函数中，是通过一个interface{}类型的变量来获取方法的。如果interface{}变量包含的是一个User类型的值，那么使用值接收器定义的方法或者指针接收器定义的方法都会被反射包检测到。如果interface{}变量包含的是一个*User类型的指针，那么只有使用指针接收器定义的方法才会被检测到。😋😋😋　为了通过反射获取所有定义在User类型上的方法（无论它们是使用值接收器还是指针接收器定义的），需要在DoFiledAndMethod函数中处理这两种情况。可以通过检查inputType的Kind来确定它是否是一个指针，并相应地获取方法。下面是一个修改后的DoFiledAndMethod函数，它可以处理这两种情况：\nfunc DoFiledAndMethod(input interface{}) { // 获取input的type inputType := reflect.TypeOf(input) fmt.Println(\u0026#34;inputType is :\u0026#34;, inputType.Name()) // 获取input的value inputValue := reflect.ValueOf(input) fmt.Println(\u0026#34;inputValue is:\u0026#34;, inputValue) // 获取字段 for i := 0; i \u0026lt; inputType.NumField(); i++ { field := inputType.Field(i) value := inputValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, field.Name, field.Type, value) } // 获取方法 var userType reflect.Type if inputType.Kind() == reflect.Ptr { // 如果input是一个指针，获取它指向的实际类型 userType = inputType.Elem() } else { // 否则，直接使用input的类型 userType = inputType } for i := 0; i \u0026lt; userType.NumMethod(); i++ { m := userType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, m.Name, m.Type) } } 在这个修改后的函数中，我们检查了inputType的Kind是否为reflect.Ptr，如果是，则使用inputType.Elem()来获取指针指向的实际类型。然后，我们在这个实际类型上调用NumMethod和Method来获取和打印方法。这样，无论input是一个User类型的值还是一个*User类型的指针，函数都会正确地打印出定义在User类型上的所有方法。ヾ(≧▽≦*)o\n那究竟怎么选择是指针接收器还是值接收器呢？\n何时使用值类型 （1）如果接收器是一个 map，func 或者 chan，使用值类型（因为它们本身就是引用类型）。 （2）如果接收器是一个 slice，并且方法不执行 reslice 操作，也不重新分配内存给 slice，使用值类型。 （3）如果接收器是一个小的数组或者原生的值类型结构体类型(比如 time.Time 类型)，而且没有可修改的字段和指针，又或者接收器是一个简单地基本类型像是 int 和 string，使用值类型就好了。\n值类型的接收器可以减少一定数量的内存垃圾生成，值类型接收器一般会在栈上分配到内存（但也不一定），在没搞明白代码想干什么之前，别为这个原因而选择值类型接收器。\n何时使用指针类型 （1）如果方法需要修改接收器里的数据，则接收器必须是指针类型。 （2）如果接收器是一个包含了 sync.Mutex 或者类似同步字段的结构体，接收器必须是指针，这样可以避免拷贝。 （3）如果接收器是一个大的结构体或者数组，那么指针类型接收器更有效率。 （4）如果接收器是一个结构体，数组或者 slice，它们中任意一个元素是指针类型而且可能被修改，建议使用指针类型接收器，这样会增加程序的可读性。\n无论你声明方法的接收器是指针接收器还是值接收器，Go都可以帮你隐式转换为正确的方法使用。\n只需要记住，值类型不能调用指针接收器方法\n**也即：值接收器方法（value methods）可以通过指针和值调用，但是指针接收器方法（pointer methods）只能通过指针来调用。**但有一个例外，如果某个值是可寻址的（addressable，或者说左值），那么编译器会在值调用指针方法时自动插入取地址符，使得在此情形下看起来像指针方法也可以通过值来调用（语法糖）。\n从逻辑上理解为什么 “值类型不能调用指针接收器方法” 指针接收器方法，很可能在方法中会对调用者的属性进行更改操作，从而影响接收器；而对于值接收器方法，在方法中不会对接收器本身产生影响。\n指针接收器方法，很可能在方法中会对调用者的属性进行更改操作，从而影响接收器；而对于值接收器方法，在方法中不会对接收器本身产生影响。所以，当实现了一个值接收器方法，就可以自动生成一个指针接收器方法，因为两者都不会影响接收器。但是，当实现了一个指针接收器方法，如果此时自动生成一个值接收器方法，原本期望对接收器的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响接收器。\n如果实现了值接收器方法，会隐含地也实现了指针接收器方法。\n最后如果实在还是不知道该使用哪种接收器，那么记住使用指针接收器是最靠谱的。\ne.g.\n1.值接收器\u0026amp;\u0026amp;值调用，ok\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%v %s: %v\\n\u0026#34;, i, m.Name, m.Type) } } 2.值接收器\u0026amp;\u0026amp;指针调用，ok（如果实现了值接收器方法，会隐含地也实现了指针接收器方法。）\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := \u0026amp;User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%v %s: %v\\n\u0026#34;, i, m.Name, m.Type) } } 3.指针接收器\u0026amp;\u0026amp;值调用，no！！！\n/**当你使用 `reflect.TypeOf(user)` 来获取 `user` 变量的类型时，你得到的是 `User` 类型，而不是 `*User` 类型。由于 `Call` 方法现在是一个指针接收器方法，它只存在于 `*User` 类型上，而不是 `User` 类型上。 这就是为什么在 `DoFiledAndMethod` 函数中找不到 `Call` 方法的原因。`DoFiledAndMethod` 函数正在查看 `User` 类型的方法，而不是 `*User` 类型的方法。 **/ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this *User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%v %s: %v\\n\u0026#34;, i, m.Name, m.Type) } } 4.指针接收器\u0026amp;\u0026amp;指针调用，ok\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this User) Call() { fmt.Print(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} user.Call() DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%v %s: %v\\n\u0026#34;, i, m.Name, m.Type) } } ","permalink":"https://gopherding.github.io/posts/tech/%E5%AF%B9%E4%BA%8E%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E5%99%A8%E5%92%8C%E5%80%BC%E6%8E%A5%E6%94%B6%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8B%99%E8%A7%81/","summary":"\u003ch3 id=\"对于指针接收器和值接收器方法的一些拙见\"\u003e对于指针接收器和值接收器方法的一些拙见\u003c/h3\u003e\n\u003cp\u003e本文主要解决了下文代码中\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einputType\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eMethod\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在使用指针接收器（pointer receiver）\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eUser\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eCall\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrint\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;user is called ..\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%v\\n\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ethis\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e定义方法时Method()无预期输出的问题😫😫😫，详见代码如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003epackage\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;fmt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;reflect\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eUser\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eId\u003c/span\u003e   \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ethis\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eUser\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eCall\u003c/span\u003e() {  \u003cspan style=\"color:#75715e\"\u003e//改成func (this User) Call()即可被下文inputType.Method(i)实现\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrint\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;user is called ..\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%v\\n\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ethis\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eUser\u003c/span\u003e{\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Aceld\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e18\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eCall\u003c/span\u003e()  \u003cspan style=\"color:#75715e\"\u003e//可寻址值变量（左值） 上调用指针接收器方法，Golang 会自动隐式的为变量取地址后调用方法，Golang 的语法糖让我们不用再啰嗦的显式取地址。同理，当指针类型调用值接收器方法时，Golang 也会通过指针找到值类型，在值类型上调用方法。此处如果写成 User{1, \u0026#34;Aceld\u0026#34;, 18}.Call() 会报错，因为 User{1, \u0026#34;Aceld\u0026#34;, 18} 不是左值。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eDoFiledAndMethod\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDoFiledAndMethod\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003einput\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e{}) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e//获取input的type\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003einputType\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereflect\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eTypeOf\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003einput\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;inputType is :\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003einputType\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e//获取input的value\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003einputValue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereflect\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eValueOf\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003einput\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;inputValue is:\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003einputValue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e//通过type 获取里面的字段\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e//1. 获取interface的reflect.Type，通过Type得到NumField ,进行遍历\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e//2. 得到每个field，数据类型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e//3. 通过filed有一个Interface()方法等到 对应的value\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u0026lt; \u003cspan style=\"color:#a6e22e\"\u003einputType\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eNumField\u003c/span\u003e(); \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#a6e22e\"\u003efield\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einputType\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eField\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einputValue\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eField\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003eInterface\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%s: %v = %v\\n\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003efield\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003efield\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eType\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003evalue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e//通过type 获取里面的方法,调用\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e \u0026lt; \u003cspan style=\"color:#a6e22e\"\u003einputType\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eNumMethod\u003c/span\u003e(); \u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einputType\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eMethod\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ei\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%s: %v\\n\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eType\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在Go语言中，方法是否可以被反射（通过\u003ccode\u003ereflect\u003c/code\u003e包）获取取决于它们是如何定义的。当使用指针接收器（pointer receiver）定义一个方法时，该方法仅在指针类型上存在，而不是在值类型上。相反，当使用值接收器（value receiver）定义方法时，该方法将在值类型和指针类型上均可用。\u003c/p\u003e","title":"对于指针接收器和值接收器方法的一些拙见"},{"content":" CAS 实际代码文件在 Go / src / runtime / internal / atomic / asm_amd.s 文件中\nfunc (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // Slow path (outlined so that the fast path can be inlined) m.lockSlow() } 如果可以获得锁资源，则修改Mutex.state中的locked位，并成功获取，如果获取不到，则执行lowSlow()方法。\n比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。\nCAS缺点：\n1.CAS在共享资源竞争比较激烈的时候，每个goroutine会容易处于自旋状态，影响效率，在竞争激烈的时候推荐使用锁。\n2.无法解决ABA问题，ABA问题是无锁结构实现中常见的一种问题，可基本表述为： 进程P1读取了一个数值A P1被挂起(时间片耗尽、中断等)，进程P2开始执行 P2修改数值A为数值B，然后又修改回A P1被唤醒，比较后发现数值A没有变化，程序继续执行。\nGo如何保证并发安全 Mutex、Channel、Atomic\nMutex\n加锁应该是最常见的并发控制方法，一般分成两种，乐观锁和悲观锁。\n悲观锁是一种悲观思想，它总认为最坏的情况可能会出现。不管意料之外的结果是否会发生，只要存在发生的可能，就在操作这个资源之前先上锁。例如互斥锁、读写锁都是悲观锁。\n乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过。乐观锁适用于多读的场景，可以提高吞吐量。乐观锁的实现方案主要包含CAS和版本号机制。\nChannel\n详见：goroutine\u0026amp;channel专题\nAtomic\n1.总线加锁\n所谓总线锁就是使用处理器提供的一个lock#信号，当一个处理器在总线上输出此信号时，其他处理器的请求会被阻塞住，那么该处理器可以独占共享内存。\n但总线锁定把cpu和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以开销比较大。\n2.缓存加锁\n第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。\n去 Go SDK/sync/atomic下找罢，或者点击这里\nCSP CSP 是通信顺序进程（Communicating Sequential Process）的简称，是一种并发编程模型。简单来说，CSP模型由并发的实体所组成，实体之间通过发送消息进行通信，而发送消息使用的就是通道，即channel。GO实现了CSP部分理论，goroutine对应CSP中的并发执行的实体，channel对应CSP中的channel。\n不要通过共享内存来通信，而应该通过通信来共享内存 一份有用的说明文档通常比额外的长名字更有价值 ","permalink":"https://gopherding.github.io/posts/tech/%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84go%E6%80%9D%E6%83%B3/","summary":"\u003col\u003e\n\u003cli\u003e\n\u003ch3 id=\"cas\"\u003eCAS\u003c/h3\u003e\n\u003cp\u003e实际代码文件在  Go / src / runtime / internal / atomic / asm_amd.s  文件中\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eMutex\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eLock\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#75715e\"\u003e// Fast path: grab unlocked mutex.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eatomic\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eCompareAndSwapInt32\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003estate\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003emutexLocked\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003erace\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eEnabled\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#a6e22e\"\u003erace\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAcquire\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eunsafe\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePointer\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#75715e\"\u003e// Slow path (outlined so that the fast path can be inlined)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003elockSlow\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果可以获得锁资源，则修改Mutex.state中的locked位，并成功获取，如果获取不到，则执行lowSlow()方法。\u003c/p\u003e\n\u003cp\u003e比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。\u003c/p\u003e","title":"眼前一亮的go思想"},{"content":"Summer for Thee,Grant I May Be By Emily Dickinson\nSummer for thee,grant I may be\nWhen summer days are flown!\nThy music still,when Whippoorwill\nAnd Oriole——are done!\nFor thee to bloom,I\u0026rsquo;ll skip the tomb\nAnd row my blossoms over!\nPray gather me——Anemone——\nThy flower——forevermore!\n","permalink":"https://gopherding.github.io/posts/read/summer-for-theegrant-i-may-be/","summary":"\u003ch3 id=\"summer-for-theegrant-i-may-be\"\u003e\u003cstrong\u003eSummer for Thee,Grant I May Be\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eBy Emily Dickinson\u003c/p\u003e\n\u003cp\u003e\u003cbr\u003eSummer for thee,grant I may be\u003c/p\u003e\n\u003cp\u003eWhen summer days are flown!\u003c/p\u003e\n\u003cp\u003eThy music still,when Whippoorwill\u003c/p\u003e\n\u003cp\u003eAnd Oriole——are done!\u003c/p\u003e\n\u003cp\u003eFor thee to bloom,I\u0026rsquo;ll skip the tomb\u003c/p\u003e\n\u003cp\u003eAnd row my blossoms over!\u003c/p\u003e\n\u003cp\u003ePray gather me——Anemone——\u003c/p\u003e\n\u003cp\u003eThy flower——forevermore!\u003c/p\u003e","title":"Summer for Thee,Grant I May Be"},{"content":"Nginx 实现负载均衡主要有以下几种方法：\n轮询（Round - Robin） 原理 轮询是 Nginx 默认的负载均衡算法。它按照顺序依次将客户端的请求分配到后端的服务器组中。例如，有服务器 A、B、C，当第一个请求来时分配到 A，第二个请求分配到 B，第三个请求分配到 C，第四个请求又回到 A，如此循环。 配置示例 在nginx.conf的http块中定义一个upstream服务器组： upstream backend { server server1.example.com; server server2.example.com; server server3.example.com; } 然后在server块中，使用proxy_pass指令将请求转发到这个upstream组： server { listen 80; server_name example.com; location / { proxy_pass http://backend; } } 加权轮询（Weighted Round - Robin） 原理 加权轮询考虑到后端服务器的性能差异。为不同的服务器分配不同的权重值，权重越高的服务器被分配到请求的概率就越大。例如，服务器 A 的权重为 3，服务器 B 的权重为 2，服务器 C 的权重为 1，那么在总共 6 次请求中，服务器 A 可能会被分配到 3 次，服务器 B 被分配到 2 次，服务器 C 被分配到 1 次。 配置示例 在upstream组中为服务器指定权重： upstream backend { server server1.example.com weight = 3; server server2.example.com weight = 2; server server3.example.com weight = 1; } IP 哈希（IP Hash） 原理 IP 哈希算法根据客户端的 IP 地址计算一个哈希值，然后根据这个哈希值将请求固定分配到后端的某一台服务器上。这样可以保证来自同一个客户端的请求总是被发送到同一台服务器，适用于有状态的服务，如某些需要保持会话状态的 Web 应用。 配置示例 在upstream组中使用ip_hash指令： upstream backend { ip_hash; server server1.example.com; server server2.example.com; server server3.example.com; } 最少连接（Least Connections） 原理 最少连接算法会将新的请求分配到当前连接数最少的服务器上。这有助于更均衡地分配负载，特别是在后端服务器的处理能力相近但请求处理时间差异较大的情况下。例如，服务器 A 当前有 10 个连接，服务器 B 有 5 个连接，服务器 C 有 3 个连接，那么新的请求就会被分配到服务器 C。 配置示例 在upstream组中使用least_conn指令： upstream backend { least_conn; server server1.example.com; server server2.example.com; server server3.example.com; } 基于 URL 的哈希（URL Hash） 原理 根据请求的 URL 计算哈希值，然后根据这个哈希值将请求分配到后端服务器。这样相同的 URL 请求总是被发送到同一台服务器，适用于对缓存有特殊要求的场景，如缓存服务器组，相同的 URL 内容可以在同一台服务器上缓存和处理。 配置示例 在upstream组中使用hash指令，并指定$uri（表示请求的 URL）作为哈希计算的依据： upstream backend { hash $uri; server server1.example.com; server server2.example.com; server server3.example.com; } ","permalink":"https://gopherding.github.io/posts/tech/nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","summary":"\u003cp\u003eNginx 实现负载均衡主要有以下几种方法：\u003c/p\u003e\n\u003ch3 id=\"轮询round---robin\"\u003e\u003cstrong\u003e轮询（Round - Robin）\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"原理\"\u003e原理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e轮询是 Nginx 默认的负载均衡算法。它按照顺序依次将客户端的请求分配到后端的服务器组中。例如，有服务器 A、B、C，当第一个请求来时分配到 A，第二个请求分配到 B，第三个请求分配到 C，第四个请求又回到 A，如此循环。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"配置示例\"\u003e配置示例\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在\u003ccode\u003enginx.conf\u003c/code\u003e的\u003ccode\u003ehttp\u003c/code\u003e块中定义一个\u003ccode\u003eupstream\u003c/code\u003e服务器组：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-nginx\" data-lang=\"nginx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#66d9ef\"\u003eupstream\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003ebackend\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver1.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver2.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver3.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e然后在\u003ccode\u003eserver\u003c/code\u003e块中，使用\u003ccode\u003eproxy_pass\u003c/code\u003e指令将请求转发到这个\u003ccode\u003eupstream\u003c/code\u003e组：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-nginx\" data-lang=\"nginx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#66d9ef\"\u003eserver\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003elisten\u003c/span\u003e       \u003cspan style=\"color:#ae81ff\"\u003e80\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver_name\u003c/span\u003e  \u003cspan style=\"color:#e6db74\"\u003eexample.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003elocation\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e/\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             \u003cspan style=\"color:#f92672\"\u003eproxy_pass\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003ehttp://backend\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"加权轮询weighted-round---robin\"\u003e\u003cstrong\u003e加权轮询（Weighted Round - Robin）\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"原理-1\"\u003e原理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e加权轮询考虑到后端服务器的性能差异。为不同的服务器分配不同的权重值，权重越高的服务器被分配到请求的概率就越大。例如，服务器 A 的权重为 3，服务器 B 的权重为 2，服务器 C 的权重为 1，那么在总共 6 次请求中，服务器 A 可能会被分配到 3 次，服务器 B 被分配到 2 次，服务器 C 被分配到 1 次。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"配置示例-1\"\u003e配置示例\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在\u003ccode\u003eupstream\u003c/code\u003e组中为服务器指定权重：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-nginx\" data-lang=\"nginx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#66d9ef\"\u003eupstream\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003ebackend\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver1.example.com\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eweight\u003c/span\u003e = \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver2.example.com\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eweight\u003c/span\u003e = \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver3.example.com\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eweight\u003c/span\u003e = \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"ip-哈希ip-hash\"\u003e\u003cstrong\u003eIP 哈希（IP Hash）\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"原理-2\"\u003e原理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eIP 哈希算法根据客户端的 IP 地址计算一个哈希值，然后根据这个哈希值将请求固定分配到后端的某一台服务器上。这样可以保证来自同一个客户端的请求总是被发送到同一台服务器，适用于有状态的服务，如某些需要保持会话状态的 Web 应用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"配置示例-2\"\u003e配置示例\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在\u003ccode\u003eupstream\u003c/code\u003e组中使用\u003ccode\u003eip_hash\u003c/code\u003e指令：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-nginx\" data-lang=\"nginx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#66d9ef\"\u003eupstream\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003ebackend\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eip_hash\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver1.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver2.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver3.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"最少连接least-connections\"\u003e\u003cstrong\u003e最少连接（Least Connections）\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"原理-3\"\u003e原理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e最少连接算法会将新的请求分配到当前连接数最少的服务器上。这有助于更均衡地分配负载，特别是在后端服务器的处理能力相近但请求处理时间差异较大的情况下。例如，服务器 A 当前有 10 个连接，服务器 B 有 5 个连接，服务器 C 有 3 个连接，那么新的请求就会被分配到服务器 C。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"配置示例-3\"\u003e配置示例\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在\u003ccode\u003eupstream\u003c/code\u003e组中使用\u003ccode\u003eleast_conn\u003c/code\u003e指令：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-nginx\" data-lang=\"nginx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#66d9ef\"\u003eupstream\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003ebackend\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eleast_conn\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver1.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver2.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver3.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"基于-url-的哈希url-hash\"\u003e\u003cstrong\u003e基于 URL 的哈希（URL Hash）\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003ch4 id=\"原理-4\"\u003e原理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e根据请求的 URL 计算哈希值，然后根据这个哈希值将请求分配到后端服务器。这样相同的 URL 请求总是被发送到同一台服务器，适用于对缓存有特殊要求的场景，如缓存服务器组，相同的 URL 内容可以在同一台服务器上缓存和处理。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch4 id=\"配置示例-4\"\u003e配置示例\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在\u003ccode\u003eupstream\u003c/code\u003e组中使用\u003ccode\u003ehash\u003c/code\u003e指令，并指定\u003ccode\u003e$uri\u003c/code\u003e（表示请求的 URL）作为哈希计算的依据：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-nginx\" data-lang=\"nginx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#66d9ef\"\u003eupstream\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003ebackend\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003ehash\u003c/span\u003e $uri;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver1.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver2.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e         \u003cspan style=\"color:#f92672\"\u003eserver\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003eserver3.example.com\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     }\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Nginx实现负载均衡的几种方法"},{"content":"nginx.conf`是 Nginx 服务器的配置文件，用于配置服务器的各种行为和功能。以下是一些常见配置项及其在静态文件服务、反向代理负载均衡、改写请求响应方面的相关用法：\n1. 基本配置块 user：指定运行 Nginx 工作进程的用户和用户组。例如：user nobody nobody;。这在控制 Nginx 进程的权限方面非常重要，确保它只能访问必要的资源。 error_log：设置错误日志的路径和级别。例如：error_log /var/log/nginx/error.log error;，其中error是日志级别，可以是debug、info、notice、warn、error、crit等，用于记录不同严重程度的错误和事件，方便排查问题。 pid：指定 Nginx 进程 ID 文件的路径。例如：pid /var/run/nginx.pid;，这个文件用于存储 Nginx 主进程的进程 ID，在一些管理操作（如重新加载配置、停止 Nginx 等）中会用到。 2. 事件配置块 worker_connections：设置每个工作进程可以同时处理的最大连接数。例如：worker_connections 1024;，这对于调整 Nginx 的并发处理能力很关键，需要根据服务器硬件资源和预期的并发请求量来合理设置。 3. HTTP 配置块（包含静态文件服务、反向代理负载均衡、改写请求响应相关配置） 静态文件服务 server：定义一个虚拟服务器，在其中可以配置多location块来处理不同的请求路径。 server_name：指定服务器的域名或 IP 地址，用于匹配客户端请求的主机头。例如：server_name example.com www.example.com;，这样 Nginx 就知道哪些请求应该由这个虚拟服务器来处理。 location：配置请求的路径匹配规则。 对于静态文件服务，例如将/static/路径下的请求映射到服务器上的/var/www/static/目录下的静态文件，可以这样配置： location /static/ { root /var/www; autoindex on; # 开启目录浏览（可选） } root指令指定了静态文件的根目录，Nginx 会在这个目录下查找与请求路径相对应的文件。如果启用了autoindex，当客户端访问该目录时，会显示目录中的文件列表（在某些情况下可能需要谨慎使用，避免暴露敏感信息）。\n反向代理负载均衡 upstream：定义后端服务器集群，给集群一个名称，以便在server块中引用。例如 upstream backend_cluster { server backend1.example.com weight=3; # 分配权重为3 server backend2.example.com; server backend3.example.com down; # 标记为不可用（临时下线） } 这里配置了一个名为backend_cluster的后端服务器集群，包含三个后端服务器。可以通过weight参数设置每个服务器的权重，权重越高，分配到的请求比例就越大；down参数用于标记服务器暂时不可用，Nginx 将不会把请求转发到该服务器。\nserver：在server块中使用location和proxy_pass指令将请求反向代理到后端服务器集群。例如： server { listen 80; server_name example.com; location / { proxy_pass http://backend_cluster; proxy_set_header Host $host; # 设置转发请求的Host头 proxy_set_header X-Real-IP $remote_addr; # 设置真实客户端IP头（可选，用于后端获取真实客户端IP） } } 当客户端访问example.com时，请求会被反向代理到backend_cluster定义的后端服务器集群中的某个服务器上，根据负载均衡算法（默认是轮询，可以通过ip_hash等指令修改算法）进行分配。proxy_set_header指令用于设置转发到后端服务器的请求头信息，确保后端服务器能够正确处理请求并获取必要的信息。\n改写请求响应 rewrite：用于改写请求的 URL。例如，将所有以.html结尾的请求重定向到不带.html的路径： location / { rewrite ^(.*)\\.html$ $1 permanent; } 这里的rewrite规则使用正则表达式^(.*)\\.html$匹配以.html结尾的请求路径，并将其重写为去掉.html的路径。permanent表示返回 301 永久重定向状态码给客户端，告诉客户端更新书签等。\nproxy_redirect：用于改写后端服务器返回的响应头中的Location和Refresh字段。例如，如果后端服务器返回的重定向地址是相对路径，而希望在返回给客户端时将其转换为绝对路径，可以这样配置： location / { proxy_pass http://backend; proxy_redirect off; # 关闭默认的重定向处理（如果需要自定义） proxy_redirect http://backend/ /; # 将后端返回的以http://backend/开头的重定向地址转换为以/开头的绝对路径 } 这样可以确保客户端接收到正确的重定向地址，提高用户体验并避免一些潜在的问题。\n4. 其他常见配置项 access_log：设置访问日志的路径和格式。例如：access_log /var/log/nginx/access.log combined;，combined是一种常用的日志格式，记录了客户端 IP、请求时间、请求方法、请求 URL、协议、响应状态码、发送字节数、引用页面等信息，方便分析服务器的访问情况和用户行为。 sendfile：用于开启或关闭高效文件传输模式（sendfile系统调用）。例如：sendfile on;，在提供静态文件服务时，开启sendfile可以提高文件传输效率，减少数据在内核空间和用户空间之间的拷贝次数。 keepalive_timeout：设置长连接的超时时间。例如：keepalive_timeout 65;，当客户端与服务器建立长连接后，如果在这个时间内没有新的请求，连接将被关闭。合理设置这个值可以在一定程度上提高性能，减少连接建立和关闭的开销，但也需要根据实际情况平衡服务器资源和客户端连接的管理。 ","permalink":"https://gopherding.github.io/posts/tech/nginx.conf%E7%9A%84%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E9%A1%B9/","summary":"\u003cp\u003enginx.conf`是 Nginx 服务器的配置文件，用于配置服务器的各种行为和功能。以下是一些常见配置项及其在静态文件服务、反向代理负载均衡、改写请求响应方面的相关用法：\u003c/p\u003e\n\u003ch3 id=\"1-基本配置块\"\u003e1. 基本配置块\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003euser\u003c/code\u003e\u003c/strong\u003e：指定运行 Nginx 工作进程的用户和用户组。例如：\u003ccode\u003euser nobody nobody;\u003c/code\u003e。这在控制 Nginx 进程的权限方面非常重要，确保它只能访问必要的资源。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eerror_log\u003c/code\u003e\u003c/strong\u003e：设置错误日志的路径和级别。例如：\u003ccode\u003eerror_log /var/log/nginx/error.log error;\u003c/code\u003e，其中\u003ccode\u003eerror\u003c/code\u003e是日志级别，可以是\u003ccode\u003edebug\u003c/code\u003e、\u003ccode\u003einfo\u003c/code\u003e、\u003ccode\u003enotice\u003c/code\u003e、\u003ccode\u003ewarn\u003c/code\u003e、\u003ccode\u003eerror\u003c/code\u003e、\u003ccode\u003ecrit\u003c/code\u003e等，用于记录不同严重程度的错误和事件，方便排查问题。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003epid\u003c/code\u003e\u003c/strong\u003e：指定 Nginx 进程 ID 文件的路径。例如：\u003ccode\u003epid /var/run/nginx.pid;\u003c/code\u003e，这个文件用于存储 Nginx 主进程的进程 ID，在一些管理操作（如重新加载配置、停止 Nginx 等）中会用到。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-事件配置块\"\u003e2. 事件配置块\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eworker_connections\u003c/code\u003e\u003c/strong\u003e：设置每个工作进程可以同时处理的最大连接数。例如：\u003ccode\u003eworker_connections 1024;\u003c/code\u003e，这对于调整 Nginx 的并发处理能力很关键，需要根据服务器硬件资源和预期的并发请求量来合理设置。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3-http-配置块包含静态文件服务反向代理负载均衡改写请求响应相关配置\"\u003e3. HTTP 配置块（包含静态文件服务、反向代理负载均衡、改写请求响应相关配置）\u003c/h3\u003e\n\u003ch4 id=\"静态文件服务\"\u003e静态文件服务\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eserver\u003c/code\u003e：定义一个虚拟服务器，在其中可以配置多location块来处理不同的请求路径。\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eserver_name\u003c/code\u003e\u003c/strong\u003e：指定服务器的域名或 IP 地址，用于匹配客户端请求的主机头。例如：\u003ccode\u003eserver_name example.com www.example.com;\u003c/code\u003e，这样 Nginx 就知道哪些请求应该由这个虚拟服务器来处理。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocation\u003c/code\u003e：配置请求的路径匹配规则。\n\u003cul\u003e\n\u003cli\u003e对于静态文件服务，例如将\u003ccode\u003e/static/\u003c/code\u003e路径下的请求映射到服务器上的\u003ccode\u003e/var/www/static/\u003c/code\u003e目录下的静态文件，可以这样配置：\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-nginx\" data-lang=\"nginx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003elocation\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e/static/\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003eroot\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e/var/www\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003eautoindex\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eon\u003c/span\u003e;  \u003cspan style=\"color:#75715e\"\u003e# 开启目录浏览（可选）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eroot\u003c/code\u003e指令指定了静态文件的根目录，Nginx 会在这个目录下查找与请求路径相对应的文件。如果启用了\u003ccode\u003eautoindex\u003c/code\u003e，当客户端访问该目录时，会显示目录中的文件列表（在某些情况下可能需要谨慎使用，避免暴露敏感信息）。\u003c/p\u003e","title":"Nginx.conf的常见配置项"},{"content":"细说\nmerge 会对提交历史进行保留，很显然更适合多人协作开发的场景，因为如果出现问题也可以追溯到历史的每一次提交。\n而 rebase 则是会让提交历史更加简洁易读，保持提交历史的线性结构，所以更适合个人开发和整理分支的情况。\n如果我想要把某个特性分支 feature_xxx 合并到 main 分支中的时候，最好的方式就是 merge，而当我一个人需要开发某个 feature_xxx 分支的时候，最好的方式就是 rebase。\ngit rebase 的黄金法则是：永远不要在公共分支上使用它！\n一句话概括就是：merge 适合团队协作，而 rebase 适合一个人开发的分支。\n","permalink":"https://gopherding.github.io/posts/tech/git-merge%E5%92%8Crebase/","summary":"\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/686538265\"\u003e细说\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003emerge\u003c/strong\u003e 会对提交历史进行保留，很显然\u003cstrong\u003e更适合多人协作开发的场景\u003c/strong\u003e，因为如果出现问题也可以追溯到历史的每一次提交。\u003c/p\u003e\n\u003cp\u003e而 \u003cstrong\u003erebase\u003c/strong\u003e 则是会让提交历史更加简洁易读，保持提交历史的线性结构，所以\u003cstrong\u003e更适合个人开发和整理分支的情况。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e如果我想要把某个特性分支 feature_xxx 合并到 main 分支中的时候，最好的方式就是 merge，而当我一个人需要开发某个 feature_xxx 分支的时候，最好的方式就是 rebase。\u003c/p\u003e","title":"Git:merge or rebase?"},{"content":" \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 命令分类 命令 描述 初始化 git init 在当前目录创建一个新的 Git 仓库。 克隆仓库 git clone [url] 从远程仓库克隆到本地。 添加文件 git add [file directory] 添加文件，将文件或目录添加到暂存区。 提交更改 git commit -m \u0026quot;message\u0026quot; 将暂存区的内容提交到本地仓库，同时附上提交信息。 查看状态 git status 显示工作区和暂存区的状态。 查看日志 git log 查看提交历史记录。 分支操作 git branch 列出本地分支。 git branch [branch-name] 创建一个新分支。 git checkout [branch-name] 切换到指定分支。 git merge [branch-name] 将指定分支合并到当前分支。 远程仓库 git remote add [name] [url] 添加一个远程仓库。 git push [remote-name] [branch-name] 将本地指定分支推送到远程仓库对应的分支。如果远程分支不存在，会自动创建。例如，git push origin master 将本地的 master 分支推送到名为 origin 的远程仓库的 master 分支。 git push --set-upstream [remote-name] [branch-name] 首次推送一个新分支到远程仓库并建立跟踪关系。 git push -f [remote-name] [branch-name] 强制推送，覆盖远程分支的内容。一般不建议常规使用，除非确定了解其后果。 拉取操作 git pull [remote-name] [branch-name] 从远程仓库拉取最新的更改并合并到当前分支。 比较差异 git diff 显示工作区和暂存区的差异。 git diff --staged 显示暂存区和上一次提交的差异。 git diff [branch1] [branch2] 比较两个分支的差异。 撤销操作 git reset git revert [commit] 创建一个新的提交来撤销指定的提交。 标签操作 git tag [tag-name] 给当前提交打标签。 git tag -a [tag-name] -m \u0026quot;message\u0026quot; 创建带注释的标签。 git push [remote-name] [tag-name] 将标签推送到远程仓库。 配置信息 git config --global user.name \u0026quot;your name\u0026quot; 设置全局用户名。 git config --global user.email \u0026quot;your email\u0026quot; 设置全局用户邮箱。 git config --list 查看所有配置信息。 ","permalink":"https://gopherding.github.io/posts/tech/git%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/","summary":"\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e命令分类\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e命令\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e描述\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e初始化\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit init\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e在当前目录创建一个新的 Git 仓库。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e克隆仓库\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit clone [url]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e从远程仓库克隆到本地。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e添加文件\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit add [file directory]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e添加文件，将文件或目录添加到暂存区。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e提交更改\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit commit -m \u0026quot;message\u0026quot;\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e将暂存区的内容提交到本地仓库，同时附上提交信息。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e查看状态\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit status\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e显示工作区和暂存区的状态。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e查看日志\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit log\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e查看提交历史记录。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e分支操作\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit branch\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e列出本地分支。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit branch [branch-name]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e创建一个新分支。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit checkout [branch-name]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e切换到指定分支。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit merge [branch-name]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e将指定分支合并到当前分支。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e远程仓库\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit remote add [name] [url]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e添加一个远程仓库。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit push [remote-name] [branch-name]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e将本地指定分支推送到远程仓库对应的分支。如果远程分支不存在，会自动创建。例如，\u003ccode\u003egit push origin master\u003c/code\u003e 将本地的 \u003ccode\u003emaster\u003c/code\u003e 分支推送到名为 \u003ccode\u003eorigin\u003c/code\u003e 的远程仓库的 \u003ccode\u003emaster\u003c/code\u003e 分支。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit push --set-upstream [remote-name] [branch-name]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e首次推送一个新分支到远程仓库并建立跟踪关系。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit push -f [remote-name] [branch-name]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e强制推送，覆盖远程分支的内容。一般不建议常规使用，除非确定了解其后果。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e拉取操作\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit pull [remote-name] [branch-name]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e从远程仓库拉取最新的更改并合并到当前分支。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e比较差异\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit diff\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e显示工作区和暂存区的差异。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit diff --staged\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e显示暂存区和上一次提交的差异。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit diff [branch1] [branch2]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e比较两个分支的差异。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e撤销操作\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit reset \u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit revert [commit]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e创建一个新的提交来撤销指定的提交。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e标签操作\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit tag [tag-name]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e给当前提交打标签。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit tag -a [tag-name] -m \u0026quot;message\u0026quot;\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e创建带注释的标签。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit push [remote-name] [tag-name]\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e将标签推送到远程仓库。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e配置信息\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit config --global user.name \u0026quot;your name\u0026quot;\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e设置全局用户名。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit config --global user.email \u0026quot;your email\u0026quot;\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e设置全局用户邮箱。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003egit config --list\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e查看所有配置信息。\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Git命令速查表"},{"content":"英语课，讲翻译，虽没听课，感触颇深，夜晚难以入眠，听着不远处“拖拉机们”（狗头保命）于梦中“呼呼”耕耘，便想到了下面的话：\nFainter, dimmer, stiller each moment.Now night.\n——Night.by Max Webber\n我欲“仿”之，原诗可押t韵，而无论dawn或是morn的n我都押不住，因为找不见合适的单词，哎嘿,,Ծ^Ծ,,\nWhisper, louder, stronger each hour.Now morn.\n——Morn.by George Ding\n嘿咻休，up emo go！\n于是又想起初见此诗(原诗)应是高一，某本褐绿书，前言还有甚么“我的我要爆了”，进而了解信达雅，遂对翻译感兴趣——多少诗是因为翻译而流传于世的啊！\n啧啧，\n小小英短诗，堪堪七八字。\n了无辜正坤，谁人又有知？\n由是方才始知翻译实在是大智慧！\n于是又感激起我可爱又“可恶”的“拖拉机们”——不过近日油价上涨，还是要少“呼呼呼”为妙。\n附：辜先生的译文是：一刻比一刻缥缈、晦暗、安宁，于是夜来临。\n于二零二二年四月十日\n","permalink":"https://gopherding.github.io/posts/life/%E8%8B%B1%E8%AF%AD%E8%AF%BE%E8%B5%B0%E7%A5%9E%E4%B8%80%E5%88%99/","summary":"\u003cp\u003e英语课，讲翻译，虽没听课，感触颇深，夜晚难以入眠，听着不远处“拖拉机们”（狗头保命）于梦中“呼呼”耕耘，便想到了下面的话：\u003c/p\u003e\n\u003cp\u003eFainter, dimmer, stiller each moment.Now night.\u003c/p\u003e\n\u003cp\u003e——Night.by Max Webber\u003c/p\u003e\n\u003cp\u003e我欲“仿”之，原诗可押t韵，而无论dawn或是morn的n我都押不住，因为找不见合适的单词，哎嘿,,Ծ^Ծ,,\u003c/p\u003e\n\u003cp\u003eWhisper, louder, stronger each hour.Now morn.\u003c/p\u003e\n\u003cp\u003e——Morn.by George Ding\u003c/p\u003e","title":"英语课走神一则"},{"content":"实现细节： 看看大佬：\nmheap：全局的内存起源，访问要加全局锁 mcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内 mcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁 附：分点阐述 mspan 的特质： mspan 是 Golang 内存管理的最小单元 mspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样） 每个 mspan 根据空间大小以及面向分配对象的大小，会被划分为不同的等级（2.2小节展开） 同等级的 mspan 会从属同一个 mcentral，最终会被组织成链表，因此带有前后指针（prev、next） 由于同等级的 mspan 内聚于同一个 mcentral，所以会基于同一把互斥锁管理 mspan 会基于 bitMap 辅助快速找到空闲内存块（块大小为对应等级下的 object 大小），此时需要使用到 Ctz64 算法. 宏观描述： 另一个大佬：\n（一）Page 和TCMalloc中page相同，上图中最下方浅蓝色长方形代表一个page。\n（二）Span 与TCMalloc中的Span相同，Span是go内存管理的基本单位，代码中为mspan，一组连续的Page组成1个Span，所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span，另外，1个淡紫色长方形为1个Span。\n（三）mcache mcache与TCMalloc中的ThreadCache类似，mcache保存的是各种大小的Span，并按Span class分类，小对象直接从mcache分配内存，它起到了缓存的作用，并且可以无锁访问。\n（四）mcentral mcentral与TCMalloc中的CentralCache类似，是所有线程共享的缓存，需要加锁访问，它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。但mcentral与CentralCache也有不同点，CentralCache是每个级别的Span有1个链表，mcache是每个级别的Span有2个链表。\n（五）mheap mheap与TCMalloc中的PageHeap类似，它是堆内存的抽象，把从OS（系统）申请出的内存页组织成Span，并保存起来。当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。但mheap与PageHeap也有不同点：mheap把Span组织成了树结构，而不是链表，并且还是2棵树，然后把Span分配到heapArena进行管理，它包含地址映射和span是否包含指针等位图，这样做的主要原因是为了更高效的利用内存：分配、回收和再利用。\nGo的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。\n大体上的分配流程：\n32KB 的对象，直接从mheap上分配；\n\u0026lt;=16B 的对象使用mcache的tiny分配器分配； (16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配； 如果mcache没有相应规格大小的mspan，则向mcentral申请 如果mcentral没有相应规格大小的mspan，则向mheap申请 如果mheap中也没有合适大小的mspan，则向操作系统申请\n总结 Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。 Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。 mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。 极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。\n","permalink":"https://gopherding.github.io/posts/tech/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/","summary":"\u003ch3 id=\"实现细节\"\u003e实现细节：\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s/2TBwpQT5-zU4Gy7-i0LZmQ\"\u003e看看大佬：\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/go%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b.png\" alt=\"go内存模型\"  /\u003e\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emheap：全局的内存起源，访问要加全局锁\u003c/li\u003e\n\u003cli\u003emcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内\u003c/li\u003e\n\u003cli\u003emcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"附分点阐述-mspan-的特质\"\u003e附：分点阐述 mspan 的特质：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003emspan 是 Golang 内存管理的最小单元\u003c/li\u003e\n\u003cli\u003emspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样）\u003c/li\u003e\n\u003cli\u003e每个 mspan 根据空间大小以及面向分配对象的大小，会被划分为不同的等级（2.2小节展开）\u003c/li\u003e\n\u003cli\u003e同等级的 mspan 会从属同一个 mcentral，最终会被组织成链表，因此带有前后指针（prev、next）\u003c/li\u003e\n\u003cli\u003e由于同等级的 mspan 内聚于同一个 mcentral，所以会基于同一把互斥锁管理\u003c/li\u003e\n\u003cli\u003emspan 会基于 bitMap 辅助快速找到空闲内存块（块大小为对应等级下的 object 大小），此时需要使用到 Ctz64 算法.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"宏观描述\"\u003e宏观描述：\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://cloud.tencent.com/developer/article/2051585\"\u003e另一个大佬：\u003c/a\u003e\u003c/p\u003e","title":"Golang内存模型与分配机制"},{"content":" := 不支持声明全局变量，作用域为局部变量。\niota，默认值为0，每行的iota都会累加1。\nGolang的自增自减\u0026rsquo;++\u0026rsquo; \u0026lsquo;\u0026ndash;\u0026lsquo;是语句而非表达式\na := 1 a ++ // 注意：不能写成 ++ a 或 -- a 必须放在右边使用 // b := a++ // 此处为错误的用法，不能写在一行，要单独作为语句使用 对外函数的函数名应该首字母大写，否则外部包无法调用该函数（类、属性亦然）。\n在包中，任何顶级声明前面的注释都将作为该声明的文档注释。在程序中，每个可导出（首字母大写）的名称都应该有文档注释。\n包应当以小写的单个单词来命名，不能使用下划线或驼峰。\nimport _ \u0026ldquo;fmt\u0026rdquo; : 给包起匿名别名，无法调用该包的方法但是可以执行当前包内部的init()方法，此即为副作用而导入。\nimport . \u0026ldquo;fmt\u0026rdquo; ：将当前包的全部方法导入到当前包的作用中，fmt包中的全部方法可以直接使用API调用，不需要使用fmt.API来调用。\ndefer执行顺序：先写的defer先入栈（代码行在上部的先入栈），然后先进后出，后出栈。\ndefer和return的先后顺序：return语句先执行，当该函数体执行完毕后（当前作用域内），defer语句执行。这是由于在Go语言中，return 语句不是原子操作，分为赋值，和返回值两步操作，最先是所有结果值在进入函数时都会初始化为其类型的零值（姑且称为ret赋值），然后执行defer命令,最后才是return操作。如果是有名返回值，返回值变量其实可视为是引用赋值，可以能被defer修改。而在匿名返回值时，给ret的值相当于拷贝赋值，defer命令时不能直接修改。return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。\ndefer延迟调用与闭包：defer 调用会在当前函数执行结束前才被执行，这些调用被称为延迟调用。defer 中使用的匿名函数也是一个闭包。重要的是：当defer被声明时，其参数就会被实时解析。\nfunc func1() { a := 1 defer func(r int) { fmt.Println(r) }(a) a = a + 100 fmt.Println(a) } func func2() { a := 1 defer func() { fmt.Println(a) }() a = a + 100 fmt.Println(a) } func1输出结果：\n$go run main.go 101 1 func2输出结果\n$go run main.go 101 101 两个函数的差异在于，func1中的defer定义时就将a=1赋值给了defer，在执行defer函数时执行时用的a是在定义时对a的拷贝并非当前环境变量中的a值，即defer执行的是:\nfunc (r int) { fmt.Println(r) }(1) 而在func2中,在defer定义时并没有完成任何赋值动作，只是注册了在执行完成后调用的函数，使用的a变量是当前环境的变量。\n函数调用时，引用类型（slice, map, interface, channel）都默认使用传递指针的值传递——只是功能类似于引用传递罢了。详见Go语言引用传递与值传递\n在Go中，结构体是一种聚合的数据类型，它包含零个或多个任意类型的值作为成员。由于结构体是值类型，当将一个结构体变量赋值给另一个变量时，会创建一个新的结构体实例，并将原始结构体的值拷贝给新实例。这意味着两个结构体变量将拥有独立的副本，对其中一个变量的修改不会影响另一个变量。\n匿名函数的快速执行：\nfunc(){ fmt.println(\u0026#34;Hello\u0026#34;) }() //这里加上()是定义并执行函数 闭包：简单来说，闭包 = 函数 + 引用环境\nslice动态数组对其传递可以修改原slice数据是因为使用了slice这个引用类型的指针进行的传递，是值传递（传递指针）而不是引用传递——GO只存在值传递——map类型亦是如此。slice能够通过函数传参后，修改对应的数组值，是因为 slice 内部保存了引用数组的指针，并不是因为引用传递。\n固定长度的数组在传参的时候是严格匹配数据类型的，e.g:[10]int的参数无法传到[5]int中，反之亦然，因为数组的大小是其类型的一部分。\nvar slice []int : 声明slice是一个切片，但是没有给其分配空间，修改其内部元素会报错index out；\n可以通过\nslice = make ([]int, 3) 来分配空间—— 一般通过\nslice := make([]int, 3) 来声明一个切片并开辟内存空间。\n切片保存了对底层数组的引用，若你将切片赋予另一个切片，它们会引用同一个数组。\nvar slice = make([]int, len, cap) ：长度为len，容量为cap;\nslice := arr[startIndex : endIndex] : 初始化切片slice为数组arr的引用。\nslice中的len表示数组空间内存在有效值的数组长度，cap表示这个底层数组空间的大小，当len达到cap时，cap自动扩容一倍；在修改切片中的元素时，需要确保索引不超出切片的长度len范围。\n如果期望容量大于当前容量的两倍就会使用期望容量； 如果当前切片的长度小于阈值（默认 256）就会将容量翻倍； 如果当前切片的长度大于等于阈值（默认 256），就会每次增加 25% 的容量，基准是 newcap + 3*threshold，直到新容量大于期望容量；\n切片截取：slice[x : y] : 截取从索引x（包含）到索引y（不包含）。\n使用 copy 函数要注意对于 copy(dst, src)，要初始化 dst 的 len，否则无法复制。\n切片就像数组的引用 切片并不存储任何数据，它只是描述了底层数组中的一段，更改切片的元素会修改其底层数组中对应的元素，和它共享底层数组的切片都会观测到这些修改。\nvar myMap map[int] string : 声明myMap是一种map类型，key是int型，value是string型，但是没有分配内存空间；\n可以通过myMap = make(map[int]string, 10)来分配空间——一般通过\nmyMap := make(map[int]string) myMap2[1] = \u0026#34;java\u0026#34; myMap2[2] = \u0026#34;c++\u0026#34; myMap2[3] = \u0026#34;python\u0026#34; //或者 myMap := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;c++\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;python\u0026#34;, } 来进行声明+初始化。\n哪些数据结构可以作为map的key？\n具有可比较性：键的类型必须支持相等性比较；\n可哈希性:键的类型必须支持哈希计算；\n通常使用整数、字符串、浮点数、指针等基本类型作为 map 的键；\n切片和函数不支持比较，不能用作map的键。\n结构体指针：结构体调用成员变量可以使用 变量名.成员名、指针名.成员名 都可以，直接用指针名.成员名的方式，修改原地址的值。\nGo 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口——鸭子类型。\n只包含一个方法的接口应当以该方法的名称加上 -er 后缀来命名。\nGo没有显式的继承，而是通过组合实现继承，内嵌一个（或多个）包含想要的行为（字段和方法）的结构体；多重继承可以通过内嵌多个结构体实现。\n所有的类型包括自定义类型都实现了空接口interface{}，所以空接口interface{}可以被当做任意类型的数值/万能数据类型。\n类型断言用于将接口类型转换为指定类型，其语法为：\nvalue.(type) 或者 value.(T) str, ok := value.(string) 其中 value 是接口类型的变量，type 或 T 是要转换成的类型。\n如果类型断言成功，它将返回转换后的值和一个布尔值，表示转换是否成功；如果断言失败，str将继续存在且为字符串类型，但将拥有零值——即空字符串。\n断言成功的两种情况：两种动态类型是相同的；断言接口值实现了目标接口的所有方法（结构体类型的断言）。\n[对于指针接收器和值接收器方法的一些拙见.md](C:\\Users\\GEORGE DING\\Desktop!\\BLOG\\Golang\\对于指针接收器和值接收器方法的一些拙见.md)\nnew 和 make 均是用于分配内存：new用于值类型的内存分配，并且置为零值。make只用于slice、map以及channel这三种引用数据类型的内存分配和初始化。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。make(T) 它返回类型T的值（不是* T）。\npanic可以在任何地方引发，但是recover只能在defer的函数中有效。recover只能捕获同一goroutine内发生的panic，对于其他goroutine引发的panic无能为力。\n","permalink":"https://gopherding.github.io/posts/tech/golang%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/","summary":"\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e:= 不支持声明全局变量，作用域为局部变量。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eiota，默认值为0，每行的iota都会累加1。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGolang的自增自减\u0026rsquo;++\u0026rsquo; \u0026lsquo;\u0026ndash;\u0026lsquo;是语句而非表达式\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ea\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003ea\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// 注意：不能写成 ++ a 或 -- a 必须放在右边使用\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// b := a++ // 此处为错误的用法，不能写在一行，要单独作为语句使用\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e对外函数的函数名应该首字母大写，否则外部包无法调用该函数（类、属性亦然）。\u003c/p\u003e","title":"Golang学习中遇到的那些坑"},{"content":"Goroutine 单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。 Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过runtime.GOMAXPROCS函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。） Channel 未初始化的通道类型变量其默认零值是nil。\n关闭后的通道有以下特点：\n对一个关闭的通道再发送值就会导致 panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。(此时若不对 value, ok := \u0026lt;- ch 的ok值进行判定，则该通道转化为一个关闭的并且没有值的通道，继续接收则会输出无限0——规则同下) 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致 panic。 使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为同步通道。\n发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。\n单向通道：\n\u0026lt;- chan int // 只接收通道，只能接收不能发送 chan \u0026lt;- int // 只发送通道，只能发送不能接收 //在函数传参及任何赋值操作中全向通道（正常通道）可以转换为单向通道，但是无法反向转换。 如图：![image-20240318204746723](C:\\Users\\GEORGE DING\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240318204746723.png)\n不要在数据接收方或者在有多个发送者的情况下关闭通道\nDon’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.\n如何优雅地关闭channel？\n一个接收者和N个发送者：增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止发送数据。\nM个接收者和N个发送者：引入一个中间调解者角色并让其关闭额外的信号通道来通知所有的接收者和发送者结束工作。\ntype hchan struct { qcount uint // 环形队列中的（缓冲区中的）总元素个数 dataqsiz uint // 环形队列（缓冲区的）容量大小，即可存放元素的个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 //每个元素的大小 closed uint32 //标识关闭状态 elemtype *_type // 元素类型 sendx uint // 发送索引，元素写入时存放到队列中的位置 recvx uint // 接收索引，元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列 sendq waitq // 等待写消息的goroutine队列 lock mutex //互斥锁，chan不允许并发读写 } 我理解的不好，找到个大佬——Golang Channel 的底层原理\n大佬二号：Golang Channel 的底层原理\n大佬三号：深入 Go 并发原语 — Channel 底层实现\n","permalink":"https://gopherding.github.io/posts/tech/goroutinechannel%E4%B8%93%E9%A2%98/","summary":"\u003ch2 id=\"goroutine\"\u003eGoroutine\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。\u003c/li\u003e\n\u003cli\u003eGo运行时的调度器使用\u003ccode\u003eGOMAXPROCS\u003c/code\u003e参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过\u003ccode\u003eruntime.GOMAXPROCS\u003c/code\u003e函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"channel\"\u003eChannel\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e未初始化的通道类型变量其默认零值是\u003ccode\u003enil\u003c/code\u003e。\u003c/p\u003e","title":"Goroutine\u0026Channel专题"},{"content":"Go的编译执行流程主要包括编译和执行两个阶段。 编译阶段：╰(艹皿艹 ) 前端编译：这个阶段的主要任务是将Go源代码转换成抽象语法树（AST, Abstract syntax tree）。首先，词法分析器将源代码转换成token序列，即将代码按关键字、标识符、运算符等分割成单个单元。然后，语法分析器将这些token序列转换成AST，即将代码按照语法规则进行解析，构建出语法树。在构建AST的过程中，还会进行语义分析，检查语法是否合法，例如变量是否被定义等。 后端编译：这个阶段的主要任务是将AST转换成机器码。编译器会将AST转换成中间代码，然后优化这些中间代码，最后生成目标机器能够运行的二进制机器码。\n执行阶段：o(￣┰￣*)ゞ 执行阶段则直接运行编译阶段生成的机器码。当程序被加载到内存中并执行时，CPU会按照机器码中的指令执行相应的操作，从而完成程序的功能。\n总的来说，Go的编译执行流程是一个典型的编译型语言的流程，先通过编译器将源代码转换成机器码，然后再由执行器执行这些机器码。在这个过程中，编译器会进行一系列的优化操作，以提高程序的运行效率。\ngo build之后发生了甚么事？😁 创建临时目录，mkdir -p $WORK/b001/ 查找依赖信息，cat \u0026gt;$WORK/b001/importcfg \u0026laquo; \u0026hellip; 执行源代码编译，/usr/local/go/pkg/tool/darwin_amd64/compile \u0026hellip; 收集链接库文件，cat \u0026gt;$WORK/b001/importcfg.link \u0026laquo; \u0026hellip; 生成可执行文件，/usr/local/go/pkg/tool/darwin_amd64/link -o \u0026hellip; 移动可执行文件，mv $WORK/b001/exe/a.out hello go run后又发生了甚么事？😀 与build不同的是，在link生成hello文件后，并没有把它移动到当前目录，而是通过$WORK/b001/exe/hello执行了程序。\n","permalink":"https://gopherding.github.io/posts/tech/go%E7%9A%84%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","summary":"\u003ch3 id=\"go的编译执行流程主要包括编译和执行两个阶段\"\u003eGo的编译执行流程主要包括编译和执行两个阶段。\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003ch4 id=\"编译阶段艹皿艹-\"\u003e编译阶段：╰(艹皿艹 )\u003c/h4\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e前端编译：这个阶段的主要任务是将Go源代码转换成抽象语法树（AST, Abstract syntax tree）。首先，词法分析器将源代码转换成token序列，即将代码按关键字、标识符、运算符等分割成单个单元。然后，语法分析器将这些token序列转换成AST，即将代码按照语法规则进行解析，构建出语法树。在构建AST的过程中，还会进行语义分析，检查语法是否合法，例如变量是否被定义等。\n后端编译：这个阶段的主要任务是将AST转换成机器码。编译器会将AST转换成中间代码，然后优化这些中间代码，最后生成目标机器能够运行的二进制机器码。\u003c/p\u003e","title":"Go的编译执行流程"},{"content":"Sonnet 73 By William Shakespeare\nThat time of year thou mayst in me behold\nWhen yellow leaves, or none, or few, do hang\nUpon those boughs which shake against the cold,\nBare ruin\u0026rsquo;d choirs, where late the sweet birds sang.\nIn me thou see\u0026rsquo;st the twilight of such day\nAs after sunset fadeth in the west,\nWhich by and by black night doth take away,\nDeath\u0026rsquo;s second self, that seals up all in rest.\nIn me thou see\u0026rsquo;st the glowing of such fire\nThat on the ashes of his youth doth lie,\nAs the death-bed whereon it must expire,\nConsum\u0026rsquo;d with that which it was nourish\u0026rsquo;d by.\nThis thou perceiv\u0026rsquo;st, which makes thy love more strong,\nTo love that well which thou must leave ere long.\n","permalink":"https://gopherding.github.io/posts/read/sonnet-73/","summary":"\u003ch3 id=\"sonnet-73\"\u003eSonnet 73\u003c/h3\u003e\n\u003cp\u003eBy \u003ca href=\"https://www.poetryfoundation.org/poets/william-shakespeare\"\u003eWilliam Shakespeare\u003c/a\u003e\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eThat time of year thou mayst in me behold\u003c/p\u003e\n\u003cp\u003eWhen yellow leaves, or none, or few, do hang\u003c/p\u003e\n\u003cp\u003eUpon those boughs which shake against the cold,\u003c/p\u003e\n\u003cp\u003eBare ruin\u0026rsquo;d choirs, where late the sweet birds sang.\u003c/p\u003e\n\u003cp\u003eIn me thou see\u0026rsquo;st the twilight of such day\u003c/p\u003e\n\u003cp\u003eAs after sunset fadeth in the west,\u003c/p\u003e\n\u003cp\u003eWhich by and by black night doth take away,\u003c/p\u003e\n\u003cp\u003eDeath\u0026rsquo;s second self, that seals up all in rest.\u003c/p\u003e\n\u003cp\u003eIn me thou see\u0026rsquo;st the glowing of such fire\u003c/p\u003e\n\u003cp\u003eThat on the ashes of his youth doth lie,\u003c/p\u003e\n\u003cp\u003eAs the death-bed whereon it must expire,\u003c/p\u003e\n\u003cp\u003eConsum\u0026rsquo;d with that which it was nourish\u0026rsquo;d by.\u003c/p\u003e\n\u003cp\u003eThis thou perceiv\u0026rsquo;st, which makes thy love more strong,\u003c/p\u003e\n\u003cp\u003eTo love that well which thou must leave ere long.\u003c/p\u003e","title":"Sonnet 73"},{"content":"索引下推： ​ 索引下推（Index Condition Pushdown）是数据库查询优化的一种技术，通常用于处理包含过滤条件的查询语句。它的原理是在使用索引进行查询时，将查询的过滤条件也应用到索引查找过程中，以减少需要读取和处理的数据量，从而提高查询性能。\n索引下推是MySQL5.6推出来的一个查询优化方案，主要的目的是减少数据库中不必要的数据读取和计算。\n索引下推的原理是尽可能把查寻条件推到索引层面进行过滤，减少从磁盘读取的数据量。\n索引覆盖： ​ 索引覆盖（Index Covering）是指一个查询可以完全通过索引来执行，而无需访问实际的数据行。在数据库中，通常查询语句包含了一系列的条件，这些条件用于筛选出符合特定条件的数据行。如果这些条件能够通过索引直接定位到符合条件的数据行，而无需访问实际的数据页，那么就称为索引覆盖。\n比如我们有这样一条SQL语句：\nselect name,age,level from user where name = \u0026#34;AAA\u0026#34; and age 17 那么我们就可以把目标查询内容设置成为索引\nkey idx_nal (name,age,level) using btree 那么这样的话，我们在搜索的时候，只需要通过索引就能够拿到我们需要的全部数据了。这样就避免了回表。\n索引覆盖注意事项：\n1.如果一个索引包含了需要查询的所有字段，那么这个索引就是覆盖索引。\n2.MySQL 只能使用B+Tree索引做覆盖索引，因为只有B+树能存储索引列值。\n","permalink":"https://gopherding.github.io/posts/tech/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E5%92%8C%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/","summary":"\u003ch3 id=\"索引下推\"\u003e\u003cstrong\u003e索引下推：\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e​        索引下推（Index Condition Pushdown）是数据库查询优化的一种技术，通常用于处理包含过滤条件的查询语句。它的原理是在使用索引进行查询时，将查询的过滤条件也应用到索引查找过程中，以减少需要读取和处理的数据量，从而提高查询性能。\u003c/p\u003e\n\u003cp\u003e索引下推是MySQL5.6推出来的一个查询优化方案，主要的目的是减少数据库中不必要的数据读取和计算。\u003c/p\u003e","title":"索引下推和覆盖索引"},{"content":"辛丑年九月十一日，黄昏，余忆旧事，睹故人，秋风寂寥，感生之须臾，岁月之无声。欲仿骚体，然学艺不精，故只略合其形；音韵种种，皆不仿古律，望先圣毋怪尔……\n噫！\n邃宇兮，隳天空空。\n窘步臲卼兮，星烁堂中。\n岁月浇荒季兮，羁我清风。\n遒宙于目兮，却似朦胧。\n溟濛兮，行色匆匆。\n惚！\n自当匆匆！！！\n—— 作于四起泠风中\n于二零二一年十月十六日\n","permalink":"https://gopherding.github.io/posts/life/%E6%B3%A0%E9%A3%8E%E5%9B%9B%E8%B5%B7%E5%9B%9B%E8%B5%B7%E6%B3%A0%E9%A3%8E/","summary":"\u003cp\u003e辛丑年九月十一日，黄昏，余忆旧事，睹故人，秋风寂寥，感生之须臾，岁月之无声。欲仿骚体，然学艺不精，故只略合其形；音韵种种，皆不仿古律，望先圣毋怪尔……\u003c/p\u003e\n\u003cp\u003e噫！\u003c/p\u003e\n\u003cp\u003e邃宇兮，隳天空空。\u003c/p\u003e\n\u003cp\u003e窘步臲卼兮，星烁堂中。\u003c/p\u003e\n\u003cp\u003e岁月浇荒季兮，羁我清风。\u003c/p\u003e\n\u003cp\u003e遒宙于目兮，却似朦胧。\u003c/p\u003e\n\u003cp\u003e溟濛兮，行色匆匆。\u003c/p\u003e\n\u003cp\u003e惚！\u003c/p\u003e\n\u003cp\u003e自当匆匆！！！\u003c/p\u003e\n\u003cp\u003e—— 作于四起泠风中\u003c/p\u003e\n\u003cp\u003e于二零二一年十月十六日\u003c/p\u003e","title":"‘泠风四起，四起泠风’"},{"content":"Sonnet 18: Shall I compare thee to a summer’s day? By William Shakespeare\nShall I compare thee to a summer’s day?\nThou art more lovely and more temperate:\nRough winds do shake the darling buds of May,\nAnd summer’s lease hath all too short a date;\nSometime too hot the eye of heaven shines,\nAnd often is his gold complexion dimm\u0026rsquo;d;\nAnd every fair from fair sometime declines,\nBy chance or nature’s changing course untrimm\u0026rsquo;d;\nBut thy eternal summer shall not fade,\nNor lose possession of that fair thou ow’st;\nNor shall death brag thou wander’st in his shade,\nWhen in eternal lines to time thou grow’st:\nSo long as men can breathe or eyes can see,\nSo long lives this, and this gives life to thee.\n","permalink":"https://gopherding.github.io/posts/read/sonnet-18/","summary":"\u003ch3 id=\"sonnet-18-shall-i-compare-thee-to-a-summers-day\"\u003eSonnet 18: Shall I compare thee to a summer’s day?\u003c/h3\u003e\n\u003cp\u003eBy \u003ca href=\"https://www.poetryfoundation.org/poets/william-shakespeare\"\u003eWilliam Shakespeare\u003c/a\u003e\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003eShall I compare thee to a summer’s day?\u003c/p\u003e\n\u003cp\u003eThou art more lovely and more temperate:\u003c/p\u003e\n\u003cp\u003eRough winds do shake the darling buds of May,\u003c/p\u003e\n\u003cp\u003eAnd summer’s lease hath all too short a date;\u003c/p\u003e\n\u003cp\u003eSometime too hot the eye of heaven shines,\u003c/p\u003e\n\u003cp\u003eAnd often is his gold complexion dimm\u0026rsquo;d;\u003c/p\u003e\n\u003cp\u003eAnd every fair from fair sometime declines,\u003c/p\u003e\n\u003cp\u003eBy chance or nature’s changing course untrimm\u0026rsquo;d;\u003c/p\u003e\n\u003cp\u003eBut thy eternal summer shall not fade,\u003c/p\u003e\n\u003cp\u003eNor lose possession of that fair thou ow’st;\u003c/p\u003e\n\u003cp\u003eNor shall death brag thou wander’st in his shade,\u003c/p\u003e\n\u003cp\u003eWhen in eternal lines to time thou grow’st:\u003c/p\u003e","title":"Sonnet 18"},{"content":"病梅馆记 清· 龚自珍\n​\t江宁之龙蟠，苏州之邓尉，杭州之西溪，皆产梅。或曰：“梅以曲为美，直则无姿；以欹为美，正则无景；以疏为美，密则无态。”固也。此文人画士，心知其意，未可明诏大号以绳天下之梅也；又不可以使天下之民斫直，删密，锄正，以夭梅病梅为业以求钱也。梅之欹之疏之曲，又非蠢蠢求钱之民能以其智力为也。有以文人画士孤癖之隐明告鬻梅者，斫其正，养其旁条，删其密，夭其稚枝，锄其直，遏其生气，以求重价，而江浙之梅皆病。文人画士之祸之烈至此哉！ 予购三百盆，皆病者，无一完者。既泣之三日，乃誓疗之：纵之顺之，毁其盆，悉埋于地，解其棕缚；以五年为期，必复之全之。予本非文人画士，甘受诟厉，辟病梅之馆以贮之。 呜呼！安得使予多暇日，又多闲田，以广贮江宁、杭州、苏州之病梅，穷予生之光阴以疗梅也哉！\n译文 ​\t江宁的龙蟠里，苏州的邓尉山，杭州的西溪，都出产梅。有人说：\u0026ldquo;梅凭着弯曲的姿态被认为是美丽的，笔直了就没有风姿；凭着枝干倾斜被认为是美丽的，端正了就没有景致；凭着枝叶稀疏被认为是美丽的，茂密了就没有姿态。”本来就如此。（对于）这，文人画家在心里明白它的意思，却不便公开宣告，大声疾呼，用（这种标准）来约束天下的梅。又不能够来让天下种梅人砍掉笔直的枝干、除去繁密的枝条、锄掉端正的枝条，把枝干摧折、使梅花呈病态作为职业来谋求钱财。梅的枝干的倾斜、枝叶的疏朗、枝干的弯曲，又不是那些忙于赚钱的人能够凭借他们的智慧、力量做得到的。有的人把文人画士这隐藏在心中的特别嗜好明白地告诉卖梅的人，（使他们）砍掉端正的（枝干），培养倾斜的侧枝，除去繁密的（枝干），摧折它的嫩枝，锄掉笔直的（枝干），阻碍它的生机，用这样的方法来谋求大价钱，于是江苏、浙江的梅都成病态了。文人画家造成的祸害严重到这个地步啊！　我买了三百盆梅，都是病梅，没有一盆完好的。我已经为它们流了好几天泪之后，于是发誓要治疗它们：我放开它们，使它们顺其自然生长，毁掉那些盆子，把梅全部种在地里，解开捆绑它们棕绳的束缚；把五年作为期限，一定使它们恢复和使它们完好。我本来不是文人画士，心甘情愿受到辱骂，开设一个病梅馆来贮存它们。 唉！怎么能让我有多一些空闲时间，又有多一些空闲的田地，来广泛贮存南京、杭州、苏州的病态的梅树，竭尽我毕生的时间来治疗病梅呢！\n","permalink":"https://gopherding.github.io/posts/read/%E7%97%85%E6%A2%85%E9%A6%86%E8%AE%B0/","summary":"\u003ch3 id=\"病梅馆记\"\u003e病梅馆记\u003c/h3\u003e\n\u003cp\u003e清· 龚自珍\u003c/p\u003e\n\u003cp\u003e​\t\t江宁之龙蟠，苏州之邓尉，杭州之西溪，皆产梅。或曰：“梅以曲为美，直则无姿；以欹为美，正则无景；以疏为美，密则无态。”固也。此文人画士，心知其意，未可明诏大号以绳天下之梅也；又不可以使天下之民斫直，删密，锄正，以夭梅病梅为业以求钱也。梅之欹之疏之曲，又非蠢蠢求钱之民能以其智力为也。有以文人画士孤癖之隐明告鬻梅者，斫其正，养其旁条，删其密，夭其稚枝，锄其直，遏其生气，以求重价，而江浙之梅皆病。文人画士之祸之烈至此哉！ 予购三百盆，皆病者，无一完者。既泣之三日，乃誓疗之：纵之顺之，毁其盆，悉埋于地，解其棕缚；以五年为期，必复之全之。予本非文人画士，甘受诟厉，辟病梅之馆以贮之。 呜呼！安得使予多暇日，又多闲田，以广贮江宁、杭州、苏州之病梅，穷予生之光阴以疗梅也哉！\u003c/p\u003e","title":"病梅馆记"},{"content":"答韦中立论师道书 唐·柳宗元\n二十一日，宗元白：\n辱书云，欲相师。仆道不笃，业甚浅近，环顾其中，未见可师者。虽常好言论，为文章，甚不自是也。不意吾子自京师来蛮夷间，乃幸见取。仆自卜固无取，假令有取，亦不敢为人师。为众人师且不敢，况敢为吾子师乎？\n孟子称“人之患在好为人师”。由魏、晋氏以下，人益不事师。今之世，不闻有师，有辄哗笑之，以为狂人。独韩愈奋不顾流俗，犯笑侮，收召后学，作《师说》，因抗颜而为师。世果群怪聚骂，指目牵引，而增与为言辞。愈以是得狂名，居长安，炊不暇熟，又挈挈而东，如是者数矣。\n屈子赋曰：“邑犬群吠，吠所怪也。”仆往闻庸、蜀之南，恒雨少日，日出则犬吠，余以为过言。前六七年，仆来南，二年冬，幸大雪逾岭，被南越中数州。数州之犬，皆苍黄吠噬，狂走者累日，至无雪乃已，然后始信前所闻者。今韩愈既自以为蜀之日，而吾子又欲使吾为越之雪，不以病乎？非独见病，亦以病吾子。然雪与日岂有过哉？顾吠者犬耳！度今天下不吠者几人，而谁敢炫怪于群目，以召闹取怒乎？\n仆自谪过以来，益少志虑。居南中九年，增脚气病，渐不喜闹。岂可使呶呶者，早暮咈吾耳，骚吾心？则固僵仆烦愦，愈不可过矣。平居，望外遭齿舌不少，独欠为人师耳。\n抑又闻之，古者重冠礼，将以责成人之道，是圣人所尤用心者也。数百年来，人不复行。近有孙昌胤者，独发愤行之。既成礼，明日造朝，至外庭，荐笏，言于卿士曰：“某子冠毕。”应之者咸怃然。京兆尹郑叔则怫然，曳笏却立，曰：“何预我耶？”廷中皆大笑。天下不以非郑尹而快孙子，何哉独为所不为也。今之命师者大类此。\n吾子行厚而辞深，凡所作皆恢恢然有古人形貌；虽仆敢为师，亦何所增加也假而以仆年先吾子，闻道著书之日不後，诚欲往来言所闻，则仆固愿悉陈中所得者。吾子苟自择之，取某事，去某事，则可矣；若定是非以敎吾子，仆才不足，而又畏前所陈者，其为不敢也决矣。吾子前所欲见吾文，既悉以陈之，非以耀明於子，聊欲以观子气色，诚好恶如何也。今书来言者皆大过。吾子诚非佞誉诬谀之徒，直见爱甚故然耳!\n始吾幼且少，为文章，以辞为工。及长，乃知文者以明道，是固不苟为炳炳烺烺，务釆色，夸声音而以为能也。凡吾所陈，皆自谓近道，而不知道之果近乎？远乎？吾子好道而可吾文，或者其於道不远矣。故吾每为文章，未尝敢以轻心掉之，惧其剽而不留也；未尝敢以怠心易之，惧其弛而不严也；未尝敢以昏气出之，惧其昧没而杂也；未尝敢以矜气作之，惧其偃蹇而骄也。抑之欲其奥，扬之欲其明，疏之欲其通，廉之欲其节；激而发之欲其清，固而存之欲其重，此吾所以羽翼夫道也。本之《书》以求其质，本之《诗》以求其恒，本之《礼》以求其宜，本之《春秋》以求其断，本之《易》以求其动：此吾所以取道之原也。参之《谷梁氏》以厉其气，参之《孟》，《荀》以畅其支，参之《庄》，《老》以肆其端，参之《国语》以博其趣，参之《离骚》以致其幽，参之《太史公》以著其洁：此吾所以旁推交通，而以为之文也。凡若此者，果是耶，非耶？有取乎，抑其无取乎？吾子幸观焉，择焉，有余以告焉。苟亟来以广是道，子不有得焉，则我得矣，又何以师云尔哉？取其实而去其名，无招越、蜀吠，而为外廷所笑，则幸矣。宗元复白。\n译文 ​\t二十一日，宗元写：\n​\t承蒙您来信说，想要认我做老师。我的道德修养不深，学识非常浅薄，从各方面审察自己，看不出有值得学习的东西。虽然经常喜欢发些议论，写点文章，但我自己很不以为都是正确的。没有想到您从京城来到偏远的永州，竟幸运地被您取法。我自估量本来就没有什么可取的东西；即使有可取的，也不敢做别人的老师。做一般人的老师尚且不敢，更何况敢做您的老师呢？\n​\t孟子说，“人们的毛病，在于喜欢充当别人的老师。”从魏、晋以来，人们更加不尊奉老师。在当今的时代，没听说还有老师；如果有，人们就会哗然讥笑他，把他看作狂人。只有韩愈奋然不顾时俗，冒着人们的嘲笑侮辱，招收后辈学生，写作《师说》，就严正不屈地当起老师来。世人果然都感到惊怪，相聚咒骂，对他指指点点使眼色，相互拉拉扯扯示意，而且大肆渲染地编造谣言来攻击他。韩愈因此得到了狂人的名声，他住在长安，煮饭都来不及煮熟，又被外放而匆匆忙忙地向东奔去，像这样的情况有好几次了。\n​\t屈原的赋里说：“城镇中的狗成群地乱叫，叫的是它们感到奇怪的东西。”我过去听说庸、蜀的南边，经常下雨，很少出太阳，太阳一出来就会引起狗叫。我以为这是过分夸大的话。六七年前，我来到南方。元和二年的冬天，遇到下大雪，越过了五岭，覆盖了南越的几个州；这几个州的狗，都惊慌地叫着咬着，疯狂奔跑了好几天，直到没有雪了才静止下来，这以后我才相信过去所听说的话。如今韩愈已经把自己当作蜀地的太阳，而您又想使我成为越地的雪，我岂不要因此受到辱骂吗？不仅我会被辱骂，人们也会因此辱骂您。然而雪和太阳难道有罪过吗？只不过感到惊怪而狂叫的是狗罢了。试想当今天下见到奇异的事情不像狗那样乱叫的能有几个人，因而谁又敢在众人眼前显出自己与众不同，来招惹人们的喧闹和恼怒呢？\n​\t我自从被贬官以来，更加意志薄弱，很少思虑。居住南方九年，增添了脚气病（风瘫之类的），渐渐不喜欢喧闹，怎能让那些喧嚣不休的人从早到晚来刺激我的耳朵，扰乱我的心绪？那么必将使我卧病不起，心烦意乱，更不能生活下去了。平时意外地遭受到不少是非口舌，唯独还没有喜欢充当别人老师的罪名罢了。\n​\t我还听说，古代重视冠礼，是借以用成年人做人的道理来要求大家。这是圣人所以特别重视的原因。几百年以来，人们不再举行这种冠礼。近来有个叫孙昌胤的人，独自下决心举行冠礼。冠礼举行过后，第二天去上朝，来到外廷，把笏板插进衣带对大臣们说：“我已经行过冠礼了。”听见这话的人都感到莫名其妙。京兆尹郑叔则却满脸怒气，垂手拖着笏板，退后一步站着，说：“这与我有什么相干呀！”廷中的人都大笑起来。天下的人不因此去责难京兆尹郑叔则，反而嘲笑孙昌胤，这是为什么呢？只是因为孙昌胤做了别人所不做的事。现在被称作老师的人，非常像这种情况。\n​\t您的品行敦厚，文辞高深，凡是您作的文章，都气魄宏大，有古人的风貌；即使我敢做您的老师，对您又有什么帮助呢？假如因为我比您年长，学道、写文章的时间比您早，您确实愿同我往来，交谈彼此所学的东西，那么，我当然愿意向您毫无保留地陈述自己全部的心得，您自己随便加以选择，吸取哪些，扬弃哪些，就可以了。如果要我判定是非来教您，我的才能不够，而且又顾忌前面所说的那些情况，我不敢做您的老师是肯定的。您以前想要看看我的文章，我已经全部陈列给您了，这并不是以此向您炫耀自己，只是姑且想要看看，从您的神情态度上反映出我的文章的确是好是坏。现在您的来信，说的话都对我过奖了。您的确不是那种巧言谄媚假意奉承的人，只不过是特别喜欢我的文章，所以才这样说罢了。\n​\t当初我年轻又不懂事，写文章时把文辞漂亮当作工巧。到了年纪大一些，才知道文章是用来阐明道的，因此不再轻率地讲究形式的美观、追求辞采的华美、炫耀声韵的铿锵、把这些当做自己的才能了。凡是我所呈给您看的文章，都自认为接近于道，但不晓得果真离道近呢，还是远呢？您喜爱道而又赞许我的文章，也许它离道不远了。所以，我每当写文章的时候，从来不敢漫不经心地随便写作，恐怕文章浮滑而不深刻，从来不敢偷懒取巧地写作，恐怕文章松散而不严谨；从来不翦用糊涂不清的态度去写作，恐怕文章晦涩而又杂乱；从来不敢用骄傲的心理去写作，恐怕文章盛气凌人而又狂妄。加以抑制是希望文章含蓄，进行发挥是希望文章明快；加以疏导是希望文气流畅，进行精简是希望文辞凝炼；剔除污浊是希望语言清雅不俗，凝聚保存文气是希望风格庄重不浮。这就是我用文章来辅佐道的方法。学习写作以《尚书》为本原，以求文章质朴无华，以《诗经》为本原，以求文章具有永恒的情理，以《三礼》为本原，以求文章内容合理，以《春秋》为本原，以求文章是非明确、褒贬分明，以《易经》为本原，以求文章能够反映出事物的发展变化。这就是我吸取“道”的源泉的办法。参考《谷梁传》，以加强文章的气势，参考《孟子》、《荀子》，以使文章条理通达，参考《庄子》、《老子》，以使文章汪洋恣肆，参考《国语》，以使文章增强情趣，参考《离骚》，以使文章能够情思幽微，参考《史记》，以使文章显得语言简洁。这就是我用来广泛学习，使它们融会贯通，并运用来写文章的办法。凡是上面所说的这些，到底是对，还是不对呢？有可取的地方呢，还是没有可取的地方呢？希望您看看，进行选择，有空就来信告诉我。如果我们经常往来交谈，以扩充发挥作文之道，即使您不因我的帮助有什么收获，我却因为您的帮助而有所收获，又何必以老师来称呼这种关系呢？采取老师的实质，去掉老师的义，不要招致越地和蜀地的狗的惊怪狂叫，或者象孙昌胤举行冠礼那样遭到人们的嘲笑，那就万幸了。宗元再告。\n","permalink":"https://gopherding.github.io/posts/read/%E7%AD%94%E9%9F%A6%E4%B8%AD%E7%AB%8B%E8%AE%BA%E5%B8%88%E9%81%93%E4%B9%A6/","summary":"\u003ch3 id=\"答韦中立论师道书\"\u003e答韦中立论师道书\u003c/h3\u003e\n\u003cp\u003e唐·柳宗元\u003c/p\u003e\n\u003cp\u003e　　二十一日，宗元白：\u003c/p\u003e\n\u003cp\u003e　　辱书云，欲相师。仆道不笃，业甚浅近，环顾其中，未见可师者。虽常好言论，为文章，甚不自是也。不意吾子自京师来蛮夷间，乃幸见取。仆自卜固无取，假令有取，亦不敢为人师。为众人师且不敢，况敢为吾子师乎？\u003c/p\u003e\n\u003cp\u003e　　孟子称“人之患在好为人师”。由魏、晋氏以下，人益不事师。今之世，不闻有师，有辄哗笑之，以为狂人。独韩愈奋不顾流俗，犯笑侮，收召后学，作《师说》，因抗颜而为师。世果群怪聚骂，指目牵引，而增与为言辞。愈以是得狂名，居长安，炊不暇熟，又挈挈而东，如是者数矣。\u003c/p\u003e","title":"答韦中立论师道书"},{"content":"好了歌( 第一回) 世人都晓神仙好, 惟有功名忘不了!\n古今将相在何方? 荒冢一堆草没了。\n世人都晓神仙好, 只有金银忘不了!\n终朝只恨聚无多, 及到多时眼闭了。\n世人都晓神仙好, 只有娇妻忘不了!\n君生日日说恩情, 君死又随人去了。\n世人都晓神仙好, 只有儿孙忘不了!\n痴心父母古来多, 孝顺子孙谁见了?\n好了歌注 陋室空堂，当年笏满床。\n衰草枯杨，曾为歌舞场。\n蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。\n说什么脂正浓，粉正香，如何两鬓又成霜？\n昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。\n金满箱，银满箱，展眼乞丐人皆谤。\n正叹他人命不长，那知自己归来丧！\n训有方，保不定日后作强梁。\n择膏粱，谁承望流落在烟花巷！\n因嫌纱帽小，致使锁枷杠。\n昨怜破袄寒，今嫌紫蟒长： 乱烘烘你方唱罢我登场，反认他乡是故乡。\n甚荒唐，到头来都是为他人作嫁衣裳！\n护官符( 第四回) 贾不假, 白玉为堂金作马。\n阿房宫, 三百里, 住不下金陵一个史。\n东海缺少白玉床, 龙王来请金陵王。\n丰年好大雪, 珍珠如土金如铁。\n警幻仙子赋( 第五回) 方离柳坞, 乍出花房。\n但行处, 鸟惊庭树; 将到时, 影度回廊。\n仙袂乍飘兮, 闻麝兰之馥郁; 荷衣欲动兮, 听环佩之铿锵。\n靥笑春桃兮, 云堆翠髻; 唇绽樱颗兮, 榴齿含香。\n纤腰之楚楚兮, 回风舞雪; 珠翠之辉辉兮, 满额鹅黄。\n金陵十二钗正册判词·可叹停机德( 第五回) 可叹停机德, 堪怜咏絮才。\n玉带林中挂, 金簪雪里埋。\n红楼梦曲·枉凝眉( 第五回) 一个是阆苑仙葩, 一个是美玉无瑕。\n若说没奇缘, 今生偏又遇着他;\n若说有奇缘, 如何心事终虚化?\n一个枉自嗟呀, 一个空劳牵挂;\n一个是水中月, 一个是镜中花。\n想眼中能有多少泪珠儿?\n怎经得秋流到冬尽, 春流到夏。\n红楼梦曲·分骨肉( 第五回) 一帆风雨路三千, 把骨肉家园齐来抛闪。\n恐哭损残年, 告爹娘: 休把儿悬念。\n自古穷通皆有定, 离合岂无缘!\n从今分两地, 各自保平安。\n奴去也, 莫牵连。\n红楼梦曲·收尾·飞鸟各投林( 第五回) 为官的, 家业凋零; 富贵的, 金银散尽;\n有恩的, 死里逃生; 无情的, 分明报应;\n欠命的, 命已还; 欠泪的, 泪已尽。\n冤冤相报实非轻, 分离聚合皆前定。\n欲知命短问前生, 老来富贵也真侥幸。\n看破的, 遁入空门; 痴迷的, 枉送了性命。\n好一似食尽鸟投林, 落了片白茫茫大地真干净!\n通灵宝玉与金锁铭文 ( 第八回) 通灵宝玉铭文:\n莫失莫忘, 仙寿恒昌 。\n金锁铭文:\n不离不弃, 芳龄永继 。\n赞会芳园 ( 第十一回) 黄花满地 , 白柳横坡。\n小桥通若耶之溪 , 曲径接天台之路 。\n石中清流激湍, 篱落飘香; 树头红叶翩翻 , 疏林如画。西风乍紧, 初罢莺啼; 暖日当暄 , 又添蛩语 。\n遥望东南, 建几处依山之榭 ; 纵观西北, 结三间临水之轩 。笙簧盈耳, 别有幽情; 罗绮穿林, 倍添韵致。\n蘅芷清芬 ( 贾宝玉) 蘅芜满净苑, 萝薜助芬芳。\n软衬三春草, 柔拖一缕香。\n轻烟迷曲径, 冷翠滴回廊。\n谁谓池塘曲, 谢家幽梦长。\n杏帘在望 ( 贾宝玉) 杏帘招客饮, 在望有山庄。\n菱荇鹅儿水, 桑榆燕子梁。\n一畦春韭绿, 十里稻花香。\n盛世无饥馁, 何须耕织忙?\n参禅偈·寄生草·解偈 ( 第二十二回) 参禅偈 你证我证, 心证意证。是无有证, 斯可云证。无可云证, 是立足境。\n无立足境, 是方干净。 (黛玉续)\n寄生草·解偈 无我原非你, 从他不解伊。肆行无碍凭来去。\n茫茫着甚悲愁喜, 纷纷说甚亲疏密。\n从前碌碌却因何, 到如今回头试想真无趣!\n葬花吟( 第二十七回) 花谢花飞花满天，红消香断有谁怜？ 游丝软系飘春榭，落絮轻沾扑绣帘。 闺中女儿惜春暮，愁绪满怀无释处。 手把花锄出绣闺，忍踏落花来复去。 柳丝榆荚自芳菲，不管桃飘与李飞； 桃李明年能再发，明年闺中知有谁？ 三月香巢已垒成，梁间燕子太无情！ 明年花发虽可啄，却不道人去梁空巢也倾。 一年三百六十日，风刀霜剑严相逼； 明媚鲜妍能几时，一朝漂泊难寻觅。 花开易见落难寻，阶前愁杀葬花人， 独倚花锄泪暗洒，洒上空枝见血痕。 杜鹃无语正黄昏，荷锄归去掩重门； 青灯照壁人初睡，冷雨敲窗被未温。 怪奴底事倍伤神？半为怜春半恼春。 怜春忽至恼忽去，至又无言去未闻。 昨宵庭外悲歌发，知是花魂与鸟魂？ 花魂鸟魂总难留，鸟自无言花自羞； 愿侬此日生双翼，随花飞到天尽头。 天尽头，何处有香丘？ 未若锦囊收艳骨，一抔净土掩风流。 质本洁来还洁去，强于污淖陷渠沟。 尔今死去侬收葬，未卜侬身何日丧？ 侬今葬花人笑痴，他年葬侬知是谁？ 试看春残花渐落，便是红颜老死时； 一朝春尽红颜老，花落人亡两不知！\n题帕三绝句 ( 第三十四回) 其一 眼空蓄泪泪空垂, 暗洒闲拋更向谁?\n尺幅鲛绡劳惠赠, 叫人焉得不伤悲!\n其二 拋珠滚玉只偷潸, 镇日无心镇日闲。\n枕上袖边难拂拭, 任他点点与斑斑。\n其三 彩线难收面上珠, 湘江旧迹已模糊。\n窗前亦有千竿竹, 不识香痕渍也无?\n林黛玉咏白海棠 ( 第三十七回) 半卷湘帘半掩门, 碾冰为土玉为盆。\n偷来梨蕊三分白, 借得梅花一缕魂。\n月窟仙人缝缟袂, 秋闺怨女拭啼痕。\n娇羞默默同谁诉? 倦倚西风夜已昏。\n蘅芜君宝钗·忆菊 ( 第三十八回) 怅望西风抱闷思, 蓼红苇白断肠时。\n空篱旧圃秋无迹, 冷月清霜梦有知。\n念念心随归雁远, 寥寥坐听晚砧迟。\n谁怜我为黄花瘦, 慰语重阳会有期。\n潇湘妃子黛玉·咏菊 ( 第三十八回) 无赖诗魔昏晓侵, 绕篱欹石自沉音。\n毫端蕴秀临霜写, 口角噙香对月吟。\n满纸自怜题素怨, 片言谁解诉秋心?\n一从陶令评章后, 千古高风说到今。\n潇湘妃子黛玉·问菊 ( 第三十八回) 欲讯秋情众莫知, 喃喃负手扣东篱。\n孤标傲世偕谁隐? 一样花开为底迟?\n圃露庭霜何寂寞? 雁归蛩病可相思?\n莫言举世无谈者, 解语何妨话片时?\n代别离·秋窗风雨夕 ( 第四十五回) 秋花惨淡秋草黄, 耿耿秋灯秋夜长。\n已觉秋窗秋不尽, 那堪风雨助凄凉!\n助秋风雨来何速? 惊破秋窗秋梦绿。\n抱得秋情不忍眠, 自向秋屏移泪烛。\n泪烛摇摇爇短檠, 牵愁照恨动离情。\n谁家秋院无风入? 何处秋窗无雨声?\n罗衾不奈秋风力, 残漏声催秋雨急。\n连宵脉脉复飕飕, 灯前似伴离人泣。\n寒烟小院转萧条, 疏竹虚窗时滴沥。\n不知风雨几时休, 已教泪洒窗纱湿。\n真真国女儿诗 ( 第五十二回) 昨夜朱楼梦, 今宵水国吟。\n岛云蒸大海, 岚气接丛林。\n月本无今古, 情缘自浅深。\n汉南春历历, 焉得不关心?\n林黛玉柳絮词·唐多令 ( 第七十回) 粉堕百花洲, 香残燕子楼。 一团团逐对成球。漂泊亦如人命薄, 空缱绻, 说风流!\n草木也知愁, 韶华竟白头。 叹今生, 谁拾谁收!嫁与东风春不管, 凭尔去, 忍淹留!\n","permalink":"https://gopherding.github.io/posts/read/%E7%BA%A2%E6%A5%BC%E6%A2%A6%E8%AF%97%E8%AF%8D%E6%9B%B2/","summary":"\u003ch3 id=\"好了歌-第一回\"\u003e好了歌( 第一回)\u003c/h3\u003e\n\u003cp\u003e世人都晓神仙好, 惟有功名忘不了!\u003c/p\u003e\n\u003cp\u003e古今将相在何方? 荒冢一堆草没了。\u003c/p\u003e\n\u003cp\u003e世人都晓神仙好, 只有金银忘不了!\u003c/p\u003e\n\u003cp\u003e终朝只恨聚无多, 及到多时眼闭了。\u003c/p\u003e\n\u003cp\u003e世人都晓神仙好, 只有娇妻忘不了!\u003c/p\u003e\n\u003cp\u003e君生日日说恩情, 君死又随人去了。\u003c/p\u003e\n\u003cp\u003e世人都晓神仙好, 只有儿孙忘不了!\u003c/p\u003e\n\u003cp\u003e痴心父母古来多, 孝顺子孙谁见了?\u003c/p\u003e\n\u003ch3 id=\"好了歌注\"\u003e好了歌注\u003c/h3\u003e\n\u003cp\u003e陋室空堂，当年笏满床。\u003c/p\u003e\n\u003cp\u003e衰草枯杨，曾为歌舞场。\u003c/p\u003e","title":"红楼梦诗词（曲）\u003cTo Be Continue\u003e"},{"content":"离家久矣，思乡甚切。家中老少，莫不望归；田中庄稼，未曾收割。来时匆匆，破衣烂衫，秋已将至，战战兢兢。大千世界，无奇不有，我之所见，寥若晨星：往之不谏，来者可追，沙渺前路，晨光嘉微。万卷之书，不如行路；万贯家财，不及亲情。国庆将至，文宗欲行，此去不远，就在太原，恳请批假，即颂近安。\n于二零二一年九月二十九日\n本文作于Covid-19期间，彼时回家仍需写请假条。\n","permalink":"https://gopherding.github.io/posts/life/%E8%AF%B7%E5%81%87%E5%8D%95%E4%B8%80%E5%88%99/","summary":"\u003cp\u003e离家久矣，思乡甚切。家中老少，莫不望归；田中庄稼，未曾收割。来时匆匆，破衣烂衫，秋已将至，战战兢兢。大千世界，无奇不有，我之所见，寥若晨星：往之不谏，来者可追，沙渺前路，晨光嘉微。万卷之书，不如行路；万贯家财，不及亲情。国庆将至，文宗欲行，此去不远，就在太原，恳请批假，即颂近安。\u003c/p\u003e\n\u003cp\u003e于二零二一年九月二十九日\u003c/p\u003e","title":"请假单一则"},{"content":"The Sound of Silence Hello darkness, my old friend\nI\u0026rsquo;ve come to talk with you again\nBecause a vision softly creeping\nLeft its seeds while I was sleeping\nAnd the vision that was planted in my brain\nStill remains\nWithin the sound of silence\nIn restless dreams I walked alone\nNarrow streets of cobblestone\n\u0026lsquo;Neath the halo of a street lamp\nI turned my collar to the cold and damp\nWhen my eyes were stabbed by the flash of a neon light\nThat split the night\nAnd touched the sound of silence\nAnd in the naked light I saw\nTen thousand people, maybe more\nPeople talking without speaking\nPeople hearing without listening\nPeople writing songs that voices never share\nNo one dare\nDisturb the sound of silence\n\u0026ldquo;Fools,\u0026rdquo; said I, \u0026ldquo;You do not know\nSilence like a cancer grows\nHear my words that I might teach you\nTake my arms that I might reach you\u0026rdquo;\nBut my words like silent raindrops fell\nAnd echoed in the wells of silence\nAnd the people bowed and prayed\nTo the neon god they made\nAnd the sign flashed out its warning\nIn the words that it was forming\nAnd the sign said, \u0026ldquo;The words of the prophets\nAre written on subway walls\nAnd tenement halls\nAnd whispered in the sounds of silence\u0026rdquo;\n","permalink":"https://gopherding.github.io/posts/read/the-sound-of-silence/","summary":"\u003ch3 id=\"the-sound-of-silence\"\u003eThe Sound of Silence\u003c/h3\u003e\n\u003cp\u003eHello darkness, my old friend\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;ve come to talk with you again\u003c/p\u003e\n\u003cp\u003eBecause a vision softly creeping\u003c/p\u003e\n\u003cp\u003eLeft its seeds while I was sleeping\u003c/p\u003e\n\u003cp\u003eAnd the vision that was planted in my brain\u003c/p\u003e\n\u003cp\u003eStill remains\u003c/p\u003e\n\u003cp\u003eWithin the sound of silence\u003c/p\u003e\n\u003cp\u003eIn restless dreams I walked alone\u003c/p\u003e\n\u003cp\u003eNarrow streets of cobblestone\u003c/p\u003e\n\u003cp\u003e\u0026lsquo;Neath the halo of a street lamp\u003c/p\u003e\n\u003cp\u003eI turned my collar to the cold and damp\u003c/p\u003e\n\u003cp\u003eWhen my eyes were stabbed by the flash of a neon light\u003c/p\u003e\n\u003cp\u003eThat split the night\u003c/p\u003e\n\u003cp\u003eAnd touched the sound of silence\u003c/p\u003e\n\u003cp\u003eAnd in the naked light I saw\u003c/p\u003e\n\u003cp\u003eTen thousand people, maybe more\u003c/p\u003e\n\u003cp\u003ePeople talking without speaking\u003c/p\u003e\n\u003cp\u003ePeople hearing without listening\u003c/p\u003e\n\u003cp\u003ePeople writing songs that voices never share\u003c/p\u003e\n\u003cp\u003eNo one dare\u003c/p\u003e\n\u003cp\u003eDisturb the sound of silence\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;Fools,\u0026rdquo; said I, \u0026ldquo;You do not know\u003c/p\u003e\n\u003cp\u003eSilence like a cancer grows\u003c/p\u003e\n\u003cp\u003eHear my words that I might teach you\u003c/p\u003e","title":"The Sound of Silence"},{"content":" 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法。 冒泡排序、插入排序、归并排序、基数排序是稳定的排序算法。\n选快希堆不稳，冒插归基稳定。\n","permalink":"https://gopherding.github.io/posts/tech/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/img/sort.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法。\u003c/strong\u003e\n\u003cstrong\u003e冒泡排序、插入排序、归并排序、基数排序是稳定的排序算法。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e选快希堆不稳，冒插归基稳定。\u003c/p\u003e","title":"排序算法"},{"content":"坐车过一段路，轮子在微醺的地上碾过，到底是不是我走过了那段路呢？那末，便下车，走过一片田地，田地是不是也算走过了我呢？那末究竟是我走过的，还是鞋子踏过的呢？我走过的路（姑且算是走过罢），以后还会不会再走一遍呢？这会不会是我与这道的最后一次相遇呢？如果是的话，我又应当对她说些什么呢？末了，自然也是寻不出话来。只得吐出一团浊气，风儿将它吹了，散了，点点白芒。我不去怨风，想必她也有烦恼罢，或许她也想找人倾诉罢。我多想在夜空中撕开一点光，让风儿和这光相遇呵！那夜的星啊，梦的眼睛，于残阳中撕裂开了些许，便莽撞地跌到了我的眼中。或许光的那头也有甚么东西南北的在望着我罢？！瞧啊，我正看着妳呢，那是一束千百年前的目光啊！我在看着妳的同时，妳又是否在看着我呢？妳能感受到我的目光么？这大千世界，芸芸众生，妳我相互对望，是不是缘分呢？大抵是不存在的，然而我又希望她存在，以显得romantic一些，就姑且附丽于存在了。\n窗外依旧喧嚣，她去了，她也去了，究竟是去了那里呢？\n一曲陈歌,月之铅华，平平仄仄,何物临空？路不言，风遂寂，星无语。\n这几天心里颇不宁静，欲写下上面的话。于是便写罢。\n于二零二零年七月十九日，夜\n","permalink":"https://gopherding.github.io/posts/life/%E8%99%9A%E6%97%A0%E4%B8%8E%E5%AD%98%E5%9C%A8/","summary":"\u003cp\u003e坐车过一段路，轮子在微醺的地上碾过，到底是不是我走过了那段路呢？那末，便下车，走过一片田地，田地是不是也算走过了我呢？那末究竟是我走过的，还是鞋子踏过的呢？我走过的路（姑且算是走过罢），以后还会不会再走一遍呢？这会不会是我与这道的最后一次相遇呢？如果是的话，我又应当对她说些什么呢？末了，自然也是寻不出话来。只得吐出一团浊气，风儿将它吹了，散了，点点白芒。我不去怨风，想必她也有烦恼罢，或许她也想找人倾诉罢。我多想在夜空中撕开一点光，让风儿和这光相遇呵！那夜的星啊，梦的眼睛，于残阳中撕裂开了些许，便莽撞地跌到了我的眼中。或许光的那头也有甚么东西南北的在望着我罢？！瞧啊，我正看着妳呢，那是一束千百年前的目光啊！我在看着妳的同时，妳又是否在看着我呢？妳能感受到我的目光么？这大千世界，芸芸众生，妳我相互对望，是不是缘分呢？大抵是不存在的，然而我又希望她存在，以显得romantic一些，就姑且附丽于存在了。\u003c/p\u003e","title":"虚无与存在"}]